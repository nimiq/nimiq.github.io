{"version":3,"sources":["index.prefix.js","LogNative.js","Log.js","Observable.js","DataChannel.js","CryptoLib.js","WebRtcFactory.js","WebSocketFactory.js","DnsUtils.js","ConstantHelper.js","Services.js","Timers.js","Version.js","Time.js","ArrayUtils.js","HashMap.js","HashSet.js","LimitIterable.js","Queue.js","UniqueQueue.js","ThrottledQueue.js","SortedList.js","Assert.js","BufferUtils.js","SerialBuffer.js","Synchronizer.js","MultiSynchronizer.js","PrioritySynchronizer.js","RateLimit.js","IWorker.js","WasmHelper.js","CryptoWorker.js","CryptoWorkerImpl.js","CRC32.js","NumberUtils.js","MerkleTree.js","MerklePath.js","MerkleProof.js","PlatformUtils.js","StringUtils.js","Policy.js","Serializable.js","Hash.js","PrivateKey.js","PublicKey.js","KeyPair.js","RandomSecret.js","Signature.js","Commitment.js","CommitmentPair.js","PartialSignature.js","Address.js","Account.js","PrunedAccount.js","BasicAccount.js","Contract.js","HashedTimeLockedContract.js","VestingContract.js","AccountsTreeNode.js","AccountsTreeStore.js","SynchronousAccountsTreeStore.js","AccountsProof.js","AccountsTreeChunk.js","AccountsTree.js","SynchronousAccountsTree.js","PartialAccountsTree.js","Accounts.js","BlockHeader.js","BlockInterlink.js","BlockBody.js","BlockUtils.js","Subscription.js","Transaction.js","SignatureProof.js","BasicTransaction.js","ExtendedTransaction.js","TransactionsProof.js","TransactionCache.js","TransactionStoreEntry.js","TransactionStore.js","TransactionReceipt.js","Block.js","IBlockchain.js","BaseChain.js","BlockChain.js","HeaderChain.js","ChainProof.js","ChainData.js","ChainDataStore.js","MempoolTransactionSet.js","Mempool.js","BaseConsensusAgent.js","BaseConsensus.js","FullChain.js","FullConsensusAgent.js","FullConsensus.js","LightChain.js","LightConsensusAgent.js","LightConsensus.js","PartialLightChain.js","NanoChain.js","NanoConsensusAgent.js","NanoConsensus.js","NanoMempool.js","ConsensusDB.js","Consensus.js","Protocol.js","Message.js","AddrMessage.js","BlockMessage.js","GetAddrMessage.js","GetBlocksMessage.js","HeaderMessage.js","InventoryMessage.js","MempoolMessage.js","PingMessage.js","PongMessage.js","RejectMessage.js","SignalMessage.js","SubscribeMessage.js","TxMessage.js","VersionMessage.js","VerAckMessage.js","AccountsProofMessage.js","GetAccountsProofMessage.js","ChainProofMessage.js","GetChainProofMessage.js","AccountsTreeChunkMessage.js","GetAccountsTreeChunkMessage.js","TransactionsProofMessage.js","GetTransactionsProofMessage.js","GetTransactionReceiptsMessage.js","TransactionReceiptsMessage.js","GetBlockProofMessage.js","BlockProofMessage.js","GetHeadMessage.js","HeadMessage.js","MessageFactory.js","WebRtcConnector.js","WebRtcDataChannel.js","WebRtcUtils.js","WebSocketConnector.js","WebSocketDataChannel.js","NetAddress.js","PeerId.js","PeerAddress.js","PeerAddressState.js","PeerAddressBook.js","GenesisConfig.js","CloseType.js","NetworkConnection.js","PeerChannel.js","NetworkAgent.js","PeerConnectionStatistics.js","PeerConnection.js","SignalProcessor.js","ConnectionPool.js","PeerScorer.js","NetworkConfig.js","Network.js","NetUtils.js","PeerKeyStore.js","Peer.js","Miner.js","Wallet.js","MultiSigWallet.js","WalletStore.js","MinerWorker.js","MinerWorkerImpl.js","MinerWorkerPool.js","index.suffix.js"],"names":["module","exports","atob","require","btoa","JDB","fs","dns","https","WebSocket","NodeNative","__dirname","chalk","global","Class","scope","register","clazz","prototype","constructor","name","LogNative","[object Object]","this","_global_level","Log","INFO","_tag_levels","tag","level","args","isLoggable","unshift","bold","prefix","Level","toStringTag","Date","toTimeString","substr","ERROR","console","log","red","join","WARNING","yellow","cyan","DEBUG","magenta","TRACE","trace","instance","_instance","native","_native","setLoggable","get","l","i","length","toString","msg","message","arguments","Array","slice","call","undefined","VERBOSE","ASSERT","v","isNaN","parseInt","toLowerCase","d","bind","e","w","t","Observable","WILDCARD","_listeners","Map","type","callback","has","push","set","id","apply","observable","types","fire","on","DataChannel","super","_buffer","_msgType","_receivingTag","_sendingTag","_expectedMessagesByType","_timers","Timers","success","expectedMsg","clearTimeout","delete","timeoutCallback","msgTimeout","MESSAGE_TIMEOUT","chunkTimeout","CHUNK_TIMEOUT","isArray","ExpectedMessage","resetTimeout","_onTimeout","Error","clearAll","close","readyState","ReadyState","OPEN","buffer","SerialBuffer","byteLength","CHUNK_SIZE_MAX","_error","readUint8","effectiveChunkLength","readPos","chunk","read","NumberUtils","UINT8_MAX","chunkBuffer","messageSize","Message","peekLength","MESSAGE_SIZE_MAX","peekType","remainingBytes","writePos","write","Assert","that","_sendChunked","remaining","writeUint8","Uint8Array","sendChunk","CONNECTING","CLOSING","CLOSED","fromString","str","CryptoLib","crypto","getRandomValues","buf","TypeError","code","bytes","randomBytes","WebRtcFactory","configuration","rtcSessionDescriptionInit","rtcIceCandidateInit","WebSocketFactory","networkConfig","port","peerAddress","sslConfig","options","key","readFileSync","cert","httpsServer","createServer","req","res","writeHead","end","listen","Server","server","url","DnsUtils","host","Promise","resolve","reject","lookup","err","address","family","NetAddress","fromIP","ConstantHelper","_originalValues","constant","indexOf","split","startsWith","toUpperCase","hasOwnProperty","Object","keys","includes","isConstant","_ensureIsConstant","value","Services","provided","NONE","accepted","_provided","_accepted","services","FULL","LIGHT","NANO","_timeouts","_intervals","fn","waitTime","setTimeout","intervalTime","setInterval","clearInterval","Version","CODE","Time","offset","_offset","now","ArrayUtils","arr","Math","floor","random","uintarr","begin","clamp","min","max","len","byteOffset","list","k","n","indices","from","x","map","reverseRange","found","j","HashMap","fnHash","_hash","_map","_fnHash","o","hashCode","clear","values","size","HashSet","collection","add","remove","Symbol","iterator","valueIterator","LimitIterable","it","limit","_iterator","_limit","count","next","done","Queue","_queue","shift","hash","index","splice","UniqueQueue","_set","Set","enqueue","enqueueFirst","enqueueUnique","dequeue","dequeueMulti","dequeueUntil","val","ThrottledQueue","maxAtOnce","Number","POSITIVE_INFINITY","allowanceNum","allowanceInterval","maxSize","allowanceCallback","_maxSize","_maxAtOnce","_availableNow","isAvailable","pop","available","SortedList","sortedList","compare","_list","_compare","a","b","currentIndex","currentElement","round","_insertionIndex","condition","BufferUtils","String","fromCharCode","string","charCodeAt","u8","TextDecoder","_ISO_8859_15_DECODER","decode","replace","num","_BASE64_LOOKUP","start","tmp","output","_tripletToBase64","extraBytes","parts","len2","_base64encodeChunk","PlatformUtils","isNodeJs","Buffer","_codePointTextDecoder","_base64fromByteArray","base64","c","toBase64","alphabet","BASE32_ALPHABET","NIMIQ","byte","symbol","carry","base32","charmap","forEach","char","hex","HEX_ALPHABET","trim","StringUtils","isHexBytes","match","viewA","viewB","BASE64_ALPHABET","RFC4648","RFC4648_HEX","bufferOrArrayOrLength","_view","DataView","_readPos","_writePos","subarray","array","getUint8","setUint8","getUint16","setUint16","getUint32","setUint32","pow","isUint64","readUint16","readUint32","readUint64","writeUint16","writeUint32","writeUint64","getFloat64","setFloat64","toAscii","isMultibyte","fromAscii","view","padding","isUint8","Synchronizer","_working","_doWork","catch","job","result","working","MultiSynchronizer","_synchronizers","synchonizer","synchronizer","PrioritySynchronizer","numPriorities","_queues","priority","isInteger","queue","RateLimit","allowedOccurences","timeRange","_allowedEntries","_timeRange","_lastReset","_counter","number","IWorker","worker","Proxy","workerScript","_workersSupported","Nimiq","_path","createProxy","Worker","window","URL","createObjectURL","Blob","_workerImplementation","init","Pool","startWorkerForProxy","data","command","self","postMessage","status","areWorkersAsync","_insideWebWorker","WorkerGlobalScope","_global","baseClazz","impl","onmessage","stubBaseOnMessage","head","document","getElementsByTagName","script","createElement","src","ret","onreadystatechange","onload","appendChild","proxyClass","_name","_messageId","_worker","_receive","_waiting","_invoke","then","cb","error","WorkerProxy","obj","funcName","getOwnPropertyNames","Stub","finalRes","_result","_onmessage","poolClass","proxyInitializer","_proxyInitializer","_poolSize","_workers","_freeWorkers","_waitingCalls","_updateToSize","poolSize","_size","_step","destroy","workerPromises","createdWorkers","all","idx","_moduleLoadedCallbacks","WasmHelper","_importStarted","importWasmBrowser","importScriptBrowser","_importFinished","importWasmNodeJs","importScriptNodeJs","wasm","_adjustWasmPath","WebAssembly","xhr","XMLHttpRequest","open","responseType","wasmBinary","response","onerror","send","u","toUint8Array","asm","_adjustScriptPath","moduleSettings","async","onRuntimeInitialized","importScripts","_loadBrowserScript","CryptoWorker","lib","_workerAsync","startWorkerPoolForProxy","input","inputs","salt","iterations","block","transactionValid","timeNow","genesisHash","networkId","CryptoWorkerImpl","_superInit","doImportBrowser","out","Hash","getSize","Algorithm","ARGON2D","node_argon2","stackPtr","Module","stackSave","hashSize","wasmOut","stackAlloc","wasmIn","HEAPU8","_nimiq_argon2","stackRestore","hashes","stackTmp","node_kdf","wasmSalt","_nimiq_kdf","blockSerialized","GenesisConfig","GENESIS_HASH","unserialize","NETWORK_ID","Block","body","transactions","_valid","valid","_verify","header","interlinkHash","interlink","bodyHash","serialize","prepareForWorkerUse","CRC32","table","_POLYNOMIAL","_table","_createTable","_hex_chars","crc","UINT16_MAX","UINT32_MAX","UINT64_MAX","MAX_SAFE_INTEGER","MerkleTree","_computeRoot","light","mid","left","right","leftHash","rightHash","concatTypedArrays","MerklePath","nodes","some","MerklePathNode","_nodes","leafValue","leafHash","path","_compute","containsLeaf","inner","equals","leftLeaf","rightLeaf","root","node","concat","serializedSize","leftBitsSize","ceil","leftBits","_compress","reduce","sum","every","_left","MerkleProof","operations","isUint16","_operations","leafValues","leafHashes","fnCompare","leaves","sort","leafIndex","valueIndex","comparisonResult","compute","Operation","CONSUME_PROOF","isLeaf","h","CONSUME_INPUT","leftOps","leftPath","rightOps","rightPath","HASH","stack","proofNodes","op","hashStack","opBitsSize","opBits","opCount","countNodes","isBrowser","process","RTCPeerConnection","webkitRTCPeerConnection","navigator","onLine","test","isHex","str1","str2","Policy","coins","SATOSHIS_PER_COIN","satoshis","blockHeight","startHeight","_supplyCacheInterval","startI","_supplyCacheMax","endI","supply","INITIAL_SUPPLY","_supplyCache","endHeight","_supplyAfter","initialSupply","_blockRewardAt","currentSupply","supplyAfter","TOTAL_SUPPLY","EMISSION_TAIL_START","EMISSION_TAIL_REWARD","EMISSION_SPEED","BLOCK_TIME","BLOCK_SIZE_MAX","BLOCK_TARGET_MAX","DIFFICULTY_BLOCK_WINDOW","DIFFICULTY_MAX_ADJUSTMENT_FACTOR","TRANSACTION_VALIDITY_WINDOW","M","K","DELTA","NUM_BLOCKS_VERIFICATION","NUM_SNAPSHOTS_MAX","Serializable","toHex","_obj","arg","algorithm","BLAKE2B","_algorithm","blake2b","computeBlake2b","argon2d","getInstanceAsync","computeArgon2d","computeSha256","SHA256","sha256","SIZE","fromBase64","fromHex","node_blake2","_nimiq_blake2","node_sha256","_nimiq_sha256","SHA512","NULL","PrivateKey","privateKey","publicKey","publicKeysHash","PublicKey","node_ed25519_derive_delinearized_private_key","wasmInPrivateKey","wasmInPublicKey","wasmInPublicKeysHash","_ed25519_derive_delinearized_private_key","delinearizedPrivateKey","_publicKeyDerive","publicKeys","_delinearizeAndAggregatePublicKeys","Address","fromHash","PeerId","publicKeysObj","_publicKeysHash","raw","_publicKeysDelinearizeAndAggregate","node_ed25519_public_key_derive","pubKeyBuffer","HEAP8","privKeyBuffer","_ed25519_public_key_derive","fill","concatenatedPublicKeys","node_ed25519_hash_public_keys","wasmInPublicKeys","_ed25519_hash_public_keys","hashedPublicKey","node_ed25519_delinearize_public_key","_ed25519_delinearize_public_key","delinearizedPublicKey","node_ed25519_aggregate_delinearized_public_keys","_ed25519_aggregate_delinearized_public_keys","aggregatePublicKey","KeyPair","locked","lockSalt","_locked","_lockedInternally","_lockSalt","_publicKey","_internalPrivateKey","generate","derive","hexBuf","roundsLog","rounds","encryptedKey","EXPORT_SALT_LENGTH","check","EXPORT_CHECKSUM_LENGTH","_otpKdf","keyPair","pubHash","_privateKey","isLocked","_unlockedPrivateKey","unlockKey","wasLocked","unlock","encryptedSize","log2","EXPORT_KDF_ROUNDS","relock","overwrite","_otpPrivateKey","_clearUnlockedPrivateKey","LOCK_KDF_ROUNDS","xor","kdf","RandomSecret","Signature","_signatureCreate","commitment","signatures","_combinePartialSignatures","s","_signatureVerify","combinedCommitment","partialSignatures","combinedSignature","_aggregatePartialSignatures","sigA","sigB","_scalarsAdd","PartialSignature","node_ed25519_add_scalars","wasmOutSum","wasmInA","wasmInB","_ed25519_add_scalars","node_ed25519_sign","wasmOutSignature","signatureBuffer","wasmInMessage","wasmInPubKey","wasmInPrivKey","_ed25519_sign","signature","node_ed25519_verify","wasmInSignature","_ed25519_verify","Commitment","commitments","_commitmentsAggregate","concatenatedCommitments","node_ed25519_aggregate_commitments","wasmInCommitments","_ed25519_aggregate_commitments","aggCommitments","CommitmentPair","secret","_secret","_commitment","randomness","RANDOMNESS_SIZE","_commitmentCreate","node_ed25519_create_commitment","wasmOutCommitment","wasmOutSecret","_ed25519_create_commitment","SERIALIZED_SIZE","aggregateCommitment","_delinearizedPartialSignatureCreate","node_ed25519_delinearized_partial_sign","wasmInSecret","wasmInCommitment","_ed25519_delinearized_partial_sign","partialSignature","fromUserFriendlyAddress","CCODE","_ibanCheck","fromBase32","withSpaces","toBase32","HEX_SIZE","CONTRACT_CREATION","Account","balance","_type","_balance","TYPE_MAP","transaction","transactionsCache","revert","validityStartHeight","withBalance","fee","newBalance","containsTransaction","INITIAL","isInitial","Type","BASIC","VESTING","HTLC","PrunedAccount","account","_address","_account","BasicAccount","SignatureProof","verifyTransaction","hasFlag","Transaction","Flag","recipientType","withIncomingTransaction","create","Contract","recipient","getContractCreationAddress","HashedTimeLockedContract","sender","hashRoot","hashCount","timeout","totalAmount","isUint32","_sender","_recipient","_hashRoot","_hashCount","_timeout","_totalAmount","hashAlgorithm","toUserFriendlyAddress","proof","ProofType","REGULAR_TRANSFER","hashDepth","preImage","verify","serializeContent","EARLY_RESOLVE","TIMEOUT_RESOLVE","verifyIncomingTransaction","minCap","isSignedBy","withOutgoingTransaction","VestingContract","owner","vestingStart","vestingStepBlocks","vestingStepAmount","vestingTotalAmount","_owner","_vestingStart","_vestingStepBlocks","_vestingStepAmount","_vestingTotalAmount","getMinCap","AccountsTreeNode","TERMINAL","childrenSuffixes","childrenHashes","BRANCH","arg2","_prefix","isBranch","_childrenSuffixes","_childrenHashes","isTerminal","readVarLengthString","isTerminalType","terminalNode","isBranchType","childCount","childSuffix","childHash","childIndex","branchNode","writeVarLengthString","child","payloadSize","varLengthStringSize","_getChildIndex","suffix","find","filter","parent","getChildren","is","ourChild","otherChild","AccountsTreeStore","jdb","createObjectStore","codec","AccountsTreeStoreCodec","getObjectStore","store","JungleDB","createVolatileObjectStore","_store","put","startPrefix","relevantKeys","keyStream","KeyRange","lowerBound","tx","snapshot","inherit","enableWatchdog","synchronousTransaction","SynchronousAccountsTreeStore","truncate","commit","abort","valueEncoding","BINARY_ENCODING","_syncStore","preload","expectedToBePresent","getSync","putSync","removeSync","AccountsProof","_index","children","isChildOf","getChildHash","getChild","rootNode","_getAccount","commonPrefix","childKey","childNode","AccountsTreeChunk","_proof","lastPrefix","tail","terminalNodes","SIZE_MAX","EMPTY","AccountsTree","getPersistent","_init","createVolatile","_synchronizer","getRootNode","_put","_insert","rootPath","newChild","newChildHash","newParent","withChild","newParentHash","_updateKeys","_prune","nodeHash","withAccount","childPrefix","withoutChild","hasSingleChild","getFirstChild","hasChildren","addresses","prefixes","_getAccountsProof","includeNode","subPrefixes","getTerminalNodes","lastNode","getAccountsProof","SynchronousAccountsTree","PartialAccountsTree","_preloadAddresses","putBatch","finalizeBatch","getRootNodeSync","_updateHashes","_insertBatch","_updateKeysBatch","_pruneBatch","zeroHash","subHashes","currentHash","newNode","_complete","_lastPrefix","Status","ERR_INCORRECT_PROOF","_putLight","_mergeProof","ERR_UNMERGEABLE","complete","OK_COMPLETE","OK_UNFINISHED","upperBound","nodeChildren","proofNode","proofChildren","nextChild","getLastChild","insertedNode","proofChild","proofHash","missingPrefix","tree","ERR_HASH_MISMATCH","Accounts","accountsTree","_tree","bubble","genesisBlock","encodedAccounts","isEmpty","_commitBlockBody","height","TransactionCache","rootSync","accountsHash","getChunk","transactionCache","preloadAddresses","getAddresses","_processSenderAccounts","_processRecipientAccounts","_processContracts","toBePruned","senderAccount","_getSync","isToBePruned","revertBlockBody","_revertBlockBody","accountType","partialTree","senderType","recipientAccount","reverse","withContractCommand","prunedAccounts","accIdx","findIndex","acc","_rewardMiner","txFees","coinbaseTransaction","ExtendedTransaction","minerAddr","blockRewardAt","BlockHeader","prevHash","copy","_prevHash","_interlinkHash","_bodyHash","_accountsHash","_nBits","_height","_timestamp","_nonce","_version","nBits","timestamp","nonce","version","CURRENT_VERSION","isHash","BlockUtils","isValidCompact","SUPPORTED_VERSIONS","isProofOfWork","target","prevHeader","_pow","hard","compactToTarget","difficulty","compactToDifficulty","V1","BlockInterlink","_hashes","repeatBits","_repeatBits","compressed","_compressed","repeatBitsSize","lastHash","computeRoot","BlockBody","extraData","_minerAddr","_extraData","_transactions","_prunedAccounts","extraDataLength","numTransactions","numPrunedAccounts","previousTx","compareBlockOrder","previousAcc","getMerkleLeafs","transactionCount","compact","isFinite","getTargetHeight","targetToCompact","difficultyToTarget","targetToDifficulty","hashToTarget","getTargetDepth","isValidTarget","headBlock","tailBlock","deltaTotalDifficulty","actualTime","adjustment","averageDifficulty","nextTarget","Subscription","ADDRESSES","minFeePerByte","MIN_FEE","_addresses","_minFeePerByte","addAll","additionalSize","ANY","contains","BLOCKS_ONLY","format","flags","_format","_senderType","_recipientType","_value","_fee","_networkId","_validityStartHeight","_flags","_data","FORMAT_MAP","serializedContentSize","verifyOutgoingTransaction","recCompare","senderCompare","feePerByte","flag","Format","EXTENDED","ALL","signerKey","merklePath","_merklePath","_signature","merkleRoot","BasicTransaction","senderPubKey","singleSig","toAddress","_signatureProof","dataSize","proofSize","TransactionsProof","blockOrder","_blockOrder","shiftBlock","removeAll","missingBlocks","blockFromOrder","blocks","TransactionStoreEntry","transactionHash","blockHash","_transactionHash","_blockHeight","_blockHash","senderBuffer","recipientBuffer","entries","transactionKey","TransactionStore","TransactionStoreCodec","createIndex","lmdbKeyEncoding","only","indexedTransactions","fromBlock","indexedTransaction","toJSON","fromJSON","JSON_ENCODING","TransactionReceipt","_header","_interlink","_body","time","isLight","blockVerify","TIMESTAMP_DRIFT_MAX","verifyProofOfWork","_verifyInterlink","isFull","_verifyBody","predecessor","isImmediateSuccessorOf","getNextInterlink","prevPow","targetHeight","blockFound","depth","depthDiff","commonBlock","thisInterlink","prevInterlink","isInterlinkSuccessorOf","nextVersion","thisPowDepth","getHashDepth","nextTargetDepth","numOccurrences","IBlockchain","headHash","BaseChain","includeForks","includeBody","chainData","getChainData","onMainChain","getBlockAt","lower","getNearestBlockAt","locators","getBlock","step","headData","_mainChain","tailHeight","tailData","getChainDataAt","prevData","totalDifficulty","getNextTarget","_prove","m","delta","BlockChain","superBlockCounts","getCandidateDepth","alpha","_getSuperChain","merge","toLight","_isGoodSuperChain","_getHeaderChain","ChainProof","chain","reference","ChainData","initial","GENESIS_BLOCK","superchain","_hasSuperQuality","_hasMultiLevelQuality","underlyingLength","_isLocallyGood","k1","mu","upperChainLength","lowerChainLength","superLength","headers","HeaderChain","failOnBadness","suffixTail","prefixHead","chains","getSuperChains","deletedBlockHeights","_superchain","referenceBlock","numBlocksToDelete","candidateBlock","newPrefix","blockToProve","knownBlock","getInterlinkReference","hashToProve","proveTarget","proveDepth","nextBlock","partitions","promises","part","computeArgon2dBatch","pows","proof1","proof2","lca","lowestCommonAncestor","score1","NanoChain","_getProofScore","score2","counts","maxScore","score","chain1","chain2","merged","i1","i2","block1","block2","superChains","_blocks","_chains","isSuccessorOf","denseSuffix","denseSuffixHead","_headers","_suffix","isAnchored","_verifyDifficulty","denseChain","totalDifficulties","headIndex","tailIndex","checkBlock","totalWork","realDifficulty","copyAndAdd","SuperBlockCounts","mainChainSuccessor","_head","_totalDifficulty","_totalWork","_superBlockCounts","_onMainChain","_mainChainSuccessor","hashBase64","successor","copyAndSubtract","_arr","subtract","ChainDataStore","chainStore","ChainDataStoreCodec","_createIndexes","BlockStoreCodec","blockStore","NUMBER_ENCODING","leveldbKeyEncoding","_chainStore","_blockStore","chainTx","blockTx","commitCombined","candidates","Query","eq","maxValues","minValues","startBlockHash","forward","getBlocksForward","getBlocksBackward","SynchronousTransaction","chainSnapshot","blockSnapshot","truncateSync","txs","toObj","fromObj","MempoolTransactionSet","sortedTransactions","Mempool","blockchain","accounts","_blockchain","_accounts","_transactionsByFeePerByte","_transactionsByHash","_transactionSetBySender","_transactionSetByRecipient","_evictTransactions","_restoreTransactions","_pushTransaction","ReturnCode","KNOWN","TRANSACTION_RELAY_FEE_MIN","numBelowFeePerByte","FREE_TRANSACTIONS_PER_SENDER_MAX","FEE_TOO_LOW","INVALID","tmpAccount","TRANSACTIONS_PER_SENDER_MAX","_removeTransaction","_popLowFeeTransaction","byRecipient","ACCEPTED","Infinity","txSize","transactionGenerator","getTransactions","gatherToBePrunedAccounts","getTransactionsBySender","maxTransactions","bySender","getTransactionsByRecipient","peekLast","__evictTransactions","BaseConsensusAgent","peer","targetSubscription","_time","_peer","_synced","_knownObjects","InvVector","BLOCK","_blocksToRequest","_txsToRequest","TRANSACTIONS_AT_ONCE","FREE_TRANSACTIONS_AT_ONCE","TRANSACTIONS_PER_SECOND","FREE_TRANSACTIONS_PER_SECOND","REQUEST_TRANSACTIONS_WAITING_MAX","_objectsInFlight","_objectsThatFlew","_objectsProcessing","_remoteSubscription","_localSubscription","_lastSubscriptionChange","_targetSubscription","_waitingInvVectors","_sendWaitingInvVectors","TRANSACTION_RELAY_INTERVAL","_waitingFreeInvVectors","_sendFreeWaitingInvVectors","FREE_TRANSACTION_RELAY_INTERVAL","_blockProofRequest","_transactionsProofRequest","_transactionReceiptsRequest","channel","_onInv","_onBlock","_onHeader","_onTx","_onNotFound","_onSubscribe","_onGetData","_onGetHeader","_onBlockProof","_onTransactionsProof","_onTransactionReceipts","_onGetHead","_onHead","_onClose","_requestHead","getHead","HEAD_REQUEST_INTERVAL","onHeadUpdated","subscription","_subscribe","subscribe","matchesBlock","vector","inv","BaseInventoryMessage","VECTORS_MAX_COUNT","invVectors","FREE_TRANSACTION_SIZE_PER_INTERVAL","matchesTransaction","fromTransaction","vectors","unknownBlocks","unknownTxs","_shouldRequestData","_getBlock","_onKnownBlockAnnounced","_onNewBlockAnnounced","TRANSACTION","_getTransaction","_onKnownTransactionAnnounced","_onNewTransactionAnnounced","enqueueAllNew","REQUEST_THRESHOLD","_requestData","REQUEST_THROTTLE","_onNoUnknownObjects","vectorsMaxCount","_doRequestData","_noMoreData","REQUEST_TIMEOUT","getData","transactionPromises","_onObjectReceived","_processBlock","_onObjectProcessed","_processHeader","_processTransaction","SUBSCRIPTION_CHANGE_GRACE_PERIOD","CloseType","RECEIVED_TRANSACTION_NOT_MATCHING_OUR_SUBSCRIPTION","_onAllObjectsReceived","_onAllObjectsProcessed","unknownObjects","notFound","blockHashToProve","_getBlockProof","getBlockProof","expectMessage","BLOCK_PROOF","BLOCK_PROOF_REQUEST_TIMEOUT","hasProof","INVALID_BLOCK_PROOF","_getTransactionsProof","getTransactionsProof","TRANSACTIONS_PROOF","GET_TRANSACTIONS_PROOF_TIMEOUT","TRANSACTIONS_PROOF_REQUEST_TIMEOUT","INVALID_TRANSACTION_PROOF","_getTransactionReceipts","getTransactionReceipts","TRANSACTION_RECEIPTS","GET_TRANSACTION_RECEIPTS_TIMEOUT","TRANSACTION_RECEIPTS_REQUEST_TIMEOUT","transactionReceipts","stop","synced","REQUEST_BLOCKS_WAITING_MAX","BaseConsensus","mempool","network","_network","_agents","_established","_syncPeer","_subscription","_onPeerJoined","_onPeerLeft","_onHeadChanged","_onTransactionAdded","agent","_newConsensusAgent","_onPeerSynced","_onPeerOutOfSync","_syncBlockchain","SYNC_THROTTLE","numSyncedFullNodes","isFullNode","MIN_FULL_NODES","randomElement","syncBlockchain","allowInboundConnections","relayBlock","relayTransaction","blockHeightToProve","agents","knownBlockHash","knowsBlock","isNanoNode","receipts","_requestTransactionReceipts","blockRequests","lastBlockHash","receipt","request","_requestBlockProof","transactionRequests","_requestTransactionsProof","flat","established","FullChain","transactionStore","_snapshots","_snapshotOrder","_transactionCache","_transactionStore","_blockKnownCount","_blockInvalidCount","_blockOrphanCount","_blockExtendedCount","_blockRebranchedCount","_blockForkedCount","_headHash","genesis","prependBlocks","putChainDataSync","setHeadSync","initialize","GENESIS_ACCOUNTS","_pushBlock","OK_KNOWN","ERR_INVALID","ERR_ORPHAN","nextChainData","_extend","OK_EXTENDED","_rebranch","OK_REBRANCHED","putChainData","OK_FORKED","accountsTx","commitBlock","storeTx","transactionStoreTx","_saveSnapshot","pushBlock","_shouldExtendChainProof","_extendChainProof","forkChain","forkHashes","curData","curHash","ancestorData","ancestorHash","transactionCacheTx","clone","revertChain","revertBlock","numMissingBlocks","revertedData","forkData","getBlocks","_getChainProof","_getSnapshot","getAccountsTreeChunk","matches","addressesSet","entriesBySender","getBySender","entriesByRecipient","getByRecipient","entry","txStoreEntry","transactionsTx","currentBlock","oldestHash","oldestSnapshot","blockForkedCount","blockRebranchedCount","blockExtendedCount","blockOrphanCount","blockInvalidCount","blockKnownCount","FullConsensusAgent","_mempool","_syncing","_numBlocksExtending","_numBlocksForking","_forkHead","_failedSyncs","_syncTarget","_chainProofLimit","CHAIN_PROOF_RATE_LIMIT","_accountsProofLimit","ACCOUNTS_PROOF_RATE_LIMIT","_accountsTreeChunkLimit","ACCOUNTS_TREE_CHUNK_RATE_LIMIT","_transactionsProofLimit","TRANSACTION_PROOF_RATE_LIMIT","_transactionReceiptsLimit","TRANSACTION_RECEIPTS_RATE_LIMIT","_onGetBlocks","_onGetChainProof","_onGetAccountsProof","_onGetAccountsTreeChunk","_onGetTransactionsProof","_onGetTransactions","_onGetBlockProof","_onMempool","_syncFinished","SYNC_ATTEMPTS_MAX","BLOCKCHAIN_SYNC_FAILED","_requestBlocks","_subscribeTarget","delay","MEMPOOL_DELAY_MIN","MEMPOOL_DELAY_MAX","maxInvSize","isExpectingMessage","INV","GET_BLOCKS_TIMEOUT","getBlockLocators","getTransaction","RECEIVED_INVALID_BLOCK","_onOrphanBlock","timeoutExists","_outOfSync","RESYNC_THROTTLE","pushTransaction","TX","RejectMessage","Code","REJECT_INSUFFICIENT_FEE","REJECT_INVALID","startBlock","locator","GETBLOCKS_VECTORS_MAX","direction","GetBlocksMessage","Direction","FORWARD","note","RATE_LIMIT_EXCEEDED","getChainProof","chainProof","blockProof","accountsProof","transactionsProof","accountsTreeChunk","getTransactionReceiptsByAddress","TransactionReceiptsMessage","RECEIPTS_MAX_COUNT","getTransactionsByAddresses","MEMPOOL_ENTRIES_MAX","MEMPOOL_THROTTLE","FullConsensus","fromMinFeePerByte","evictBelowMinFeePerByte","LightChain","partialChain","PartialLightChain","mainChain","LightConsensusAgent","_partialChain","_catchup","_orphanedBlocks","_busy","_accountsRequest","_requestedChainProof","_numWeakProofs","_onChainProof","_onAccountsTreeChunk","getHeader","DID_NOT_GET_REQUESTED_HEADER","_initChainProofSync","state","State","PROVE_CHAIN","_requestChainProof","PROVE_ACCOUNTS_TREE","_requestAccountsTree","PROVE_BLOCKS","_requestProofBlocks","COMPLETE","_applyOrphanedBlocks","ABORTED","ABORTED_SYNC","WEAK_PROOF","WEAK_PROOFS_MAX","CHAIN_PROOF","GET_CHAIN_PROOF_TIMEOUT","CHAINPROOF_REQUEST_TIMEOUT","CHAINPROOF_CHUNK_TIMEOUT","pushProof","INVALID_CHAIN_PROOF","getMissingAccountsPrefix","ACCOUNTS_TREE_CHUNK","GET_ACCOUNTS_TREE_CHUNK_TIMEOUT","ACCOUNTS_TREE_CHUNK_REQUEST_TIMEOUT","hasChunk","INVALID_ACCOUNTS_TREE_CHUNK","rootHash","ACCOUNTS_TREE_CHUNCK_ROOT_HASH_MISMATCH","pushAccountsTreeChunk","_lastChainHeight","proofHeadHeight","numBlocksNeeded","_chain","_headerRequest","HEADER","GET_HEADER_TIMEOUT","NanoConsensusAgent","requestedHash","RECEIVED_WRONG_HEADER","LightConsensus","_state","_partialTree","_accountsTx","_proofHead","_pushProof","toDo","manyPow","suffixBlocks","currentProof","isBetterProof","_acceptProof","tailEnd","_pushLightBlock","partialAccountsTree","setHead","_pushBlockInternal","proofHeadHash","_pushBlockBackwards","_pushHeadBlock","_prepend","needsMoreBlocks","previousChainData","pushChunk","numBlocks","_pushHeader","_onAccountsProof","requestMempool","pushHeader","RECEIVED_INVALID_HEADER","_getAccounts","ACCOUNTS_PROOF","GET_ACCOUNTS_PROOF_TIMEOUT","ACCOUNTSPROOF_REQUEST_TIMEOUT","INVALID_ACCOUNTS_PROOF","ACCOUNTS_PROOF_ROOT_HASH_MISMATCH","getAccount","INCOMPLETE_ACCOUNTS_PROOF","NanoConsensus","fromAddresses","evictExceptAddresses","includedTransactions","changeHead","getAccounts","relayed","NanoMempool","_transactionSetByAddress","maxCount","addressSet","blockHeader","txHash","ConsensusDB","dbPrefix","dbName","VERSION","maxDbSize","INITIAL_DB_SIZE","autoResize","minResize","MIN_RESIZE","initPersistent","connect","Consensus","netconfig","NetworkConfig","getDefault","db","getFull","NETWORK_NAME","Network","getLight","initVolatile","Protocol","DUMB","WS","RTC","pos","readVarUint","magic","checksum","MAGIC","_writeChecksum","writeVarUint","varUintSize","GET_DATA","GET_HEADER","NOT_FOUND","GET_BLOCKS","MEMPOOL","REJECT","SUBSCRIBE","ADDR","GET_ADDR","PING","PONG","SIGNAL","GET_CHAIN_PROOF","GET_ACCOUNTS_PROOF","GET_ACCOUNTS_TREE_CHUNK","GET_TRANSACTIONS_PROOF","GET_TRANSACTION_RECEIPTS","GET_BLOCK_PROOF","GET_HEAD","HEAD","VERACK","AddrMessage","PeerAddress","addr","_setChecksum","BlockMessage","_block","GetAddrMessage","protocolMask","serviceMask","_protocolMask","_serviceMask","_locators","_maxInvSize","_direction","BACKWARD","HeaderMessage","_vectors","InvMessage","GetDataMessage","GetHeaderMessage","NotFoundMessage","MempoolMessage","PingMessage","PongMessage","messageType","reason","_messageType","_code","_reason","REJECT_MALFORMED","REJECT_OBSOLETE","REJECT_DOUBLE","REJECT_DUST","SignalMessage","senderId","recipientId","ttl","payload","hasPayload","_senderId","_recipientId","_ttl","_payload","_senderPubKey","toPeerId","UNROUTABLE","TTL_EXCEEDED","SubscribeMessage","TxMessage","_transaction","_accountsProof","hasAccountsProof","VersionMessage","challengeNonce","_peerAddress","_genesisHash","_challengeNonce","CHALLENGE_SIZE","VerAckMessage","AccountsProofMessage","GetAccountsProofMessage","ChainProofMessage","GetChainProofMessage","AccountsTreeChunkMessage","_accountsTreeChunk","GetAccountsTreeChunkMessage","_startPrefix","TransactionsProofMessage","GetTransactionsProofMessage","GetTransactionReceiptsMessage","_transactionReceipts","GetBlockProofMessage","_blockHashToProve","_knownBlockHash","BlockProofMessage","GetHeadMessage","HeadMessage","MessageFactory","CLASSES","WebRtcConnector","_networkConfig","_connectors","signalChannel","protocol","peerId","connector","OutboundPeerConnector","conn","_onConnection","rtcConnection","CONNECT_TIMEOUT","isUnroutable","isTtlExceeded","isValidSignal","JSON","parse","InboundPeerConnector","onSignal","PeerConnector","_signalChannel","_peerId","randomUint32","_rtcConnection","newPeerConnection","rtcConfig","onicecandidate","_onIceCandidate","_lastIceCandidate","_iceCandidateQueue","signal","sdp","setRemoteDescription","newSessionDescription","createAnswer","description","_onDescription","_handleCandidateQueue","candidate","_addIceCandidate","newIceCandidate","remoteDescription","addIceCandidate","stringify","SIGNAL_TTL_INITIAL","event","_signal","setLocalDescription","localDescription","WebRtcDataChannel","netAddress","WebRtcUtils","candidateToNetAddress","NetworkConnection","webRtcConfig","createDataChannel","binaryType","onopen","_onDataChannel","createOffer","offer","ondatachannel","nativeChannel","ordered","_channel","_onMessage","onclose","reader","FileReader","onloadend","readAsArrayBuffer","WebSocketConnector","_wss","newWebSocketServer","ws","_sockets","timeoutKey","newWebSocket","handshakeTimeout","_socket","remoteAddress","WebSocketDataChannel","_ws","ip","reliable","saneIp","NetUtils","ipToBytes","sanitizeIP","isIPv4Address","IPv4","IPv6","ipArray","IPv4_LENGTH","IPv6_LENGTH","UNKNOWN","UNSPECIFIED","_ip","_reliable","bytesToIp","isPseudo","isPrivateIP","isIPv6Address","bitCount","ipToSubnet","distance","_protocol","_services","_netAddress","_distance","WsPeerAddress","RtcPeerAddress","DumbPeerAddress","isPrivate","_signatureVerified","isSeed","age","PeerAddressBook","MAX_AGE_WEBSOCKET","MAX_AGE_WEBRTC","MAX_AGE_DUMB","publicKeyHex","_host","_port","hostGloballyReachable","PeerAddressState","NEW","lastConnected","bannedUntil","banBackoff","INITIAL_FAILED_BACKOFF","_signalRouter","SignalRouter","_failedAttempts","_closeTypes","_addedBy","signalRouter","maxFailedAttempts","MAX_FAILED_ATTEMPTS_RTC","MAX_FAILED_ATTEMPTS_WS","failedAttempts","bestRoute","updateBestRoute","BANNED","isBanningType","isFailingType","FAILED","TRIED","addedBy","ESTABLISHED","_bestRoute","_routes","oldRoute","newRoute","SignalRoute","deleteRoute","route","MAX_DISTANCE","_stateByPeerId","_statesByNetAddress","SEED_PEERS","_housekeeping","HOUSEKEEPING_INTERVAL","localPeerAddress","withoutId","_get","peerAddressState","maxAddresses","addressStates","numAddresses","exceedsAge","peerAddresses","newAddresses","_add","MAX_SIZE","MAX_TIMESTAMP_DRIFT","knownAddress","changed","states","MAX_SIZE_PER_IP","addRoute","_removeBySignalChannel","_ban","MAX_FAILED_BACKOFF","_remove","deleteBestRoute","hasRoute","duration","DEFAULT_BAN_TIME","deleteAllRoutes","unbannedAddresses","knownAddressesCount","CONFIGS","config","_config","dev","seed","difficultyToCompact","bounty","closeType","INVALID_BLOCK","SENDING_PING_MESSAGE_FAILED","SENDING_OF_VERSION_MESSAGE_FAILED","SIMULTANEOUS_CONNECTION","DUPLICATE_CONNECTION","PEER_IS_BANNED","MANUAL_NETWORK_DISCONNECT","MANUAL_WEBSOCKET_DISCONNECT","MAX_PEER_COUNT_REACHED","PEER_CONNECTION_RECYCLED","PEER_CONNECTION_RECYCLED_INBOUND_EXCHANGE","INBOUND_CONNECTIONS_BLOCKED","MANUAL_PEER_DISCONNECT","ADDR_MESSAGE_TOO_LARGE","INVALID_ADDR","ADDR_NOT_GLOBALLY_REACHABLE","INVALID_SIGNAL_TTL","INVALID_SIGNATURE","RECEIVED_BLOCK_NOT_MATCHING_OUR_SUBSCRIPTION","INCOMPATIBLE_VERSION","DIFFERENT_GENESIS_BLOCK","INVALID_PEER_ADDRESS_IN_VERSION_MESSAGE","UNEXPECTED_PEER_ADDRESS_IN_VERSION_MESSAGE","INVALID_PUBLIC_KEY_IN_VERACK_MESSAGE","INVALID_SIGNATURE_IN_VERACK_MESSAGE","BANNED_IP","MANUAL_PEER_BAN","CLOSED_BY_REMOTE","PING_TIMEOUT","CONNECTION_FAILED","NETWORK_ERROR","VERSION_TIMEOUT","VERACK_TIMEOUT","FAILED_TO_PARSE_MESSAGE_TYPE","CONNECTION_LIMIT_PER_IP","CHANNEL_CLOSING","MANUAL_PEER_FAIL","_bytesSent","_bytesReceived","_inbound","_closed","_lastError","_id","_instanceCount","_onError","logAddress","_isChannelClosing","_isChannelClosed","_isChannelOpen","confirmExpectedMessage","connType","_close","bytesSent","bytesReceived","inbound","outbound","closed","PeerChannel","connection","_conn","rawMsg","Event","_send","ascending","NetworkAgent","_knownAddresses","_versionReceived","_verackReceived","_versionSent","_verackSent","_versionAttempts","_peerAddressVerified","_peerChallengeNonce","_pingTimes","_addrQueue","MAX_ADDR_RELAY_PER_MESSAGE","ADDR_QUEUE_INTERVAL","ADDR_RATE_LIMIT","_relayNow","_addrLimit","_onVersion","_onVerAck","_onAddr","_onGetAddr","_onPing","_onPong","filteredAddresses","RELAY_THROTTLE","_sendVerAck","HANDSHAKE_TIMEOUT","VERSION_ATTEMPTS_MAX","handshake","VERSION_RETRY_DELAY","_canAcceptMessage","isCompatible","verifySignature","storedAddress","Peer","_finishHandshake","verack","_checkConnectivity","CONNECTIVITY_CHECK_INTERVAL","ANNOUNCE_ADDR_INTERVAL","_requestAddresses","getAddr","MAX_ADDR_PER_MESSAGE","globallyReachable","query","ping","pong","startTime","PeerConnectionStatistics","_latencies","_messages","latency","msgType","latencyMedian","median","PeerConnection","peerConnection","PeerConnectionState","networkConnection","_networkConnection","_peerChannel","_networkAgent","_score","_establishedSince","_statistics","CONNECTED","peerChannel","networkAgent","NEGOTIATING","addLatency","addMessage","establishedSince","ageEstablished","statistics","SignalProcessor","rtcConnector","_rtcConnector","_forwards","SignalStore","myPeerId","signalForwarded","senderAddr","getByPeerId","unroutable","getChannelByPeerId","ForwardedSignal","oldest","lastSeen","SIGNAL_MAX_AGE","toDelete","dSignal","ConnectionPool","_connectionsByPeerAddress","_connectionsByNetAddress","_connectionsBySubnet","_wsConnector","peerAddr","_onConnectError","_peerCountWs","_peerCountRtc","_peerCountDumb","_peerCountFull","_peerCountLight","_peerCountNano","_peerCountOutbound","_peerCountFullWsOutbound","_connectingCount","_inboundCount","_signalProcessor","_allowInboundExchange","_allowInboundConnections","_bannedIPv4IPs","_bannedIPv6IPs","_checkUnbanIps","UNBAN_IPS_INTERVAL","_getSubnetAddress","subnet","isIPv4","IPV4_SUBNET_MASK","IPV6_SUBNET_MASK","_removeNetAddress","subnetAddress","peerConnections","isBanned","getConnectionByPeerAddress","getConnectionsByNetAddress","PEER_COUNT_PER_IP_MAX","getOutboundConnectionsBySubnet","OUTBOUND_PEER_COUNT_PER_SUBNET_MAX","_checkOutboundConnectionRequest","getOutbound","connecting","_isIpBanned","getConnectionsBySubnet","INBOUND_PEER_COUNT_PER_SUBNET_MAX","peerCount","PEER_COUNT_MAX","getInbound","_checkConnection","_addNetAddress","_checkHandshake","_onHandshake","storedConnection","negotiating","_updateConnectedPeerCount","_banIp","kbTransferred","toFixed","isIPv6","isLightNode","peerCountWs","peerCountRtc","peerCountDumb","peerCountFull","peerCountLight","peerCountNano","peerCountOutbound","peerCountFullWsOutbound","connectingCount","allowInboundExchange","PeerScorer","connections","_connections","_connectionScores","findCandidates","numCandidates","allowBadPeers","minCandidates","addressState","_scoreAddress","needsGoodPeers","goodCandidates","PICK_SELECTION_SIZE","canConnect","isGoodPeer","needsMorePeers","PEER_COUNT_MIN_FULL_WS_OUTBOUND","PEER_COUNT_MIN_OUTBOUND","_getMinAge","_scoreConnection","reset","scoreAge","_scoreConnectionAge","scoreOutbound","scoreType","scoreProtocol","BEST_PROTOCOL_WS_DISTRIBUTION","medianLatency","scoreSpeed","bestAge","maxAge","BEST_AGE_FULL","BEST_AGE_LIGHT","MAX_AGE_LIGHT","BEST_AGE_NANO","MAX_AGE_NANO","MIN_AGE_FULL","MIN_AGE_LIGHT","MIN_AGE_NANO","lowestConnectionScore","supportsWebRTC","RtcNetworkConfig","DumbNetworkConfig","_keyPair","PeerKeyStore","WsNetworkConfig","_key","_cert","_sslConfig","_rtcConfig","iceServers","urls","_autoConnect","_backoff","CONNECT_BACKOFF_INITIAL","_backedOff","_relayAddresses","_checkPeerCount","_onPeersChanged","_onRecyclingRequest","CONNECT_THROTTLE","_scorer","_houseKeepingIntervalId","disconnect","disconnectWebSocket","_updateTimeOffset","recycleConnections","SCORE_INBOUND_EXCHANGE","PEER_COUNT_RELAY","relayAddresses","isGoodPeerSet","CONNECTING_COUNT_MAX","pickAddress","onlyGoodPeers","oldBackoff","CONNECT_BACKOFF_MAX","connectOutbound","offsets","timeOffset","offsetsLength","TIME_OFFSET_MAX","scoreConnections","PEER_COUNT_RECYCLING_ACTIVE","percentageToRecycle","connectionsToRecycle","peerCountWebSocket","peerCountWebRtc","peerCountConnecting","isLocalIP","IPv4_PRIVATE_NETWORK","isIPv4inSubnet","subIp","mask","_IPv4toLong","isEmbeddedIPv4","innerEmpty","_normalizeIP","IP_BLACKLIST","_extendIPv6","maxZeroSeqStart","maxZeroSeqLength","curZeroSeqStart","curZeroSeqLength","hexIp","ipv6","ipv4","_IPv4toIPv6","emptyPart","stringResult","KEY_DATABASE","PeerKeyStoreCodec","leveldbValueEncoding","lmdbValueEncoding","_timeOffset","_setNetAddress","Miner","minerAddress","_lastHashrate","_hashrateWorker","_hashrate","_lastHashCounts","_totalHashCount","_lastElapsed","_totalElapsed","_workerPool","MinerWorkerPool","hardwareConcurrency","threads","cores","cpus","throttleAfter","_onWorkerShare","_mempoolChanged","_restarting","_lastRestart","_submittingBlock","_startWork","_updateHashrate","_retry","getNextBlock","startMiningOnBlock","stopWork","startWork","noncesPerRun","MIN_TIME_ON_BLOCK","_getNextInterlink","_getNextBody","_getNextHeader","commitBlockBody","_getNextTimestamp","interlinkSize","getMetadataSize","getTransactionsForBlock","elapsed","MOVING_AVERAGE_MAX_SIZE","oldestElapsed","oldestHashCount","hashrate","throttleWait","cycleWait","runsPerCycle","Wallet","fromEncrypted","exportEncrypted","lock","MultiSigWallet","minSignatures","multiSigKeys","k_combinations","numPublicKeys","serialBuf","_loadMultiSig","_minSignatures","_publicKeys","exportedSize","pubKey","encryptedExportedSize","recipientAddr","aggregatedCommitment","aggregatedPublicKey","fromPartialSignatures","multiSig","signTransaction","WalletStore","_jdb","_walletStore","_multiSigStore","WALLET_DATABASE","WalletStoreCodec","MULTISIG_WALLET_DATABASE","defaultAddress","defaultWallet","setDefault","base64Address","loadEncrypted","loadPlain","wallet","exportPlain","MinerWorker","minNonce","maxNonce","MinerWorkerImpl","_malloc","_nimiq_argon2_target","_free","_miningEnabled","_activeNonces","_noncesPerRun","_observable","_shareCompact","_runsPerCycle","_cycleWait","_superUpdateToSize","multiMine","fail","node_argon2_target_async","nonces","off","shareCompact","_startMiner","nonceRange","_singleMiner","newMin","newRange"],"mappings":"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","file":"node.js","sourcesContent":["module.exports = {};\nconst atob = require('atob');\nconst btoa = require('btoa');\nconst JDB = require('@nimiq/jungle-db');\nconst fs = require('fs');\nconst dns = require('dns');\nconst https = require('https');\nconst WebSocket = require('ws');\nconst NodeNative = require(`${__dirname}/nimiq_node`);\nconst chalk = require('chalk');\n\nglobal.Class = {\n    scope: module.exports,\n    register: clazz => {\n        module.exports[clazz.prototype.constructor.name] = clazz;\n    }\n};\n","class LogNative {\n    constructor() {\n        this._global_level = Log.INFO;\n        this._tag_levels = {};\n    }\n\n    isLoggable(tag, level) {\n        if (tag && tag.name) tag = tag.name;\n        if (tag && this._tag_levels[tag]) {\n            return this._tag_levels[tag] <= level;\n        }\n        return this._global_level <= level;\n    }\n\n    setLoggable(tag, level) {\n        this._tag_levels[tag] = level;\n    }\n\n    /**\n     * @param {Log.Level} level\n     * @param {string} tag\n     * @param {Array} args\n     */\n    msg(level, tag, args) {\n        if (!this.isLoggable(tag, level)) return;\n        if (tag && tag.name) tag = tag.name;\n        if (tag) args.unshift(chalk.bold(tag) + ':');\n        let prefix = `[${Log.Level.toStringTag(level)} ${new Date().toTimeString().substr(0, 8)}] `;\n        if (level >= Log.ERROR) {\n            console.log(prefix + chalk.red(args.join(' ')));\n        } else if (level >= Log.WARNING) {\n            console.log(prefix + chalk.yellow(args.join(' ')));\n        } else if (level >= Log.INFO) {\n            console.log(prefix + chalk.cyan(args.join(' ')));\n        } else if (level >= Log.DEBUG) {\n            console.log(prefix + chalk.magenta(args.join(' ')));\n        } else if (level <= Log.TRACE) {\n            console.trace(prefix + args.join(' '));\n        } else {\n            console.log(prefix + args.join(' '));\n        }\n    }\n}\nClass.register(LogNative);\n","class Log {\n    /**\n     * @returns {Log}\n     */\n    static get instance() {\n        if (!Log._instance) {\n            Log._instance = new Log(new LogNative());\n        }\n        return Log._instance;\n    }\n\n    /**\n     * @param {LogNative} native\n     */\n    constructor(native) {\n        /** @type {LogNative} */\n        this._native = native;\n    }\n\n    /**\n     * @param {string} tag\n     * @param {Log.Level} level\n     */\n    setLoggable(tag, level) {\n        this._native.setLoggable(tag, Log.Level.get(level));\n    }\n\n    /** @type {Log.Level} */\n    get level() {\n        return this._native._global_level;\n    }\n\n    /** @type {Log.Level} */\n    set level(l) {\n        this._native._global_level = Log.Level.get(l);\n    }\n\n    /**\n     * @param {Log.Level} level\n     * @param {string|{name:string}} tag\n     * @param {Array} args\n     */\n    msg(level, tag, args) {\n        if (this._native.isLoggable(tag, level)) {\n            for (let i = 0; i < args.length; ++i) {\n                if (typeof args[i] === 'function') {\n                    args[i] = args[i]();\n                }\n                if (typeof args[i] === 'object') {\n                    if (typeof args[i].toString === 'function') {\n                        args[i] = args[i].toString();\n                    } else if (args[i].constructor && args[i].constructor.name) {\n                        args[i] = `{Object: ${args[i].constructor.name}}`;\n                    } else {\n                        args[i] = '{Object}';\n                    }\n                }\n            }\n            this._native.msg(level, tag, args);\n        }\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static d(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.DEBUG, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static e(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.ERROR, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static i(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.INFO, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static v(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.VERBOSE, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static w(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.WARNING, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static t(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.TRACE, tag, args);\n    }\n}\n\n/**\n * @enum {number|string}\n */\nLog.Level = {\n    TRACE: 1,\n    VERBOSE: 2,\n    DEBUG: 3,\n    INFO: 4,\n    WARNING: 5,\n    ERROR: 6,\n    ASSERT: 7,\n\n    /**\n     * @param {Log.Level} level\n     * @returns {string}\n     */\n    toStringTag: function (level) {\n        switch (level) {\n            case Log.Level.TRACE:\n                return 'T';\n            case Log.Level.VERBOSE:\n                return 'V';\n            case Log.Level.DEBUG:\n                return 'D';\n            case Log.Level.INFO:\n                return 'I';\n            case Log.Level.WARNING:\n                return 'W';\n            case Log.Level.ERROR:\n                return 'E';\n            case Log.Level.ASSERT:\n                return 'A';\n            default:\n                return '*';\n        }\n    },\n\n    toString: function (level) {\n        switch (level) {\n            case Log.Level.TRACE:\n                return 'trace';\n            case Log.Level.VERBOSE:\n                return 'verbose';\n            case Log.Level.DEBUG:\n                return 'debug';\n            case Log.Level.INFO:\n                return 'info';\n            case Log.Level.WARNING:\n                return 'warn';\n            case Log.Level.ERROR:\n                return 'error';\n            case Log.Level.ASSERT:\n                return 'assert';\n            default:\n                return 'unknown';\n        }\n    },\n\n    /**\n     * @param {string|number|Log.Level} v\n     * @returns {Log.Level}\n     */\n    get: function (v) {\n        if (typeof v === 'number') return /** @type {Log.Level} */ v;\n        if (!isNaN(parseInt(v))) return /** @type {Log.Level} */ parseInt(v);\n        switch (v.toLowerCase()) {\n            case 't':\n            case 'trace':\n                return Log.Level.TRACE;\n            case 'v':\n            case 'verbose':\n                return Log.Level.VERBOSE;\n            case 'd':\n            case 'debug':\n                return Log.Level.DEBUG;\n            case 'i':\n            case 'info':\n                return Log.Level.INFO;\n            case 'w':\n            case 'warn':\n            case 'warning':\n                return Log.Level.WARNING;\n            case 'e':\n            case 'error':\n            case 'exception':\n                return Log.Level.ERROR;\n            case 'a':\n            case 'assert':\n            case 'assertion':\n                return Log.Level.ASSERT;\n        }\n        return /** @type {Log.Level} */ 0;\n    }\n};\nLog.TRACE = Log.Level.TRACE;\nLog.VERBOSE = Log.Level.VERBOSE;\nLog.DEBUG = Log.Level.DEBUG;\nLog.INFO = Log.Level.INFO;\nLog.WARNING = Log.Level.WARNING;\nLog.ERROR = Log.Level.ERROR;\nLog.ASSERT = Log.Level.ASSERT;\nLog._instance = null;\n\nLog.d.tag = (tag) => Log.d.bind(null, tag);\nLog.e.tag = (tag) => Log.e.bind(null, tag);\nLog.i.tag = (tag) => Log.i.bind(null, tag);\nLog.v.tag = (tag) => Log.v.bind(null, tag);\nLog.w.tag = (tag) => Log.w.bind(null, tag);\nLog.t.tag = (tag) => Log.t.bind(null, tag);\n\nClass.register(Log);\n","class Observable {\n    /**\n     * @returns {string}\n     * @constant\n     */\n    static get WILDCARD() {\n        return '*';\n    }\n\n    constructor() {\n        /** @type {Map.<string, Array.<Function>>} */\n        this._listeners = new Map();\n    }\n\n    /**\n     * @param {string} type\n     * @param {Function} callback\n     * @return {number}\n     */\n    on(type, callback) {\n        if (!this._listeners.has(type)) {\n            this._listeners.set(type, [callback]);\n            return 0;\n        } else {\n            return this._listeners.get(type).push(callback) - 1;\n        }\n    }\n\n    /**\n     * @param {string} type\n     * @param {number} id\n     */\n    off(type, id) {\n        if (!this._listeners.has(type) || !this._listeners.get(type)[id]) return;\n        delete this._listeners.get(type)[id];\n    }\n\n    /**\n     * @param {string} type\n     * @param {...*} args\n     */\n    fire(type, ...args) {\n        // Notify listeners for this event type.\n        if (this._listeners.has(type)) {\n            for (const i in this._listeners.get(type)) {\n                const listener = this._listeners.get(type)[i];\n                listener.apply(null, args);\n            }\n        }\n\n        // Notify wildcard listeners. Pass event type as first argument\n        if (this._listeners.has(Observable.WILDCARD)) {\n            for (const i in this._listeners.get(Observable.WILDCARD)) {\n                const listener = this._listeners.get(Observable.WILDCARD)[i];\n                listener.apply(null, arguments);\n            }\n        }\n    }\n\n    /**\n     * @param {Observable} observable\n     * @param {...string} types\n     */\n    bubble(observable, ...types) {\n        for (const type of types) {\n            let callback;\n            if (type == Observable.WILDCARD) {\n                callback = function() {\n                    this.fire.apply(this, arguments);\n                };\n            } else {\n                callback = function() {\n                    this.fire.apply(this, [type, ...arguments]);\n                };\n            }\n            observable.on(type, callback.bind(this));\n        }\n    }\n}\nClass.register(Observable);\n","/**\n * @abstract\n */\nclass DataChannel extends Observable {\n    constructor() {\n        super();\n\n        // Buffer for chunked messages.\n        // XXX We currently only support one chunked message at a time.\n        /** @type {SerialBuffer} */\n        this._buffer = null;\n\n        /** @type {Message.Type} */\n        this._msgType = 0;\n\n        /** @type {number} */\n        this._receivingTag = -1;\n\n        /** @type {number} */\n        this._sendingTag = 0;\n\n        /** @type {Map.<Message.Type, ExpectedMessage>} */\n        this._expectedMessagesByType = new Map();\n\n        /** @type {Timers} */\n        this._timers = new Timers();\n    }\n\n    /**\n     * @param {Message.Type} type\n     * @returns {boolean}\n     */\n    isExpectingMessage(type) {\n        return this._expectedMessagesByType.has(type);\n    }\n\n    /**\n     * @param {Message.Type} type\n     * @param {boolean} success\n     */\n    confirmExpectedMessage(type, success) {\n        const expectedMsg = this._expectedMessagesByType.get(type);\n        if (!expectedMsg) return;\n\n        this._timers.clearTimeout(`chunk-${expectedMsg.id}`);\n        this._timers.clearTimeout(`msg-${expectedMsg.id}`);\n        for (const type of expectedMsg.types) {\n            this._expectedMessagesByType.delete(type);\n        }\n\n        if (!success) {\n            expectedMsg.timeoutCallback();\n        }\n    }\n\n    /**\n     * @param {Message.Type|Array.<Message.Type>} types\n     * @param {function()} timeoutCallback\n     * @param {number} [msgTimeout]\n     * @param {number} [chunkTimeout]\n     */\n    expectMessage(types, timeoutCallback, msgTimeout = DataChannel.MESSAGE_TIMEOUT, chunkTimeout = DataChannel.CHUNK_TIMEOUT) {\n        if (!Array.isArray(types)) {\n            types = [types];\n        }\n\n        if (types.length === 0) return;\n\n        const expectedMsg = new ExpectedMessage(types, timeoutCallback, msgTimeout, chunkTimeout);\n        for (const type of types) {\n            this._expectedMessagesByType.set(type, expectedMsg);\n        }\n\n        // Set timers for any of the expected types.\n        this._timers.resetTimeout(`chunk-${expectedMsg.id}`, this._onTimeout.bind(this, expectedMsg), chunkTimeout);\n        this._timers.resetTimeout(`msg-${expectedMsg.id}`, this._onTimeout.bind(this, expectedMsg), msgTimeout);\n    }\n\n    /**\n     * @abstract\n     */\n\n    /* istanbul ignore next */\n    close() { throw new Error('Not implemented'); }\n\n    /**\n     * @protected\n     */\n    _onClose() {\n        this._timers.clearAll();\n        this.fire('close', this);\n    }\n\n    /**\n     * @param {string} msg\n     * @private\n     */\n    _error(msg) {\n        this.fire('error', msg, this);\n        Log.e(DataChannel, msg);\n        this.close();\n    }\n\n    /**\n     * @param {ArrayBuffer} msg\n     * @protected\n     */\n    _onMessage(msg) {\n        try {\n            // Drop message if the channel is not open.\n            if (this.readyState !== DataChannel.ReadyState.OPEN) {\n                return;\n            }\n\n            // Drop empty messages.\n            const buffer = new SerialBuffer(msg);\n            if (buffer.byteLength === 0) {\n                return;\n            }\n\n            // Chunk is too large.\n            if (buffer.byteLength > DataChannel.CHUNK_SIZE_MAX) {\n                this._error('Received chunk larger than maximum chunk size, discarding');\n                return;\n            }\n\n            const tag = buffer.readUint8();\n\n            // Buffer length without tag.\n            const effectiveChunkLength = buffer.byteLength - buffer.readPos;\n            const chunk = buffer.read(effectiveChunkLength);\n\n            // Detect if this is a new message.\n            if (this._buffer === null && tag === (this._receivingTag + 1) % NumberUtils.UINT8_MAX) {\n                const chunkBuffer = new SerialBuffer(chunk);\n                const messageSize = Message.peekLength(chunkBuffer);\n\n                if (messageSize > DataChannel.MESSAGE_SIZE_MAX) {\n                    this._error(`Received message with excessive message size ${messageSize} > ${DataChannel.MESSAGE_SIZE_MAX}`);\n                    return;\n                }\n\n                this._buffer = new SerialBuffer(messageSize);\n                this._receivingTag = tag;\n                this._msgType = Message.peekType(chunkBuffer);\n            }\n\n            if (this._buffer === null) {\n                Log.e(DataChannel, `Message does not start with next tag ${this._receivingTag + 1} (got ${tag} instead), but buffer is null`);\n                return;\n            }\n\n            // Currently, we only support one message at a time.\n            if (tag !== this._receivingTag) {\n                this._error(`Received message with wrong message tag ${tag}, expected ${this._receivingTag}`);\n                return;\n            }\n\n            let remainingBytes = this._buffer.byteLength - this._buffer.writePos;\n\n            // Mismatch between buffer sizes.\n            if (effectiveChunkLength > remainingBytes) {\n                this._error('Received chunk larger than remaining bytes to read, discarding');\n                return;\n            }\n\n            // Write chunk and subtract remaining byte length.\n            this._buffer.write(chunk);\n            remainingBytes -= effectiveChunkLength;\n\n            const expectedMsg = this._expectedMessagesByType.get(this._msgType);\n            if (remainingBytes === 0) {\n                const msg = this._buffer.buffer;\n                this._buffer = null;\n                this.fire('message', msg, this);\n            } else {\n                // Set timeout.\n                if (expectedMsg) {\n                    this._timers.resetTimeout(`chunk-${expectedMsg.id}`, this._onTimeout.bind(this, expectedMsg), expectedMsg.chunkTimeout);\n                }\n                this.fire('chunk', this._buffer);\n            }\n        } catch (e) {\n            this._error(`Error occurred while parsing incoming message, ${e.message}`);\n        }\n    }\n\n    /**\n     * @param {ExpectedMessage} [expectedMsg]\n     * @private\n     */\n    _onTimeout(expectedMsg) {\n        if (expectedMsg) {\n            this._timers.clearTimeout(`chunk-${expectedMsg.id}`);\n            this._timers.clearTimeout(`msg-${expectedMsg.id}`);\n\n            for (const type of expectedMsg.types) {\n                this._expectedMessagesByType.delete(type);\n            }\n\n            expectedMsg.timeoutCallback();\n        }\n\n        Log.e(DataChannel, 'Timeout while receiving chunked message');\n        this._buffer = null;\n    }\n\n    /**\n     * @param {Uint8Array} msg\n     */\n    send(msg) {\n        Assert.that(msg.byteLength <= DataChannel.MESSAGE_SIZE_MAX, 'DataChannel.send() max message size exceeded');\n\n        const tag = this._sendingTag;\n        this._sendingTag = (this._sendingTag + 1) % NumberUtils.UINT8_MAX;\n        this._sendChunked(msg, tag);\n    }\n\n    /**\n     * @param {Uint8Array} msg\n     * @param {number} tag\n     * @private\n     */\n    _sendChunked(msg, tag) {\n        // Send chunks.\n        let remaining = msg.byteLength;\n        let chunk = null;\n        while (remaining > 0) {\n            let buffer = null;\n            if (remaining + /*tag*/ 1 >= DataChannel.CHUNK_SIZE_MAX) {\n                buffer = new SerialBuffer(DataChannel.CHUNK_SIZE_MAX);\n                buffer.writeUint8(tag);\n                chunk = new Uint8Array(msg.buffer, msg.byteLength - remaining, DataChannel.CHUNK_SIZE_MAX - /*tag*/ 1);\n            } else {\n                buffer = new SerialBuffer(remaining + /*tag*/ 1);\n                buffer.writeUint8(tag);\n                chunk = new Uint8Array(msg.buffer, msg.byteLength - remaining, remaining);\n            }\n\n            buffer.write(chunk);\n            this.sendChunk(buffer);\n            remaining -= chunk.byteLength;\n        }\n    }\n\n    /**\n     * @abstract\n     * @param {Uint8Array} msg\n     */\n\n    /* istanbul ignore next */\n    sendChunk(msg) { throw  new Error('Not implemented'); }\n\n    /**\n     * @abstract\n     * @type {DataChannel.ReadyState}\n     */\n\n    /* istanbul ignore next */\n    get readyState() { throw new Error('Not implemented'); }\n}\n\nDataChannel.CHUNK_SIZE_MAX = 1024 * 16; // 16 kb\nDataChannel.MESSAGE_SIZE_MAX = 10 * 1024 * 1024; // 10 mb\nDataChannel.CHUNK_TIMEOUT = 1000 * 5; // 5 seconds\nDataChannel.MESSAGE_TIMEOUT = (DataChannel.MESSAGE_SIZE_MAX / DataChannel.CHUNK_SIZE_MAX) * DataChannel.CHUNK_TIMEOUT;\n\nclass ExpectedMessage {\n    /**\n     * @param {Array.<Message.Type>} types\n     * @param {function()} timeoutCallback\n     * @param {number} msgTimeout\n     * @param {number} chunkTimeout\n     */\n    constructor(types, timeoutCallback, msgTimeout = DataChannel.MESSAGE_TIMEOUT, chunkTimeout = DataChannel.CHUNK_TIMEOUT) {\n        this.id = types.join(':');\n        this.types = types;\n        this.timeoutCallback = timeoutCallback;\n        this.msgTimeout = msgTimeout;\n        this.chunkTimeout = chunkTimeout;\n    }\n}\n\n/**\n * @enum {number}\n */\nDataChannel.ReadyState = {\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSING: 2,\n    CLOSED: 3\n};\n\n/**\n * @param {string} str\n * @return {DataChannel.ReadyState}\n */\nDataChannel.ReadyState.fromString = function (str) {\n    switch (str) {\n        case 'connecting':\n            return DataChannel.ReadyState.CONNECTING;\n        case 'open':\n            return DataChannel.ReadyState.OPEN;\n        case 'closing':\n            return DataChannel.ReadyState.CLOSING;\n        case 'closed':\n            return DataChannel.ReadyState.CLOSED;\n        default:\n            throw new Error('Invalid string');\n    }\n};\n\nClass.register(DataChannel);\n","class CryptoLib {\n    static get instance() {\n        if (!CryptoLib._instance) {\n            const instance = {};\n            const crypto = require('crypto');\n            instance.getRandomValues = (buf) => {\n                if (!(buf instanceof Uint8Array)) {\n                    throw new TypeError('expected Uint8Array');\n                }\n                if (buf.length > 65536) {\n                    const e = new Error();\n                    e.code = 22;\n                    e.message = `Failed to execute 'getRandomValues' on 'Crypto': The ArrayBufferView's byte length ${buf.length} exceeds the number of bytes of entropy available via this API (65536).`;\n                    e.name = 'QuotaExceededError';\n                    throw e;\n                }\n                const bytes = crypto.randomBytes(buf.length);\n                buf.set(bytes);\n                return buf;\n            };\n\n            CryptoLib._instance = instance;\n        }\n        return CryptoLib._instance;\n    }\n}\n\nCryptoLib._instance = null;\nClass.register(CryptoLib);\n","/**\n * We don't have support for WebRTC in node.js, none of the methods\n * of this factory should ever be called in production. This may\n * change in the future.\n */\nclass WebRtcFactory {\n    /**\n     * @param {?RTCConfiguration} configuration\n     * @returns {?RTCPeerConnection}\n     */\n    static newPeerConnection(configuration) {\n        return null;\n    }\n\n    /**\n     * @param {*} rtcSessionDescriptionInit\n     * @returns {?RTCSessionDescription}\n     */\n    static newSessionDescription(rtcSessionDescriptionInit) {\n        return null;\n    }\n\n    /**\n     * @param {*} rtcIceCandidateInit\n     * @returns {?RTCIceCandidate}\n     */\n    static newIceCandidate(rtcIceCandidateInit) {\n        return null;\n    }\n}\nClass.register(WebRtcFactory);\n","class WebSocketFactory {\n    /**\n     * @static\n     * @param {NetworkConfig} networkConfig\n     * @return {WebSocketServer}\n     */\n    static newWebSocketServer(networkConfig) {\n        const port = networkConfig.peerAddress.port;\n        const sslConfig = networkConfig.sslConfig;\n\n        const options = {\n            key: fs.readFileSync(sslConfig.key),\n            cert: fs.readFileSync(sslConfig.cert)\n        };\n\n        const httpsServer = https.createServer(options, (req, res) => {\n            res.writeHead(200);\n            res.end('Nimiq NodeJS Client\\n');\n        }).listen(port);\n\n        return new WebSocket.Server({ server: httpsServer });\n    }\n\n    /**\n     * @static\n     * @param {string} url\n     * @param {*} [options]\n     * @return {WebSocket}\n     */\n    static newWebSocket(url, options) {\n        return new WebSocket(url, options);\n    }\n}\nClass.register(WebSocketFactory);\n","class DnsUtils {\n    /**\n     * @static\n     * @param {string} host\n     * @returns {Promise.<NetAddress>}\n     */\n    static lookup(host) {\n        return new Promise((resolve, reject) => {\n            dns.lookup(host, (err, address, family) => {\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                resolve(NetAddress.fromIP(address, true));\n            });\n        });\n    }\n}\nClass.register(DnsUtils);\n","class ConstantHelper {\n    constructor() {\n        this._originalValues = new Map();\n    }\n\n    static get instance() {\n        if (!ConstantHelper._instance) {\n            ConstantHelper._instance = new ConstantHelper();\n        }\n        return ConstantHelper._instance;\n    }\n\n    /**\n     * @param {string} constant\n     * @return {boolean}\n     */\n    isConstant(constant) {\n        if (constant.indexOf('.') < 1) return false;\n        const clazz = constant.split('.', 2)[0];\n        constant = constant.split('.', 2)[1];\n        if (constant.startsWith('_')) return false;\n        if (constant.toUpperCase() !== constant) return false;\n        if (!(clazz in Class.scope)) return false;\n        if (!Class.scope[clazz]) return false;\n        if (!Class.scope[clazz].hasOwnProperty) return false;\n        if (!Class.scope[clazz].hasOwnProperty(constant)) return false;\n        if (!Object.keys(Class.scope[clazz]).includes(constant)) return false;\n        if (typeof Class.scope[clazz][constant] !== 'number') return false;\n        return true;\n    }\n\n    /**\n     * @param {string} constant\n     */\n    _ensureIsConstant(constant) {\n        if (!this.isConstant(constant)) {\n            throw new Error(`${constant} is not a numerical constant.`);\n        }\n    }\n\n    /**\n     * @param {string} constant\n     * @returns {number}\n     */\n    get(constant) {\n        this._ensureIsConstant(constant);\n        const clazz = constant.split('.', 2)[0];\n        constant = constant.split('.', 2)[1];\n        return Class.scope[clazz][constant];\n    }\n\n    /**\n     * @param {string} constant\n     * @param {number} value\n     */\n    set(constant, value) {\n        this._ensureIsConstant(constant);\n        if (!this._originalValues.has(constant)) {\n            this._originalValues.set(constant, this.get(constant));\n        }\n        const clazz = constant.split('.', 2)[0];\n        constant = constant.split('.', 2)[1];\n        Class.scope[clazz][constant] = value;\n    }\n\n    /**\n     * @param {string} constant\n     */\n    reset(constant) {\n        this._ensureIsConstant(constant);\n        if (this._originalValues.has(constant)) {\n            this.set(constant, this._originalValues.get(constant));\n        }\n    }\n}\n\nClass.register(ConstantHelper);\n","class Services {\n    /**\n     * @constructor\n     * @param {number} [provided=Services.NONE] Bitmap of services that can be provided by this node\n     * @param {number} [accepted=Services.NONE] Bitmap of services that can be accepted by this node\n     */\n    constructor(provided = Services.NONE, accepted = Services.NONE) {\n        this._provided = provided;\n        this._accepted = accepted;\n    }\n\n    /**\n     * @type {number}\n     */\n    get provided() {\n        return this._provided;\n    }\n\n    /**\n     * @type {number}\n     */\n    get accepted() {\n        return this._accepted;\n    }\n\n    /**\n     * @param {number} services Bitmap of services that can be provided\n     */\n    set provided(services) {\n        this._provided = services;\n    }\n\n    /**\n     * @param {number} services Bitmap of services that can be accepted\n     */\n    set accepted(services) {\n        this._accepted = services;\n    }\n\n    /**\n     * @param {number} services Bitmap of the services to check\n     * @returns {boolean}\n     */\n    static isFullNode(services) {\n        return (services & Services.FULL) !== 0;\n    }\n\n    /**\n     * @param {number} services Bitmap of the services to check\n     * @returns {boolean}\n     */\n    static isLightNode(services) {\n        return (services & Services.LIGHT) !== 0;\n    }\n\n    /**\n     * @param {number} services Bitmap of the services to check\n     * @returns {boolean}\n     */\n    static isNanoNode(services) {\n        return services === Services.NANO;\n    }\n}\nServices.NONE   = 0;\nServices.NANO   = 1;\nServices.LIGHT  = 2;\nServices.FULL   = 4;\nClass.register(Services);\n","class Timers {\n    constructor() {\n        this._timeouts = {};\n        this._intervals = {};\n    }\n\n    setTimeout(key, fn, waitTime) {\n        if (this._timeouts[key]) throw 'Duplicate timeout for key ' + key;\n        this._timeouts[key] = setTimeout(fn, waitTime);\n    }\n\n    clearTimeout(key) {\n        clearTimeout(this._timeouts[key]);\n        delete this._timeouts[key];\n    }\n\n    resetTimeout(key, fn, waitTime) {\n        clearTimeout(this._timeouts[key]);\n        this._timeouts[key] = setTimeout(fn, waitTime);\n    }\n\n    timeoutExists(key) {\n        return this._timeouts[key] !== undefined;\n    }\n\n    setInterval(key, fn, intervalTime) {\n        if (this._intervals[key]) throw 'Duplicate interval for key ' + key;\n        this._intervals[key] = setInterval(fn, intervalTime);\n    }\n\n    clearInterval(key) {\n        clearInterval(this._intervals[key]);\n        delete this._intervals[key];\n    }\n\n    resetInterval(key, fn, intervalTime) {\n        clearInterval(this._intervals[key]);\n        this._intervals[key] = setInterval(fn, intervalTime);\n    }\n\n    intervalExists(key) {\n        return this._intervals[key] !== undefined;\n    }\n\n    clearAll() {\n        for (const key in this._timeouts) {\n            this.clearTimeout(key);\n        }\n        for (const key in this._intervals) {\n            this.clearInterval(key);\n        }\n    }\n}\nClass.register(Timers);\n","class Version {\n    static isCompatible(code) {\n        // Allow future, backwards-compatible versions.\n        return code >= Version.CODE;\n    }\n}\nVersion.CODE = 1;\nClass.register(Version);\n","/**\n * This class stores and provides the network time (current system\n * time with an offset calculated from our peer's time)\n */\nclass Time {\n    /**\n     * @constructor\n     * @param {number} [offset=0]\n     */\n    constructor(offset = 0) {\n        this._offset = offset;\n    }\n\n    /**\n     * @param {number} offset\n     */\n    set offset(offset) {\n        this._offset = offset;\n    }\n\n    /**\n     * Returns the current time adjusted with the network's offset\n     * @return {number}\n     */\n    now() {\n        return Date.now() + this._offset;\n    }\n}\nClass.register(Time);\n","class ArrayUtils {\n    /**\n     * @template T\n     * @param {Array.<T>} arr\n     * @return {T}\n     */\n    static randomElement(arr) {\n        return arr[Math.floor(Math.random() * arr.length)];\n    }\n\n    /**\n     * @param {Uint8Array} uintarr\n     * @param {number} begin\n     * @param {number} end\n     * @return {Uint8Array}\n     */\n    static subarray(uintarr, begin, end) {\n        function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }\n\n        if (begin === undefined) { begin = 0; }\n        if (end === undefined) { end = uintarr.byteLength; }\n\n        begin = clamp(begin, 0, uintarr.byteLength);\n        end = clamp(end, 0, uintarr.byteLength);\n\n        let len = end - begin;\n        if (len < 0) {\n            len = 0;\n        }\n\n        return new Uint8Array(uintarr.buffer, uintarr.byteOffset + begin, len);\n    }\n\n    /**\n     * @param {Array} list\n     * @param {number} k\n     * @return {Generator}\n     */\n    static *k_combinations(list, k) {\n        const n = list.length;\n        // Shortcut:\n        if (k > n) {\n            return;\n        }\n        const indices = Array.from(new Array(k), (x,i) => i);\n        yield indices.map(i => list[i]);\n        const reverseRange = Array.from(new Array(k), (x,i) => k-i-1);\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n            let i = k-1, found = false;\n            for (i of reverseRange) {\n                if (indices[i] !== i + n - k) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return;\n            }\n            indices[i] += 1;\n            for (const j of Array.from(new Array(k-i-1), (x,k) => i+k+1)) {\n                indices[j] = indices[j-1] + 1;\n            }\n            yield indices.map(i => list[i]);\n        }\n    }\n}\nClass.register(ArrayUtils);\n","/**\n * @template K,V\n */\nclass HashMap {\n    /**\n     * @param {function(o: object): string} [fnHash]\n     */\n    constructor(fnHash = HashMap._hash) {\n        /** @type {Map.<string,V>} */\n        this._map = new Map();\n        /** @type {function(o: object): string} */\n        this._fnHash = fnHash;\n    }\n\n    /**\n     * @param {{hashCode: function():string}|*} o\n     * @returns {string}\n     * @private\n     */\n    static _hash(o) {\n        if (o === null || o === undefined) return o;\n        return o.hashCode ? o.hashCode() : o.toString();\n    }\n\n    /**\n     * @param {K|*} key\n     * @returns {V|*}\n     */\n    get(key) {\n        return this._map.get(this._fnHash(key));\n    }\n\n    /**\n     * @param {K|*} key\n     * @param {V|*} value\n     */\n    put(key, value) {\n        this._map.set(this._fnHash(key), value);\n    }\n\n    /**\n     * @param {K|*} key\n     */\n    remove(key) {\n        this._map.delete(this._fnHash(key));\n    }\n\n    clear() {\n        this._map.clear();\n    }\n\n    /**\n     * @param {K|*} key\n     * @returns {boolean}\n     */\n    contains(key) {\n        return this._map.has(this._fnHash(key));\n    }\n\n    /**\n     * @returns {Array.<K|*>}\n     */\n    keys() {\n        return Array.from(this._map.keys());\n    }\n\n    /**\n     * @returns {Iterator.<K|*>}\n     */\n    keyIterator() {\n        return this._map.keys();\n    }\n\n    /**\n     * @returns {Array.<V|*>}\n     */\n    values() {\n        return Array.from(this._map.values());\n    }\n\n    /**\n     * @returns {Iterator.<V|*>}\n     */\n    valueIterator() {\n        return this._map.values();\n    }\n\n    /**\n     * @returns {number}\n     */\n    get length() {\n        return this._map.size;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return this._map.size === 0;\n    }\n}\nClass.register(HashMap);\n","/**\n * @template V\n * @implements {Iterable.<V>}\n */\nclass HashSet {\n    constructor(fnHash = HashSet._hash) {\n        /** @type {Map.<string,V>} */\n        this._map = new Map();\n        /** @type {function(o: object): string} */\n        this._fnHash = fnHash;\n    }\n\n    /**\n     * @param {{hashCode: function():string}|*} o\n     * @returns {string}\n     * @private\n     */\n    static _hash(o) {\n        if (o === null || o === undefined) return o;\n        return o.hashCode ? o.hashCode() : o.toString();\n    }\n\n    /**\n     * @param {V|*} value\n     */\n    add(value) {\n        this._map.set(this._fnHash(value), value);\n    }\n\n    /**\n     * @param {Iterable.<V|*>} collection\n     */\n    addAll(collection) {\n        for (const value of collection) {\n            this.add(value);\n        }\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {V|*}\n     */\n    get(value) {\n        return this._map.get(this._fnHash(value));\n    }\n\n    /**\n     * @param {V|*} value\n     */\n    remove(value) {\n        this._map.delete(this._fnHash(value));\n    }\n\n    /**\n     * @param {Array.<V|*>} collection\n     */\n    removeAll(collection) {\n        for (const value of collection) {\n            this.remove(value);\n        }\n    }\n\n    clear() {\n        this._map.clear();\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {boolean}\n     */\n    contains(value) {\n        return this._map.has(this._fnHash(value));\n    }\n\n    /**\n     * @returns {Array.<V|*>}\n     */\n    values() {\n        return Array.from(this._map.values());\n    }\n\n    /**\n     * @returns {Iterator.<V|*>}\n     */\n    valueIterator() {\n        return this._map.values();\n    }\n\n    /**\n     * @returns {Iterator.<V|*>}\n     */\n    [Symbol.iterator]() {\n        return this.valueIterator();\n    }\n\n    /**\n     * @returns {number}\n     */\n    get length() {\n        return this._map.size;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return this._map.size === 0;\n    }\n}\nClass.register(HashSet);\n","/**\n * @template T\n * @implements {Iterable.<T>}\n */\nclass LimitIterable {\n    /**\n     * @param {Iterable.<T>|Iterator.<T>} it\n     * @param {number} limit\n     */\n    constructor(it, limit) {\n        /** @type {Iterator.<T>} */\n        this._iterator = it[Symbol.iterator] ? it[Symbol.iterator]() : it;\n        /** @type {number} */\n        this._limit = limit;\n    }\n\n    /**\n     * @returns {{next: function():object}}\n     */\n    [Symbol.iterator]() {\n        return LimitIterable.iterator(this._iterator, this._limit);\n    }\n\n    /**\n     * @template V\n     * @param {Iterator.<V>} iterator\n     * @param {number} limit\n     * @returns {{next: function():object}}\n     */\n    static iterator(iterator, limit) {\n        let count = 0;\n        return {\n            next: () => {\n                const done = count++ >= limit;\n                const next = iterator.next();\n                return {\n                    value: done ? undefined : next.value,\n                    done: done || next.done\n                };\n            }\n        };\n    }\n}\nClass.register(LimitIterable);\n","/**\n * @template V\n */\nclass Queue {\n    /**\n     * @param {function(o: object): string} [fnHash]\n     */\n    constructor(fnHash) {\n        /**\n         * @type {Array.<V|*>}\n         * @protected\n         */\n        this._queue = [];\n\n        /**\n         * @type {function(o: object): string}\n         * @protected\n         */\n        this._fnHash = fnHash || Queue._hash;\n    }\n\n    /**\n     * @param {{hashCode: function():string}|*} o\n     * @returns {string}\n     * @protected\n     */\n    static _hash(o) {\n        if (o === null || o === undefined) return o;\n        return o.hashCode ? o.hashCode() : o.toString();\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {void}\n     */\n    enqueue(value) {\n        this._queue.push(value);\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {void}\n     */\n    enqueueFirst(value) {\n        this._queue.unshift(value);\n    }\n\n    /**\n     * @returns {V|*}\n     */\n    dequeue() {\n        return this._queue.shift();\n    }\n\n    /**\n     * @returns {V|*}\n     */\n    peek() {\n        return this._queue[0];\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {number}\n     */\n    indexOf(value) {\n        const hash = this._fnHash(value);\n        for (let i = 0; i < this._queue.length; ++i) {\n            if (hash === this._fnHash(this._queue[i])) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {void}\n     */\n    remove(value) {\n        const index = this.indexOf(value);\n        if (index > -1) {\n            this._queue.splice(index, 1);\n        }\n    }\n\n    /**\n     * @param {number} count\n     * @returns {Array.<V|*>}\n     */\n    dequeueMulti(count) {\n        return this._queue.splice(0, count);\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {Array.<V|*>}\n     */\n    dequeueUntil(value) {\n        const index = this.indexOf(value);\n        if (index > -1) {\n            return this._queue.splice(0, index + 1);\n        }\n        return [];\n    }\n\n    /**\n     * @returns {void}\n     */\n    clear() {\n        this._queue = [];\n    }\n\n    /**\n     * @returns {Array.<V|*>}\n     */\n    values() {\n        return this._queue;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return this.length === 0;\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._queue.length;\n    }\n}\nClass.register(Queue);\n","/**\n * @template V\n */\nclass UniqueQueue extends Queue {\n    /**\n     * @param {function(o: object): string} [fnHash]\n     */\n    constructor(fnHash) {\n        super(fnHash);\n        this._set = new Set();\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {void}\n     * @override\n     */\n    enqueue(value) {\n        super.enqueue(value);\n        this._set.add(this._fnHash(value));\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {void}\n     * @override\n     */\n    enqueueFirst(value) {\n        super.enqueueFirst(value);\n        this._set.add(this._fnHash(value));\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {void}\n     * @override\n     */\n    enqueueUnique(value) {\n        const hashCode = this._fnHash(value);\n        if (this._set.has(hashCode)) return;\n\n        super.enqueue(value);\n        this._set.add(hashCode);\n    }\n\n    /**\n     * @param {Array.<V|*>} values\n     * @returns {void}\n     * @override\n     */\n    enqueueAllNew(values) {\n        for (const value of values) {\n            this.enqueueUnique(value);\n        }\n    }\n\n    /**\n     * @returns {V|*}\n     * @override\n     */\n    dequeue() {\n        const value = super.dequeue();\n        this._set.delete(this._fnHash(value));\n        return value;\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {void}\n     * @override\n     */\n    remove(value) {\n        super.remove(value);\n        this._set.delete(this._fnHash(value));\n    }\n\n    /**\n     * @param {number} count\n     * @returns {Array.<V|*>}\n     * @override\n     */\n    dequeueMulti(count) {\n        const values = super.dequeueMulti(count);\n        for (const value of values) {\n            this._set.delete(this._fnHash(value));\n        }\n        return values;\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {Array.<V|*>}\n     * @override\n     */\n    dequeueUntil(value) {\n        const values = super.dequeueUntil(value);\n        for (const val of values) {\n            this._set.delete(this._fnHash(val));\n        }\n        return values;\n    }\n}\nClass.register(UniqueQueue);\n","class ThrottledQueue extends UniqueQueue {\n    /**\n     * @param {number} [maxAtOnce]\n     * @param {number} [allowanceNum]\n     * @param {number} [allowanceInterval]\n     * @param {number} [maxSize]\n     * @param {function} [allowanceCallback]\n     */\n    constructor(maxAtOnce = Number.POSITIVE_INFINITY, allowanceNum = maxAtOnce, allowanceInterval = 1000, maxSize = Number.POSITIVE_INFINITY, allowanceCallback) {\n        super();\n        this._maxSize = maxSize;\n        this._maxAtOnce = maxAtOnce;\n        this._availableNow = this._maxAtOnce;\n\n        this._timers = new Timers();\n        this._timers.setInterval('allowance', () => {\n            this._availableNow = Math.min(this._maxAtOnce, this._availableNow + allowanceNum);\n            if (typeof allowanceCallback === 'function' && this.isAvailable()) allowanceCallback();\n        }, allowanceInterval);\n    }\n\n    stop() {\n        this._timers.clearAll();\n    }\n\n    enqueue(value) {\n        if (this.length >= this._maxSize) return;\n        super.enqueue(value);\n    }\n\n    enqueueFirst(value) {\n        super.enqueueFirst(value);\n        if (this.length > this._maxSize) this._queue.pop();\n    }\n\n    dequeue() {\n        if (this.available > 0) {\n            this._availableNow--;\n            return super.dequeue();\n        }\n        return null;\n    }\n\n    /**\n     * @param count\n     * @returns {Array}\n     */\n    dequeueMulti(count) {\n        count = Math.min(this.available, count);\n        this._availableNow -= count;\n        return super.dequeueMulti(count);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isAvailable() {\n        return this.available > 0;\n    }\n\n    get available() {\n        return Math.min(this._availableNow, this.length);\n    }\n}\n\nClass.register(ThrottledQueue);\n","class SortedList {\n    constructor(sortedList = [], compare) {\n        this._list = sortedList;\n        this._compare = compare || SortedList._compare;\n    }\n\n    static _compare(a, b) {\n        return a.compare ? a.compare(b) : (a > b ? 1 : (a < b ? -1 : 0));\n    }\n\n    indexOf(o) {\n        let a = 0, b = this._list.length - 1;\n        let currentIndex = null;\n        let currentElement = null;\n\n        while (a <= b) {\n            currentIndex = Math.round((a + b) / 2);\n            currentElement = this._list[currentIndex];\n\n            if (this._compare(currentElement, o) < 0) {\n                a = currentIndex + 1;\n            }\n            else if (this._compare(currentElement, o) > 0) {\n                b = currentIndex - 1;\n            }\n            else {\n                return currentIndex;\n            }\n        }\n\n        return -1;\n    }\n\n    _insertionIndex(o) {\n        let a = 0, b = this._list.length - 1;\n        let currentIndex = null;\n        let currentElement = null;\n\n        while (a <= b) {\n            currentIndex = Math.round((a + b) / 2);\n            currentElement = this._list[currentIndex];\n\n            if (this._compare(currentElement, o) < 0) {\n                a = currentIndex + 1;\n            }\n            else if (this._compare(currentElement, o) > 0) {\n                b = currentIndex - 1;\n            }\n            else {\n                break;\n            }\n        }\n\n        return a;\n    }\n\n    add(value) {\n        this._list.splice(this._insertionIndex(value), 0, value);\n    }\n\n    shift() {\n        return this._list.shift();\n    }\n\n    pop() {\n        return this._list.pop();\n    }\n\n    peekFirst() {\n        return this._list[0];\n    }\n\n    peekLast() {\n        return this._list[this._list.length - 1];\n    }\n\n    remove(value) {\n        const index = this.indexOf(value);\n        if (index > -1) {\n            this._list.splice(index, 1);\n        }\n    }\n\n    clear() {\n        this._list = [];\n    }\n\n    values() {\n        return this._list;\n    }\n\n    /**\n     * @returns {Iterator.<V|*>}\n     */\n    [Symbol.iterator]() {\n        return this._list[Symbol.iterator]();\n    }\n\n    copy() {\n        return new SortedList(this._list.slice(), this._compare);\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._list.length;\n    }\n}\nClass.register(SortedList);\n","class Assert {\n    /**\n     * @param {boolean} condition\n     * @param {string} [message]\n     * @returns {void}\n     */\n    static that(condition, message = 'Assertion failed') {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n}\nClass.register(Assert);\n","class BufferUtils {\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toAscii(buffer) {\n        return String.fromCharCode.apply(null, new Uint8Array(buffer));\n    }\n\n    /**\n     * @param {string} string\n     * @return {Uint8Array}\n     */\n    static fromAscii(string) {\n        const buf = new Uint8Array(string.length);\n        for (let i = 0; i < string.length; ++i) {\n            buf[i] = string.charCodeAt(i);\n        }\n        return buf;\n    }\n\n    static _codePointTextDecoder(u8) {\n        if (typeof TextDecoder === 'undefined') throw new Error('TextDecoder not supported');\n        if (BufferUtils._ISO_8859_15_DECODER === null) throw new Error('TextDecoder does not supprot iso-8859-15');\n        if (BufferUtils._ISO_8859_15_DECODER === undefined) {\n            try {\n                BufferUtils._ISO_8859_15_DECODER = new TextDecoder('iso-8859-15');\n            } finally {\n                BufferUtils._ISO_8859_15_DECODER = null;\n            }\n        }\n        return BufferUtils._ISO_8859_15_DECODER.decode(u8)\n            .replace('', '').replace('', '').replace('', '').replace('', '')\n            .replace('', '').replace('', '').replace('', '').replace('', '');\n    }\n\n    static _tripletToBase64(num) {\n        return BufferUtils._BASE64_LOOKUP[num >> 18 & 0x3F] + BufferUtils._BASE64_LOOKUP[num >> 12 & 0x3F] + BufferUtils._BASE64_LOOKUP[num >> 6 & 0x3F] + BufferUtils._BASE64_LOOKUP[num & 0x3F];\n    }\n\n    static _base64encodeChunk(u8, start, end) {\n        let tmp;\n        const output = [];\n        for (let i = start; i < end; i += 3) {\n            tmp = ((u8[i] << 16) & 0xFF0000) + ((u8[i + 1] << 8) & 0xFF00) + (u8[i + 2] & 0xFF);\n            output.push(BufferUtils._tripletToBase64(tmp));\n        }\n        return output.join('');\n    }\n\n    static _base64fromByteArray(u8) {\n        let tmp;\n        const len = u8.length;\n        const extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n        let output = '';\n        const parts = [];\n        const maxChunkLength = 16383; // must be multiple of 3\n\n        // go through the array every three bytes, we'll deal with trailing stuff later\n        for (let i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n            parts.push(BufferUtils._base64encodeChunk(u8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n        }\n\n        // pad the end with zeros, but make sure to not forget the extra bytes\n        if (extraBytes === 1) {\n            tmp = u8[len - 1];\n            output += BufferUtils._BASE64_LOOKUP[tmp >> 2];\n            output += BufferUtils._BASE64_LOOKUP[(tmp << 4) & 0x3F];\n            output += '==';\n        } else if (extraBytes === 2) {\n            tmp = (u8[len - 2] << 8) + (u8[len - 1]);\n            output += BufferUtils._BASE64_LOOKUP[tmp >> 10];\n            output += BufferUtils._BASE64_LOOKUP[(tmp >> 4) & 0x3F];\n            output += BufferUtils._BASE64_LOOKUP[(tmp << 2) & 0x3F];\n            output += '=';\n        }\n\n        parts.push(output);\n\n        return parts.join('');\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toBase64(buffer) {\n        if (PlatformUtils.isNodeJs()) {\n            return new Buffer(buffer).toString('base64');\n        } else if (typeof TextDecoder !== 'undefined' && BufferUtils._ISO_8859_15_DECODER !== null) {\n            try {\n                return btoa(BufferUtils._codePointTextDecoder(new Uint8Array(buffer)));\n            } catch (e) {\n                // Disabled itself\n            }\n        }\n\n        return BufferUtils._base64fromByteArray(new Uint8Array(buffer));\n    }\n\n    /**\n     * @param {string} base64\n     * @return {SerialBuffer}\n     */\n    static fromBase64(base64) {\n        return new SerialBuffer(Uint8Array.from(atob(base64), c => c.charCodeAt(0)));\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toBase64Url(buffer) {\n        return BufferUtils.toBase64(buffer).replace(/\\//g, '_').replace(/\\+/g, '-').replace(/=/g, '.');\n    }\n\n    /**\n     * @param {string} base64\n     * @return {SerialBuffer}\n     */\n    static fromBase64Url(base64) {\n        return new SerialBuffer(Uint8Array.from(atob(base64.replace(/_/g, '/').replace(/-/g, '+').replace(/\\./g, '=')), c => c.charCodeAt(0)));\n    }\n\n    /**\n     * @param {Uint8Array} buf\n     * @param {string} [alphabet] Alphabet to use\n     * @return {string}\n     */\n    static toBase32(buf, alphabet = BufferUtils.BASE32_ALPHABET.NIMIQ) {\n        let shift = 3, carry = 0, byte, symbol, i, res = '';\n\n        for (i = 0; i < buf.length; i++) {\n            byte = buf[i];\n            symbol = carry | (byte >> shift);\n            res += alphabet[symbol & 0x1f];\n\n            if (shift > 5) {\n                shift -= 5;\n                symbol = byte >> shift;\n                res += alphabet[symbol & 0x1f];\n            }\n\n            shift = 5 - shift;\n            carry = byte << shift;\n            shift = 8 - shift;\n        }\n\n        if (shift !== 3) {\n            res += alphabet[carry & 0x1f];\n        }\n\n        while (res.length % 8 !== 0 && alphabet.length === 33) {\n            res += alphabet[32];\n        }\n\n        return res;\n    }\n\n    /**\n     * @param {string} base32\n     * @param {string} [alphabet] Alphabet to use\n     * @return {Uint8Array}\n     */\n    static fromBase32(base32, alphabet = BufferUtils.BASE32_ALPHABET.NIMIQ) {\n        const charmap = [];\n        alphabet.toUpperCase().split('').forEach((c, i) => {\n            if (!(c in charmap)) charmap[c] = i;\n        });\n\n        let symbol, shift = 8, carry = 0, buf = [];\n        base32.toUpperCase().split('').forEach((char) => {\n            // ignore padding\n            if (alphabet.length === 33 && char === alphabet[32]) return;\n\n            symbol = charmap[char] & 0xff;\n\n            shift -= 5;\n            if (shift > 0) {\n                carry |= symbol << shift;\n            } else if (shift < 0) {\n                buf.push(carry | (symbol >> -shift));\n                shift += 8;\n                carry = (symbol << shift) & 0xff;\n            } else {\n                buf.push(carry | symbol);\n                shift = 8;\n                carry = 0;\n            }\n        });\n\n        if (shift !== 8 && carry !== 0) {\n            buf.push(carry);\n        }\n\n        return new Uint8Array(buf);\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toHex(buffer) {\n        let hex = '';\n        for (let i = 0; i < buffer.length; i++) {\n            const code = buffer[i];\n            hex += BufferUtils.HEX_ALPHABET[code >>> 4];\n            hex += BufferUtils.HEX_ALPHABET[code & 0x0F];\n        }\n        return hex;\n    }\n\n    /**\n     * @param {string} hex\n     * @return {SerialBuffer}\n     */\n    static fromHex(hex) {\n        hex = hex.trim();\n        if (!StringUtils.isHexBytes(hex)) return null;\n        return new SerialBuffer(Uint8Array.from(hex.match(/.{2}/g) || [], byte => parseInt(byte, 16)));\n    }\n\n    /**\n     * @template T\n     * @param {T} a\n     * @param {*} b\n     * @return {T}\n     */\n    static concatTypedArrays(a, b) {\n        const c = new (a.constructor)(a.length + b.length);\n        c.set(a, 0);\n        c.set(b, a.length);\n        return c;\n    }\n\n    /**\n     * @param {*} a\n     * @param {*} b\n     * @return {boolean}\n     */\n    static equals(a, b) {\n        if (a.length !== b.length) return false;\n        const viewA = new Uint8Array(a);\n        const viewB = new Uint8Array(b);\n        for (let i = 0; i < a.length; i++) {\n            if (viewA[i] !== viewB[i]) return false;\n        }\n        return true;\n    }\n\n    /**\n     * @param {*} a\n     * @param {*} b\n     * @return {number} -1 if a is smaller than b, 1 if a is larger than b, 0 if a equals b.\n     */\n    static compare(a, b) {\n        if (a.length < b.length) return -1;\n        if (a.length > b.length) return 1;\n        for (let i = 0; i < a.length; i++) {\n            if (a[i] < b[i]) return -1;\n            if (a[i] > b[i]) return 1;\n        }\n        return 0;\n    }\n\n    /**\n     * @param {Uint8Array} a\n     * @param {Uint8Array} b\n     * @return {Uint8Array}\n     */\n    static xor(a, b) {\n        const res = new Uint8Array(a.byteLength);\n        for (let i = 0; i < a.byteLength; ++i) {\n            res[i] = a[i] ^ b[i];\n        }\n        return res;\n    }\n}\nBufferUtils.BASE64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nBufferUtils.BASE32_ALPHABET = {\n    RFC4648: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n    RFC4648_HEX: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n    NIMIQ: '0123456789ABCDEFGHJKLMNPQRSTUVXY'\n};\nBufferUtils.HEX_ALPHABET = '0123456789abcdef';\nBufferUtils._BASE64_LOOKUP = [];\nfor (let i = 0, len = BufferUtils.BASE64_ALPHABET.length; i < len; ++i) {\n    BufferUtils._BASE64_LOOKUP[i] = BufferUtils.BASE64_ALPHABET[i];\n}\n\nClass.register(BufferUtils);\n","class SerialBuffer extends Uint8Array {\n    /**\n     * @param {*} bufferOrArrayOrLength\n     */\n    constructor(bufferOrArrayOrLength) {\n        super(bufferOrArrayOrLength);\n        this._view = new DataView(this.buffer);\n        this._readPos = 0;\n        this._writePos = 0;\n    }\n\n    /**\n     * @param {number} start\n     * @param {number} end\n     * @return {Uint8Array}\n     */\n    subarray(start, end) {\n        return ArrayUtils.subarray(this, start, end);\n    }\n\n    /** @type {number} */\n    get readPos() {\n        return this._readPos;\n    }\n\n    /** @type {number} */\n    set readPos(value) {\n        if (value < 0 || value > this.byteLength) throw `Invalid readPos ${value}`;\n        this._readPos = value;\n    }\n\n    /** @type {number} */\n    get writePos() {\n        return this._writePos;\n    }\n\n    /** @type {number} */\n    set writePos(value) {\n        if (value < 0 || value > this.byteLength) throw `Invalid writePos ${value}`;\n        this._writePos = value;\n    }\n\n    /**\n     * Resets the read and write position of the buffer to zero.\n     * @returns {void}\n     */\n    reset() {\n        this._readPos = 0;\n        this._writePos = 0;\n    }\n\n    /**\n     * @param {number} length\n     * @return {Uint8Array}\n     */\n    read(length) {\n        const value = this.subarray(this._readPos, this._readPos + length);\n        this._readPos += length;\n        return value;\n    }\n\n    /**\n     * @param {*} array\n     */\n    write(array) {\n        this.set(array, this._writePos);\n        this._writePos += array.byteLength;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint8() {\n        return this._view.getUint8(this._readPos++);\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint8(value) {\n        this._view.setUint8(this._writePos++, value);\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint16() {\n        const value = this._view.getUint16(this._readPos);\n        this._readPos += 2;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint16(value) {\n        this._view.setUint16(this._writePos, value);\n        this._writePos += 2;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint32() {\n        const value = this._view.getUint32(this._readPos);\n        this._readPos += 4;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint32(value) {\n        this._view.setUint32(this._writePos, value);\n        this._writePos += 4;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint64() {\n        const value = this._view.getUint32(this._readPos) * Math.pow(2, 32) + this._view.getUint32(this._readPos + 4);\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        this._readPos += 8;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint64(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        this._view.setUint32(this._writePos, Math.floor(value / Math.pow(2, 32)));\n        this._view.setUint32(this._writePos + 4, value);\n        this._writePos += 8;\n    }\n\n    /**\n     * @return {number}\n     */\n    readVarUint() {\n        const value = this.readUint8();\n        if (value < 0xFD) {\n            return value;\n        } else if (value === 0xFD) {\n            return this.readUint16();\n        } else if (value === 0xFE) {\n            return this.readUint32();\n        } else /*if (value === 0xFF)*/ {\n            return this.readUint64();\n        }\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeVarUint(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        if (value < 0xFD) {\n            this.writeUint8(value);\n        } else if (value <= 0xFFFF) {\n            this.writeUint8(0xFD);\n            this.writeUint16(value);\n        } else if (value <= 0xFFFFFFFF) {\n            this.writeUint8(0xFE);\n            this.writeUint32(value);\n        } else {\n            this.writeUint8(0xFF);\n            this.writeUint64(value);\n        }\n    }\n\n    /**\n     * @param {number} value\n     * @returns {number}\n     */\n    static varUintSize(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        if (value < 0xFD) {\n            return 1;\n        } else if (value <= 0xFFFF) {\n            return 3;\n        } else if (value <= 0xFFFFFFFF) {\n            return 5;\n        } else {\n            return 9;\n        }\n    }\n\n    /**\n     * @return {number}\n     */\n    readFloat64() {\n        const value = this._view.getFloat64(this._readPos);\n        this._readPos += 8;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeFloat64(value) {\n        this._view.setFloat64(this._writePos, value);\n        this._writePos += 8;\n    }\n\n    /**\n     * @param {number} length\n     * @return {string}\n     */\n    readString(length) {\n        const bytes = this.read(length);\n        return BufferUtils.toAscii(bytes);\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} length\n     */\n    writeString(value, length) {\n        if (StringUtils.isMultibyte(value) || value.length !== length) throw 'Malformed value/length';\n        const bytes = BufferUtils.fromAscii(value);\n        this.write(bytes);\n    }\n\n    /**\n     * @param {number} length\n     * @return {string}\n     */\n    readPaddedString(length) {\n        const bytes = this.read(length);\n        let i = 0;\n        while (i < length && bytes[i] !== 0x0) i++;\n        const view = new Uint8Array(bytes.buffer, bytes.byteOffset, i);\n        return BufferUtils.toAscii(view);\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} length\n     */\n    writePaddedString(value, length) {\n        if (StringUtils.isMultibyte(value) || value.length > length) throw 'Malformed value/length';\n        const bytes = BufferUtils.fromAscii(value);\n        this.write(bytes);\n        const padding = length - bytes.byteLength;\n        this.write(new Uint8Array(padding));\n    }\n\n    /**\n     * @return {string}\n     */\n    readVarLengthString() {\n        const length = this.readUint8();\n        if (this._readPos + length > this.length) throw 'Malformed length';\n        const bytes = this.read(length);\n        return BufferUtils.toAscii(bytes);\n    }\n\n    /**\n     * @param {string} value\n     */\n    writeVarLengthString(value) {\n        if (StringUtils.isMultibyte(value) || !NumberUtils.isUint8(value.length)) throw new Error('Malformed value');\n        const bytes = BufferUtils.fromAscii(value);\n        this.writeUint8(bytes.byteLength);\n        this.write(bytes);\n    }\n\n    /**\n     * @param {string} value\n     * @returns {number}\n     */\n    static varLengthStringSize(value) {\n        if (StringUtils.isMultibyte(value) || !NumberUtils.isUint8(value.length)) throw new Error('Malformed value');\n        return /*length*/ 1 + value.length;\n    }\n}\nClass.register(SerialBuffer);\n","class Synchronizer extends Observable {\n    constructor() {\n        super();\n        this._queue = [];\n        this._working = false;\n    }\n\n    /**\n     * Push function to the Synchronizer for later, synchronous execution\n     * @template T\n     * @param {function():T} fn Function to be invoked later by this Synchronizer\n     * @returns {Promise.<T>}\n     */\n    push(fn) {\n        return new Promise((resolve, reject) => {\n            this._queue.push({fn: fn, resolve: resolve, reject: reject});\n            if (!this._working) {\n                this._doWork().catch(Log.w.tag(Synchronizer));\n            }\n        });\n    }\n\n    /**\n     * Reject all jobs in the queue and clear it.\n     * @returns {void}\n     */\n    clear() {\n        for (const job of this._queue) {\n            if (job.reject) job.reject();\n        }\n        this._queue = [];\n    }\n\n    async _doWork() {\n        this._working = true;\n        this.fire('work-start', this);\n\n        while (this._queue.length > 0) {\n            const job = this._queue.shift();\n            try {\n                const result = await job.fn();\n                job.resolve(result);\n            } catch (e) {\n                if (job.reject) job.reject(e);\n            }\n        }\n\n        this._working = false;\n        this.fire('work-end', this);\n    }\n\n    /** @type {boolean} */\n    get working() {\n        return this._working;\n    }\n}\nClass.register(Synchronizer);\n","class MultiSynchronizer extends Observable {\n    constructor() {\n        super();\n        /** @type {Map.<string, Synchronizer>} */\n        this._synchronizers = new Map();\n    }\n\n    /**\n     * Push function to the Synchronizer for later, synchronous execution\n     * @template T\n     * @param {string} tag\n     * @param {function():T} fn Function to be invoked later by this Synchronizer\n     * @returns {Promise.<T>}\n     */\n    push(tag, fn) {\n        let synchonizer = this._synchronizers.get(tag);\n        if (!synchonizer) {\n            synchonizer = new Synchronizer();\n            synchonizer.on('work-start', () => this.fire('work-start', synchonizer, tag, this));\n            synchonizer.on('work-end', () => this.fire('work-end', synchonizer, tag, this));\n            this._synchronizers.set(tag, synchonizer);\n        }\n        return synchonizer.push(fn);\n    }\n\n    /**\n     * Reject all jobs in the queue and clear it.\n     * @returns {void}\n     */\n    clear() {\n        for (const synchronizer of this._synchronizers.values()) {\n            synchronizer.clear();\n        }\n        this._synchronizers.clear();\n    }\n\n    /**\n     * @param {string} tag\n     * @returns {boolean}\n     */\n    isWorking(tag) {\n        const synchonizer = this._synchronizers.get(tag);\n        return !!synchonizer && synchonizer.working;\n    }\n}\nClass.register(MultiSynchronizer);\n","class PrioritySynchronizer extends Observable {\n    /**\n     * @param {number} numPriorities\n     */\n    constructor(numPriorities) {\n        super();\n        this._queues = [];\n        for (let i = 0; i < numPriorities; i++) {\n            this._queues[i] = [];\n        }\n        this._working = false;\n    }\n\n    /**\n     * Push function to the Synchronizer for later, synchronous execution\n     * @template T\n     * @param {number} priority A discrete priority, 0 being highest.\n     * @param {function():T} fn Function to be invoked later by this Synchronizer\n     * @returns {Promise.<T>}\n     */\n    push(priority, fn) {\n        Assert.that(priority >= 0 && priority < this._queues.length && Number.isInteger(priority), 'Invalid priority');\n\n        return new Promise((resolve, reject) => {\n            this._queues[priority].push({fn: fn, resolve: resolve, reject: reject});\n            if (!this._working) {\n                this._doWork().catch(Log.w.tag(PrioritySynchronizer));\n            }\n        });\n    }\n\n    /**\n     * Reject all jobs in the queue and clear it.\n     * @returns {void}\n     */\n    clear() {\n        for (const queue of this._queues) {\n            for (const job of queue) {\n                if (job.reject) job.reject();\n            }\n        }\n        this._queues = [];\n    }\n\n    async _doWork() {\n        this._working = true;\n        this.fire('work-start', this);\n\n        for (const queue of this._queues) {\n            while (queue.length > 0) {\n                const job = queue.shift();\n                try {\n                    const result = await job.fn();\n                    job.resolve(result);\n                } catch (e) {\n                    if (job.reject) job.reject(e);\n                }\n            }\n        }\n\n        this._working = false;\n        this.fire('work-end', this);\n    }\n\n    /** @type {boolean} */\n    get working() {\n        return this._working;\n    }\n}\nClass.register(PrioritySynchronizer);\n","class RateLimit {\n    /**\n     * @param {number} allowedOccurences\n     * @param {number} [timeRange=60000]\n     */\n    constructor(allowedOccurences, timeRange = 60000) {\n        /** @type {number} */\n        this._allowedEntries = allowedOccurences;\n        /** @type {number} */\n        this._timeRange = timeRange;\n\n        /** @type {number} */\n        this._lastReset = 0;\n        /** @type {number} */\n        this._counter = 0;\n    }\n\n    /**\n     * @param {number} [number=1]\n     * @returns {boolean}\n     */\n    note(number = 1) {\n        if (this._lastReset < Date.now() - this._timeRange) {\n            this._lastReset = Date.now();\n            this._counter = 0;\n        }\n        return (this._counter += number) <= this._allowedEntries;\n    }\n}\n\nClass.register(RateLimit);\n","/**\n * @interface\n */\nclass IWorker {\n    static async createProxy(clazz, name, worker) {\n        return new (IWorker.Proxy(clazz))(worker, name);\n    }\n\n    static async startWorkerForProxy(clazz, name, workerScript) {\n        if (!IWorker._workersSupported) {\n            await IWorker._workerImplementation[clazz.name].init(name);\n            return IWorker._workerImplementation[clazz.name];\n        } else {\n            if (!workerScript) {\n                workerScript = `${Nimiq._path}worker.js`;\n            }\n            return IWorker.createProxy(clazz, name, new Worker(window.URL.createObjectURL(new Blob([`Nimiq = {_path: '${Nimiq._path}'}; importScripts('${workerScript.replace(/'/g, '')}');`]))));\n        }\n    }\n\n    static async startWorkerPoolForProxy(clazz, name, size, workerScript) {\n        return (new (IWorker.Pool(clazz))((name) => IWorker.startWorkerForProxy(clazz, name, workerScript), name, size)).start();\n    }\n\n    static async stubBaseOnMessage(msg) {\n        try {\n            if (msg.data.command === 'init') {\n                if (IWorker._workerImplementation[msg.data.args[0]]) {\n                    const res = await IWorker._workerImplementation[msg.data.args[0]].init(msg.data.args[1]);\n                    self.postMessage({status: 'OK', result: res, id: msg.data.id});\n                } else {\n                    self.postMessage({status: 'error', result: 'Unknown worker!', id: msg.data.id});\n                }\n            } else {\n                self.postMessage({status: 'error', result: 'Worker not yet initialized!', id: msg.data.id});\n            }\n        } catch (e) {\n            self.postMessage({status: 'error', result: e, id: msg.data.id});\n        }\n    }\n\n    static get _workersSupported() {\n        return typeof Worker !== 'undefined';\n    }\n\n    static get areWorkersAsync() {\n        return IWorker._workersSupported;\n    }\n\n    static get _insideWebWorker() {\n        return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n    }\n\n    static get _global() {\n        return typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : null;\n    }\n\n    static prepareForWorkerUse(baseClazz, impl) {\n        if (IWorker._insideWebWorker) {\n            // Only inside WebWorker\n            self.onmessage = IWorker.stubBaseOnMessage;\n        }\n        IWorker._workerImplementation = IWorker._workerImplementation || {};\n        IWorker._workerImplementation[baseClazz.name] = impl;\n    }\n\n    static _loadBrowserScript(url, resolve) {\n        // Adding the script tag to the head as suggested before\n        const head = document.getElementsByTagName('head')[0];\n        const script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n\n        // Then bind the event to the callback function.\n        // There are several events for cross browser compatibility.\n        // These events might occur before processing, so delay them a bit.\n        const ret = () => window.setTimeout(resolve, 100);\n        script.onreadystatechange = ret;\n        script.onload = ret;\n\n        // Fire the loading\n        head.appendChild(script);\n    }\n\n    static Proxy(clazz) {\n        const proxyClass = class extends clazz {\n            /**\n             * @param {Worker} worker\n             * @param {string} [name]\n             */\n            constructor(worker, name) {\n                super();\n                this._name = name;\n                this._messageId = 0;\n                this._worker = worker;\n                this._worker.onmessage = this._receive.bind(this);\n                /** @type {Map.<number,{resolve:Function,error:Function}>} */\n                this._waiting = new Map();\n                return this._invoke('init', [clazz.name, name]).then(() => { return this; });\n            }\n\n            _receive(msg) {\n                const cb = this._waiting.get(msg.data.id);\n                if (!cb) {\n                    Log.w(WorkerProxy, 'Unknown reply', msg);\n                } else {\n                    this._waiting.delete(msg.data.id);\n                    if (msg.data.status === 'OK') {\n                        cb.resolve(msg.data.result);\n                    } else if (msg.data.status === 'error') {\n                        cb.error(msg.data.result);\n                    }\n                }\n            }\n\n            /**\n             * @param {string} command\n             * @param {object[]} [args]\n             * @returns {Promise}\n             * @private\n             */\n            _invoke(command, args = []) {\n                return new Promise((resolve, error) => {\n                    const obj = {command: command, args: args, id: this._messageId++};\n                    this._waiting.set(obj.id, {resolve, error});\n                    this._worker.postMessage(obj);\n                });\n            }\n\n            destroy() {\n                return this._invoke('destroy');\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                proxyClass.prototype[funcName] = function (...args) {\n                    return this._invoke(funcName, args);\n                };\n            }\n        }\n        return proxyClass;\n    }\n\n    /**\n     * @param {object} clazz\n     * @return {Stub}\n     * @constructor\n     */\n    static Stub(clazz) {\n        const Stub = class extends clazz {\n            constructor() {\n                super();\n            }\n\n            _result(msg, status, result) {\n                self.postMessage({status, result, id: msg.data.id});\n            }\n\n            _onmessage(msg) {\n                try {\n                    const res = this._invoke(msg.data.command, msg.data.args);\n                    if (res instanceof Promise) {\n                        res.then((finalRes) => { this._result(msg, 'OK', finalRes); });\n                    } else {\n                        this._result(msg, 'OK', res);\n                    }\n                } catch (e) {\n                    this._result(msg, 'error', e.message || e);\n                }\n            }\n\n            init(name) {\n                this._name = name;\n                if (IWorker._insideWebWorker) {\n                    self.name = name;\n                    self.onmessage = (msg) => this._onmessage(msg);\n                }\n            }\n\n            _invoke(command, args) {\n                return this[command].apply(this, args);\n            }\n\n            destroy() {\n                if (IWorker._insideWebWorker) {\n                    self.close();\n                }\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                Stub.prototype[funcName] = function () {\n                    throw `Not implemented in IWorker Stub: ${funcName}`;\n                };\n            }\n        }\n        return Stub;\n    }\n\n    static Pool(clazz) {\n        const poolClass = class extends clazz {\n            /**\n             *\n             * @param {function(string):Promise} proxyInitializer\n             * @param {string} [name]\n             * @param {number} [size] Number of workers in this pool.\n             */\n            constructor(proxyInitializer, name = 'pool', size = 1) {\n                super();\n                /** @type {function(string):Promise} */\n                this._proxyInitializer = proxyInitializer;\n                /** @type {string} */\n                this._name = name;\n                /** @type {number} */\n                this._poolSize = size;\n                /** @type {Array} */\n                this._workers = [];\n                /** @type {Array} */\n                this._freeWorkers = [];\n                /** @type {Array.<{name:string, args:Array, resolve:function, error:function}>} */\n                this._waitingCalls = [];\n            }\n\n            async start() {\n                await this._updateToSize();\n\n                return this;\n            }\n\n            get poolSize() {\n                return this._poolSize;\n            }\n\n            set poolSize(_size) {\n                this._poolSize = _size;\n                this._updateToSize().catch(Log.w.tag(IWorker));\n            }\n\n            destroy() {\n                this._poolSize = 0;\n                return this._updateToSize();\n            }\n\n            /**\n             * @param {string} name Name of the function to call on a worker\n             * @param {Array} args Arguments to pass to the function\n             * @returns {Promise}\n             */\n            _invoke(name, args) {\n                if (IWorker._workersSupported) {\n                    return new Promise((resolve, error) => {\n                        this._waitingCalls.push({name, args, resolve, error});\n                        const worker = this._freeWorkers.shift();\n                        if (worker) {\n                            this._step(worker).catch(Log.w.tag(IWorker));\n                        }\n                    });\n                } else {\n                    return this._workers[0][name].apply(this._workers[0], args);\n                }\n            }\n\n            /**\n             * @param worker\n             * @returns {Promise.<void>}\n             * @private\n             */\n            async _step(worker) {\n                let call = this._waitingCalls.shift();\n                while (call) {\n                    try {\n                        // eslint-disable-next-line no-await-in-loop\n                        call.resolve(await worker[call.name].apply(worker, call.args));\n                    } catch (e) {\n                        call.error(e);\n                    }\n                    if (this._workers.indexOf(worker) === -1) {\n                        worker.destroy();\n                        return;\n                    }\n                    call = this._waitingCalls.shift();\n                }\n                this._freeWorkers.push(worker);\n            }\n\n            async _updateToSize() {\n                if (typeof Worker === 'undefined' && this._poolSize > 1) {\n                    Log.d(IWorker, 'Pool of size larger than 1 requires WebWorker support.');\n                    this._poolSize = 1;\n                }\n\n                const workerPromises = [];\n                while (this._workers.length + workerPromises.length < this._poolSize) {\n                    workerPromises.push(this._proxyInitializer(`${this._name}#${this._workers.length + workerPromises.length}`));\n                }\n                const createdWorkers = await Promise.all(workerPromises);\n                for (const worker of createdWorkers) {\n                    this._workers.push(worker);\n                    this._step(worker).catch(Log.w.tag(IWorker));\n                }\n\n                while (this._workers.length > this._poolSize) {\n                    const worker = this._freeWorkers.shift() || this._workers.pop();\n                    const idx = this._workers.indexOf(worker);\n                    if (idx >= 0) {\n                        // This was a free worker, also remove it from the worker list and destroy it now.\n                        this._workers.splice(idx, 1);\n                        worker.destroy();\n                    }\n                }\n                return this;\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                poolClass.prototype[funcName] = function (...args) {\n                    return this._invoke(funcName, args);\n                };\n            }\n        }\n        return poolClass;\n    }\n}\n\nIWorker._moduleLoadedCallbacks = {};\nIWorker._workerImplementation = {};\nClass.register(IWorker);\n","class WasmHelper {\n\n    static async doImportBrowser() {\n        if (PlatformUtils.isNodeJs()) return;\n        if (WasmHelper._importStarted) {\n            Log.e(WasmHelper, 'doImportBrowser invoked twice');\n            return;\n        }\n        WasmHelper._importStarted = true;\n        if (await WasmHelper.importWasmBrowser('worker-wasm.wasm')) {\n            await WasmHelper.importScriptBrowser('worker-wasm.js');\n        } else {\n            await WasmHelper.importScriptBrowser('worker-js.js');\n        }\n        WasmHelper._importFinished = true;\n    }\n\n    static doImportNodeJs() {\n        if (!PlatformUtils.isNodeJs()) return;\n        if (WasmHelper.importWasmNodeJs('worker-wasm.wasm')) {\n            WasmHelper.importScriptNodeJs('worker-wasm.js');\n        } else {\n            WasmHelper.importScriptNodeJs('worker-js.js');\n        }\n    }\n\n    /**\n     * @param {string} wasm\n     * @param {string} module\n     * @returns {Promise.<boolean>}\n     */\n    static importWasmBrowser(wasm, module = 'Module') {\n        wasm = WasmHelper._adjustWasmPath(wasm);\n        if (!WasmHelper._global.WebAssembly) {\n            Log.w(WasmHelper, 'No support for WebAssembly available.');\n            return Promise.resolve(false);\n        }\n\n        return new Promise((resolve) => {\n            try {\n                const xhr = new XMLHttpRequest();\n                xhr.open('GET', wasm, true);\n                xhr.responseType = 'arraybuffer';\n                xhr.onload = function () {\n                    WasmHelper._global[module] = WasmHelper._global[module] || {};\n                    WasmHelper._global[module].wasmBinary = xhr.response;\n                    resolve(true);\n                };\n                xhr.onerror = function () {\n                    Log.w(WasmHelper, `Failed to access WebAssembly module ${wasm}`);\n                    resolve(false);\n                };\n                xhr.send(null);\n            } catch (e) {\n                Log.w(WasmHelper, `Failed to access WebAssembly module ${wasm}`);\n                resolve(false);\n            }\n        });\n    }\n\n    static importWasmNodeJs(wasm, module = 'Module') {\n        wasm = WasmHelper._adjustWasmPath(wasm);\n        if (!WasmHelper._global.WebAssembly) {\n            Log.w(WasmHelper, 'No support for WebAssembly available.');\n            return false;\n        }\n\n        const toUint8Array = function (buf) {\n            const u = new Uint8Array(buf.length);\n            for (let i = 0; i < buf.length; ++i) {\n                u[i] = buf[i];\n            }\n            return u;\n        };\n        const fs = require('fs');\n        try {\n            const data = fs.readFileSync(wasm);\n            WasmHelper._global[module] = WasmHelper._global[module] || {};\n            WasmHelper._global[module].wasmBinary = toUint8Array(data);\n            return true;\n        } catch (e) {\n            Log.w(WasmHelper, `Failed to access WebAssembly module ${wasm}: ${e}`);\n            return false;\n        }\n    }\n\n    static importScriptBrowser(script, module = 'Module') {\n        if (module && WasmHelper._global[module] && WasmHelper._global[module].asm) return false;\n        script = WasmHelper._adjustScriptPath(script);\n\n        const moduleSettings = WasmHelper._global[module] || {};\n        return new Promise(async (resolve, reject) => {\n            if (module) {\n                moduleSettings.onRuntimeInitialized = () => resolve(true);\n            }\n            if (typeof importScripts === 'function') {\n                await new Promise((resolve) => {\n                    WasmHelper._moduleLoadedCallbacks[module] = resolve;\n                    importScripts(script);\n                });\n                WasmHelper._global[module] = WasmHelper._global[module](moduleSettings);\n                if (!module) resolve(true);\n            } else if (typeof window === 'object') {\n                await new Promise((resolve) => {\n                    WasmHelper._moduleLoadedCallbacks[module] = resolve;\n                    WasmHelper._loadBrowserScript(script);\n                });\n                WasmHelper._global[module] = WasmHelper._global[module](moduleSettings);\n                if (!module) resolve(true);\n            } else if (typeof require === 'function') {\n                WasmHelper._global[module] = require(script)(moduleSettings);\n                if (!module) resolve(true);\n            } else {\n                reject('No way to load scripts.');\n            }\n        });\n    }\n\n    static importScriptNodeJs(script, module = 'Module') {\n        if (module && WasmHelper._global[module] && WasmHelper._global[module].asm) return false;\n        script = WasmHelper._adjustScriptPath(script);\n\n        const moduleSettings = WasmHelper._global[module] || {};\n\n        if (typeof require === 'function') {\n            WasmHelper._global[module] = require(script)(moduleSettings);\n            if (!module) return true;\n        }\n        return false;\n    }\n\n    static fireModuleLoaded(module = 'Module') {\n        if (typeof WasmHelper._moduleLoadedCallbacks[module] === 'function') {\n            WasmHelper._moduleLoadedCallbacks[module]();\n            WasmHelper._moduleLoadedCallbacks[module] = null;\n        }\n    }\n\n    static _loadBrowserScript(url) {\n        const head = document.getElementsByTagName('head')[0];\n        const script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n        head.appendChild(script);\n    }\n\n    static _adjustWasmPath(wasm) {\n        if (typeof Nimiq !== 'undefined' && Nimiq._path) wasm = `${Nimiq._path}${wasm}`;\n        if (typeof __dirname === 'string' && wasm.indexOf('/') === -1) wasm = `${__dirname}/${wasm}`;\n        return wasm;\n    }\n\n    static _adjustScriptPath(script) {\n        if (typeof Nimiq !== 'undefined' && Nimiq._path) script = `${Nimiq._path}${script}`;\n        if (typeof __dirname === 'string' && script.indexOf('/') === -1) script = `${__dirname}/${script}`;\n        return script;\n    }\n\n    static get _global() {\n        return typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : null;\n    }\n}\nWasmHelper._moduleLoadedCallbacks = {};\n\nClass.register(WasmHelper);\n\n","/**\n * @interface\n */\nclass CryptoWorker {\n    static get lib() { return CryptoLib.instance; }\n\n    /**\n     * @returns {Promise.<CryptoWorker>}\n     */\n    static async getInstanceAsync() {\n        if (!CryptoWorker._workerAsync) {\n            CryptoWorker._workerAsync = await IWorker.startWorkerPoolForProxy(CryptoWorker, 'crypto', 4);\n        }\n        return CryptoWorker._workerAsync;\n    }\n    /**\n     * @param {Uint8Array} input\n     * @returns {Promise.<Uint8Array>}\n     */\n    async computeArgon2d(input) {}\n\n    /**\n     * @param {Array.<Uint8Array>} inputs\n     * @returns {Promise.<Array.<Uint8Array>>}\n     */\n    async computeArgon2dBatch(inputs) {}\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @returns {Promise.<Uint8Array>}\n     */\n    async kdf(key, salt, iterations) {}\n\n    /**\n     * @param {Uint8Array} block\n     * @param {Array.<bool>} transactionValid\n     * @param {number} timeNow\n     * @param {Uint8Array} genesisHash\n     * @param {number} networkId\n     * @returns {Promise.<{valid: boolean, pow: SerialBuffer, interlinkHash: SerialBuffer, bodyHash: SerialBuffer}>}\n     */\n    async blockVerify(block, transactionValid, timeNow, genesisHash, networkId) {}\n}\n/** @type {CryptoWorker} */\nCryptoWorker._workerAsync = null;\n\nClass.register(CryptoWorker);\n","class CryptoWorkerImpl extends IWorker.Stub(CryptoWorker) {\n    constructor() {\n        super();\n        // FIXME: This is needed for Babel to work correctly. Can be removed as soon as we updated to Babel v7.\n        this._superInit = super.init;\n    }\n\n    async init(name) {\n        await this._superInit.call(this, name);\n        await WasmHelper.doImportBrowser();\n        CryptoWorker._workerAsync = this;\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    computeArgon2d(input) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.ARGON2D));\n            const res = NodeNative.node_argon2(out, new Uint8Array(input), 512);\n            if (res !== 0) {\n                throw res;\n            }\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.ARGON2D);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmIn = Module.stackAlloc(input.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                const res = Module._nimiq_argon2(wasmOut, wasmIn, input.length, 512);\n                if (res !== 0) {\n                    throw res;\n                }\n                const hash = new Uint8Array(hashSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hash;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} inputs\n     * @returns {Array.<Uint8Array>}\n     */\n    computeArgon2dBatch(inputs) {\n        const hashes = [];\n        if (PlatformUtils.isNodeJs()) {\n            for(const input of inputs) {\n                const out = new Uint8Array(Hash.getSize(Hash.Algorithm.ARGON2D));\n                const res = NodeNative.node_argon2(out, new Uint8Array(input), 512);\n                if (res !== 0) {\n                    throw res;\n                }\n                hashes.push(out);\n            }\n            return hashes;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.ARGON2D);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const stackTmp = Module.stackSave();\n                for (const input of inputs) {\n                    Module.stackRestore(stackTmp);\n                    const wasmIn = Module.stackAlloc(input.length);\n                    new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                    const res = Module._nimiq_argon2(wasmOut, wasmIn, input.length, 512);\n                    if (res !== 0) {\n                        throw res;\n                    }\n                    const hash = new Uint8Array(hashSize);\n                    hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                    hashes.push(hash);\n                }\n                return hashes;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @returns {Uint8Array}\n     */\n    kdf(key, salt, iterations) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.ARGON2D));\n            const res = NodeNative.node_kdf(out, new Uint8Array(key), new Uint8Array(salt), 512, iterations);\n            if (res !== 0) {\n                throw res;\n            }\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.ARGON2D);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmIn = Module.stackAlloc(key.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, key.length).set(key);\n                const wasmSalt = Module.stackAlloc(salt.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmSalt, salt.length).set(salt);\n                const res = Module._nimiq_kdf(wasmOut, wasmIn, key.length, wasmSalt, salt.length, 512, iterations);\n                if (res !== 0) {\n                    throw res;\n                }\n                const hash = new Uint8Array(hashSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hash;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} blockSerialized\n     * @param {Array.<boolean|undefined>} transactionValid\n     * @param {number} timeNow\n     * @param {Uint8Array} genesisHash\n     * @param {number} networkId\n     * @returns {Promise.<{valid: boolean, pow: SerialBuffer, interlinkHash: SerialBuffer, bodyHash: SerialBuffer}>}\n     */\n    async blockVerify(blockSerialized, transactionValid, timeNow, genesisHash, networkId) {\n        // The worker only uses a stub genesis config.\n        GenesisConfig = {\n            GENESIS_HASH: Hash.unserialize(new SerialBuffer(genesisHash)),\n            NETWORK_ID: networkId\n        };\n\n        const block = Block.unserialize(new SerialBuffer(blockSerialized));\n        for (let i = 0; i < transactionValid.length; i++) {\n            block.body.transactions[i]._valid = transactionValid[i];\n        }\n\n        const valid = await block._verify(timeNow);\n        const pow = await block.header.pow();\n        const interlinkHash = block.interlink.hash();\n        const bodyHash = block.body.hash();\n        return { valid: valid, pow: pow.serialize(), interlinkHash: interlinkHash.serialize(), bodyHash: bodyHash.serialize() };\n    }\n}\n\nIWorker.prepareForWorkerUse(CryptoWorker, new CryptoWorkerImpl());\n","class CRC32 {\n    static _createTable () {\n        let b;\n        const table = [];\n\n        for (let j = 0; j < 256; ++j) {\n            b = j;\n            for (let k = 0; k < 8; ++k) {\n                b = b & 1 ? CRC32._POLYNOMIAL ^ (b >>> 1) : b >>> 1;\n            }\n            table[j] = b >>> 0;\n        }\n        return table;\n    }\n\n    /**\n     * @param {Uint8Array} buf\n     * @returns {number}\n     */\n    static compute(buf) {\n        if (!CRC32._table) CRC32._table = CRC32._createTable();\n        if (!CRC32._hex_chars) CRC32._hex_chars = '0123456789abcdef'.split('');\n\n        const message = new Uint8Array(buf);\n        const initialValue = -1;\n\n        let crc = initialValue;\n        let hex = '';\n\n        for (let i = 0; i < message.length; ++i) {\n            crc = CRC32._table[(crc ^ message[i]) & 0xFF] ^ (crc >>> 8);\n        }\n        crc ^= initialValue;\n\n        hex += CRC32._hex_chars[(crc >> 28) & 0x0F] + CRC32._hex_chars[(crc >> 24) & 0x0F] +\n            CRC32._hex_chars[(crc >> 20) & 0x0F] + CRC32._hex_chars[(crc >> 16) & 0x0F] +\n            CRC32._hex_chars[(crc >> 12) & 0x0F] + CRC32._hex_chars[(crc >> 8) & 0x0F] +\n            CRC32._hex_chars[(crc >> 4) & 0x0F] + CRC32._hex_chars[crc & 0x0F];\n\n        return parseInt(hex, 16);\n    }\n}\nCRC32._table = null;\nCRC32._hex_chars = null;\nCRC32._POLYNOMIAL = 0xEDB88320;\nClass.register(CRC32);\n","class NumberUtils {\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint8(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT8_MAX;\n    }\n\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint16(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT16_MAX;\n    }\n\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint32(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT32_MAX;\n    }\n\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint64(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT64_MAX;\n    }\n\n    /**\n     * @return {number}\n     */\n    static randomUint32() {\n        return Math.floor(Math.random() * (NumberUtils.UINT32_MAX + 1));\n    }\n\n    /**\n     * @return {number}\n     */\n    static randomUint64() {\n        return Math.floor(Math.random() * (NumberUtils.UINT64_MAX + 1));\n    }\n}\n\nNumberUtils.UINT8_MAX = 255;\nNumberUtils.UINT16_MAX = 65535;\nNumberUtils.UINT32_MAX = 4294967295;\nNumberUtils.UINT64_MAX = Number.MAX_SAFE_INTEGER;\n//Object.freeze(NumberUtils);\nClass.register(NumberUtils);\n","class MerkleTree {\n    /**\n     * @param {Array} values\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {Hash}\n     */\n    static computeRoot(values, fnHash = MerkleTree._hash) {\n        return MerkleTree._computeRoot(values, fnHash);\n    }\n\n    /**\n     * @param {Array} values\n     * @param {function(o: *):Hash} fnHash\n     * @returns {Hash}\n     * @private\n     */\n    static _computeRoot(values, fnHash) {\n        const len = values.length;\n        if (len === 0) {\n            return Hash.light(new Uint8Array(0));\n        }\n        if (len === 1) {\n            return fnHash(values[0]);\n        }\n\n        const mid = Math.round(len / 2);\n        const left = values.slice(0, mid);\n        const right = values.slice(mid);\n        const leftHash = MerkleTree._computeRoot(left, fnHash);\n        const rightHash = MerkleTree._computeRoot(right, fnHash);\n        return Hash.light(BufferUtils.concatTypedArrays(leftHash.serialize(), rightHash.serialize()));\n    }\n\n    /**\n     * @param {Hash|Uint8Array|{hash: function():Hash}|{serialize: function():Uint8Array}} o\n     * @returns {Hash}\n     * @private\n     */\n    static _hash(o) {\n        if (o instanceof Hash) {\n            return o;\n        }\n        if (typeof o.hash === 'function') {\n            return o.hash();\n        }\n        if (typeof o.serialize === 'function') {\n            return Hash.light(o.serialize());\n        }\n        if (o instanceof Uint8Array) {\n            return Hash.light(o);\n        }\n        throw new Error('MerkleTree objects must be Uint8Array or have a .hash()/.serialize() method');\n    }\n}\nClass.register(MerkleTree);\n","class MerklePath {\n    /**\n     * @param {Array.<MerklePathNode>} nodes\n     */\n    constructor(nodes) {\n        if (!Array.isArray(nodes) || !NumberUtils.isUint8(nodes.length)\n            || nodes.some(it => !(it instanceof MerklePathNode))) throw new Error('Malformed nodes');\n        /**\n         * @type {Array.<MerklePathNode>}\n         * @private\n         */\n        this._nodes = nodes;\n    }\n\n    /**\n     * @param {Array} values\n     * @param {*} leafValue\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {MerklePath}\n     */\n    static compute(values, leafValue, fnHash = MerkleTree._hash) {\n        const leafHash = fnHash(leafValue);\n        const path = [];\n        MerklePath._compute(values, leafHash, path, fnHash);\n        return new MerklePath(path);\n    }\n\n    /**\n     * @param {Array} values\n     * @param {Hash} leafHash\n     * @param {Array.<MerklePathNode>} path\n     * @param {function(o: *):Hash} fnHash\n     * @returns {{containsLeaf:boolean, inner:Hash}}\n     * @private\n     */\n    static _compute(values, leafHash, path, fnHash) {\n        const len = values.length;\n        let hash;\n        if (len === 0) {\n            hash = Hash.light(new Uint8Array(0));\n            return {containsLeaf: false, inner: hash};\n        }\n        if (len === 1) {\n            hash = fnHash(values[0]);\n            return {containsLeaf: hash.equals(leafHash), inner: hash};\n        }\n\n        const mid = Math.round(len / 2);\n        const left = values.slice(0, mid);\n        const right = values.slice(mid);\n        const {containsLeaf: leftLeaf, inner: leftHash} = MerklePath._compute(left, leafHash, path, fnHash);\n        const {containsLeaf: rightLeaf, inner: rightHash} = MerklePath._compute(right, leafHash, path, fnHash);\n        hash = Hash.light(BufferUtils.concatTypedArrays(leftHash.serialize(), rightHash.serialize()));\n\n        if (leftLeaf) {\n            path.push(new MerklePathNode(rightHash, false));\n            return {containsLeaf: true, inner: hash};\n        } else if (rightLeaf) {\n            path.push(new MerklePathNode(leftHash, true));\n            return {containsLeaf: true, inner: hash};\n        }\n\n        return {containsLeaf: false, inner: hash};\n    }\n\n    /**\n     * @param {*} leafValue\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {Hash}\n     */\n    computeRoot(leafValue, fnHash = MerkleTree._hash) {\n        /** @type {Hash} */\n        let root = fnHash(leafValue);\n        for (const node of this._nodes) {\n            const left = node.left;\n            const hash = node.hash;\n            const concat = new SerialBuffer(hash.serializedSize * 2);\n            if (left) hash.serialize(concat);\n            root.serialize(concat);\n            if (!left) hash.serialize(concat);\n            root = Hash.light(concat);\n        }\n        return root;\n    }\n\n    /**\n     * @param {Array.<MerklePathNode>} nodes\n     * @returns {Uint8Array}\n     * @private\n     */\n    static _compress(nodes) {\n        const count = nodes.length;\n        const leftBitsSize = Math.ceil(count / 8);\n        const leftBits = new Uint8Array(leftBitsSize);\n\n        for (let i = 0; i < count; i++) {\n            if (nodes[i].left) {\n                leftBits[Math.floor(i / 8)] |= 0x80 >>> (i % 8);\n            }\n        }\n\n        return leftBits;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {MerklePath}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint8();\n        const leftBitsSize = Math.ceil(count / 8);\n        const leftBits = buf.read(leftBitsSize);\n\n        const nodes = [];\n        for (let i = 0; i < count; i++) {\n            const left = (leftBits[Math.floor(i / 8)] & (0x80 >>> (i % 8))) !== 0;\n            const hash = Hash.unserialize(buf);\n            nodes.push(new MerklePathNode(hash, left));\n        }\n        return new MerklePath(nodes);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._nodes.length);\n        buf.write(MerklePath._compress(this._nodes));\n\n        for (const node of this._nodes) {\n            node.hash.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        const leftBitsSize = Math.ceil(this._nodes.length / 8);\n        return /*count*/ 1\n            + leftBitsSize\n            + this._nodes.reduce((sum, node) => sum + node.hash.serializedSize, 0);\n    }\n\n    /**\n     * @param {MerklePath} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof MerklePath\n            && this._nodes.length === o._nodes.length\n            && this._nodes.every((node, i) => node.equals(o._nodes[i]));\n    }\n\n    /** @type {Array.<MerklePathNode>} */\n    get nodes() {\n        return this._nodes;\n    }\n}\nClass.register(MerklePath);\n\nclass MerklePathNode {\n    /**\n     * @param {Hash} hash\n     * @param {boolean} left\n     */\n    constructor(hash, left) {\n        this._hash = hash;\n        this._left = left;\n    }\n\n    /** @type {Hash} */\n    get hash() {\n        return this._hash;\n    }\n\n    /** @type {boolean} */\n    get left() {\n        return this._left;\n    }\n\n    /**\n     * @param {MerklePathNode} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof MerklePathNode\n            && this._hash.equals(o.hash)\n            && this._left === o.left;\n    }\n}\nClass.register(MerklePathNode);\n","class MerkleProof {\n    /**\n     * @param {Array.<*>} hashes\n     * @param {Array.<MerkleProof.Operation>} operations\n     */\n    constructor(hashes, operations) {\n        if (!Array.isArray(hashes) || !NumberUtils.isUint16(hashes.length)) throw new Error('Malformed nodes');\n        if (!Array.isArray(operations) || !NumberUtils.isUint16(operations.length)) throw new Error('Malformed operations');\n        /**\n         * @type {Array.<*>}\n         * @private\n         */\n        this._nodes = hashes;\n        this._operations = operations;\n    }\n\n    /**\n     * @param {Array} values\n     * @param {Array.<*>} leafValues\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {MerkleProof}\n     */\n    static compute(values, leafValues, fnHash = MerkleTree._hash) {\n        const leafHashes = leafValues.map(fnHash);\n        const {containsLeaf, operations, path, inner} = MerkleProof._compute(values, leafHashes, fnHash);\n        return new MerkleProof(path, operations);\n    }\n\n    /**\n     * Assumes ordered array of values.\n     * @param {Array} values\n     * @param {Array.<*>} leafValues\n     * @param {function(a: *, b: *):number} fnCompare\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {MerkleProof}\n     */\n    static computeWithAbsence(values, leafValues, fnCompare, fnHash = MerkleTree._hash) {\n        const leaves = new Set();\n        leafValues = leafValues.slice();\n        leafValues.sort(fnCompare);\n        // Find missing leaves and include neighbours instead.\n        let leafIndex = 0, valueIndex = 0;\n        while (valueIndex < values.length && leafIndex < leafValues.length) {\n            const value = values[valueIndex];\n            const comparisonResult = fnCompare(value, leafValues[leafIndex]);\n            // Leave is included.\n            if (comparisonResult === 0) {\n                leaves.add(leafValues[leafIndex]);\n                ++leafIndex;\n            }\n            // Leave should already have been there, so it is missing.\n            else if (comparisonResult > 0) {\n                // Use both, prevValue and value, as a proof of absence.\n                // Special case: prevValue unknown as we're at the first value.\n                if (valueIndex > 0) {\n                    leaves.add(values[valueIndex - 1]);\n                }\n                leaves.add(value);\n                ++leafIndex;\n            }\n            // This value is not interesting for us, skip it.\n            else {\n                ++valueIndex;\n            }\n        }\n        // If we processed all values but not all leaves, these are missing. Add last value as proof.\n        if (leafIndex < leafValues.length && values.length > 0) {\n            leaves.add(values[values.length - 1]);\n        }\n\n        return MerkleProof.compute(values, Array.from(leaves), fnHash);\n    }\n\n    /**\n     * @param {Array} values\n     * @param {Array.<Hash>} leafHashes\n     * @param {function(o: *):Hash} fnHash\n     * @returns {{containsLeaf:boolean, inner:Hash}}\n     * @private\n     */\n    static _compute(values, leafHashes, fnHash) {\n        const len = values.length;\n        let hash;\n        if (len === 0) {\n            hash = Hash.light(new Uint8Array(0));\n            return {containsLeaf: false, operations: [MerkleProof.Operation.CONSUME_PROOF], path: [hash], inner: hash};\n        }\n        if (len === 1) {\n            hash = fnHash(values[0]);\n            const isLeaf = leafHashes.some(h => hash.equals(h));\n            return {\n                containsLeaf: isLeaf,\n                operations: [isLeaf ? MerkleProof.Operation.CONSUME_INPUT : MerkleProof.Operation.CONSUME_PROOF],\n                path: isLeaf ? [] : [hash],\n                inner: hash\n            };\n        }\n\n        const mid = Math.round(len / 2);\n        const left = values.slice(0, mid);\n        const right = values.slice(mid);\n        const {containsLeaf: leftLeaf, operations: leftOps, path: leftPath, inner: leftHash} = MerkleProof._compute(left, leafHashes, fnHash);\n        const {containsLeaf: rightLeaf, operations: rightOps, path: rightPath, inner: rightHash} = MerkleProof._compute(right, leafHashes, fnHash);\n        hash = Hash.light(BufferUtils.concatTypedArrays(leftHash.serialize(), rightHash.serialize()));\n\n        // If a branch does not contain a leaf, we can directly use its hash and discard any inner operations.\n        if (!leftLeaf && !rightLeaf) {\n            return {containsLeaf: false, operations: [MerkleProof.Operation.CONSUME_PROOF], path: [hash], inner: hash};\n        }\n\n        // At least one branch contains a leaf, so execute all operations.\n        let operations = leftOps;\n        operations = operations.concat(rightOps);\n        let path = leftPath;\n        path = path.concat(rightPath);\n\n        operations.push(MerkleProof.Operation.HASH);\n\n        return {containsLeaf: true, operations: operations, path: path, inner: hash};\n    }\n\n    /**\n     * @param {Array.<*>} leafValues\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {Hash}\n     */\n    computeRoot(leafValues, fnHash = MerkleTree._hash) {\n        /** @type {Array.<Hash>} */\n        const inputs = leafValues.map(fnHash);\n        const stack = [];\n        const proofNodes = this._nodes.slice();\n        for (const op of this._operations) {\n            switch (op) {\n                case MerkleProof.Operation.CONSUME_PROOF:\n                    if (proofNodes.length === 0) {\n                        throw new Error('Invalid operation.');\n                    }\n                    stack.push(proofNodes.shift());\n                    break;\n                case MerkleProof.Operation.CONSUME_INPUT:\n                    if (inputs.length === 0) {\n                        throw new Error('Invalid operation.');\n                    }\n                    stack.push(inputs.shift());\n                    break;\n                case MerkleProof.Operation.HASH: {\n                    if (stack.length < 2) {\n                        throw new Error('Invalid operation.');\n                    }\n                    const hashStack = stack.splice(-2, 2);\n                    const concat = new SerialBuffer(hashStack.reduce((size, hash) => size + hash.serializedSize, 0));\n                    const [left, right] = hashStack;\n                    left.serialize(concat);\n                    right.serialize(concat);\n                    stack.push(Hash.light(concat));\n                    break;\n                }\n                default:\n                    throw new Error('Invalid operation.');\n            }\n        }\n\n        // Everything but the root needs to be consumed.\n        if (stack.length !== 1 || proofNodes.length !== 0 || inputs.length !== 0) {\n            throw Error('Did not consume all nodes.');\n        }\n\n        return stack[0];\n    }\n\n    /**\n     * @param {Array.<MerkleProof.Operation>} operations\n     * @returns {Uint8Array}\n     * @private\n     */\n    static _compress(operations) {\n        const count = operations.length;\n        const opBitsSize = Math.ceil(count / 4);\n        const opBits = new Uint8Array(opBitsSize);\n\n        for (let i = 0; i < count; i++) {\n            const op = operations[i] & 0x3;\n            opBits[Math.floor(i / 4)] |= op << (i % 4) * 2;\n        }\n\n        return opBits;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {MerkleProof}\n     */\n    static unserialize(buf) {\n        const opCount = buf.readUint16();\n        const opBitsSize = Math.ceil(opCount / 4);\n        const opBits = buf.read(opBitsSize);\n\n        const operations = [];\n        for (let i = 0; i < opCount; i++) {\n            const op = ((opBits[Math.floor(i / 4)] >>> (i % 4) * 2) & 0x3);\n            operations.push(op);\n        }\n\n        const countNodes = buf.readUint16();\n        const hashes = [];\n        for (let i = 0; i < countNodes; i++) {\n            hashes.push(Hash.unserialize(buf));\n        }\n        return new MerkleProof(hashes, operations);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._operations.length);\n        buf.write(MerkleProof._compress(this._operations));\n        buf.writeUint16(this._nodes.length);\n        for (const hash of this._nodes) {\n            hash.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        const opBitsSize = Math.ceil(this._operations.length / 4);\n        return /*counts*/ 4\n            + opBitsSize\n            + this._nodes.reduce((sum, node) => sum + node.serializedSize, 0);\n    }\n\n    /**\n     * @param {MerkleProof} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof MerkleProof\n            && this._nodes.length === o._nodes.length\n            && this._nodes.every((node, i) => node.equals(o._nodes[i]))\n            && this._operations.length === o._operations.length\n            && this._operations.every((op, i) => op === o._operations[i]);\n    }\n\n    /** @type {Array.<Hash>} */\n    get nodes() {\n        return this._nodes;\n    }\n}\n/** @enum {number} */\nMerkleProof.Operation = {\n    CONSUME_PROOF: 0,\n    CONSUME_INPUT: 1,\n    HASH: 2\n};\nClass.register(MerkleProof);\n","class PlatformUtils {\n    /**\n     * @returns {boolean}\n     */\n    static isBrowser() {\n        return typeof window !== 'undefined';\n    }\n\n    /**\n     * @return {boolean}\n     */\n    static isNodeJs() {\n        return !PlatformUtils.isBrowser() && typeof process === 'object' && typeof require === 'function';\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    static supportsWebRTC() {\n        let RTCPeerConnection = PlatformUtils.isBrowser() ? (window.RTCPeerConnection || window.webkitRTCPeerConnection) : null;\n        return !!RTCPeerConnection;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    static isOnline() {\n        return (!PlatformUtils.isBrowser() || !('onLine' in window.navigator)) || window.navigator.onLine;\n    }\n}\nClass.register(PlatformUtils);\n","class StringUtils {\n    /**\n     * @param {string} str\n     * @returns {boolean}\n     */\n    static isMultibyte(str) {\n        return /[\\uD800-\\uDFFF]/.test(str);\n    }\n\n    /**\n     * @param {string} str\n     * @returns {boolean}\n     */\n    static isHex(str) {\n        return /^[0-9A-Fa-f]*$/.test(str);\n    }\n\n    /**\n     * @param {string} str\n     * @param {number} [length]\n     * @returns {boolean}\n     */\n    static isHexBytes(str, length) {\n        if (!StringUtils.isHex(str)) return false;\n        if (str.length % 2 !== 0) return false;\n        if (typeof length === 'number' && str.length / 2 !== length) return false;\n        return true;\n    }\n\n    /**\n     * @param {string} str1\n     * @param {string} str2\n     * @returns {string}\n     */\n    static commonPrefix(str1, str2) {\n        let i = 0;\n        for (; i < str1.length; ++i) {\n            if (str1[i] !== str2[i]) break;\n        }\n        return str1.substr(0, i);\n    }\n\n}\nClass.register(StringUtils);\n","class Policy {\n    /**\n     * Convert Nimiq decimal to Number of Satoshis.\n     * @param {number} coins Nimiq count in decimal\n     * @return {number} Number of Satoshis\n     */\n    static coinsToSatoshis(coins) {\n        return Math.round(coins * Policy.SATOSHIS_PER_COIN);\n    }\n\n    /**\n     * Convert Number of Satoshis to Nimiq decimal.\n     * @param {number} satoshis Number of Satoshis.\n     * @return {number} Nimiq count in decimal.\n     */\n    static satoshisToCoins(satoshis) {\n        return satoshis / Policy.SATOSHIS_PER_COIN;\n    }\n\n    /**\n     * Circulating supply after block.\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static supplyAfter(blockHeight) {\n        // Calculate last entry in supply cache that is below blockHeight.\n        let startHeight = Math.floor(blockHeight / Policy._supplyCacheInterval) * Policy._supplyCacheInterval;\n        startHeight = Math.max(0, Math.min(startHeight, Policy._supplyCacheMax));\n\n        // Calculate respective block for the last entry of the cache and the targeted height.\n        const startI = startHeight / Policy._supplyCacheInterval;\n        const endI = Math.floor(blockHeight / Policy._supplyCacheInterval);\n\n        // The starting supply is the initial supply at the beginning and a cached value afterwards.\n        let supply = startHeight === 0 ? Policy.INITIAL_SUPPLY : Policy._supplyCache.get(startHeight);\n        // Use and update cache.\n        for (let i = startI; i < endI; ++i) {\n            startHeight = i * Policy._supplyCacheInterval;\n            // Since the cache stores the supply *before* a certain block, subtract one.\n            const endHeight = (i + 1) * Policy._supplyCacheInterval - 1;\n            supply = Policy._supplyAfter(supply, endHeight, startHeight);\n            // Don't forget to add one again.\n            Policy._supplyCache.set(endHeight + 1, supply);\n            Policy._supplyCacheMax = endHeight + 1;\n        }\n\n        // Calculate remaining supply (this also adds the block reward for endI*interval).\n        return Policy._supplyAfter(supply, blockHeight, endI * Policy._supplyCacheInterval);\n    }\n\n    /**\n     * Circulating supply after block.\n     * @param {number} initialSupply\n     * @param {number} blockHeight\n     * @param {number} [startHeight]\n     * @return {number}\n     */\n    static _supplyAfter(initialSupply, blockHeight, startHeight=0) {\n        let supply = initialSupply;\n        for (let i = startHeight; i <= blockHeight; ++i) {\n            supply += Policy._blockRewardAt(supply, i);\n        }\n        return supply;\n    }\n\n    /**\n     * Miner reward per block.\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static blockRewardAt(blockHeight) {\n        const currentSupply = Policy.supplyAfter(blockHeight - 1);\n        return Policy._blockRewardAt(currentSupply, blockHeight);\n    }\n\n    /**\n     * Miner reward per block.\n     * @param {number} currentSupply\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static _blockRewardAt(currentSupply, blockHeight) {\n        if (blockHeight <= 0) return 0;\n        const remaining = Policy.TOTAL_SUPPLY - currentSupply;\n        if (blockHeight >= Policy.EMISSION_TAIL_START && remaining >= Policy.EMISSION_TAIL_REWARD) {\n            return Policy.EMISSION_TAIL_REWARD;\n        }\n        const remainder = remaining % Policy.EMISSION_SPEED;\n        return (remaining - remainder) / Policy.EMISSION_SPEED;\n    }\n}\n\n/**\n * Targeted block time in seconds.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_TIME = 60;\n\n/**\n * Maximum block size in bytes.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_SIZE_MAX = 1e5; // 100 kb\n\n/**\n * The highest (easiest) block PoW target.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_TARGET_MAX = Math.pow(2, 240);\n\n/**\n * Number of blocks we take into account to calculate next difficulty.\n * @type {number}\n * @constant\n */\nPolicy.DIFFICULTY_BLOCK_WINDOW = 120;\n\n/**\n * Limits the rate at which the difficulty is adjusted min/max.\n * @type {number}\n * @constant\n */\nPolicy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR = 2;\n\n/**\n * Number of blocks a transaction is valid.\n * @type {number}\n * @constant\n */\nPolicy.TRANSACTION_VALIDITY_WINDOW = 120;\n\n\n/* Supply & Emission Parameters */\n\n/**\n * Number of Satoshis per Nimiq.\n * @type {number}\n * @constant\n */\nPolicy.SATOSHIS_PER_COIN = 1e5;\n\n/**\n * Targeted total supply in satoshis.\n * @type {number}\n * @constant\n */\nPolicy.TOTAL_SUPPLY = 21e14;\n\n/**\n * Initial supply before genesis block in satoshis.\n * FIXME: Change for main net.\n * @type {number}\n * @constant\n */\nPolicy.INITIAL_SUPPLY = 252000000000000;\n\n/**\n * Emission speed.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_SPEED = Math.pow(2, 22);\n\n/**\n * First block using constant tail emission until total supply is reached.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_TAIL_START = 48692960;\n\n/**\n * Constant tail emission in satoshis until total supply is reached.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_TAIL_REWARD = 4000;\n\n/* Security parameters */\n\n/**\n * NIPoPoW Security parameter M\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.M = 240;\n\n/**\n * NIPoPoW Security parameter K\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.K = 120;\n\n/**\n * NIPoPoW Security parameter DELTA\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.DELTA = 0.1;\n\n/**\n * Number of blocks the light client downloads to verify the AccountsTree construction.\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.NUM_BLOCKS_VERIFICATION = 250;\n\n\n/* Snapshot Parameters */\n\n/**\n * Maximum number of snapshots.\n * @type {number}\n * @constant\n */\nPolicy.NUM_SNAPSHOTS_MAX = 20;\n\n\n/**\n * Stores the circulating supply before the given block.\n * @type {Map.<number, number>}\n * @private\n */\nPolicy._supplyCache = new Map();\nPolicy._supplyCacheMax = 0; // blocks\nPolicy._supplyCacheInterval = 5000; // blocks\nClass.register(Policy);\n","/**\n * @abstract\n */\nclass Serializable {\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Serializable && BufferUtils.equals(this.serialize(), o.serialize());\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {number} negative if this is smaller than o, positive if this is larger than o, zero if equal.\n     */\n    compare(o) {\n        return BufferUtils.compare(this.serialize(), o.serialize());\n    }\n\n    hashCode() {\n        return this.toBase64();\n    }\n\n    /**\n     * @abstract\n     * @param {SerialBuffer} [buf]\n     */\n    serialize(buf) {}\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return this.toBase64();\n    }\n\n    /**\n     * @return {string}\n     */\n    toBase64() {\n        return BufferUtils.toBase64(this.serialize());\n    }\n\n    /**\n     * @return {string}\n     */\n    toHex() {\n        return BufferUtils.toHex(this.serialize());\n    }\n}\n\nClass.register(Serializable);\n","class Hash extends Serializable {\n    /**\n     * @param {Hash} o\n     * @returns {Hash}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const obj = new Uint8Array(o._obj);\n        return new Hash(obj);\n    }\n\n    /**\n     * @param {?Uint8Array} arg\n     * @param {Hash.Algorithm} [algorithm]\n     * @private\n     */\n    constructor(arg, algorithm = Hash.Algorithm.BLAKE2B) {\n        if (arg === null) {\n            arg = new Uint8Array(Hash.getSize(algorithm));\n        } else {\n            if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n            if (arg.length !== Hash.getSize(algorithm)) throw new Error('Primitive: Invalid length');\n        }\n        super();\n        this._obj = arg;\n        /** @type {Hash.Algorithm} */\n        this._algorithm = algorithm;\n    }\n\n    /**\n     * @deprecated\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static light(arr) {\n        return Hash.blake2b(arr);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static blake2b(arr) {\n        return new Hash(Hash.computeBlake2b(arr), Hash.Algorithm.BLAKE2B);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @deprecated\n     * @returns {Promise.<Hash>}\n     */\n    static hard(arr) {\n        return Hash.argon2d(arr);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Promise.<Hash>}\n     */\n    static async argon2d(arr) {\n        return new Hash(await (await CryptoWorker.getInstanceAsync()).computeArgon2d(arr), Hash.Algorithm.ARGON2D);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static sha256(arr) {\n        return new Hash(Hash.computeSha256(arr), Hash.Algorithm.SHA256);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @param {Hash.Algorithm} algorithm\n     * @returns {Hash}\n     */\n    static compute(arr, algorithm) {\n        // !! The algorithms supported by this function are the allowed hash algorithms for HTLCs !!\n        switch (algorithm) {\n            case Hash.Algorithm.BLAKE2B: return Hash.blake2b(arr);\n            case Hash.Algorithm.SHA256: return Hash.sha256(arr);\n            // Hash.Algorithm.ARGON2 intentionally omitted\n            default: throw new Error('Invalid hash algorithm');\n        }\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @param {Hash.Algorithm} [algorithm]\n     * @returns {Hash}\n     */\n    static unserialize(buf, algorithm = Hash.Algorithm.BLAKE2B) {\n        return new Hash(buf.read(Hash.getSize(algorithm)), algorithm);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /**\n     * @param {number} begin\n     * @param {number} end\n     * @returns {Uint8Array}\n     */\n    subarray(begin, end) {\n        return this._obj.subarray(begin, end);\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Hash.SIZE.get(this._algorithm);\n    }\n\n    /** @type {Uint8Array} */\n    get array() {\n        return this._obj;\n    }\n\n    /** @type {Hash.Algorithm} */\n    get algorithm() {\n        return this._algorithm;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof Hash && o._algorithm === this._algorithm && super.equals(o);\n    }\n\n    /**\n     * @param {string} base64\n     * @returns {Hash}\n     */\n    static fromBase64(base64) {\n        return new Hash(BufferUtils.fromBase64(base64));\n    }\n\n    /**\n     * @param {string} hex\n     * @returns {Hash}\n     */\n    static fromHex(hex) {\n        return new Hash(BufferUtils.fromHex(hex));\n    }\n\n    /**\n     * @param {string} str\n     * @returns {Hash}\n     */\n    static fromString(str) {\n        try {\n            return Hash.fromHex(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Hash.fromBase64(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        throw new Error('Invalid hash format');\n    }\n\n    /**\n     * @param {Hash} o\n     * @returns {boolean}\n     */\n    static isHash(o) {\n        return o instanceof Hash;\n    }\n\n    /**\n     * @param {Hash.Algorithm} algorithm\n     * @returns {number}\n     */\n    static getSize(algorithm) {\n        const size = Hash.SIZE.get(algorithm);\n        if (typeof size !== 'number') throw new Error('Invalid hash algorithm');\n        return size;\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    static computeBlake2b(input) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.BLAKE2B));\n            NodeNative.node_blake2(out, new Uint8Array(input));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.BLAKE2B);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmIn = Module.stackAlloc(input.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                const res = Module._nimiq_blake2(wasmOut, wasmIn, input.length);\n                if (res !== 0) {\n                    throw res;\n                }\n                const hash = new Uint8Array(hashSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hash;\n            } catch (e) {\n                Log.w(Hash, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    static computeSha256(input) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.SHA256));\n            NodeNative.node_sha256(out, new Uint8Array(input));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.SHA256);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmIn = Module.stackAlloc(input.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                Module._nimiq_sha256(wasmOut, wasmIn, input.length);\n                const hash = new Uint8Array(hashSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hash;\n            } catch (e) {\n                Log.w(Hash, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\n/**\n * @enum {number}\n */\nHash.Algorithm = {\n    BLAKE2B: 1,\n    ARGON2D: 2,\n    SHA256: 3,\n    SHA512: 4\n};\n/**\n * @type {Map<Hash.Algorithm, number>}\n */\nHash.SIZE = new Map();\nHash.SIZE.set(Hash.Algorithm.BLAKE2B, 32);\nHash.SIZE.set(Hash.Algorithm.ARGON2D, 32);\nHash.SIZE.set(Hash.Algorithm.SHA256, 32);\nHash.SIZE.set(Hash.Algorithm.SHA512, 64);\n\nHash.NULL = new Hash(new Uint8Array(32));\nClass.register(Hash);\n","class PrivateKey extends Serializable {\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== PrivateKey.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @return {PrivateKey}\n     */\n    static generate() {\n        const privateKey = new Uint8Array(PrivateKey.SIZE);\n        CryptoWorker.lib.getRandomValues(privateKey);\n        return new PrivateKey(privateKey);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {PrivateKey}\n     */\n    static unserialize(buf) {\n        return new PrivateKey(buf.read(PrivateKey.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return PrivateKey.SIZE;\n    }\n\n    /**\n     * Overwrite this private key with a replacement in-memory\n     * @param {PrivateKey} privateKey\n     */\n    overwrite(privateKey) {\n        this._obj.set(privateKey._obj);\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PrivateKey && super.equals(o);\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Uint8Array}\n     */\n    static _privateKeyDelinearize(privateKey, publicKey, publicKeysHash) {\n        if (privateKey.byteLength !== PrivateKey.SIZE\n            || publicKey.byteLength !== PublicKey.SIZE\n            || publicKeysHash.byteLength !== Hash.getSize(Hash.Algorithm.SHA512)) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_derive_delinearized_private_key(out, new Uint8Array(publicKeysHash), new Uint8Array(publicKey), new Uint8Array(privateKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const wasmInPrivateKey = Module.stackAlloc(privateKey.length);\n                const wasmInPublicKey = Module.stackAlloc(publicKey.length);\n                const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPrivateKey, privateKey.length).set(privateKey);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);\n                Module._ed25519_derive_delinearized_private_key(wasmOut, wasmInPublicKeysHash, wasmInPublicKey, wasmInPrivateKey);\n                const delinearizedPrivateKey = new Uint8Array(PrivateKey.SIZE);\n                delinearizedPrivateKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PrivateKey.SIZE));\n                return delinearizedPrivateKey;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nPrivateKey.SIZE = 32;\n\nClass.register(PrivateKey);\n","class PublicKey extends Serializable {\n    /**\n     * @param {PublicKey} o\n     * @returns {PublicKey}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new PublicKey(new Uint8Array(o._obj));\n    }\n\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== PublicKey.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @return {PublicKey}\n     */\n    static derive(privateKey) {\n        return new PublicKey(PublicKey._publicKeyDerive(privateKey._obj));\n    }\n\n    /**\n     * @param {Array.<PublicKey>} publicKeys\n     * @return {PublicKey}\n     */\n    static sum(publicKeys) {\n        publicKeys = publicKeys.slice();\n        publicKeys.sort((a, b) => a.compare(b));\n        return PublicKey._delinearizeAndAggregatePublicKeys(publicKeys);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {PublicKey}\n     */\n    static unserialize(buf) {\n        return new PublicKey(buf.read(PublicKey.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return PublicKey.SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PublicKey && super.equals(o);\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        return Hash.light(this.serialize());\n    }\n\n    /**\n     * @param {PublicKey} o\n     * @return {number}\n     */\n    compare(o) {\n        return BufferUtils.compare(this._obj, o._obj);\n    }\n\n    /**\n     * @return {Address}\n     */\n    toAddress() {\n        return Address.fromHash(this.hash());\n    }\n\n    /**\n     * @return {PeerId}\n     */\n    toPeerId() {\n        return new PeerId(this.hash().subarray(0, 16));\n    }\n\n    /**\n     * @param {Array.<PublicKey>} publicKeys\n     * @returns {PublicKey}\n     */\n    static _delinearizeAndAggregatePublicKeys(publicKeys) {\n        const publicKeysObj = publicKeys.map(k => k.serialize());\n        const publicKeysHash = PublicKey._publicKeysHash(publicKeysObj);\n        const raw = PublicKey._publicKeysDelinearizeAndAggregate(publicKeysObj, publicKeysHash);\n        return new PublicKey(raw);\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @returns {Uint8Array}\n     */\n    static _publicKeyDerive(privateKey) {\n        if (privateKey.byteLength !== PrivateKey.SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_public_key_derive(out, new Uint8Array(privateKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const pubKeyBuffer = new Uint8Array(Module.HEAP8.buffer, wasmOut, PrivateKey.SIZE);\n                pubKeyBuffer.set(privateKey);\n                const wasmIn = Module.stackAlloc(privateKey.length);\n                const privKeyBuffer = new Uint8Array(Module.HEAP8.buffer, wasmIn, PrivateKey.SIZE);\n                privKeyBuffer.set(privateKey);\n\n                Module._ed25519_public_key_derive(wasmOut, wasmIn);\n                privKeyBuffer.fill(0);\n                const publicKey = new Uint8Array(PublicKey.SIZE);\n                publicKey.set(pubKeyBuffer);\n                return publicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @returns {Uint8Array}\n     */\n    static _publicKeysHash(publicKeys) {\n        if (publicKeys.some(publicKey => publicKey.byteLength !== PublicKey.SIZE)) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedPublicKeys = new Uint8Array(publicKeys.length * PublicKey.SIZE);\n        for (let i = 0; i < publicKeys.length; ++i) {\n            concatenatedPublicKeys.set(publicKeys[i], i * PublicKey.SIZE);\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.SHA512));\n            NodeNative.node_ed25519_hash_public_keys(out, concatenatedPublicKeys, publicKeys.length);\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.SHA512);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);\n                Module._ed25519_hash_public_keys(wasmOut, wasmInPublicKeys, publicKeys.length);\n                const hashedPublicKey = new Uint8Array(hashSize);\n                hashedPublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hashedPublicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Uint8Array}\n     */\n    static _publicKeyDelinearize(publicKey, publicKeysHash) {\n        if (publicKey.byteLength !== PublicKey.SIZE\n            || publicKeysHash.byteLength !== Hash.getSize(Hash.Algorithm.SHA512)) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_delinearize_public_key(out, new Uint8Array(publicKeysHash), new Uint8Array(publicKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const wasmInPublicKey = Module.stackAlloc(publicKey.length);\n                const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);\n                Module._ed25519_delinearize_public_key(wasmOut, wasmInPublicKeysHash, wasmInPublicKey);\n                const delinearizedPublicKey = new Uint8Array(PublicKey.SIZE);\n                delinearizedPublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PublicKey.SIZE));\n                return delinearizedPublicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Uint8Array}\n     */\n    static _publicKeysDelinearizeAndAggregate(publicKeys, publicKeysHash) {\n        if (publicKeys.some(publicKey => publicKey.byteLength !== PublicKey.SIZE)\n            || publicKeysHash.byteLength !== Hash.getSize(Hash.Algorithm.SHA512)) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedPublicKeys = new Uint8Array(publicKeys.length * PublicKey.SIZE);\n        for (let i = 0; i < publicKeys.length; ++i) {\n            concatenatedPublicKeys.set(publicKeys[i], i * PublicKey.SIZE);\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_aggregate_delinearized_public_keys(out, new Uint8Array(publicKeysHash), concatenatedPublicKeys, publicKeys.length);\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);\n                const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);\n                Module._ed25519_aggregate_delinearized_public_keys(wasmOut, wasmInPublicKeysHash, wasmInPublicKeys, publicKeys.length);\n                const aggregatePublicKey = new Uint8Array(PublicKey.SIZE);\n                aggregatePublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PublicKey.SIZE));\n                return aggregatePublicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nPublicKey.SIZE = 32;\n\nClass.register(PublicKey);\n","class KeyPair extends Serializable {\n    /**\n     * @param {PrivateKey} privateKey\n     * @param {PublicKey} publicKey\n     * @param {boolean} locked\n     * @param {Uint8Array} lockSalt\n     * @private\n     */\n    constructor(privateKey, publicKey, locked = false, lockSalt = null) {\n        if (!(privateKey instanceof Object)) throw new Error('Primitive: Invalid type');\n        if (!(publicKey instanceof Object)) throw new Error('Primitive: Invalid type');\n        super();\n\n        /** @type {boolean} */\n        this._locked = locked;\n        /** @type {boolean} */\n        this._lockedInternally = locked;\n        /** @type {Uint8Array} */\n        this._lockSalt = lockSalt;\n        /** @type {PublicKey} */\n        this._publicKey = publicKey;\n        /** @type {PrivateKey} */\n        this._internalPrivateKey = new PrivateKey(privateKey.serialize());\n    }\n\n    /**\n     * @return {KeyPair}\n     */\n    static generate() {\n        const privateKey = PrivateKey.generate();\n        return new KeyPair(privateKey, PublicKey.derive(privateKey));\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @return {KeyPair}\n     */\n    static derive(privateKey) {\n        return new KeyPair(privateKey, PublicKey.derive(privateKey));\n    }\n\n    /**\n     * @param {string} hexBuf\n     * @return {KeyPair}\n     */\n    static fromHex(hexBuf) {\n        return KeyPair.unserialize(BufferUtils.fromHex(hexBuf));\n    }\n\n    /**\n     *\n     * @param {SerialBuffer} buf\n     * @param {Uint8Array} key\n     * @return {Promise<KeyPair>}\n     */\n    static async fromEncrypted(buf, key) {\n        const type = buf.readUint8();\n        if (type !== 1) throw new Error('Unsupported type');\n        const roundsLog = buf.readUint8();\n        if (roundsLog > 32) throw new Error('Rounds out-of-bounds');\n        const rounds = Math.pow(2, roundsLog);\n        const encryptedKey = PrivateKey.unserialize(buf);\n        const salt = buf.read(KeyPair.EXPORT_SALT_LENGTH);\n        const check = buf.read(KeyPair.EXPORT_CHECKSUM_LENGTH);\n\n        const privateKey = new PrivateKey(await KeyPair._otpKdf(encryptedKey.serialize(), key, salt, rounds));\n        const keyPair = KeyPair.derive(privateKey);\n        const pubHash = keyPair.publicKey.hash();\n        if (!BufferUtils.equals(pubHash.subarray(0, 4), check)) {\n            throw new Error('Invalid key');\n        }\n        return keyPair;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {KeyPair}\n     */\n    static unserialize(buf) {\n        const privateKey = PrivateKey.unserialize(buf);\n        const publicKey = PublicKey.unserialize(buf);\n        let locked = false;\n        let lockSalt = null;\n        if (buf.readPos < buf.byteLength) {\n            const extra = buf.readUint8();\n            if (extra === 1) {\n                locked = true;\n                lockSalt = buf.read(32);\n            }\n        }\n        return new KeyPair(privateKey, publicKey, locked, lockSalt);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._privateKey.serialize(buf);\n        this.publicKey.serialize(buf);\n        if (this._locked) {\n            buf.writeUint8(1);\n            buf.write(this._lockSalt);\n        } else {\n            buf.writeUint8(0);\n        }\n        return buf;\n    }\n\n    /**\n     * The unlocked private key.\n     * @type {PrivateKey}\n     */\n    get privateKey() {\n        if (this.isLocked) throw new Error('Wallet is locked');\n        return this._privateKey;\n    }\n\n    /**\n     * The private key in its current state, i.e., depending on this._locked.\n     * If this._locked, it is the internally locked private key.\n     * If !this._locked, it is either the internally unlocked private key (if !this._lockedInternally)\n     * or this._unlockedPrivateKey.\n     * @type {PrivateKey}\n     */\n    get _privateKey() {\n        return this._unlockedPrivateKey || this._internalPrivateKey;\n    }\n\n    /** @type {PublicKey} */\n    get publicKey() {\n        return this._publicKey || (this._publicKey = new PublicKey(this._obj.publicKey));\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._privateKey.serializedSize + this.publicKey.serializedSize + (this._locked ? this._lockSalt.byteLength + 1 : 1);\n    }\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} [unlockKey]\n     * @return {Promise.<Uint8Array>}\n     */\n    async exportEncrypted(key, unlockKey) {\n        const wasLocked = this._locked;\n        if (this._locked) {\n            try {\n                await this.unlock(unlockKey || key);\n            } catch (e) {\n                throw new Error('KeyPair is locked and lock key mismatches');\n            }\n        }\n\n        const salt = new Uint8Array(KeyPair.EXPORT_SALT_LENGTH);\n        CryptoWorker.lib.getRandomValues(salt);\n\n        const buf = new SerialBuffer(this.encryptedSize);\n        buf.writeUint8(1); // Argon2 KDF\n        buf.writeUint8(Math.log2(KeyPair.EXPORT_KDF_ROUNDS));\n        buf.write(await KeyPair._otpKdf(this.privateKey.serialize(), key, salt, KeyPair.EXPORT_KDF_ROUNDS));\n        buf.write(salt);\n        buf.write(this.publicKey.hash().subarray(0, KeyPair.EXPORT_CHECKSUM_LENGTH));\n\n        if (wasLocked) this.relock();\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get encryptedSize() {\n        return 2 + this.privateKey.serializedSize + KeyPair.EXPORT_SALT_LENGTH + KeyPair.EXPORT_CHECKSUM_LENGTH;\n    }\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} [lockSalt]\n     */\n    async lock(key, lockSalt) {\n        if (this._locked) throw new Error('KeyPair already locked');\n\n        if (lockSalt) this._lockSalt = lockSalt;\n        if (!this._lockSalt || this._lockSalt.length === 0) {\n            this._lockSalt = new Uint8Array(32);\n            CryptoWorker.lib.getRandomValues(this._lockSalt);\n        }\n\n        this._internalPrivateKey.overwrite(await this._otpPrivateKey(key));\n        this._clearUnlockedPrivateKey();\n        this._locked = true;\n        this._lockedInternally = true;\n    }\n\n    /**\n     * @param {Uint8Array} key\n     */\n    async unlock(key) {\n        if (!this._locked) throw new Error('KeyPair not locked');\n\n        const privateKey = await this._otpPrivateKey(key);\n        const verifyPub = PublicKey.derive(privateKey);\n        if (verifyPub.equals(this.publicKey)) {\n            // Only set this._internalPrivateKey, but keep this._obj locked.\n            this._unlockedPrivateKey = privateKey;\n            this._locked = false;\n        } else {\n            throw new Error('Invalid key');\n        }\n    }\n\n    /**\n     * Destroy cached unlocked private key if the internal key is in locked state.\n     */\n    relock() {\n        if (this._locked) throw new Error('KeyPair already locked');\n        if (!this._lockedInternally) throw new Error('KeyPair was never locked');\n        this._clearUnlockedPrivateKey();\n        this._locked = true;\n    }\n\n    _clearUnlockedPrivateKey() {\n        // If this wallet is not locked internally and unlocked, this method does not have any effect.\n        if (!this._lockedInternally || this._locked) return;\n\n        // Overwrite cached key in this._unlockedPrivateKey with 0s.\n        this._unlockedPrivateKey.overwrite(PrivateKey.unserialize(new SerialBuffer(this._unlockedPrivateKey.serializedSize)));\n        // Then, reset it.\n        this._unlockedPrivateKey = null;\n    }\n\n    /**\n     * @param {Uint8Array} key\n     * @return {Promise<PrivateKey>}\n     * @private\n     */\n    async _otpPrivateKey(key) {\n        return new PrivateKey(await KeyPair._otpKdf(this._privateKey.serialize(), key, this._lockSalt, KeyPair.LOCK_KDF_ROUNDS));\n    }\n\n    /**\n     * @param {Uint8Array} message\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @return {Promise<Uint8Array>}\n     * @private\n     */\n    static async _otpKdf(message, key, salt, iterations) {\n        return BufferUtils.xor(message, await (await CryptoWorker.getInstanceAsync()).kdf(key, salt, iterations));\n    }\n\n    get isLocked() {\n        return this._locked;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof KeyPair && super.equals(o);\n    }\n}\nKeyPair.LOCK_KDF_ROUNDS = 256;\nKeyPair.EXPORT_KDF_ROUNDS = 256;\nKeyPair.EXPORT_CHECKSUM_LENGTH = 4;\nKeyPair.EXPORT_SALT_LENGTH = 16;\n\nClass.register(KeyPair);\n","class RandomSecret extends Serializable {\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== RandomSecret.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {RandomSecret}\n     */\n    static unserialize(buf) {\n        return new RandomSecret(buf.read(RandomSecret.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return RandomSecret.SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof RandomSecret && super.equals(o);\n    }\n}\n\nRandomSecret.SIZE = 32;\n\nClass.register(RandomSecret);\n","class Signature extends Serializable {\n    /**\n     * @param {Signature} o\n     * @returns {Signature}\n     */\n    static copy(o) {\n        if (!o) return o;\n        // FIXME Move this to Crypto class.\n        const obj = new Uint8Array(o._obj);\n        return new Signature(obj);\n    }\n\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== Signature.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @param {PublicKey} publicKey\n     * @param {Uint8Array} data\n     * @return {Signature}\n     */\n    static create(privateKey, publicKey, data) {\n        return new Signature(Signature._signatureCreate(privateKey._obj, publicKey._obj, data));\n    }\n\n    /**\n     * @param {Commitment} commitment\n     * @param {Array.<PartialSignature>} signatures\n     * @return {Signature}\n     */\n    static fromPartialSignatures(commitment, signatures) {\n        const raw = Signature._combinePartialSignatures(commitment.serialize(), signatures.map(s => s.serialize()));\n        return new Signature(raw);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Signature}\n     */\n    static unserialize(buf) {\n        return new Signature(buf.read(Signature.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Signature.SIZE;\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Uint8Array} data\n     * @return {boolean}\n     */\n    verify(publicKey, data) {\n        return Signature._signatureVerify(publicKey._obj, data, this._obj);\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Signature && super.equals(o);\n    }\n\n    /**\n     * @param {Uint8Array} combinedCommitment\n     * @param {Array.<Uint8Array>} partialSignatures\n     * @returns {Uint8Array}\n     */\n    static _combinePartialSignatures(combinedCommitment, partialSignatures) {\n        const combinedSignature = Signature._aggregatePartialSignatures(partialSignatures);\n        return BufferUtils.concatTypedArrays(combinedCommitment, combinedSignature);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} partialSignatures\n     * @returns {Uint8Array}\n     */\n    static _aggregatePartialSignatures(partialSignatures) {\n        return partialSignatures.reduce((sigA, sigB) => Signature._scalarsAdd(sigA, sigB));\n    }\n\n    /**\n     * @param {Uint8Array} a\n     * @param {Uint8Array} b\n     * @returns {Uint8Array}\n     */\n    static _scalarsAdd(a, b) {\n        if (a.byteLength !== PartialSignature.SIZE || b.byteLength !== PartialSignature.SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PartialSignature.SIZE);\n            NodeNative.node_ed25519_add_scalars(out, new Uint8Array(a), new Uint8Array(b));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOutSum = Module.stackAlloc(PartialSignature.SIZE);\n                const wasmInA = Module.stackAlloc(a.length);\n                const wasmInB = Module.stackAlloc(b.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInA, a.length).set(a);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInB, b.length).set(b);\n                Module._ed25519_add_scalars(wasmOutSum, wasmInA, wasmInB);\n                const sum = new Uint8Array(PartialSignature.SIZE);\n                sum.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutSum, PartialSignature.SIZE));\n                return sum;\n            } catch (e) {\n                Log.w(Signature, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} message\n     * @returns {Uint8Array}\n     */\n    static _signatureCreate(privateKey, publicKey, message) {\n        if (publicKey.byteLength !== PublicKey.SIZE\n            || privateKey.byteLength !== PrivateKey.SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Signature.SIZE);\n            NodeNative.node_ed25519_sign(out, new Uint8Array(message), new Uint8Array(publicKey), new Uint8Array(privateKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                const wasmOutSignature = Module.stackAlloc(Signature.SIZE);\n                const signatureBuffer = new Uint8Array(Module.HEAP8.buffer, wasmOutSignature, Signature.SIZE);\n                const wasmInMessage = Module.stackAlloc(message.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInMessage, message.length).set(message);\n                const wasmInPubKey = Module.stackAlloc(publicKey.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInPubKey, publicKey.length).set(publicKey);\n                const wasmInPrivKey = Module.stackAlloc(privateKey.length);\n                const privKeyBuffer = new Uint8Array(Module.HEAP8.buffer, wasmInPrivKey, privateKey.length);\n                privKeyBuffer.set(privateKey);\n\n                Module._ed25519_sign(wasmOutSignature, wasmInMessage, message.byteLength, wasmInPubKey, wasmInPrivKey);\n                privKeyBuffer.fill(0);\n\n                const signature = new Uint8Array(Signature.SIZE);\n                signature.set(signatureBuffer);\n                return signature;\n            } catch (e) {\n                Log.w(Signature, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} message\n     * @param {Uint8Array} signature\n     * @returns {boolean}\n     */\n    static _signatureVerify(publicKey, message, signature) {\n        if (PlatformUtils.isNodeJs()) {\n            return !!NodeNative.node_ed25519_verify(new Uint8Array(signature), new Uint8Array(message), new Uint8Array(publicKey));\n        } else {\n            let stackPtr;\n            try {\n                const wasmInPubKey = Module.stackAlloc(publicKey.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInPubKey, publicKey.length).set(publicKey);\n                const wasmInMessage = Module.stackAlloc(message.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInMessage, message.length).set(message);\n                const wasmInSignature = Module.stackAlloc(signature.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInSignature, signature.length).set(signature);\n\n                return !!Module._ed25519_verify(wasmInSignature, wasmInMessage, message.byteLength, wasmInPubKey);\n            } catch (e) {\n                Log.w(Signature, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nSignature.SIZE = 64;\n\nClass.register(Signature);\n","class Commitment extends Serializable {\n    /**\n     * @param {Commitment} o\n     * @returns {Commitment}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new Commitment(new Uint8Array(o._obj));\n    }\n\n    /**\n     * @param {Array.<Commitment>} commitments\n     * @return {Commitment}\n     */\n    static sum(commitments) {\n        return new Commitment(Commitment._commitmentsAggregate(commitments.map(c => c._obj)));\n    }\n\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== Commitment.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Commitment}\n     */\n    static unserialize(buf) {\n        return new Commitment(buf.read(Commitment.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Commitment.SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Commitment && super.equals(o);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} commitments\n     * @returns {Uint8Array}\n     */\n    static _commitmentsAggregate(commitments) {\n        if (commitments.some(commitment => commitment.byteLength !== PublicKey.SIZE)) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedCommitments = new Uint8Array(commitments.length * PublicKey.SIZE);\n        for (let i = 0; i < commitments.length; ++i) {\n            concatenatedCommitments.set(commitments[i], i * PublicKey.SIZE);\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_aggregate_commitments(out, concatenatedCommitments, commitments.length);\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const wasmInCommitments = Module.stackAlloc(concatenatedCommitments.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInCommitments, concatenatedCommitments.length).set(concatenatedCommitments);\n                Module._ed25519_aggregate_commitments(wasmOut, wasmInCommitments, commitments.length);\n                const aggCommitments = new Uint8Array(PublicKey.SIZE);\n                aggCommitments.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PublicKey.SIZE));\n                return aggCommitments;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nCommitment.SIZE = 32;\n\nClass.register(Commitment);\n","class CommitmentPair extends Serializable {\n    /**\n     * @param {RandomSecret} arg\n     * @param {Commitment} arg\n     * @private\n     */\n    constructor(secret, commitment) {\n        super();\n        if (!(secret instanceof RandomSecret)) throw new Error('Primitive: Invalid type');\n        if (!(commitment instanceof Commitment)) throw new Error('Primitive: Invalid type');\n        this._secret = secret;\n        this._commitment = commitment;\n    }\n\n    /**\n     * @return {CommitmentPair}\n     */\n    static generate() {\n        const randomness = new Uint8Array(CommitmentPair.RANDOMNESS_SIZE);\n        CryptoWorker.lib.getRandomValues(randomness);\n        const raw = CommitmentPair._commitmentCreate(randomness);\n        return new CommitmentPair(new RandomSecret(raw.secret), new Commitment(raw.commitment));\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {CommitmentPair}\n     */\n    static unserialize(buf) {\n        const secret = RandomSecret.unserialize(buf);\n        const commitment = Commitment.unserialize(buf);\n        return new CommitmentPair(secret, commitment);\n    }\n\n    /**\n     * @param {string} hexBuf\n     * @return {CommitmentPair}\n     */\n    static fromHex(hexBuf) {\n        return this.unserialize(BufferUtils.fromHex(hexBuf));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this.secret.serialize(buf);\n        this.commitment.serialize(buf);\n        return buf;\n    }\n\n    /** @type {RandomSecret} */\n    get secret() {\n        return this._secret;\n    }\n\n    /** @type {Commitment} */\n    get commitment() {\n        return this._commitment;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this.secret.serializedSize + this.commitment.serializedSize;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof CommitmentPair && super.equals(o);\n    }\n\n    /**\n     * @param {Uint8Array} randomness\n     * @returns {{commitment:Uint8Array, secret:Uint8Array}}\n     */\n    static _commitmentCreate(randomness) {\n        if (PlatformUtils.isNodeJs()) {\n            const commitment = new Uint8Array(PublicKey.SIZE);\n            const secret = new Uint8Array(PrivateKey.SIZE);\n            NodeNative.node_ed25519_create_commitment(secret, commitment, randomness);\n            return {commitment, secret};\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOutCommitment = Module.stackAlloc(PublicKey.SIZE);\n                const wasmOutSecret = Module.stackAlloc(PrivateKey.SIZE);\n                const wasmIn = Module.stackAlloc(randomness.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, randomness.length).set(randomness);\n                const res = Module._ed25519_create_commitment(wasmOutSecret, wasmOutCommitment, wasmIn);\n                if (res !== 1) {\n                    throw new Error(`Secret must not be 0 or 1: ${res}`);\n                }\n                const commitment = new Uint8Array(PublicKey.SIZE);\n                const secret = new Uint8Array(PrivateKey.SIZE);\n                commitment.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutCommitment, PublicKey.SIZE));\n                secret.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutSecret, PrivateKey.SIZE));\n                return {commitment, secret};\n            } catch (e) {\n                Log.w(CommitmentPair, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nCommitmentPair.SERIALIZED_SIZE = RandomSecret.SIZE + Signature.SIZE;\nCommitmentPair.RANDOMNESS_SIZE = 32;\n\nClass.register(CommitmentPair);\n","class PartialSignature extends Serializable {\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== PartialSignature.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @param {PublicKey} publicKey\n     * @param {Array.<PublicKey>} publicKeys\n     * @param {RandomSecret} secret\n     * @param {Commitment} aggregateCommitment\n     * @param {Uint8Array} data\n     * @return {PartialSignature}\n     */\n    static create(privateKey, publicKey, publicKeys, secret, aggregateCommitment, data) {\n        const raw = PartialSignature._delinearizedPartialSignatureCreate(publicKeys.map(o => o._obj), privateKey._obj,\n            publicKey._obj, secret._obj, aggregateCommitment._obj, data);\n        return new PartialSignature(raw);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {PartialSignature}\n     */\n    static unserialize(buf) {\n        return new PartialSignature(buf.read(PartialSignature.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return PartialSignature.SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PartialSignature && super.equals(o);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} secret\n     * @param {Uint8Array} aggregateCommitment\n     * @param {Uint8Array} message\n     * @returns {Uint8Array}\n     */\n    static _delinearizedPartialSignatureCreate(publicKeys, privateKey, publicKey, secret, aggregateCommitment, message) {\n        if (publicKeys.some(publicKey => publicKey.byteLength !== PublicKey.SIZE)\n            || privateKey.byteLength !== PrivateKey.SIZE\n            || publicKey.byteLength !== PublicKey.SIZE\n            || secret.byteLength !== RandomSecret.SIZE\n            || aggregateCommitment.byteLength !== Commitment.SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedPublicKeys = new Uint8Array(publicKeys.length * PublicKey.SIZE);\n        for (let i = 0; i < publicKeys.length; ++i) {\n            concatenatedPublicKeys.set(publicKeys[i], i * PublicKey.SIZE);\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PartialSignature.SIZE);\n            NodeNative.node_ed25519_delinearized_partial_sign(out, new Uint8Array(message), new Uint8Array(aggregateCommitment), new Uint8Array(secret), new Uint8Array(concatenatedPublicKeys), publicKeys.length, new Uint8Array(publicKey), new Uint8Array(privateKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PartialSignature.SIZE);\n                const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);\n                const wasmInPrivateKey = Module.stackAlloc(privateKey.length);\n                const wasmInPublicKey = Module.stackAlloc(publicKey.length);\n                const wasmInSecret = Module.stackAlloc(secret.length);\n                const wasmInCommitment = Module.stackAlloc(aggregateCommitment.length);\n                const wasmInMessage = Module.stackAlloc(message.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPrivateKey, privateKey.length).set(privateKey);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInSecret, secret.length).set(secret);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInCommitment, aggregateCommitment.length).set(aggregateCommitment);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInMessage, message.length).set(message);\n                Module._ed25519_delinearized_partial_sign(wasmOut, wasmInMessage, message.length, wasmInCommitment, wasmInSecret, wasmInPublicKeys, publicKeys.length, wasmInPublicKey, wasmInPrivateKey);\n                const partialSignature = new Uint8Array(PartialSignature.SIZE);\n                partialSignature.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PartialSignature.SIZE));\n                return partialSignature;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nPartialSignature.SIZE = 32;\nClass.register(PartialSignature);\n","class Address extends Serializable {\n    /**\n     * @param {Address} o\n     * @returns {Address}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const obj = new Uint8Array(o._obj);\n        return new Address(obj);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Address}\n     */\n    static fromHash(hash) {\n        return new Address(hash.subarray(0, Address.SERIALIZED_SIZE));\n    }\n\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== Address.SERIALIZED_SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * Create Address object from binary form.\n     * @param {SerialBuffer} buf Buffer to read from.\n     * @return {Address} Newly created Account object.\n     */\n    static unserialize(buf) {\n        return new Address(buf.read(Address.SERIALIZED_SIZE));\n    }\n\n    /**\n     * Serialize this Address object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    subarray(begin, end) {\n        return this._obj.subarray(begin, end);\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        return Address.SERIALIZED_SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Address\n            && super.equals(o);\n    }\n\n    static fromString(str) {\n        try {\n            return Address.fromUserFriendlyAddress(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Address.fromHex(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Address.fromBase64(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        throw new Error('Invalid address format');\n    }\n\n    /**\n     * @param {string} base64\n     * @return {Address}\n     */\n    static fromBase64(base64) {\n        return new Address(BufferUtils.fromBase64(base64));\n    }\n\n    /**\n     * @param {string} hex\n     * @return {Address}\n     */\n    static fromHex(hex) {\n        return new Address(BufferUtils.fromHex(hex));\n    }\n\n    /**\n     * @param {string} str\n     * @return {Address}\n     */\n    static fromUserFriendlyAddress(str) {\n        str = str.replace(/ /g, '');\n        if (str.substr(0, 2).toUpperCase() !== Address.CCODE) {\n            throw new Error('Invalid Address: Wrong country code');\n        }\n        if (str.length !== 36) {\n            throw new Error('Invalid Address: Should be 36 chars (ignoring spaces)');\n        }\n        if (Address._ibanCheck(str.substr(4) + str.substr(0, 4)) !== 1) {\n            throw new Error('Invalid Address: Checksum invalid');\n        }\n        return new Address(BufferUtils.fromBase32(str.substr(4)));\n    }\n\n    static _ibanCheck(str) {\n        const num = str.split('').map((c) => {\n            const code = c.toUpperCase().charCodeAt(0);\n            return code >= 48 && code <= 57 ? c : (code - 55).toString();\n        }).join('');\n        let tmp = '';\n\n        for (let i = 0; i < Math.ceil(num.length / 6); i++) {\n            tmp = (parseInt(tmp + num.substr(i * 6, 6)) % 97).toString();\n        }\n\n        return parseInt(tmp);\n    }\n\n    /**\n     * @param {boolean} [withSpaces]\n     * @return {string}\n     */\n    toUserFriendlyAddress(withSpaces = true) {\n        const base32 = BufferUtils.toBase32(this.serialize());\n        // eslint-disable-next-line prefer-template\n        const check = ('00' + (98 - Address._ibanCheck(base32 + Address.CCODE + '00'))).slice(-2);\n        let res = Address.CCODE + check + base32;\n        if (withSpaces) res = res.replace(/.{4}/g, '$& ').trim();\n        return res;\n    }\n}\nAddress.CCODE = 'NQ';\nAddress.SERIALIZED_SIZE = 20;\nAddress.HEX_SIZE = 40;\nAddress.NULL = new Address(new Uint8Array(Address.SERIALIZED_SIZE));\nAddress.CONTRACT_CREATION = new Address(new Uint8Array(Address.SERIALIZED_SIZE));\nClass.register(Address);\n","/**\n * @abstract\n */\nclass Account {\n    /**\n     * @param {Account.Type} type\n     * @param {number} balance\n     */\n    constructor(type, balance) {\n        if (!NumberUtils.isUint8(type)) throw new Error('Malformed type');\n        if (!NumberUtils.isUint64(balance)) throw new Error('Malformed balance');\n\n        /** @type {Account.Type} */\n        this._type = type;\n        /** @type {number} */\n        this._balance = balance;\n    }\n\n    /**\n     * Create Account object from binary form.\n     * @param {SerialBuffer} buf Buffer to read from.\n     * @return {Account} Newly created Account object.\n     */\n    static unserialize(buf) {\n        const type = /** @type {Account.Type} */ buf.readUint8();\n        buf.readPos--;\n\n        if (!Account.TYPE_MAP.has(type)) {\n            throw new Error('Unknown account type');\n        }\n\n        return Account.TYPE_MAP.get(type).unserialize(buf);\n    }\n\n    /**\n     * Serialize this Account object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._type);\n        buf.writeUint64(this._balance);\n        return buf;\n    }\n\n    /**\n     * @return {number}\n     */\n    get serializedSize() {\n        return /*type*/ 1\n            + /*balance*/ 8;\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return BufferUtils.equals(this.serialize(), o.serialize());\n    }\n\n    toString() {\n        return `Account{type=${this._type}, balance=${this._balance.toString()}`;\n    }\n\n    /**\n     * @type {number} Account balance\n     */\n    get balance() {\n        return this._balance;\n    }\n\n    /** @type {Account.Type} */\n    get type() {\n        return this._type;\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) { throw new Error('Not yet implemented.'); }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionsCache\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert = false) {\n        if (!revert) {\n            const newBalance = this._balance - transaction.value - transaction.fee;\n            if (newBalance < 0) {\n                throw new Error('Balance Error!');\n            }\n            if (blockHeight < transaction.validityStartHeight\n                || blockHeight >= transaction.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n                throw new Error('Validity Error!');\n            }\n            if (transactionsCache.containsTransaction(transaction)) {\n                throw new Error('Double Transaction Error!');\n            }\n            return this.withBalance(newBalance);\n        } else {\n            if (blockHeight < transaction.validityStartHeight\n                || blockHeight >= transaction.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n                throw new Error('Validity Error!');\n            }\n            return this.withBalance(this._balance + transaction.value + transaction.fee);\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        if (!revert) {\n            return this.withBalance(this._balance + transaction.value);\n        } else {\n            const newBalance = this._balance - transaction.value;\n            if (newBalance < 0) {\n                throw new Error('Balance Error!');\n            }\n            return this.withBalance(newBalance);\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withContractCommand(transaction, blockHeight, revert = false) {\n        throw new Error('Not yet implemented');\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isInitial() {\n        return this === Account.INITIAL;\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isToBePruned() {\n        return this._balance === 0 && !this.isInitial();\n    }\n}\n\n/**\n * Enum for Account types.\n * Non-zero values are contracts.\n * @enum\n */\nAccount.Type = {\n    /**\n     * Basic account type.\n     * @see {BasicAccount}\n     */\n    BASIC: 0,\n    /**\n     * Account with vesting functionality.\n     * @see {VestingContract}\n     */\n    VESTING: 1,\n    /**\n     * Hashed Time-Locked Contract\n     * @see {HashedTimeLockedContract}\n     */\n    HTLC: 2\n};\n/**\n * @type {Map.<Account.Type, {copy: function(o: *):Account, unserialize: function(buf: SerialBuffer):Account, create: function(balance: number, blockHeight: number, transaction: Transaction):Account, verifyOutgoingTransaction: function(transaction: Transaction):Promise.<boolean>, verifyIncomingTransaction: function(transaction: Transaction):Promise.<boolean>}>}\n */\nAccount.TYPE_MAP = new Map();\n\nClass.register(Account);\n","class PrunedAccount {\n    /**\n     * @param {Address} address\n     * @param {Account} account\n     */\n    constructor(address, account) {\n        if (!(address instanceof Address)) throw new Error('Malformed address');\n\n        /** @type {Address} */\n        this._address = address;\n        /** @type {Account} */\n        this._account = account;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {PrunedAccount}\n     */\n    static unserialize(buf) {\n        return new PrunedAccount(Address.unserialize(buf), Account.unserialize(buf));\n    }\n\n    /**\n     * @param {PrunedAccount} o\n     * @return {number} negative if this is smaller than o, positive if this is larger than o, zero if equal.\n     */\n    compare(o) {\n        return this._address.compare(o._address);\n    }\n\n    /**\n     * @returns {Address}\n     */\n    get address() {\n        return this._address;\n    }\n\n    /**\n     * @returns {Account}\n     */\n    get account() {\n        return this._account;\n    }\n\n    /**\n     * @param buf\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._address.serialize(buf);\n        this._account.serialize(buf);\n        return this;\n    }\n\n    get serializedSize() {\n        return this._address.serializedSize + this._account.serializedSize;\n    }\n}\n\nClass.register(PrunedAccount);\n","/**\n * This is a classic account that can send all his funds and receive any transaction.\n * All outgoing transactions are signed using the key corresponding to this address.\n */\nclass BasicAccount extends Account {\n    /**\n     * @param {BasicAccount} o\n     * @returns {BasicAccount}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new BasicAccount(o._balance);\n    }\n\n    /**\n     * @param {number} [balance]\n     */\n    constructor(balance = 0) {\n        super(Account.Type.BASIC, balance);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {BasicAccount}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        if (type !== Account.Type.BASIC) throw new Error('Invalid account type');\n\n        const balance = buf.readUint64();\n        return new BasicAccount(balance);\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return o instanceof BasicAccount\n            && this._type === o._type\n            && this._balance === o._balance;\n    }\n\n    toString() {\n        return `BasicAccount{balance=${this._balance}}`;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyOutgoingTransaction(transaction) {\n        return SignatureProof.verifyTransaction(transaction);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        if (transaction.data.byteLength > 64) return false;\n        return true;\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) {\n        return new BasicAccount(balance);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        if (!revert) {\n            const isContractCreation = transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION);\n            const isTypeChange = transaction.recipientType !== this._type;\n            if (isContractCreation !== isTypeChange) {\n                throw new Error('Data Error!');\n            }\n        }\n        return super.withIncomingTransaction(transaction, blockHeight, revert);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withContractCommand(transaction, blockHeight, revert = false) {\n        if (!revert && transaction.recipientType !== this._type && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {\n            // Contract creation\n            return Account.TYPE_MAP.get(transaction.recipientType).create(this._balance, blockHeight, transaction);\n        }\n        return this;\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isInitial() {\n        return this._balance === 0;\n    }\n}\n\nAccount.INITIAL = new BasicAccount(0);\nAccount.TYPE_MAP.set(Account.Type.BASIC, BasicAccount);\nClass.register(BasicAccount);\n","class Contract extends Account {\n    /**\n     * @param {Account.Type} type\n     * @param {number} balance\n     */\n    constructor(type, balance) {\n        super(type, balance);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        if (!transaction.recipient.equals(transaction.getContractCreationAddress())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        if (!revert && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {\n            // Contract already created\n            throw new Error('Data error');\n        }\n        return super.withIncomingTransaction(transaction, blockHeight, revert);\n    }\n\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withContractCommand(transaction, blockHeight, revert = false) {\n        if (revert && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {\n            // Revert contract creation\n            return new BasicAccount(this.balance);\n        }\n        return this;\n    }\n}\n\nClass.register(Contract);\n","class HashedTimeLockedContract extends Contract {\n    /**\n     * @param {number} balance\n     * @param {Address} sender\n     * @param {Address} recipient\n     * @param {Hash} hashRoot\n     * @param {number} hashCount\n     * @param {number} timeout\n     * @param {number} totalAmount\n     */\n    constructor(balance = 0, sender = Address.NULL, recipient = Address.NULL, hashRoot = Hash.NULL, hashCount = 1, timeout = 0, totalAmount = balance) {\n        super(Account.Type.HTLC, balance);\n        if (!(sender instanceof Address)) throw new Error('Malformed address');\n        if (!(recipient instanceof Address)) throw new Error('Malformed address');\n        if (!(hashRoot instanceof Hash)) throw new Error('Malformed address');\n        if (!NumberUtils.isUint8(hashCount) || hashCount === 0) throw new Error('Malformed hashCount');\n        if (!NumberUtils.isUint32(timeout)) throw new Error('Malformed timeout');\n        if (!NumberUtils.isUint64(totalAmount)) throw new Error('Malformed totalAmount');\n\n        /** @type {Address} */\n        this._sender = sender;\n        /** @type {Address} */\n        this._recipient = recipient;\n        /** @type {Hash} */\n        this._hashRoot = hashRoot;\n        /** @type {number} */\n        this._hashCount = hashCount;\n        /** @type {number} */\n        this._timeout = timeout;\n        /** @type {number} */\n        this._totalAmount = totalAmount;\n    }\n\n    /**\n     * @param {number} balance\n     * @param {number} blockHeight\n     * @param {Transaction} transaction\n     */\n    static create(balance, blockHeight, transaction) {\n        const buf = new SerialBuffer(transaction.data);\n\n        const sender = Address.unserialize(buf);\n        const recipient = Address.unserialize(buf);\n        const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n        const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n        const hashCount = buf.readUint8();\n        const timeout = buf.readUint32();\n\n        return new HashedTimeLockedContract(balance, sender, recipient, hashRoot, hashCount, timeout);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {HashedTimeLockedContract}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        if (type !== Account.Type.HTLC) throw new Error('Invalid account type');\n\n        const balance = buf.readUint64();\n        const sender = Address.unserialize(buf);\n        const recipient = Address.unserialize(buf);\n        const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n        const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n        const hashCount = buf.readUint8();\n        const timeout = buf.readUint32();\n        const totalAmount = buf.readUint64();\n        return new HashedTimeLockedContract(balance, sender, recipient, hashRoot, hashCount, timeout, totalAmount);\n    }\n\n\n    /**\n     * Serialize this HTLC object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._sender.serialize(buf);\n        this._recipient.serialize(buf);\n        buf.writeUint8(this._hashRoot.algorithm);\n        this._hashRoot.serialize(buf);\n        buf.writeUint8(this._hashCount);\n        buf.writeUint32(this._timeout);\n        buf.writeUint64(this._totalAmount);\n        return buf;\n    }\n\n    /**\n     * @return {number}\n     */\n    get serializedSize() {\n        return super.serializedSize\n            + this._sender.serializedSize\n            + this._recipient.serializedSize\n            + /*hashAlgorithm*/ 1\n            + this._hashRoot.serializedSize\n            + /*hashCount*/ 1\n            + /*timeout*/ 4\n            + /*totalAmount*/ 8;\n    }\n\n    /** @type {Address} */\n    get sender() {\n        return this._sender;\n    }\n\n    /** @type {Address} */\n    get recipient() {\n        return this._recipient;\n    }\n\n    /** @type {Hash} */\n    get hashRoot() {\n        return this._hashRoot;\n    }\n\n    /** @type {number} */\n    get hashCount() {\n        return this._hashCount;\n    }\n\n    /** @type {number} */\n    get timeout() {\n        return this._timeout;\n    }\n\n    /** @type {number} */\n    get totalAmount() {\n        return this._totalAmount;\n    }\n\n    toString() {\n        return `HashedTimeLockedContract{balance=${this._balance}, sender=${this._sender.toUserFriendlyAddress(false)}, recipient=${this._sender.toUserFriendlyAddress(false)}, amount=${this._totalAmount}/${this._hashCount}, timeout=${this._timeout}}`;\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return o instanceof HashedTimeLockedContract\n            && this._type === o._type\n            && this._balance === o._balance\n            && this._sender.equals(o._sender)\n            && this._recipient.equals(o._recipient)\n            && this._hashRoot.equals(o._hashRoot)\n            && this._hashCount === o._hashCount\n            && this._timeout === o._timeout\n            && this._totalAmount === o._totalAmount;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyOutgoingTransaction(transaction) {\n        try {\n            const buf = new SerialBuffer(transaction.proof);\n            const type = buf.readUint8();\n            switch (type) {\n                case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER: {\n                    const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n                    const hashDepth = buf.readUint8();\n                    const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n                    let preImage = Hash.unserialize(buf, hashAlgorithm);\n\n                    // Verify that the preImage hashed hashDepth times matches the _provided_ hashRoot.\n                    for (let i = 0; i < hashDepth; ++i) {\n                        preImage = Hash.compute(preImage.array, hashAlgorithm);\n                    }\n                    if (!hashRoot.equals(preImage)) {\n                        return false;\n                    }\n\n                    // Signature proof of the HTLC recipient\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n                    break;\n                }\n                case HashedTimeLockedContract.ProofType.EARLY_RESOLVE: {\n                    // Signature proof of the HTLC recipient\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n\n                    // Signature proof of the HTLC creator\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n                    break;\n                }\n                case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE:\n                    // Signature proof of the HTLC creator\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n                    break;\n                default:\n                    return false;\n            }\n\n            // Reject overlong proof.\n            if (buf.readPos !== buf.byteLength) {\n                return false;\n            }\n\n            return true; // Accept\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        try {\n            const buf = new SerialBuffer(transaction.data);\n\n            Address.unserialize(buf); // sender address\n            Address.unserialize(buf); // recipient address\n            const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n            Hash.unserialize(buf, hashAlgorithm);\n            buf.readUint8(); // hash count\n            buf.readUint32(); // timeout\n\n            // Blacklist Argon2 hash function.\n            if (hashAlgorithm === Hash.Algorithm.ARGON2D) {\n                return false;\n            }\n\n            if (buf.readPos !== buf.byteLength) {\n                return false;\n            }\n\n            return Contract.verifyIncomingTransaction(transaction);\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) {\n        return new HashedTimeLockedContract(balance, this._sender, this._recipient, this._hashRoot, this._hashCount, this._timeout, this._totalAmount);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionsCache\n     * @param {boolean} [revert]\n     * @return {Account|*}\n     */\n    withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert = false) {\n        const buf = new SerialBuffer(transaction.proof);\n        const type = buf.readUint8();\n        let minCap = 0;\n        switch (type) {\n            case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER: {\n                // Check that the contract has not expired yet.\n                if (this._timeout < blockHeight) {\n                    throw new Error('Proof Error!');\n                }\n\n                // Check that the provided hashRoot is correct.\n                const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n                const hashDepth = buf.readUint8();\n                const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n                if (!hashRoot.equals(this._hashRoot)) {\n                    throw new Error('Proof Error!');\n                }\n\n                // Ignore the preImage.\n                Hash.unserialize(buf, hashAlgorithm);\n\n                // Verify that the transaction is signed by the authorized recipient.\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._recipient)) {\n                    throw new Error('Proof Error!');\n                }\n\n                minCap = Math.max(0, Math.floor((1 - (hashDepth / this._hashCount)) * this._totalAmount));\n\n                break;\n            }\n            case HashedTimeLockedContract.ProofType.EARLY_RESOLVE: {\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._recipient)) {\n                    throw new Error('Proof Error!');\n                }\n\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._sender)) {\n                    throw new Error('Proof Error!');\n                }\n\n                break;\n            }\n            case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE: {\n                if (this._timeout >= blockHeight) {\n                    throw new Error('Proof Error!');\n                }\n\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._sender)) {\n                    throw new Error('Proof Error!');\n                }\n\n                break;\n            }\n            default:\n                throw new Error('Proof Error!');\n        }\n\n        if (!revert) {\n            const newBalance = this._balance - transaction.value - transaction.fee;\n            if (newBalance < minCap) {\n                throw new Error('Balance Error!');\n            }\n        }\n\n        return super.withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert);\n    }\n\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        throw new Error('Illegal incoming transaction');\n    }\n}\n\nHashedTimeLockedContract.ProofType = {\n    REGULAR_TRANSFER: 1,\n    EARLY_RESOLVE: 2,\n    TIMEOUT_RESOLVE: 3\n};\n\nAccount.TYPE_MAP.set(Account.Type.HTLC, HashedTimeLockedContract);\nClass.register(HashedTimeLockedContract);\n","class VestingContract extends Contract {\n    /**\n     * @param {number} [balance]\n     * @param {Address} [owner]\n     * @param {number} [vestingStart]\n     * @param {number} [vestingStepBlocks]\n     * @param {number} [vestingStepAmount]\n     * @param {number} [vestingTotalAmount]\n     */\n    constructor(balance = 0, owner = Address.NULL, vestingStart = 0, vestingStepBlocks = 0, vestingStepAmount = balance, vestingTotalAmount = balance) {\n        super(Account.Type.VESTING, balance);\n        if (!(owner instanceof Address)) throw new Error('Malformed address');\n        if (!NumberUtils.isUint32(vestingStart)) throw new Error('Malformed vestingStart');\n        if (!NumberUtils.isUint32(vestingStepBlocks)) throw new Error('Malformed vestingStepBlocks');\n        if (!NumberUtils.isUint64(vestingStepAmount)) throw new Error('Malformed vestingStepAmount');\n        if (!NumberUtils.isUint64(vestingTotalAmount)) throw new Error('Malformed lowerCap');\n\n        /** @type {Address} */\n        this._owner = owner;\n        /** @type {number} */\n        this._vestingStart = vestingStart;\n        /** @type {number} */\n        this._vestingStepBlocks = vestingStepBlocks;\n        /** @type {number} */\n        this._vestingStepAmount = vestingStepAmount;\n        /** @type {number} */\n        this._vestingTotalAmount = vestingTotalAmount;\n    }\n\n    /**\n     * @param {number} balance\n     * @param {number} blockHeight\n     * @param {Transaction} transaction\n     */\n    static create(balance, blockHeight, transaction) {\n        /** @type {number} */\n        let vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount;\n        const buf = new SerialBuffer(transaction.data);\n        const owner = Address.unserialize(buf);\n        vestingTotalAmount = transaction.value;\n        switch (transaction.data.length) {\n            case Address.SERIALIZED_SIZE + 4:\n                // Only block number: vest full amount at that block\n                vestingStart = 0;\n                vestingStepBlocks = buf.readUint32();\n                vestingStepAmount = vestingTotalAmount;\n                break;\n            case Address.SERIALIZED_SIZE + 16:\n                vestingStart = buf.readUint32();\n                vestingStepBlocks = buf.readUint32();\n                vestingStepAmount = buf.readUint64();\n                break;\n            case Address.SERIALIZED_SIZE + 24:\n                // Create a vesting account with some instantly vested funds or additional funds considered.\n                vestingStart = buf.readUint32();\n                vestingStepBlocks = buf.readUint32();\n                vestingStepAmount = buf.readUint64();\n                vestingTotalAmount = buf.readUint64();\n                break;\n            default:\n                throw new Error('Invalid transaction data');\n        }\n        return new VestingContract(balance, owner, vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {VestingContract}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        if (type !== Account.Type.VESTING) throw new Error('Invalid account type');\n\n        const balance = buf.readUint64();\n        const owner = Address.unserialize(buf);\n        const vestingStart = buf.readUint32();\n        const vestingStepBlocks = buf.readUint32();\n        const vestingStepAmount = buf.readUint64();\n        const vestingTotalAmount = buf.readUint64();\n        return new VestingContract(balance, owner, vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount);\n    }\n\n    /**\n     * Serialize this VestingContract object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._owner.serialize(buf);\n        buf.writeUint32(this._vestingStart);\n        buf.writeUint32(this._vestingStepBlocks);\n        buf.writeUint64(this._vestingStepAmount);\n        buf.writeUint64(this._vestingTotalAmount);\n        return buf;\n    }\n\n    /**\n     * @return {number}\n     */\n    get serializedSize() {\n        return super.serializedSize\n            + this._owner.serializedSize\n            + /*vestingStart*/ 4\n            + /*vestingStepBlocks*/ 4\n            + /*vestingStepAmount*/ 8\n            + /*vestingTotalAmount*/ 8;\n    }\n\n    /** @type {Address} */\n    get owner() {\n        return this._owner;\n    }\n\n    /** @type {number} */\n    get vestingStart() {\n        return this._vestingStart;\n    }\n\n    /** @type {number} */\n    get vestingStepBlocks() {\n        return this._vestingStepBlocks;\n    }\n\n    /** @type {number} */\n    get vestingStepAmount() {\n        return this._vestingStepAmount;\n    }\n\n    /** @type {number} */\n    get vestingTotalAmount() {\n        return this._vestingTotalAmount;\n    }\n\n    toString() {\n        return `VestingAccount{balance=${this._balance}, owner=${this._owner.toUserFriendlyAddress()}`;\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return o instanceof VestingContract\n            && this._type === o._type\n            && this._balance === o._balance\n            && this._owner.equals(o._owner)\n            && this._vestingStart === o._vestingStart\n            && this._vestingStepBlocks === o._vestingStepBlocks\n            && this._vestingStepAmount === o._vestingStepAmount\n            && this._vestingTotalAmount === o._vestingTotalAmount;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyOutgoingTransaction(transaction) {\n        const buf = new SerialBuffer(transaction.proof);\n\n        if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n            return false;\n        }\n\n        if (buf.readPos !== buf.byteLength) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        switch (transaction.data.length) {\n            case Address.SERIALIZED_SIZE + 4:\n            case Address.SERIALIZED_SIZE + 16:\n            case Address.SERIALIZED_SIZE + 24:\n                return Contract.verifyIncomingTransaction(transaction);\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) {\n        return new VestingContract(balance, this._owner, this._vestingStart, this._vestingStepBlocks, this._vestingStepAmount, this._vestingTotalAmount);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionsCache\n     * @param {boolean} [revert]\n     * @return {Account|*}\n     */\n    withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert = false) {\n        if (!revert) {\n            const minCap = this.getMinCap(blockHeight);\n            const newBalance = this._balance - transaction.value - transaction.fee;\n            if (newBalance < minCap) {\n                throw new Error('Balance Error!');\n            }\n\n            const buf = new SerialBuffer(transaction.proof);\n            if (!SignatureProof.unserialize(buf).isSignedBy(this._owner)) {\n                throw new Error('Proof Error!');\n            }\n        }\n        return super.withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        throw new Error('Illegal incoming transaction');\n    }\n\n    /**\n     * @param {number} blockHeight\n     * @returns {number}\n     */\n    getMinCap(blockHeight) {\n        return this._vestingStepBlocks && this._vestingStepAmount > 0\n            ? Math.max(0, this._vestingTotalAmount - Math.floor((blockHeight - this._vestingStart) / this._vestingStepBlocks) * this._vestingStepAmount)\n            : 0;\n    }\n}\n\nAccount.TYPE_MAP.set(Account.Type.VESTING, VestingContract);\nClass.register(VestingContract);\n","class AccountsTreeNode {\n    /**\n     * @param {string} prefix\n     * @param {Account} account\n     * @returns {AccountsTreeNode}\n     */\n    static terminalNode(prefix, account) {\n        return new AccountsTreeNode(AccountsTreeNode.TERMINAL, prefix, account);\n    }\n\n    /**\n     * @param {string} prefix\n     * @param {Array.<string>} childrenSuffixes\n     * @param {Array.<Hash>} childrenHashes\n     * @returns {AccountsTreeNode}\n     */\n    static branchNode(prefix, childrenSuffixes = [], childrenHashes = []) {\n        if (childrenSuffixes.length !== childrenHashes.length) {\n            throw new Error('Invalid list of children for branch node');\n        }\n        return new AccountsTreeNode(AccountsTreeNode.BRANCH, prefix, childrenSuffixes, childrenHashes);\n    }\n\n    /**\n     * @param type\n     * @param {string} prefix\n     * @param {Account|Array.<string>} arg\n     * @param {Array.<Hash>} [arg2]\n     */\n    constructor(type, prefix = '', arg, arg2 = []) {\n        this._type = type;\n        /** @type {string} */\n        this._prefix = prefix;\n        if (this.isBranch()) {\n            /** @type {Array.<string>} */\n            this._childrenSuffixes = arg;\n            /** @type {Array.<Hash>} */\n            this._childrenHashes = arg2;\n        } else if (this.isTerminal()) {\n            /** @type {Account} */\n            this._account = arg;\n        } else {\n            throw `Invalid AccountsTreeNode type: ${type}`;\n        }\n    }\n\n    /**\n     * @param type\n     * @returns {boolean}\n     */\n    static isTerminalType(type) {\n        return type === AccountsTreeNode.TERMINAL;\n    }\n\n    /**\n     * @param type\n     * @returns {boolean}\n     */\n    static isBranchType(type) {\n        return type === AccountsTreeNode.BRANCH;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {AccountsTreeNode}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        const prefix = buf.readVarLengthString();\n\n        if (AccountsTreeNode.isTerminalType(type)) {\n            // Terminal node\n            const account = Account.unserialize(buf);\n            return AccountsTreeNode.terminalNode(prefix, account);\n        } else if (AccountsTreeNode.isBranchType(type)) {\n            // Branch node\n            const childrenSuffixes = [], childrenHashes = [];\n            const childCount = buf.readUint8();\n            for (let i = 0; i < childCount; ++i) {\n                const childSuffix = buf.readVarLengthString();\n                const childHash = Hash.unserialize(buf);\n                const childIndex = parseInt(childSuffix[0], 16);\n                childrenSuffixes[childIndex] = childSuffix;\n                childrenHashes[childIndex] = childHash;\n            }\n            return AccountsTreeNode.branchNode(prefix, childrenSuffixes, childrenHashes);\n        } else {\n            throw `Invalid AccountsTreeNode type: ${type}`;\n        }\n    }\n\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._type);\n        buf.writeVarLengthString(this._prefix);\n        if (this.isTerminal()) {\n            // Terminal node\n            this._account.serialize(buf);\n        } else {\n            // Branch node\n            const childCount = this._childrenSuffixes.reduce((count, child) => count + !!child, 0);\n            buf.writeUint8(childCount);\n            for (let i = 0; i < this._childrenSuffixes.length; ++i) {\n                if (this._childrenHashes[i]) {\n                    buf.writeVarLengthString(this._childrenSuffixes[i]);\n                    this._childrenHashes[i].serialize(buf);\n                }\n            }\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let payloadSize;\n        if (this.isTerminal()) {\n            payloadSize = this._account.serializedSize;\n        } else {\n            // The children array contains undefined values for non existing children.\n            // Only count existing ones.\n            const childrenSize = this._childrenHashes.reduce((sum, child, i) => {\n                return sum + (child ? child.serializedSize + SerialBuffer.varLengthStringSize(this._childrenSuffixes[i]) : 0);\n            }, 0);\n            payloadSize = /*childCount*/ 1 + childrenSize;\n        }\n\n        return /*type*/ 1\n            + SerialBuffer.varLengthStringSize(this._prefix)\n            + payloadSize;\n    }\n\n    /**\n     * @param {string} prefix\n     * @returns {?Hash}\n     */\n    getChildHash(prefix) {\n        return this._childrenHashes && this._childrenHashes[this._getChildIndex(prefix)];\n    }\n\n    /**\n     * @param {string} prefix\n     * @returns {?string}\n     */\n    getChild(prefix) {\n        const suffix = this._childrenSuffixes && this._childrenSuffixes[this._getChildIndex(prefix)];\n        if (suffix) {\n            return this.prefix + suffix;\n        }\n        return suffix;\n    }\n\n    /**\n     * @param {string} prefix\n     * @param {Hash} childHash\n     * @returns {AccountsTreeNode}\n     */\n    withChild(prefix, childHash) {\n        const childrenSuffixes = this._childrenSuffixes.slice() || [];\n        const childrenHashes = this._childrenHashes.slice() || [];\n        childrenSuffixes[this._getChildIndex(prefix)] = prefix.substr(this.prefix.length);\n        childrenHashes[this._getChildIndex(prefix)] = childHash;\n        return AccountsTreeNode.branchNode(this._prefix, childrenSuffixes, childrenHashes);\n    }\n\n    /**\n     * @param {string} prefix\n     * @returns {AccountsTreeNode}\n     */\n    withoutChild(prefix) {\n        const childrenSuffixes = this._childrenSuffixes.slice() || [];\n        const childrenHashes = this._childrenHashes.slice() || [];\n        delete childrenSuffixes[this._getChildIndex(prefix)];\n        delete childrenHashes[this._getChildIndex(prefix)];\n        return AccountsTreeNode.branchNode(this._prefix, childrenSuffixes, childrenHashes);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    hasChildren() {\n        return this._childrenSuffixes && this._childrenSuffixes.some(child => !!child);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    hasSingleChild() {\n        return this._childrenSuffixes && this._childrenSuffixes.reduce((count, child) => count + !!child, 0) === 1;\n    }\n\n    /**\n     * @returns {?string}\n     */\n    getFirstChild() {\n        if (!this._childrenSuffixes) {\n            return undefined;\n        }\n        const suffix = this._childrenSuffixes.find(child => !!child);\n        return suffix ? this.prefix + suffix : undefined;\n    }\n\n    /**\n     * @returns {?string}\n     */\n    getLastChild() {\n        if (!this._childrenSuffixes) {\n            return undefined;\n        }\n        for (let i = this._childrenSuffixes.length - 1; i >= 0; --i) {\n            if (this._childrenSuffixes[i]) {\n                return this.prefix + this._childrenSuffixes[i];\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * @returns {?Array.<string>}\n     */\n    getChildren() {\n        if (!this._childrenSuffixes) {\n            return undefined;\n        }\n        return this._childrenSuffixes.filter(child => !!child).map(child => this.prefix + child);\n    }\n\n    /** @type {Account} */\n    get account() {\n        return this._account;\n    }\n\n    /** @type {string} */\n    get prefix() {\n        return this._prefix;\n    }\n\n    /** @type {string} */\n    set prefix(value) {\n        this._prefix = value;\n        this._hash = undefined;\n    }\n\n    /**\n     * @param {Account} account\n     * @returns {AccountsTreeNode}\n     */\n    withAccount(account) {\n        return AccountsTreeNode.terminalNode(this._prefix, account);\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    hash() {\n        if (!this._hash) {\n            this._hash = Hash.light(this.serialize());\n        }\n        return this._hash;\n    }\n\n    /**\n     * Tests if this node is a child of some other node.\n     * @param {AccountsTreeNode} parent\n     * @returns {boolean}\n     */\n    isChildOf(parent) {\n        return parent.getChildren() && parent.getChildren().includes(this._prefix);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isTerminal() {\n        return AccountsTreeNode.isTerminalType(this._type);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isBranch() {\n        return AccountsTreeNode.isBranchType(this._type);\n    }\n\n    /**\n     * @param {string} prefix\n     * @returns {number}\n     * @private\n     */\n    _getChildIndex(prefix) {\n        Assert.that(prefix.substr(0, this.prefix.length) === this.prefix, `Prefix ${prefix} is not a child of the current node ${this.prefix}`);\n        return parseInt(prefix[this.prefix.length], 16);\n    }\n\n    /**\n     * @param {AccountsTreeNode} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        if (!(o instanceof AccountsTreeNode)) return false;\n        if (!Object.is(this.prefix, o.prefix)) return false;\n        if (this.isTerminal()) {\n            return o.isTerminal() && o._account.equals(this._account);\n        } else {\n            if (!o.isBranch()) return false;\n            if (this._childrenSuffixes.length !== o._childrenSuffixes.length) return false;\n            if (o._childrenSuffixes.length !== o._childrenHashes.length) return false;\n            for (let i = 0; i < this._childrenSuffixes.length; ++i) {\n                // hashes of child nodes\n                const ourChild = this._childrenHashes[i];\n                const otherChild = o._childrenHashes[i];\n                if (ourChild) {\n                    if (!otherChild || !ourChild.equals(otherChild)) return false;\n                } else {\n                    if (otherChild) return false;\n                }\n                if (this._childrenSuffixes[i] !== o._childrenSuffixes[i]) return false;\n            }\n        }\n        return true;\n    }\n}\nAccountsTreeNode.BRANCH = 0x00;\nAccountsTreeNode.TERMINAL = 0xff;\nClass.register(AccountsTreeNode);\n","class AccountsTreeStore {\n    /**\n     * @param {JungleDB} jdb\n     */\n    static initPersistent(jdb) {\n        jdb.createObjectStore('Accounts', { codec: new AccountsTreeStoreCodec() });\n    }\n\n    /**\n     * @param {JungleDB} jdb\n     * @returns {AccountsTreeStore}\n     */\n    static getPersistent(jdb) {\n        return new AccountsTreeStore(jdb.getObjectStore('Accounts'));\n    }\n\n    /**\n     * @returns {AccountsTreeStore}\n     */\n    static createVolatile() {\n        const store = JDB.JungleDB.createVolatileObjectStore();\n        return new AccountsTreeStore(store);\n    }\n\n    /**\n     * @param {IObjectStore} store\n     */\n    constructor(store) {\n        this._store = store;\n    }\n\n    /**\n     * @override\n     * @param {string} key\n     * @returns {Promise.<AccountsTreeNode>}\n     */\n    get(key) {\n        return this._store.get(key);\n    }\n\n    /**\n     * @override\n     * @param {AccountsTreeNode} node\n     * @returns {Promise.<string>}\n     */\n    async put(node) {\n        const key = node.prefix;\n        await this._store.put(key, node);\n        return key;\n    }\n\n    /**\n     * @override\n     * @param {AccountsTreeNode} node\n     * @returns {Promise.<string>}\n     */\n    async remove(node) {\n        const key = node.prefix;\n        await this._store.remove(key);\n        return key;\n    }\n\n    /**\n     * @returns {Promise.<AccountsTreeNode>}\n     */\n    getRootNode() {\n        return this.get('');\n    }\n\n    /**\n     * @param startPrefix This prefix will *not* be included.\n     * @param size\n     * @returns {Promise.<Array.<AccountsTreeNode>>}\n     */\n    async getTerminalNodes(startPrefix, size) {\n        const relevantKeys = [];\n        await this._store.keyStream(key => {\n            if (key.length === Address.HEX_SIZE) {\n                relevantKeys.push(key);\n                if (relevantKeys.length === size) {\n                    return false;\n                }\n            }\n            return true;\n        }, true, JDB.KeyRange.lowerBound(startPrefix, true));\n        const nodes = [];\n        for (const key of relevantKeys) {\n            nodes.push(this._store.get(key));\n        }\n        return Promise.all(nodes);\n    }\n\n    /**\n     * @param {AccountsTreeStore} [tx]\n     * @returns {AccountsTreeStore}\n     */\n    snapshot(tx) {\n        const snapshot = this._store.snapshot();\n        if (tx) {\n            snapshot.inherit(tx._store);\n        }\n        return new AccountsTreeStore(snapshot);\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {AccountsTreeStore}\n     */\n    transaction(enableWatchdog = true) {\n        const tx = this._store.transaction(enableWatchdog);\n        return new AccountsTreeStore(tx);\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {SynchronousAccountsTreeStore}\n     */\n    synchronousTransaction(enableWatchdog = true) {\n        const tx = this._store.synchronousTransaction(enableWatchdog);\n        return new SynchronousAccountsTreeStore(tx);\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    truncate() {\n        return this._store.truncate();\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    commit() {\n        return this._store.commit();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    abort() {\n        return this._store.abort();\n    }\n\n    /** @type {Transaction} */\n    get tx() {\n        if (this._store instanceof JDB.Transaction) {\n            return this._store;\n        }\n        return undefined;\n    }\n}\nClass.register(AccountsTreeStore);\n\n/**\n * @implements {ICodec}\n */\nclass AccountsTreeStoreCodec {\n    /**\n     * @param {*} obj The object to encode before storing it.\n     * @returns {*} Encoded object.\n     */\n    encode(obj) {\n        return obj.serialize();\n    }\n\n    /**\n     * @param {*} obj The object to decode.\n     * @param {string} key The object's primary key.\n     * @returns {*} Decoded object.\n     */\n    decode(obj, key) {\n        return AccountsTreeNode.unserialize(new SerialBuffer(obj));\n    }\n\n    /**\n     * @type {{encode: function(val:*):*, decode: function(val:*):*, buffer: boolean, type: string}|void}\n     */\n    get valueEncoding() {\n        return JDB.JungleDB.BINARY_ENCODING;\n    }\n}\n","class SynchronousAccountsTreeStore extends AccountsTreeStore {\n    /**\n     * @param {SynchronousTransaction} store\n     */\n    constructor(store) {\n        super(store);\n        this._syncStore = store;\n    }\n\n    /**\n     * @param {Array.<string>} keys\n     */\n    async preload(keys) {\n        await this._syncStore.preload(keys);\n    }\n\n    /**\n     * @param {string} key\n     * @param {boolean} [expectedToBePresent]\n     * @returns {AccountsTreeNode}\n     */\n    getSync(key, expectedToBePresent = true) {\n        return this._syncStore.getSync(key, expectedToBePresent);\n    }\n\n    /**\n     * @param {AccountsTreeNode} node\n     * @returns {string}\n     */\n    putSync(node) {\n        const key = node.prefix;\n        this._syncStore.putSync(key, node);\n        return key;\n    }\n\n    /**\n     * @param {AccountsTreeNode} node\n     * @returns {string}\n     */\n    removeSync(node) {\n        const key = node.prefix;\n        this._syncStore.removeSync(key);\n        return key;\n    }\n\n    /**\n     * @returns {AccountsTreeNode}\n     */\n    getRootNodeSync() {\n        return this.getSync('');\n    }\n}\nClass.register(SynchronousAccountsTreeStore);\n","class AccountsProof {\n    /**\n     * @param {Array.<AccountsTreeNode>} nodes\n     */\n    constructor(nodes) {\n        if (!nodes || !Array.isArray(nodes) || !NumberUtils.isUint16(nodes.length)\n            || nodes.some(it => !(it instanceof AccountsTreeNode))) throw 'Malformed nodes';\n\n        /** @type {Array.<AccountsTreeNode>} */\n        this._nodes = nodes;\n        /** @type {HashMap.<Hash,AccountsTreeNode>} */\n        this._index = null;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {AccountsProof}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint16();\n        const nodes = [];\n        for (let i = 0; i < count; i++) {\n            nodes.push(AccountsTreeNode.unserialize(buf));\n        }\n        return new AccountsProof(nodes);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._nodes.length);\n        for (const node of this._nodes) {\n            node.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let size = /*count*/ 2;\n        for (const node of this._nodes) {\n            size += node.serializedSize;\n        }\n        return size;\n    }\n\n    /**\n     * Assumes nodes to be in post order and hashes nodes to check internal consistency of proof.\n     * XXX Abuse this method to index the nodes contained in the proof. This forces callers to explicitly verify()\n     * the proof before retrieving accounts.\n     * @returns {boolean}\n     */\n    verify() {\n        /** @type {Array.<AccountsTreeNode>} */\n        const children = [];\n        this._index = new HashMap();\n        for (const node of this._nodes) {\n            // If node is a branch node, validate its children.\n            if (node.isBranch()) {\n                let child;\n                while (child = children.pop()) { // eslint-disable-line no-cond-assign\n                    if (child.isChildOf(node)) {\n                        const hash = child.hash();\n                        // If the child is not valid, return false.\n                        if (!node.getChildHash(child.prefix).equals(hash) || node.getChild(child.prefix) !== child.prefix) {\n                            return false;\n                        }\n                        this._index.put(hash, child);\n                    } else {\n                        children.push(child);\n                        break;\n                    }\n                }\n            }\n\n            // Append child.\n            children.push(node);\n        }\n\n        // The last element must be the root node.\n        return children.length === 1 && children[0].prefix === '' && children[0].isBranch();\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {?Account}\n     */\n    getAccount(address) {\n        if (!this._index) {\n            throw new Error('AccountsProof must be verified before retrieving accounts. Call verify() first.');\n        }\n\n        const rootNode = this._nodes[this._nodes.length - 1];\n        const prefix = address.toHex();\n        return this._getAccount(rootNode, prefix);\n    }\n\n    /**\n     * @param {AccountsTreeNode} node\n     * @param {string} prefix\n     * @returns {?Account}\n     * @private\n     */\n    _getAccount(node, prefix) {\n        // Find common prefix between node and requested address.\n        const commonPrefix = StringUtils.commonPrefix(node.prefix, prefix);\n\n        // If the prefix does not fully match, the requested account does not exist.\n        if (commonPrefix.length !== node.prefix.length) return null;\n\n        // If the remaining address is empty, we have found the requested node.\n        if (commonPrefix === prefix) return node.account;\n\n        // Descend into the matching child node if one exists.\n        const childKey = node.getChildHash(prefix);\n        if (childKey) {\n            const childNode = this._index.get(childKey);\n\n            // If the child exists but is not part of the proof, fail.\n            if (!childNode) {\n                throw new Error('Requested address not part of AccountsProof');\n            }\n\n            return this._getAccount(childNode, prefix);\n        }\n\n        // No matching child exists, the requested account does not exist.\n        return null;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `AccountsProof{length=${this.length}}`;\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    root() {\n        return this._nodes[this._nodes.length - 1].hash();\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._nodes.length;\n    }\n\n    /** @type {Array.<AccountsTreeNode>} */\n    get nodes() {\n        return this._nodes;\n    }\n}\nClass.register(AccountsProof);\n","class AccountsTreeChunk {\n    /**\n     * @param {Array.<AccountsTreeNode>} nodes\n     * @param {AccountsProof} proof\n     */\n    constructor(nodes, proof) {\n        if (!nodes || !NumberUtils.isUint16(nodes.length)\n            || nodes.some(it => !(it instanceof AccountsTreeNode) || !it.isTerminal())) throw 'Malformed nodes';\n\n        /** @type {Array.<AccountsTreeNode>} */\n        this._nodes = nodes;\n        this._proof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {AccountsTreeChunk}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint16();\n        const nodes = [];\n        for (let i = 0; i < count; i++) {\n            nodes.push(AccountsTreeNode.unserialize(buf));\n        }\n        const proof = AccountsProof.unserialize(buf);\n        return new AccountsTreeChunk(nodes, proof);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._nodes.length);\n        for (const node of this._nodes) {\n            node.serialize(buf);\n        }\n        this._proof.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let size = /*count*/ 2;\n        for (const node of this._nodes) {\n            size += node.serializedSize;\n        }\n        size += this._proof.serializedSize;\n        return size;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    verify() {\n        if (!this._proof.verify()) {\n            return false;\n        }\n\n        let lastPrefix = null;\n        for (let i = 0; i <= this._nodes.length; ++i) {\n            const node = i < this._nodes.length ? this._nodes[i] : this.tail;\n            if (lastPrefix && lastPrefix >= node.prefix) {\n                return false;\n            }\n            lastPrefix = node.prefix;\n        }\n        return true;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `AccountsTreeChunk{length=${this.length}}`;\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    root() {\n        return this._proof.root();\n    }\n\n    /** @type {Array.<AccountsTreeNode>} */\n    get terminalNodes() {\n        return this._nodes.concat([this.tail]);\n    }\n\n    /** @type {AccountsProof} */\n    get proof() {\n        return this._proof;\n    }\n\n    /** @type {AccountsTreeNode} */\n    get head() {\n        return this._nodes[0];\n    }\n\n    /** @type {AccountsTreeNode} */\n    get tail() {\n        return this._proof.nodes[0];\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._nodes.length + 1;\n    }\n}\nAccountsTreeChunk.SIZE_MAX = 1000;\nAccountsTreeChunk.EMPTY = new AccountsTreeChunk([], new AccountsProof([]));\nClass.register(AccountsTreeChunk);\n","class AccountsTree extends Observable {\n    /**\n     * @returns {Promise.<AccountsTree>}\n     */\n    static async getPersistent(jdb) {\n        const store = AccountsTreeStore.getPersistent(jdb);\n        const tree = new AccountsTree(store);\n        return tree._init();\n    }\n\n    /**\n     * @returns {Promise.<AccountsTree>}\n     */\n    static async createVolatile() {\n        const store = AccountsTreeStore.createVolatile();\n        const tree = new AccountsTree(store);\n        return tree._init();\n    }\n\n    /**\n     * @private\n     * @param {AccountsTreeStore} store\n     * @returns {AccountsTree}\n     */\n    constructor(store) {\n        super();\n        /** @type {AccountsTreeStore} */\n        this._store = store;\n        this._synchronizer = new Synchronizer();\n    }\n\n    /**\n     * @returns {Promise.<AccountsTree>}\n     * @protected\n     */\n    async _init() {\n        let rootNode = await this._store.getRootNode();\n        if (!rootNode) {\n            rootNode = AccountsTreeNode.branchNode(/*prefix*/ '', /*childrenSuffixes*/ [], /*childrenHashes*/ []);\n            await this._store.put(rootNode);\n        }\n        return this;\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Account} account\n     * @returns {Promise}\n     */\n    put(address, account) {\n        return this._synchronizer.push(() => {\n            return this._put(address, account);\n        });\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Account} account\n     * @returns {Promise}\n     * @private\n     */\n    async _put(address, account) {\n        if (account.isInitial() && !(await this.get(address))) {\n            return;\n        }\n\n        // Fetch the root node.\n        const rootNode = await this._store.getRootNode();\n        Assert.that(!!rootNode, 'Corrupted store: Failed to fetch AccountsTree root node');\n\n        // Insert account into the tree at address.\n        const prefix = address.toHex();\n        await this._insert(rootNode, prefix, account, []);\n    }\n\n    /**\n     * @param {AccountsTreeNode} node\n     * @param {string} prefix\n     * @param {Account} account\n     * @param {Array.<AccountsTreeNode>} rootPath\n     * @returns {Promise}\n     * @private\n     */\n    async _insert(node, prefix, account, rootPath) {\n        // Find common prefix between node and new address.\n        const commonPrefix = StringUtils.commonPrefix(node.prefix, prefix);\n\n        // If the node prefix does not fully match the new address, split the node.\n        if (commonPrefix.length !== node.prefix.length) {\n            // Insert the new account node.\n            const newChild = AccountsTreeNode.terminalNode(prefix, account);\n            const newChildHash = newChild.hash();\n            await this._store.put(newChild);\n\n            // Insert the new parent node.\n            const newParent = AccountsTreeNode.branchNode(commonPrefix)\n                .withChild(node.prefix, node.hash())\n                .withChild(newChild.prefix, newChildHash);\n            const newParentHash = newParent.hash();\n            await this._store.put(newParent);\n\n            return this._updateKeys(newParent.prefix, newParentHash, rootPath);\n        }\n\n        // If the commonPrefix is the specified address, we have found an (existing) node\n        // with the given address. Update the account.\n        if (commonPrefix === prefix) {\n            // XXX How does this generalize to more than one account type?\n            // Special case: If the new balance is the initial balance\n            // (i.e. balance=0, nonce=0), it is like the account never existed\n            // in the first place. Delete the node in this case.\n            if (account.isInitial()) {\n                await this._store.remove(node);\n                // We have already deleted the node, remove the subtree it was on.\n                return this._prune(node.prefix, rootPath);\n            }\n\n            // Update the account.\n            node = node.withAccount(account);\n            const nodeHash = node.hash();\n            await this._store.put(node);\n\n            return this._updateKeys(node.prefix, nodeHash, rootPath);\n        }\n\n        // If the node prefix matches and there are address bytes left, descend into\n        // the matching child node if one exists.\n        const childPrefix = node.getChild(prefix);\n        if (childPrefix) {\n            const childNode = await this._store.get(childPrefix);\n            rootPath.push(node);\n            return this._insert(childNode, prefix, account, rootPath);\n        }\n\n        // If no matching child exists, add a new child account node to the current node.\n        const newChild = AccountsTreeNode.terminalNode(prefix, account);\n        const newChildHash = newChild.hash();\n        await this._store.put(newChild);\n\n        node = node.withChild(newChild.prefix, newChildHash);\n        const nodeHash = node.hash();\n        await this._store.put(node);\n\n        return this._updateKeys(node.prefix, nodeHash, rootPath);\n    }\n\n    /**\n     * @param {string} prefix\n     * @param {Array.<AccountsTreeNode>} rootPath\n     * @returns {Promise}\n     * @private\n     */\n    async _prune(prefix, rootPath) {\n        // Walk along the rootPath towards the root node starting with the\n        // immediate predecessor of the node specified by 'prefix'.\n        let i = rootPath.length - 1;\n        for (; i >= 0; --i) {\n            let node = rootPath[i];\n\n            node = node.withoutChild(prefix);\n\n            // If the node has only a single child, merge it with the next node.\n            if (node.hasSingleChild() && node.prefix !== '') {\n                await this._store.remove(node); // eslint-disable-line no-await-in-loop\n\n                const childPrefix = node.getFirstChild();\n                const childNode = await this._store.get(childPrefix); // eslint-disable-line no-await-in-loop\n\n                await this._store.put(childNode); // eslint-disable-line no-await-in-loop\n                const childHash = childNode.hash();\n                return this._updateKeys(childNode.prefix, childHash, rootPath.slice(0, i));\n            }\n            // Otherwise, if the node has children left, update it and all keys on the\n            // remaining root path. Pruning finished.\n            // XXX Special case: We start with an empty root node. Don't delete it.\n            else if (node.hasChildren() || node.prefix === '') {\n                const nodeHash = node.hash();\n                await this._store.put(node); // eslint-disable-line no-await-in-loop\n                return this._updateKeys(node.prefix, nodeHash, rootPath.slice(0, i));\n            }\n\n            // The node has no children left, continue pruning.\n            prefix = node.prefix;\n        }\n\n        // XXX This should never be reached.\n        return undefined;\n    }\n\n    /**\n     * @param {string} prefix\n     * @param {Hash} nodeHash\n     * @param {Array.<AccountsTreeNode>} rootPath\n     * @returns {Promise}\n     * @private\n     */\n    async _updateKeys(prefix, nodeHash, rootPath) {\n        // Walk along the rootPath towards the root node starting with the\n        // immediate predecessor of the node specified by 'prefix'.\n        let i = rootPath.length - 1;\n        for (; i >= 0; --i) {\n            let node = rootPath[i];\n\n            node = node.withChild(prefix, nodeHash);\n            await this._store.put(node); // eslint-disable-line no-await-in-loop\n            nodeHash = node.hash();\n            prefix = node.prefix;\n        }\n\n        return nodeHash;\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise.<?Account>}\n     */\n    async get(address) {\n        const node = await this._store.get(address.toHex());\n        return node !== undefined ? node.account : null;\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<AccountsProof>}\n     */\n    async getAccountsProof(addresses) {\n        const rootNode = await this._store.getRootNode();\n        Assert.that(!!rootNode, 'Corrupted store: Failed to fetch AccountsTree root node');\n\n        const prefixes = [];\n        for (const address of addresses) {\n            prefixes.push(address.toHex());\n        }\n        // We sort the addresses to simplify traversal in post order (leftmost addresses first).\n        prefixes.sort();\n\n        const nodes = [];\n        await this._getAccountsProof(rootNode, prefixes, nodes);\n        return new AccountsProof(nodes);\n    }\n\n    /**\n     * Constructs the accounts proof in post-order.\n     * @param {AccountsTreeNode} node\n     * @param {Array.<string>} prefixes\n     * @param {Array.<AccountsTreeNode>} nodes\n     * @returns {Promise.<*>}\n     * @private\n     */\n    async _getAccountsProof(node, prefixes, nodes) {\n        // For each prefix, descend the tree individually.\n        let includeNode = false;\n        for (let i = 0; i < prefixes.length; ) {\n            let prefix = prefixes[i];\n\n            // Find common prefix between node and the current requested prefix.\n            const commonPrefix = StringUtils.commonPrefix(node.prefix, prefix);\n\n            // If the prefix fully matches, we have found the requested node.\n            // If the prefix does not fully match, the requested address is not part of this node.\n            // Include the node in the proof nevertheless to prove that the account doesn't exist.\n            if (commonPrefix.length !== node.prefix.length || node.prefix === prefix) {\n                includeNode = true;\n                i++;\n                continue;\n            }\n\n            // Descend into the matching child node if one exists.\n            const childKey = node.getChild(prefix);\n            if (childKey) {\n                const childNode = await this._store.get(childKey); // eslint-disable-line no-await-in-loop\n\n                // Group addresses with same prefix:\n                // Because of our ordering, they have to be located next to the current prefix.\n                // Hence, we iterate over the next prefixes, until we don't find commonalities anymore.\n                // In the next main iteration we can skip those we already requested here.\n                const subPrefixes = [prefix];\n                // Find other prefixes to descend into this tree as well.\n                let j = i + 1;\n                for (; j < prefixes.length; ++j) {\n                    // Since we ordered prefixes, there can't be any other prefixes with commonalities.\n                    if (!prefixes[j].startsWith(childNode.prefix)) break;\n                    // But if there is a commonality, add it to the list.\n                    subPrefixes.push(prefixes[j]);\n                }\n                // Now j is the last index which doesn't have commonalities,\n                // we continue from there in the next iteration.\n                i = j;\n\n                includeNode = (await this._getAccountsProof(childNode, subPrefixes, nodes)) || includeNode; // eslint-disable-line no-await-in-loop\n            }\n            // No child node exists with the requested prefix. Include the current node to prove the absence of the requested account.\n            else {\n                includeNode = true;\n                i++;\n            }\n        }\n\n        // If this branch contained at least one account, we add this node.\n        if (includeNode) {\n            nodes.push(node);\n        }\n\n        return includeNode;\n    }\n\n    /**\n     * @param {string} startPrefix The prefix to start with.\n     * @param {number} size The maximum number of terminal nodes to include.\n     * @returns {Promise.<AccountsTreeChunk>}\n     */\n    async getChunk(startPrefix, size) {\n        const chunk = await this._store.getTerminalNodes(startPrefix, size);\n        const lastNode = chunk.pop();\n        let /** @type {AccountsProof} */ proof;\n        if (lastNode) {\n            proof = await this.getAccountsProof([Address.fromHex(lastNode.prefix)]);\n        } else {\n            // The proof that the last address does not exist is sufficient to prove that there is no such chunk.\n            proof = await this.getAccountsProof([Address.fromHex('ffffffffffffffffffffffffffffffffffffffff')]);\n        }\n        return new AccountsTreeChunk(chunk, proof);\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {Promise.<AccountsTree>}\n     */\n    transaction(enableWatchdog = true) {\n        const tree = new AccountsTree(this._store.transaction(enableWatchdog));\n        return tree._init();\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {Promise.<SynchronousAccountsTree>}\n     */\n    synchronousTransaction(enableWatchdog = true) {\n        const tx = this._store.synchronousTransaction(enableWatchdog);\n        const tree = new SynchronousAccountsTree(tx);\n        return tree._init();\n    }\n\n    /**\n     * @returns {Promise.<PartialAccountsTree>}\n     */\n    async partialTree() {\n        const tx = this._store.synchronousTransaction(false);\n        await tx.truncate();\n        const tree = new PartialAccountsTree(tx);\n        return tree._init();\n    }\n\n    /**\n     * @param {AccountsTree} [tx]\n     * @returns {Promise.<AccountsTree>}\n     */\n    snapshot(tx) {\n        const tree = new AccountsTree(this._store.snapshot(tx ? tx._store : undefined));\n        return tree._init();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    async commit() {\n        Assert.that(!(await this.root()).equals(new Hash(null)));\n        return this._store.commit();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    abort() {\n        return this._store.abort();\n    }\n\n    /**\n     * @returns {Promise.<Hash>}\n     */\n    async root() {\n        const rootNode = await this._store.getRootNode();\n        return rootNode && rootNode.hash();\n    }\n\n    /** @type {Transaction} */\n    get tx() {\n        return this._store.tx;\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    async isEmpty() {\n        const rootNode = await this._store.getRootNode();\n        return !rootNode.hasChildren();\n    }\n}\nClass.register(AccountsTree);\n\n","class SynchronousAccountsTree extends AccountsTree {\n    /**\n     * @private\n     * @param {SynchronousAccountsTreeStore} store\n     * @returns {SynchronousAccountsTree}\n     */\n    constructor(store) {\n        super(store);\n        /** @type {SynchronousAccountsTreeStore} */\n        this._syncStore = store;\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     * @returns {Promise}\n     */\n    async preloadAddresses(addresses) {\n        const rootNode = await this._syncStore.getRootNode();\n        Assert.that(!!rootNode, 'Corrupted store: Failed to fetch AccountsTree root node');\n\n        const prefixes = [];\n        for (const address of addresses) {\n            prefixes.push(address.toHex());\n        }\n        // We sort the addresses to simplify traversal in post order (leftmost addresses first).\n        prefixes.sort();\n\n        await this._preloadAddresses(rootNode, prefixes);\n    }\n\n    /**\n     * @param {AccountsTreeNode} node\n     * @param {Array.<string>} prefixes\n     * @private\n     */\n    async _preloadAddresses(node, prefixes) {\n        if (node.hasChildren()) {\n            await this._syncStore.preload(node.getChildren());\n        }\n        \n        // For each prefix, descend the tree individually.\n        for (let i = 0; i < prefixes.length; ) {\n            const prefix = prefixes[i];\n\n            // Find common prefix between node and the current requested prefix.\n            const commonPrefix = StringUtils.commonPrefix(node.prefix, prefix);\n\n            // If the prefix fully matches, we have found the requested node.\n            // If the prefix does not fully match, the requested address is not part of this node.\n            // Include the node in the proof nevertheless to prove that the account doesn't exist.\n            if (commonPrefix.length !== node.prefix.length || node.prefix === prefix) {\n                i++;\n                continue;\n            }\n\n            // Descend into the matching child node if one exists.\n            const childKey = node.getChild(prefix);\n            if (childKey) {\n                const childNode = this._syncStore.getSync(childKey);\n\n                // Group addresses with same prefix:\n                // Because of our ordering, they have to be located next to the current prefix.\n                // Hence, we iterate over the next prefixes, until we don't find commonalities anymore.\n                // In the next main iteration we can skip those we already requested here.\n                const subPrefixes = [prefix];\n                // Find other prefixes to descend into this tree as well.\n                let j = i + 1;\n                for (; j < prefixes.length; ++j) {\n                    // Since we ordered prefixes, there can't be any other prefixes with commonalities.\n                    if (!prefixes[j].startsWith(childNode.prefix)) break;\n                    // But if there is a commonality, add it to the list.\n                    subPrefixes.push(prefixes[j]);\n                }\n                // Now j is the last index which doesn't have commonalities,\n                // we continue from there in the next iteration.\n                i = j;\n\n                await this._preloadAddresses(childNode, subPrefixes); // eslint-disable-line no-await-in-loop\n            }\n            // No child node exists with the requested prefix. Include the current node to prove the absence of the requested account.\n            else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Account} account\n     */\n    putSync(address, account) {\n        this.putBatch(address, account);\n        this.finalizeBatch();\n    }\n\n    finalizeBatch() {\n        const rootNode = this._syncStore.getRootNodeSync();\n        this._updateHashes(rootNode);\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Account} account\n     * @private\n     */\n    putBatch(address, account) {\n        if (account.isInitial() && !this.getSync(address, false)) {\n            return;\n        }\n\n        // Fetch the root node.\n        const rootNode = this._syncStore.getRootNodeSync();\n        Assert.that(!!rootNode, 'Corrupted store: Failed to fetch AccountsTree root node');\n\n        // Insert account into the tree at address.\n        const prefix = address.toHex();\n        this._insertBatch(rootNode, prefix, account, []);\n    }\n\n    /**\n     * @param {AccountsTreeNode} node\n     * @param {string} prefix\n     * @param {Account} account\n     * @param {Array.<AccountsTreeNode>} rootPath\n     * @protected\n     */\n    _insertBatch(node, prefix, account, rootPath) {\n        // Find common prefix between node and new address.\n        const commonPrefix = StringUtils.commonPrefix(node.prefix, prefix);\n\n        // If the node prefix does not fully match the new address, split the node.\n        if (commonPrefix.length !== node.prefix.length) {\n            // Insert the new account node.\n            const newChild = AccountsTreeNode.terminalNode(prefix, account);\n            this._syncStore.putSync(newChild);\n\n            // Insert the new parent node.\n            const newParent = AccountsTreeNode.branchNode(commonPrefix)\n                .withChild(node.prefix, new Hash(null))\n                .withChild(newChild.prefix, new Hash(null));\n            this._syncStore.putSync(newParent);\n\n            return this._updateKeysBatch(newParent.prefix, rootPath);\n        }\n\n        // If the commonPrefix is the specified address, we have found an (existing) node\n        // with the given address. Update the account.\n        if (commonPrefix === prefix) {\n            // XXX How does this generalize to more than one account type?\n            // Special case: If the new balance is the initial balance\n            // (i.e. balance=0, nonce=0), it is like the account never existed\n            // in the first place. Delete the node in this case.\n            if (account.isInitial()) {\n                this._syncStore.removeSync(node);\n                // We have already deleted the node, remove the subtree it was on.\n                return this._pruneBatch(node.prefix, rootPath);\n            }\n\n            // Update the account.\n            node = node.withAccount(account);\n            this._syncStore.putSync(node);\n\n            return this._updateKeysBatch(node.prefix, rootPath);\n        }\n\n        // If the node prefix matches and there are address bytes left, descend into\n        // the matching child node if one exists.\n        const childPrefix = node.getChild(prefix);\n        if (childPrefix) {\n            const childNode = this._syncStore.getSync(childPrefix);\n            rootPath.push(node);\n            return this._insertBatch(childNode, prefix, account, rootPath);\n        }\n\n        // If no matching child exists, add a new child account node to the current node.\n        const newChild = AccountsTreeNode.terminalNode(prefix, account);\n        this._syncStore.putSync(newChild);\n\n        node = node.withChild(newChild.prefix, new Hash(null));\n        this._syncStore.putSync(node);\n\n        return this._updateKeysBatch(node.prefix, rootPath);\n    }\n\n    /**\n     * @param {string} prefix\n     * @param {Array.<AccountsTreeNode>} rootPath\n     * @private\n     */\n    _pruneBatch(prefix, rootPath) {\n        // Walk along the rootPath towards the root node starting with the\n        // immediate predecessor of the node specified by 'prefix'.\n        let i = rootPath.length - 1;\n        for (; i >= 0; --i) {\n            let node = rootPath[i];\n\n            node = node.withoutChild(prefix);\n\n            // If the node has only a single child, merge it with the next node.\n            if (node.hasSingleChild() && node.prefix !== '') {\n                this._syncStore.removeSync(node);\n\n                const childPrefix = node.getFirstChild();\n                const childNode = this._syncStore.getSync(childPrefix);\n\n                this._syncStore.putSync(childNode);\n                return this._updateKeysBatch(childNode.prefix, rootPath.slice(0, i));\n            }\n            // Otherwise, if the node has children left, update it and all keys on the\n            // remaining root path. Pruning finished.\n            // XXX Special case: We start with an empty root node. Don't delete it.\n            else if (node.hasChildren() || node.prefix === '') {\n                this._syncStore.putSync(node);\n                return this._updateKeysBatch(node.prefix, rootPath.slice(0, i));\n            }\n\n            // The node has no children left, continue pruning.\n            prefix = node.prefix;\n        }\n\n        // XXX This should never be reached.\n        return undefined;\n    }\n\n    /**\n     * @param {string} prefix\n     * @param {Array.<AccountsTreeNode>} rootPath\n     * @private\n     */\n    _updateKeysBatch(prefix, rootPath) {\n        // Walk along the rootPath towards the root node starting with the\n        // immediate predecessor of the node specified by 'prefix'.\n        let i = rootPath.length - 1;\n        for (; i >= 0; --i) {\n            let node = rootPath[i];\n\n            node = node.withChild(prefix, new Hash(null));\n            this._syncStore.putSync(node);\n            prefix = node.prefix;\n        }\n    }\n\n    /**\n     * This method updates all empty hashes (and only such).\n     * @param {AccountsTreeNode} node\n     * @protected\n     */\n    _updateHashes(node) {\n        if (node.isTerminal()) {\n            return node.hash();\n        }\n\n        const zeroHash = new Hash(null);\n        // Compute sub hashes if necessary.\n        const subHashes = node.getChildren().map(child => {\n            const currentHash = node.getChildHash(child);\n            if (!currentHash.equals(zeroHash)) {\n                return currentHash;\n            }\n            const childNode = this._syncStore.getSync(child);\n            return this._updateHashes(childNode);\n        });\n\n        // Then prepare new node and update.\n        let newNode = node;\n        node.getChildren().forEach((child, i) => {\n            newNode = newNode.withChild(child, subHashes[i]);\n        });\n        this._syncStore.putSync(newNode);\n        return newNode.hash();\n    }\n\n    /**\n     * @param {Address} address\n     * @param {boolean} [expectedToBePresent]\n     * @returns {?Account}\n     */\n    getSync(address, expectedToBePresent = true) {\n        const node = this._syncStore.getSync(address.toHex(), expectedToBePresent);\n        return node !== undefined ? node.account : null;\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    rootSync() {\n        const rootNode = this._syncStore.getRootNodeSync();\n        return rootNode && rootNode.hash();\n    }\n}\nClass.register(SynchronousAccountsTree);\n\n","class PartialAccountsTree extends SynchronousAccountsTree {\n    /**\n     * @private\n     * @param {SynchronousAccountsTreeStore} store\n     */\n    constructor(store) {\n        super(store);\n        this._complete = false;\n        /** @type {string} */\n        this._lastPrefix = '';\n    }\n\n    /**\n     * @param {AccountsTreeChunk} chunk\n     * @returns {Promise.<PartialAccountsTree.Status>}\n     */\n    async pushChunk(chunk) {\n        // First verify the proof.\n        if (!chunk.verify()) {\n            return PartialAccountsTree.Status.ERR_INCORRECT_PROOF;\n        }\n\n        const tx = this.synchronousTransaction();\n\n        // Then apply all\n        tx._putLight(chunk.terminalNodes);\n\n        // Check if proof can be merged.\n        if (!tx._mergeProof(chunk.proof, chunk.tail.prefix)) {\n            await tx.abort();\n            return PartialAccountsTree.Status.ERR_UNMERGEABLE;\n        }\n        this._complete = tx.complete;\n\n        // Now, we can put all nodes into the store.\n        await tx.commit();\n\n        // Update last prefix.\n        this._lastPrefix = chunk.tail.prefix;\n\n        // And return OK code depending on internal state.\n        return this._complete ? PartialAccountsTree.Status.OK_COMPLETE : PartialAccountsTree.Status.OK_UNFINISHED;\n    }\n\n    /**\n     * @param {AccountsProof} proof\n     * @param {string} upperBound\n     * @returns {boolean}\n     * @private\n     */\n    _mergeProof(proof, upperBound) {\n        // Retrieve rightmost path of the in-memory tree.\n        let node = this._store.getRootNodeSync();\n        let nodeChildren = node.getChildren();\n        let complete = true;\n\n        // Iterate over the proof and check for consistency.\n        let j = proof.length - 1;\n        for (; j > 0; --j) {\n            const proofNode = proof.nodes[j];\n            // The node's prefix might be shorter than the proof node's prefix if it is a newly\n            // introduces node in the proof.\n            if (StringUtils.commonPrefix(node.prefix, proofNode.prefix) !== node.prefix) {\n                return false;\n            }\n\n            const proofChildren = proofNode.getChildren();\n\n            // The tree node may not have more children than the proof node.\n            if (nodeChildren.length > proofChildren.length) {\n                return false;\n            }\n\n            // The nextChild we descend to.\n            const nextChild = node.getLastChild();\n            let insertedNode = false;\n\n            // There are three cases:\n            // 1) the child is in our inner tree (so between lower and upper bound), then the hashes must coincide.\n            // 2) the child is left of our chunk, so it must be in the store.\n            // 3) the child is right of our chunk, so it is a dangling reference.\n            let i = 0;\n            for (const proofChild of proofChildren) {\n                const upperBoundPrefix = upperBound.substr(0, proofChild.length);\n                if (proofChild <= upperBoundPrefix) {\n                    // An inner node.\n                    const child = nodeChildren.shift();\n\n                    // This is the next child.\n                    if (StringUtils.commonPrefix(nextChild, proofChild) === proofChild) {\n                        // If it is a real prefix of the next child, we have inserted a new node.\n                        if (proofChild !== nextChild) {\n                            insertedNode = true;\n                        }\n                        continue;\n                    }\n\n                    if (child !== proofChild) {\n                        return false;\n                    }\n                    // The child is equal and not the next child, so the hash must coincide.\n                    const nodeHash = node.getChildHash(child);\n                    const proofHash = proofNode.getChildHash(child);\n                    if (!nodeHash || !proofHash || !nodeHash.equals(proofHash)) {\n                        return false;\n                    }\n                } else {\n                    // The others may be dangling references.\n                    break;\n                }\n                ++i;\n            }\n\n            // We must have consumed all children!\n            if (nodeChildren.length !== 0) {\n                return false;\n            }\n\n            // If not all of the proof children have been tested, we are definitely incomplete.\n            complete = complete && (i === proofChildren.length - 1);\n\n            // If the prefix was the same, we can move on.\n            if (insertedNode) {\n                nodeChildren = [nextChild];\n            } else {\n                // We should never end here with a terminal node.\n                if (node.isTerminal()) {\n                    return false;\n                }\n                node = this._store.getSync(node.getLastChild());\n                nodeChildren = node.getChildren();\n                if (node.isTerminal()) {\n                    break;\n                }\n            }\n        }\n\n        // Check the terminal nodes.\n        if (!node.equals(proof.nodes[0])) {\n            return false;\n        }\n\n        this._complete = complete;\n        return true;\n    }\n\n    /**\n     * @param {Array.<AccountsTreeNode>} nodes\n     * @private\n     */\n    _putLight(nodes) {\n        Assert.that(nodes.every(node => node.isTerminal()), 'Can only build tree from terminal nodes');\n\n        // Fetch the root node.\n        let rootNode = this._store.getRootNodeSync();\n        Assert.that(!!rootNode, 'Corrupted store: Failed to fetch AccountsTree root node');\n\n        // TODO: Bulk insertion instead of sequential insertion!\n        for (const node of nodes) {\n            this._insertBatch(rootNode, node.prefix, node.account, []);\n            rootNode = this._store.getRootNodeSync();\n            Assert.that(!!rootNode, 'Corrupted store: Failed to fetch AccountsTree root node');\n        }\n        this._updateHashes(rootNode);\n    }\n\n    /** @type {boolean} */\n    get complete() {\n        return this._complete;\n    }\n\n    /** @type {string} */\n    get missingPrefix() {\n        return this._lastPrefix;\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {PartialAccountsTree}\n     */\n    synchronousTransaction(enableWatchdog = true) {\n        const tree = new PartialAccountsTree(this._store.synchronousTransaction(enableWatchdog));\n        tree._complete = this._complete;\n        tree._lastPrefix = this._lastPrefix;\n        return tree;\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {AccountsTree}\n     */\n    transaction(enableWatchdog = true) {\n        if (!this.complete) {\n            throw new Error('Can only construct AccountsTree from complete PartialAccountsTree');\n        }\n        // Use a synchronous transaction here to enable better caching.\n        return new AccountsTree(this._store.synchronousTransaction(enableWatchdog));\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    commit() {\n        return this._store.commit();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    abort() {\n        return this._store.abort();\n    }\n}\n\n/**\n * @enum {number}\n */\nPartialAccountsTree.Status = {\n    ERR_HASH_MISMATCH: -3,\n    ERR_INCORRECT_PROOF: -2,\n    ERR_UNMERGEABLE: -1,\n    OK_COMPLETE: 0,\n    OK_UNFINISHED: 1\n};\nClass.register(PartialAccountsTree);\n\n","class Accounts extends Observable {\n    /**\n     * Generate an Accounts object that is persisted to the local storage.\n     * @returns {Promise.<Accounts>} Accounts object\n     */\n    static async getPersistent(jdb) {\n        const tree = await AccountsTree.getPersistent(jdb);\n        return new Accounts(tree);\n    }\n\n    /**\n     * Generate an Accounts object that loses it's data after usage.\n     * @returns {Promise.<Accounts>} Accounts object\n     */\n    static async createVolatile() {\n        const tree = await AccountsTree.createVolatile();\n        return new Accounts(tree);\n    }\n\n    /**\n     * @param {AccountsTree} accountsTree\n     */\n    constructor(accountsTree) {\n        super();\n        this._tree = accountsTree;\n\n        // Forward balance change events to listeners registered on this Observable.\n        this.bubble(this._tree, '*');\n    }\n\n    /**\n     * @param {Block} genesisBlock\n     * @param {string} encodedAccounts\n     * @returns {Promise.<void>}\n     */\n    async initialize(genesisBlock, encodedAccounts) {\n        Assert.that(await this._tree.isEmpty());\n\n        const tree = await this._tree.synchronousTransaction();\n        try {\n            const buf = BufferUtils.fromBase64(encodedAccounts);\n            const count = buf.readUint16();\n            for (let i = 0; i < count; i++) {\n                const address = Address.unserialize(buf);\n                const account = Account.unserialize(buf);\n                tree.putSync(address, account);\n            }\n\n            await this._commitBlockBody(tree, genesisBlock.body, genesisBlock.height, new TransactionCache());\n\n            tree.finalizeBatch();\n        } catch (e) {\n            await tree.abort();\n            throw e;\n        }\n\n        const hash = tree.rootSync();\n        if (!genesisBlock.accountsHash.equals(hash)) {\n            await tree.abort();\n            throw new Error('Genesis AccountsHash mismatch');\n        }\n\n        return tree.commit();\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<AccountsProof>}\n     */\n    getAccountsProof(addresses) {\n        return this._tree.getAccountsProof(addresses);\n    }\n\n    /**\n     * @param {string} startPrefix\n     * @returns {Promise.<AccountsTreeChunk>}\n     */\n    getAccountsTreeChunk(startPrefix) {\n        return this._tree.getChunk(startPrefix, AccountsTreeChunk.SIZE_MAX);\n    }\n\n    /**\n     * @param {Block} block\n     * @param {TransactionCache} transactionCache\n     * @return {Promise}\n     */\n    async commitBlock(block, transactionCache) {\n        const tree = await this._tree.synchronousTransaction();\n        await tree.preloadAddresses(block.body.getAddresses());\n        try {\n            this._commitBlockBody(tree, block.body, block.height, transactionCache);\n        } catch (e) {\n            await tree.abort();\n            throw e;\n        }\n\n        tree.finalizeBatch();\n\n        const hash = tree.rootSync();\n        if (!block.accountsHash.equals(hash)) {\n            await tree.abort();\n            throw new Error('AccountsHash mismatch');\n        }\n        return tree.commit();\n    }\n\n    /**\n     * @param {BlockBody} body\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionCache\n     * @return {Promise}\n     */\n    async commitBlockBody(body, blockHeight, transactionCache) {\n        const tree = await this._tree.synchronousTransaction();\n        await tree.preloadAddresses(body.getAddresses());\n        try {\n            this._commitBlockBody(tree, body, blockHeight, transactionCache);\n        } catch (e) {\n            await tree.abort();\n            throw e;\n        }\n        tree.finalizeBatch();\n        return tree.commit();\n    }\n\n    /**\n     * @param {Array.<Transaction>} transactions\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionCache\n     * @return {Promise<Array.<PrunedAccount>>}\n     */\n    async gatherToBePrunedAccounts(transactions, blockHeight, transactionCache) {\n        const tree = await this._tree.synchronousTransaction();\n        const addresses = [];\n        for (const tx of transactions) {\n            addresses.push(tx.sender, tx.recipient);\n        }\n        await tree.preloadAddresses(addresses);\n        try {\n            this._processSenderAccounts(tree, transactions, blockHeight, transactionCache);\n            this._processRecipientAccounts(tree, transactions, blockHeight);\n            this._processContracts(tree, transactions, blockHeight);\n\n            const toBePruned = [];\n            for (const tx of transactions) {\n                const senderAccount = this._getSync(tx.sender, undefined, tree);\n                if (senderAccount.isToBePruned()) {\n                    toBePruned.push(new PrunedAccount(tx.sender, senderAccount));\n                }\n            }\n            return toBePruned.sort((a, b) => a.compare(b));\n        } finally {\n            await tree.abort();\n        }\n    }\n\n    /**\n     * @param {Block} block\n     * @param {TransactionCache} transactionCache\n     * @return {Promise}\n     */\n    async revertBlock(block, transactionCache) {\n        if (!block) throw new Error('block undefined');\n\n        const hash = await this._tree.root();\n        if (!block.accountsHash.equals(hash)) {\n            throw new Error('AccountsHash mismatch');\n        }\n        return this.revertBlockBody(block.body, block.height, transactionCache);\n    }\n\n    /**\n     * @param {BlockBody} body\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionCache\n     * @return {Promise}\n     */\n    async revertBlockBody(body, blockHeight, transactionCache) {\n        const tree = await this._tree.synchronousTransaction();\n        await tree.preloadAddresses(body.getAddresses());\n        try {\n            this._revertBlockBody(tree, body, blockHeight, transactionCache);\n        } catch (e) {\n            await tree.abort();\n            throw e;\n        }\n        tree.finalizeBatch();\n        return tree.commit();\n    }\n\n    /**\n     * Gets the {@link Account}-object for an address.\n     *\n     * @param {Address} address\n     * @param {Account.Type} [accountType]\n     * @param {AccountsTree} [tree]\n     * @return {Promise.<Account>}\n     */\n    async get(address, accountType, tree = this._tree) {\n        const account = await tree.get(address);\n        if (!account) {\n            if (typeof accountType === 'undefined') {\n                return Account.INITIAL;\n            }\n            throw new Error('Account type was given but account not present');\n        } else if (typeof accountType !== 'undefined' && account.type !== accountType) {\n            throw new Error('Account type does match actual account');\n        }\n        return account;\n    }\n\n    /**\n     * Gets the {@link Account}-object for an address.\n     *\n     * @param {Address} address\n     * @param {Account.Type} [accountType]\n     * @param {SynchronousAccountsTree} tree\n     * @private\n     * @return {Account}\n     */\n    _getSync(address, accountType, tree) {\n        const account = tree.getSync(address, false);\n        if (!account) {\n            if (typeof accountType === 'undefined') {\n                return Account.INITIAL;\n            }\n            throw new Error('Account type was given but account not present');\n        } else if (typeof accountType !== 'undefined' && account.type !== accountType) {\n            throw new Error('Account type does match actual account');\n        }\n        return account;\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {Promise.<Accounts>}\n     */\n    async transaction(enableWatchdog = true) {\n        return new Accounts(await this._tree.transaction(enableWatchdog));\n    }\n\n    /**\n     * @param {Accounts} [tx]\n     * @returns {Promise.<Accounts>}\n     */\n    async snapshot(tx) {\n        return new Accounts(await this._tree.snapshot(tx ? tx._tree : undefined));\n    }\n\n    /**\n     * @returns {Promise.<PartialAccountsTree>}\n     */\n    partialAccountsTree() {\n        return this._tree.partialTree();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    commit() {\n        return this._tree.commit();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    abort() {\n        return this._tree.abort();\n    }\n\n    /**\n     * Step 1)\n     * @param {SynchronousAccountsTree} tree\n     * @param {Array.<Transaction>} transactions\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionCache\n     * @param {boolean} [revert]\n     * @private\n     */\n    _processSenderAccounts(tree, transactions, blockHeight, transactionCache, revert = false) {\n        for (const tx of transactions) {\n            const senderAccount = this._getSync(tx.sender, !revert ? tx.senderType : undefined, tree);\n            tree.putBatch(tx.sender, senderAccount.withOutgoingTransaction(tx, blockHeight, transactionCache, revert));\n        }\n    }\n\n    /**\n     * Step 2)\n     * @param {SynchronousAccountsTree} tree\n     * @param {Array.<Transaction>} transactions\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @private\n     */\n    _processRecipientAccounts(tree, transactions, blockHeight, revert = false) {\n        for (const tx of transactions) {\n            const recipientAccount = this._getSync(tx.recipient, undefined, tree);\n            tree.putBatch(tx.recipient, recipientAccount.withIncomingTransaction(tx, blockHeight, revert));\n        }\n    }\n\n    /**\n     * Step 3)\n     * @param {SynchronousAccountsTree} tree\n     * @param {Array.<Transaction>} transactions\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @private\n     */\n    _processContracts(tree, transactions, blockHeight, revert = false) {\n        // TODO: Filter & sort contract command.\n        if (revert) {\n            transactions = transactions.slice().reverse();\n        }\n        for (const tx of transactions) {\n            const recipientAccount = this._getSync(tx.recipient, !revert ? undefined : tx.recipientType, tree);\n            tree.putBatch(tx.recipient, recipientAccount.withContractCommand(tx, blockHeight, revert));\n        }\n    }\n\n    /**\n     * @param {SynchronousAccountsTree} tree\n     * @param {BlockBody} body\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionCache\n     * @private\n     */\n    _commitBlockBody(tree, body, blockHeight, transactionCache) {\n        this._processSenderAccounts(tree, body.transactions, blockHeight, transactionCache);\n        this._processRecipientAccounts(tree, body.transactions, blockHeight);\n        this._processContracts(tree, body.transactions, blockHeight);\n\n        const prunedAccounts = body.prunedAccounts.slice();\n        for (const tx of body.transactions) {\n            const senderAccount = this._getSync(tx.sender, undefined, tree);\n            if (senderAccount.isToBePruned()) {\n                const accIdx = prunedAccounts.findIndex((acc) => acc.address.equals(tx.sender));\n                if (accIdx === -1 || !senderAccount.equals(prunedAccounts[accIdx].account)) {\n                    throw new Error('Account was not pruned correctly');\n                } else {\n                    // Pruned accounts are reset to their initial state\n                    tree.putBatch(tx.sender, Account.INITIAL);\n                    prunedAccounts.splice(accIdx, 1);\n                }\n            }\n        }\n        if (prunedAccounts.length > 0) {\n            throw new Error('Account was invalidly pruned');\n        }\n\n        this._rewardMiner(tree, body, blockHeight, false);\n    }\n\n    /**\n     * @param {SynchronousAccountsTree} tree\n     * @param {BlockBody} body\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionCache\n     * @private\n     */\n    _revertBlockBody(tree, body, blockHeight, transactionCache) {\n        this._rewardMiner(tree, body, blockHeight, true);\n\n        for (const acc of body.prunedAccounts) {\n            tree.putBatch(acc.address, acc.account);\n        }\n\n        // Execute transactions in reverse order.\n        this._processContracts(tree, body.transactions, blockHeight, true);\n        this._processRecipientAccounts(tree, body.transactions, blockHeight, true);\n        this._processSenderAccounts(tree, body.transactions, blockHeight, transactionCache, true);\n    }\n\n    /**\n     * @param {SynchronousAccountsTree} tree\n     * @param {BlockBody} body\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @private\n     */\n    _rewardMiner(tree, body, blockHeight, revert = false) {\n        // Sum up transaction fees.\n        const txFees = body.transactions.reduce((sum, tx) => sum + tx.fee, 0);\n\n        // \"Coinbase transaction\"\n        const coinbaseTransaction = new ExtendedTransaction(\n            Address.NULL, Account.Type.BASIC,\n            body.minerAddr, Account.Type.BASIC,\n            txFees + Policy.blockRewardAt(blockHeight),\n            0, // Fee\n            0, // ValidityStartHeight\n            Transaction.Flag.NONE,\n            new Uint8Array(0));\n\n        const recipientAccount = this._getSync(body.minerAddr, undefined, tree);\n        tree.putBatch(body.minerAddr, recipientAccount.withIncomingTransaction(coinbaseTransaction, blockHeight, revert));\n    }\n\n    /**\n     * @returns {Promise.<Hash>}\n     */\n    hash() {\n        return this._tree.root();\n    }\n\n    /** @type {Transaction} */\n    get tx() {\n        return this._tree.tx;\n    }\n}\nClass.register(Accounts);\n","class BlockHeader {\n    /**\n     * @param {BlockHeader} o\n     * @returns {BlockHeader}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const prevHash = Hash.copy(o._prevHash);\n        const interlinkHash = Hash.copy(o._interlinkHash);\n        const bodyHash = Hash.copy(o._bodyHash);\n        const accountsHash = Hash.copy(o._accountsHash);\n        return new BlockHeader(\n            prevHash, interlinkHash, bodyHash, accountsHash,\n            o._nBits, o._height, o._timestamp, o._nonce, o._version\n        );\n    }\n\n    /**\n     * @param {Hash} prevHash\n     * @param {Hash} interlinkHash\n     * @param {Hash} bodyHash\n     * @param {Hash} accountsHash\n     * @param {number} nBits\n     * @param {number} height\n     * @param {number} timestamp\n     * @param {number} nonce\n     * @param {number} version\n     */\n    constructor(prevHash, interlinkHash, bodyHash, accountsHash, nBits, height, timestamp, nonce, version = BlockHeader.CURRENT_VERSION) {\n        if (!NumberUtils.isUint16(version)) throw 'Malformed version';\n        if (!Hash.isHash(prevHash)) throw 'Malformed prevHash';\n        if (!Hash.isHash(interlinkHash)) throw 'Malformed interlinkHash';\n        if (!Hash.isHash(bodyHash)) throw 'Malformed bodyHash';\n        if (!Hash.isHash(accountsHash)) throw 'Malformed accountsHash';\n        if (!NumberUtils.isUint32(nBits) || !BlockUtils.isValidCompact(nBits)) throw 'Malformed nBits';\n        if (!NumberUtils.isUint32(height)) throw 'Invalid height';\n        if (!NumberUtils.isUint32(timestamp)) throw 'Malformed timestamp';\n        if (!NumberUtils.isUint32(nonce)) throw 'Malformed nonce';\n\n        /** @type {number} */\n        this._version = version;\n        /** @type {Hash} */\n        this._prevHash = prevHash;\n        /** @type {Hash} */\n        this._interlinkHash = interlinkHash;\n        /** @type {Hash} */\n        this._bodyHash = bodyHash;\n        /** @type {Hash} */\n        this._accountsHash = accountsHash;\n        /** @type {number} */\n        this._nBits = nBits;\n        /** @type {number} */\n        this._height = height;\n        /** @type {number} */\n        this._timestamp = timestamp;\n        /** @type {number} */\n        this._nonce = nonce;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {BlockHeader}\n     */\n    static unserialize(buf) {\n        const version = buf.readUint16();\n        if (!BlockHeader.SUPPORTED_VERSIONS.includes(version)) throw new Error(`Unsupported block version ${version}`);\n        const prevHash = Hash.unserialize(buf);\n        const interlinkHash = Hash.unserialize(buf);\n        const bodyHash = Hash.unserialize(buf);\n        const accountsHash = Hash.unserialize(buf);\n        const nBits = buf.readUint32();\n        const height = buf.readUint32();\n        const timestamp = buf.readUint32();\n        const nonce = buf.readUint32();\n        return new BlockHeader(prevHash, interlinkHash, bodyHash, accountsHash, nBits, height, timestamp, nonce, version);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._version);\n        this._prevHash.serialize(buf);\n        this._interlinkHash.serialize(buf);\n        this._bodyHash.serialize(buf);\n        this._accountsHash.serialize(buf);\n        buf.writeUint32(this._nBits);\n        buf.writeUint32(this._height);\n        buf.writeUint32(this._timestamp);\n        buf.writeUint32(this._nonce);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*version*/ 2\n            + this._prevHash.serializedSize\n            + this._interlinkHash.serializedSize\n            + this._bodyHash.serializedSize\n            + this._accountsHash.serializedSize\n            + /*nBits*/ 4\n            + /*height*/ 4\n            + /*timestamp*/ 4\n            + /*nonce*/ 4;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Promise.<boolean>}\n     */\n    async verifyProofOfWork(buf) {\n        const pow = await this.pow(buf);\n        return BlockUtils.isProofOfWork(pow, this.target);\n    }\n\n    /**\n     * @param {BlockHeader} prevHeader\n     * @returns {boolean}\n     */\n    isImmediateSuccessorOf(prevHeader) {\n        // Check that the height is one higher than the previous height.\n        if (this.height !== prevHeader.height + 1) {\n            return false;\n        }\n\n        // Check that the timestamp is greater or equal to the predecessor's timestamp.\n        if (this.timestamp < prevHeader.timestamp) {\n            return false;\n        }\n\n        // Check that the hash of the predecessor block equals prevHash.\n        const prevHash = prevHeader.hash();\n        if (!this.prevHash.equals(prevHash)) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Hash}\n     */\n    hash(buf) {\n        this._hash = this._hash || Hash.light(this.serialize(buf));\n        return this._hash;\n    }\n    \n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Promise.<Hash>}\n     */\n    async pow(buf) {\n        this._pow = this._pow || await Hash.hard(this.serialize(buf));\n        return this._pow;\n    }\n\n    /**\n     * @param {BlockHeader|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof BlockHeader\n            && this._prevHash.equals(o.prevHash)\n            && this._interlinkHash.equals(o.interlinkHash)\n            && this._bodyHash.equals(o.bodyHash)\n            && this._accountsHash.equals(o.accountsHash)\n            && this._nBits === o.nBits\n            && this._height === o.height\n            && this._timestamp === o.timestamp\n            && this._nonce === o.nonce;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return 'BlockHeader{'\n            + `prevHash=${this._prevHash}, `\n            + `interlinkHash=${this._interlinkHash}, `\n            + `bodyHash=${this._bodyHash}, `\n            + `accountsHash=${this._accountsHash}, `\n            + `nBits=${this._nBits.toString(16)}, `\n            + `height=${this._height}, `\n            + `timestamp=${this._timestamp}, `\n            + `nonce=${this._nonce}`\n            + '}';\n    }\n\n    /** @type {number} */\n    get version() {\n        return this._version;\n    }\n\n    /** @type {Hash} */\n    get prevHash() {\n        return this._prevHash;\n    }\n\n    /** @type {Hash} */\n    get interlinkHash() {\n        return this._interlinkHash;\n    }\n\n    /** @type {Hash} */\n    get bodyHash() {\n        return this._bodyHash;\n    }\n\n    /** @type {Hash} */\n    get accountsHash() {\n        return this._accountsHash;\n    }\n\n    /** @type {number} */\n    get nBits() {\n        return this._nBits;\n    }\n\n    /** @type {number} */\n    get target() {\n        return BlockUtils.compactToTarget(this._nBits);\n    }\n\n    /** @type {number} */\n    get difficulty() {\n        return BlockUtils.compactToDifficulty(this._nBits);\n    }\n\n    /** @type {number} */\n    get height() {\n        return this._height;\n    }\n\n    /** @type {number} */\n    get timestamp() {\n        return this._timestamp;\n    }\n\n    /** @type {number} */\n    get nonce() {\n        return this._nonce;\n    }\n\n    // XXX The miner changes the nonce of an existing BlockHeader during the\n    // mining process.\n    /** @type {number} */\n    set nonce(n) {\n        this._nonce = n;\n        this._hash = null;\n        this._pow = null;\n    }\n}\n// FIXME: Clean up for mainnet.\nBlockHeader.Version = {\n    V1: 1\n};\nBlockHeader.CURRENT_VERSION = BlockHeader.Version.V1;\nBlockHeader.SUPPORTED_VERSIONS = [\n    BlockHeader.Version.V1\n];\nBlockHeader.SERIALIZED_SIZE = 146;\nClass.register(BlockHeader);\n","class BlockInterlink {\n    /**\n     * @param {BlockInterlink} o\n     * @returns {BlockInterlink}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const hashes = o._hashes.map(it => Hash.copy(it));\n        const repeatBits = new Uint8Array(o._repeatBits);\n        const compressed = o._compressed.map(it => Hash.copy(it));\n        return new BlockInterlink(hashes, undefined, repeatBits, compressed);\n    }\n\n    /**\n     * @param {Array.<Hash>} hashes\n     * @param {Hash} prevHash\n     * @returns {{repeatBits: Uint8Array, compressed: Array.<Hash>}}\n     * @protected\n     */\n    static _compress(hashes, prevHash) {\n        const count = hashes.length;\n        const repeatBitsSize = Math.ceil(count / 8);\n        const repeatBits = new Uint8Array(repeatBitsSize);\n\n        let lastHash = prevHash;\n        const compressed = [];\n        for (let i = 0; i < count; i++) {\n            const hash = hashes[i];\n            if (!hash.equals(lastHash)) {\n                compressed.push(hash);\n                lastHash = hash;\n            } else {\n                repeatBits[Math.floor(i / 8)] |= 0x80 >>> (i % 8);\n            }\n        }\n\n        return {repeatBits, compressed};\n    }\n\n    /**\n     * @param {Array.<Hash>} hashes\n     * @param {Hash} [prevHash]\n     * @param {Uint8Array} [repeatBits]\n     * @param {Array.<Hash>} [compressed]\n     */\n    constructor(hashes, prevHash, repeatBits, compressed) {\n        if (!Array.isArray(hashes) || !NumberUtils.isUint8(hashes.length)\n            || hashes.some(it => !(it instanceof Hash))) throw new Error('Malformed hashes');\n        if ((repeatBits || compressed) && !(repeatBits && compressed)) throw new Error('Malformed repeatBits/compressed');\n        if (!prevHash && !repeatBits) throw new Error('Either prevHash or repeatBits/compressed required');\n\n        if (!repeatBits) {\n            ({repeatBits, compressed} = BlockInterlink._compress(hashes, prevHash));\n        }\n\n        /** @type {Array.<Hash>} */\n        this._hashes = hashes;\n        /** @type {Uint8Array} */\n        this._repeatBits = repeatBits;\n        /** @type {Array.<Hash>} */\n        this._compressed = compressed;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @param {Hash} prevHash\n     * @returns {BlockInterlink}\n     */\n    static unserialize(buf, prevHash) {\n        const count = buf.readUint8();\n        const repeatBitsSize = Math.ceil(count / 8);\n        const repeatBits = buf.read(repeatBitsSize);\n\n        let hash = prevHash;\n        const hashes = [];\n        const compressed = [];\n        for (let i = 0; i < count; i++) {\n            const repeated = (repeatBits[Math.floor(i / 8)] & (0x80 >>> (i % 8))) !== 0;\n            if (!repeated) {\n                hash = Hash.unserialize(buf);\n                compressed.push(hash);\n            }\n            hashes.push(hash);\n        }\n\n        return new BlockInterlink(hashes, prevHash, repeatBits, compressed);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._hashes.length);\n        buf.write(this._repeatBits);\n        for (const hash of this._compressed) {\n            hash.serialize(buf);\n        }\n        return buf;\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        return /*count*/ 1\n            + this._repeatBits.length\n            + this._compressed.reduce((sum, hash) => sum + hash.serializedSize, 0);\n    }\n\n    /**\n     * @param {BlockInterlink|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof BlockInterlink\n            && this._hashes.length === o._hashes.length\n            && this._hashes.every((hash, i) => hash.equals(o.hashes[i]));\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    hash() {\n        if (!this._hash) {\n            this._hash = MerkleTree.computeRoot([this._repeatBits, GenesisConfig.GENESIS_HASH, ...this._compressed]);\n        }\n        return this._hash;\n    }\n\n    /**\n     * @type {Array.<Hash>}\n     */\n    get hashes() {\n        return this._hashes;\n    }\n\n    /**\n     * @type {number}\n     */\n    get length() {\n        return this._hashes.length;\n    }\n}\nClass.register(BlockInterlink);\n","class BlockBody {\n    /**\n     * @param {Uint8Array} extraData\n     * @returns {number}\n     */\n    static getMetadataSize(extraData) {\n        return Address.SERIALIZED_SIZE\n            + /*extraDataLength*/ 1\n            + extraData.byteLength\n            + /*transactionsLength*/ 2;\n    }\n\n    /**\n     * @param {Address} minerAddr\n     * @param {Array.<Transaction>} transactions\n     * @param {Uint8Array} [extraData]\n     * @param {Array.<PrunedAccount>} prunedAccounts\n     */\n    constructor(minerAddr, transactions, extraData = new Uint8Array(0), prunedAccounts = []) {\n        if (!(minerAddr instanceof Address)) throw 'Malformed minerAddr';\n        if (!Array.isArray(transactions) || transactions.some(it => !(it instanceof Transaction))) throw 'Malformed transactions';\n        if (!(extraData instanceof Uint8Array) || !NumberUtils.isUint8(extraData.byteLength)) throw 'Malformed extraData';\n\n        /** @type {Address} */\n        this._minerAddr = minerAddr;\n        /** @type {Uint8Array} */\n        this._extraData = extraData;\n        /** @type {Array.<Transaction>} */\n        this._transactions = transactions;\n        /** @type {Array.<PrunedAccount>} */\n        this._prunedAccounts = prunedAccounts;\n        /** @type {Hash} */\n        this._hash = null;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {BlockBody}\n     */\n    static unserialize(buf) {\n        const minerAddr = Address.unserialize(buf);\n        const extraDataLength = buf.readUint8();\n        const extraData = buf.read(extraDataLength);\n        const numTransactions = buf.readUint16();\n        const transactions = new Array(numTransactions);\n        for (let i = 0; i < numTransactions; i++) {\n            transactions[i] = Transaction.unserialize(buf);\n        }\n        const numPrunedAccounts = buf.readUint16();\n        const prunedAccounts = [];\n        for (let i = 0; i < numPrunedAccounts; i++) {\n            prunedAccounts.push(PrunedAccount.unserialize(buf));\n        }\n        return new BlockBody(minerAddr, transactions, extraData, prunedAccounts);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._minerAddr.serialize(buf);\n        buf.writeUint8(this._extraData.byteLength);\n        buf.write(this._extraData);\n        buf.writeUint16(this._transactions.length);\n        for (const tx of this._transactions) {\n            tx.serialize(buf);\n        }\n        buf.writeUint16(this._prunedAccounts.length);\n        for (const acc of this._prunedAccounts) {\n            acc.serialize(buf);\n        }\n        return buf;\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        let size = this._minerAddr.serializedSize\n            + /*extraDataLength*/ 1\n            + this._extraData.byteLength\n            + /*transactionsLength*/ 2\n            + /*prunedAccountsLength*/ 2;\n        for (const tx of this._transactions) {\n            size += tx.serializedSize;\n        }\n        size += this._prunedAccounts.reduce((sum, acc) => sum + acc.serializedSize, 0);\n        return size;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    verify() {\n        /** @type {Transaction} */\n        let previousTx = null;\n        for (const tx of this._transactions) {\n            // Ensure transactions are ordered and unique.\n            if (previousTx && previousTx.compareBlockOrder(tx) >= 0) {\n                Log.w(BlockBody, 'Invalid block - transactions not ordered.');\n                return false;\n            }\n            previousTx = tx;\n\n            // Check that all transactions are valid.\n            if (!tx.verify()) {\n                Log.w(BlockBody, 'Invalid block - invalid transaction');\n                return false;\n            }\n        }\n\n        let previousAcc = null;\n        for (const acc of this._prunedAccounts) {\n            // Ensure pruned accounts are ordered and unique.\n            if (previousAcc && previousAcc.compare(acc) >= 0) {\n                Log.w(BlockBody, 'Invalid block - pruned accounts not ordered.');\n                return false;\n            }\n            previousAcc = acc;\n            \n            // Check that pruned accounts are actually supposed to be pruned\n            if (!acc.account.isToBePruned()) {\n                Log.w(BlockBody, 'Invalid block - invalid pruned account');\n                return false;\n            }\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {Array}\n     */\n    getMerkleLeafs() {\n        return [this._minerAddr, this._extraData, ...this._transactions, ...this.prunedAccounts];\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        if (!this._hash) {\n            this._hash = MerkleTree.computeRoot(this.getMerkleLeafs());\n        }\n        return this._hash;\n    }\n\n    /**\n     * @param {BlockBody} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof BlockBody\n            && this._minerAddr.equals(o.minerAddr)\n            && BufferUtils.equals(this._extraData, o.extraData)\n            && this._transactions.length === o.transactions.length\n            && this._transactions.every((tx, i) => tx.equals(o.transactions[i]));\n    }\n\n    /**\n     * @return {Array.<Address>}\n     */\n    getAddresses() {\n        const addresses = [this._minerAddr];\n        for (const tx of this._transactions) {\n            addresses.push(tx.sender, tx.recipient);\n        }\n        return addresses;\n    }\n\n    /** @type {Uint8Array} */\n    get extraData() {\n        return this._extraData;\n    }\n\n    /** @type {Address} */\n    get minerAddr() {\n        return this._minerAddr;\n    }\n\n    /** @type {Array.<Transaction>} */\n    get transactions() {\n        return this._transactions;\n    }\n\n    /** @type {number} */\n    get transactionCount() {\n        return this._transactions.length;\n    }\n\n    /** @type {Array.<PrunedAccount>} */\n    get prunedAccounts() {\n        return this._prunedAccounts;\n    }\n}\n\nClass.register(BlockBody);\n","class BlockUtils {\n    /**\n     * @param {number} compact\n     * @returns {number}\n     */\n    static compactToTarget(compact) {\n        return (compact & 0xffffff) * Math.pow(2, (8 * ((compact >> 24) - 3)));\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static targetToCompact(target) {\n        if (!Number.isFinite(target) || Number.isNaN(target)) throw 'Invalid Target';\n\n        // Divide to get first byte\n        let size = Math.max(Math.ceil(Math.log2(target) / 8), 1);\n        const firstByte = target / Math.pow(2, (size - 1) * 8);\n\n        // If the first (most significant) byte is greater than 127 (0x7f),\n        // prepend a zero byte.\n        if (firstByte >= 0x80) {\n            size++;\n        }\n\n        // The first byte of the 'compact' format is the number of bytes,\n        // including the prepended zero if it's present.\n        // The following three bytes are the first three bytes of the above\n        // representation. If less than three bytes are present, then one or\n        // more of the last bytes of the compact representation will be zero.\n        return (size << 24) + ((target / Math.pow(2, (size - 3) * 8)) & 0xffffff);\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static getTargetHeight(target) {\n        return Math.ceil(Math.log2(target));\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static getTargetDepth(target) {\n        return BlockUtils.getTargetHeight(Policy.BLOCK_TARGET_MAX) - BlockUtils.getTargetHeight(target);\n    }\n\n    /**\n     * @param {number} compact\n     * @returns {number}\n     */\n    static compactToDifficulty(compact) {\n        return Policy.BLOCK_TARGET_MAX / BlockUtils.compactToTarget(compact);\n    }\n\n    /**\n     * @param {number} difficulty\n     * @returns {number}\n     */\n    static difficultyToCompact(difficulty) {\n        return BlockUtils.targetToCompact(BlockUtils.difficultyToTarget(difficulty));\n    }\n\n    /**\n     * @param {number} difficulty\n     * @returns {number}\n     */\n    static difficultyToTarget(difficulty) {\n        return Policy.BLOCK_TARGET_MAX / difficulty;\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static targetToDifficulty(target) {\n        return Policy.BLOCK_TARGET_MAX / target;\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {number}\n     */\n    static hashToTarget(hash) {\n        return parseInt(hash.toHex(), 16);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {number}\n     */\n    static realDifficulty(hash) {\n        return BlockUtils.targetToDifficulty(BlockUtils.hashToTarget(hash));\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {number}\n     */\n    static getHashDepth(hash) {\n        return BlockUtils.getTargetDepth(BlockUtils.hashToTarget(hash));\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {number} target\n     * @returns {boolean}\n     */\n    static isProofOfWork(hash, target) {\n        return parseInt(hash.toHex(), 16) <= target;\n    }\n\n    /**\n     * @param {number} compact\n     * @returns {boolean}\n     */\n\n    static isValidCompact(compact) {\n        return BlockUtils.isValidTarget(BlockUtils.compactToTarget(compact));\n    }\n\n    /**\n     * @param {number} target\n     * @returns {boolean}\n     */\n    static isValidTarget(target) {\n        return target >= 1 && target <= Policy.BLOCK_TARGET_MAX;\n    }\n\n    /**\n     * @param {BlockHeader} headBlock\n     * @param {BlockHeader} tailBlock\n     * @param {number} deltaTotalDifficulty\n     * @returns {number}\n     */\n    static getNextTarget(headBlock, tailBlock, deltaTotalDifficulty) {\n        Assert.that(\n            (headBlock.height - tailBlock.height === Policy.DIFFICULTY_BLOCK_WINDOW)\n                || (headBlock.height <= Policy.DIFFICULTY_BLOCK_WINDOW && tailBlock.height === 1),\n            `Tail and head block must be ${Policy.DIFFICULTY_BLOCK_WINDOW} blocks apart`);\n\n        let actualTime = headBlock.timestamp - tailBlock.timestamp;\n\n        // Simulate that the Policy.BLOCK_TIME was achieved for the blocks before the genesis block, i.e. we simulate\n        // a sliding window that starts before the genesis block. Assume difficulty = 1 for these blocks.\n        if (headBlock.height <= Policy.DIFFICULTY_BLOCK_WINDOW) {\n            actualTime += (Policy.DIFFICULTY_BLOCK_WINDOW - headBlock.height + 1) * Policy.BLOCK_TIME;\n            deltaTotalDifficulty += Policy.DIFFICULTY_BLOCK_WINDOW - headBlock.height + 1;\n        }\n\n        // Compute the target adjustment factor.\n        const expectedTime = Policy.DIFFICULTY_BLOCK_WINDOW * Policy.BLOCK_TIME;\n        let adjustment = actualTime / expectedTime;\n\n        // Clamp the adjustment factor to [1 / MAX_ADJUSTMENT_FACTOR, MAX_ADJUSTMENT_FACTOR].\n        adjustment = Math.max(adjustment, 1 / Policy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR);\n        adjustment = Math.min(adjustment, Policy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR);\n\n        // Compute the next target.\n        const averageDifficulty = deltaTotalDifficulty / Policy.DIFFICULTY_BLOCK_WINDOW;\n        const averageTarget = BlockUtils.difficultyToTarget(averageDifficulty);\n        let nextTarget = averageTarget * adjustment;\n\n        // Make sure the target is below or equal the maximum allowed target (difficulty 1).\n        // Also enforce a minimum target of 1.\n        nextTarget = Math.min(nextTarget, Policy.BLOCK_TARGET_MAX);\n        nextTarget = Math.max(nextTarget, 1);\n\n        // XXX Reduce target precision to nBits precision.\n        const nBits = BlockUtils.targetToCompact(nextTarget);\n        return BlockUtils.compactToTarget(nBits);\n    }\n}\nClass.register(BlockUtils);\n","class Subscription {\n    /**\n     * @param {Array.<Address>} addresses\n     */\n    static fromAddresses(addresses) {\n        return new Subscription(Subscription.Type.ADDRESSES, addresses);\n    }\n\n    /**\n     * @param {number} addresses\n     */\n    static fromMinFeePerByte(minFeePerByte) {\n        return new Subscription(Subscription.Type.MIN_FEE, minFeePerByte);\n    }\n\n    /**\n     * @param {Subscription.Type} type\n     * @param {Array.<Address>|number} [filter]\n     */\n    constructor(type, filter=null) {\n        if (!NumberUtils.isUint8(type)) throw new Error('Invalid type');\n        if (type === Subscription.Type.ADDRESSES\n            && (!Array.isArray(filter) || !NumberUtils.isUint16(filter.length)\n            || filter.some(it => !(it instanceof Address)))) throw new Error('Invalid addresses');\n        if (type === Subscription.Type.MIN_FEE && !NumberUtils.isUint64(filter)) throw new Error('Invalid minFeePerByte');\n        this._type = type;\n\n        this._addresses = new HashSet();\n        this._minFeePerByte = 0;\n\n        switch (type) {\n            case Subscription.Type.ADDRESSES:\n                this._addresses.addAll(filter);\n                break;\n            case Subscription.Type.MIN_FEE:\n                this._minFeePerByte = filter;\n                break;\n        }\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Subscription}\n     */\n    static unserialize(buf) {\n        const type = /** @type {Subscription.Type} */ buf.readUint8();\n        let filter = null;\n        switch (type) {\n            case Subscription.Type.ADDRESSES: {\n                filter = [];\n                const size = buf.readUint16();\n                for (let i = 0; i < size; ++i) {\n                    filter.push(Address.unserialize(buf));\n                }\n                break;\n            }\n            case Subscription.Type.MIN_FEE:\n                filter = buf.readUint64();\n                break;\n        }\n        return new Subscription(type, filter);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._type);\n        switch (this._type) {\n            case Subscription.Type.ADDRESSES:\n                buf.writeUint16(this._addresses.length);\n                for (const address of this._addresses) {\n                    address.serialize(buf);\n                }\n                break;\n            case Subscription.Type.MIN_FEE:\n                buf.writeUint64(this._minFeePerByte);\n                break;\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let additionalSize = 0;\n        switch (this._type) {\n            case Subscription.Type.ADDRESSES:\n                additionalSize = /*length*/ 2;\n                for (const address of this._addresses) {\n                    additionalSize += address.serializedSize;\n                }\n                break;\n            case Subscription.Type.MIN_FEE:\n                additionalSize = /*minFeePerByte*/ 8;\n                break;\n        }\n        return /*type*/ 1\n            + additionalSize;\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {boolean}\n     */\n    matchesBlock(block) {\n        switch (this._type) {\n            case Subscription.Type.NONE:\n                return false;\n            case Subscription.Type.ANY:\n            case Subscription.Type.ADDRESSES:\n            case Subscription.Type.MIN_FEE:\n                return true;\n            default:\n                throw new Error('Unknown type');\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @returns {boolean}\n     */\n    matchesTransaction(transaction) {\n        switch (this._type) {\n            case Subscription.Type.NONE:\n                return false;\n            case Subscription.Type.ANY:\n                return true;\n            case Subscription.Type.ADDRESSES:\n                return this._addresses.contains(transaction.recipient) || this._addresses.contains(transaction.sender);\n            case Subscription.Type.MIN_FEE:\n                return transaction.fee / transaction.serializedSize >= this._minFeePerByte;\n            default:\n                throw new Error('Unknown type');\n        }\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `Subscription{type=${this._type}, addresses=[${this._addresses.values()}], minFeePerByte=${this._minFeePerByte}}`;\n    }\n\n    /** @type {Subscription.Type} */\n    get type() {\n        return this._type;\n    }\n\n    /** @type {Array.<Address>} */\n    get addresses() {\n        return this._addresses.values();\n    }\n\n    /** @type {number} */\n    get minFeePerByte() {\n        return this._minFeePerByte;\n    }\n}\n/** @enum {number} */\nSubscription.Type = {\n    NONE: 0,\n    ANY: 1,\n    ADDRESSES: 2,\n    MIN_FEE: 3\n};\nSubscription.NONE = new Subscription(Subscription.Type.NONE);\nSubscription.BLOCKS_ONLY = new Subscription(Subscription.Type.ADDRESSES, []);\nSubscription.ANY = new Subscription(Subscription.Type.ANY);\nClass.register(Subscription);\n","/**\n * @abstract\n */\nclass Transaction {\n    /**\n     * @param {Transaction.Format} format\n     * @param {Address} sender\n     * @param {Account.Type} senderType\n     * @param {Address} recipient\n     * @param {Account.Type} recipientType\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Transaction.Flag | *} flags\n     * @param {Uint8Array} data\n     * @param {Uint8Array} [proof]\n     * @param {number} [networkId]\n     */\n    constructor(format, sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof, networkId = GenesisConfig.NETWORK_ID) {\n        if (!(sender instanceof Address)) throw new Error('Malformed sender');\n        if (!NumberUtils.isUint8(senderType)) throw new Error('Malformed sender type');\n        if (!(recipient instanceof Address)) throw new Error('Malformed recipient');\n        if (!NumberUtils.isUint8(recipientType)) throw new Error('Malformed recipient type');\n        if (!NumberUtils.isUint64(value) || value === 0) throw new Error('Malformed value');\n        if (!NumberUtils.isUint64(fee)) throw new Error('Malformed fee');\n        if (!NumberUtils.isUint32(validityStartHeight)) throw new Error('Malformed validityStartHeight');\n        if (!NumberUtils.isUint8(flags) && (flags & ~(Transaction.Flag.ALL)) > 0) throw new Error('Malformed flags');\n        if (!(data instanceof Uint8Array) || !(NumberUtils.isUint16(data.byteLength))) throw new Error('Malformed data');\n        if (proof && (!(proof instanceof Uint8Array) || !(NumberUtils.isUint16(proof.byteLength)))) throw new Error('Malformed proof');\n        if (!NumberUtils.isUint8(networkId)) throw new Error('Malformed networkId');\n\n        /** @type {Transaction.Format} */\n        this._format = format;\n        /** @type {Address} */\n        this._sender = sender;\n        /** @type {Account.Type} */\n        this._senderType = senderType;\n        /** @type {Address} */\n        this._recipient = recipient;\n        /** @type {Account.Type} */\n        this._recipientType = recipientType;\n        /** @type {number} */\n        this._value = value;\n        /** @type {number} */\n        this._fee = fee;\n        /** @type {number} */\n        this._networkId = networkId;\n        /** @type {number} */\n        this._validityStartHeight = validityStartHeight;\n        /** @type {Transaction.Flag | *} */\n        this._flags = flags;\n        /** @type {Uint8Array} */\n        this._data = data;\n        /** @type {Uint8Array} */\n        this._proof = proof;\n\n        if (this._recipient === Address.CONTRACT_CREATION) this._recipient = this.getContractCreationAddress();\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const format = /** @type {Transaction.Format} */ buf.readUint8();\n        buf.readPos--;\n\n        if (!Transaction.FORMAT_MAP.has(format)) throw new Error('Invalid transaction type');\n        return Transaction.FORMAT_MAP.get(format).unserialize(buf);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serializeContent(buf) {\n        buf = buf || new SerialBuffer(this.serializedContentSize);\n        buf.writeUint16(this._data.byteLength);\n        buf.write(this._data);\n        this._sender.serialize(buf);\n        buf.writeUint8(this._senderType);\n        this._recipient.serialize(buf);\n        buf.writeUint8(this._recipientType);\n        buf.writeUint64(this._value);\n        buf.writeUint64(this._fee);\n        buf.writeUint32(this._validityStartHeight);\n        buf.writeUint8(this._networkId);\n        buf.writeUint8(this._flags);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedContentSize() {\n        return /*dataSize*/ 2\n            + this._data.byteLength\n            + this._sender.serializedSize\n            + /*senderType*/ 1\n            + this._recipient.serializedSize\n            + /*recipientType*/ 1\n            + /*value*/ 8\n            + /*fee*/ 8\n            + /*validityStartHeight*/ 4\n            + /*networkId*/ 1\n            + /*flags*/ 1;\n    }\n\n    /**\n     * @param {number} [networkId]\n     * @returns {boolean}\n     */\n    verify(networkId) {\n        if (this._valid === undefined) {\n            this._valid = this._verify(networkId);\n        }\n        return this._valid;\n    }\n\n    /**\n     * @param {number} [networkId]\n     * @returns {boolean}\n     * @private\n     */\n    _verify(networkId = GenesisConfig.NETWORK_ID) {\n        if (this._networkId !== networkId) {\n            Log.w(Transaction, 'Transaction is not valid in this network', this);\n            return false;\n        }\n        // Check that sender != recipient.\n        if (this._recipient.equals(this._sender)) {\n            Log.w(Transaction, 'Sender and recipient must not match', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.has(this._senderType) || !Account.TYPE_MAP.has(this._recipientType)) {\n            Log.w(Transaction, 'Invalid account type', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.get(this._senderType).verifyOutgoingTransaction(this)) {\n            Log.w(Transaction, 'Invalid for sender', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.get(this._recipientType).verifyIncomingTransaction(this)) {\n            Log.w(Transaction, 'Invalid for recipient', this);\n            return false;\n        }\n        return true;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        throw new Error('Getter needs to be overwritten by subclasses');\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        throw new Error('Method needs to be overwritten by subclasses');\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        // Exclude the signature, we don't want transactions to be malleable.\n        this._hash = this._hash || Hash.light(this.serializeContent());\n        return this._hash;\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {number}\n     */\n    compare(o) {\n        if (this.fee / this.serializedSize > o.fee / o.serializedSize) return -1;\n        if (this.fee / this.serializedSize < o.fee / o.serializedSize) return 1;\n        if (this.serializedSize > o.serializedSize) return -1;\n        if (this.serializedSize < o.serializedSize) return 1;\n        if (this.fee > o.fee) return -1;\n        if (this.fee < o.fee) return 1;\n        if (this.value > o.value) return -1;\n        if (this.value < o.value) return 1;\n        return this.compareBlockOrder(o);\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {number}\n     */\n    compareBlockOrder(o) {\n        // This function must return 0 iff this.equals(o).\n        const recCompare = this._recipient.compare(o._recipient);\n        if (recCompare !== 0) return recCompare;\n        if (this._validityStartHeight < o._validityStartHeight) return -1;\n        if (this._validityStartHeight > o._validityStartHeight) return 1;\n        if (this._fee > o._fee) return -1;\n        if (this._fee < o._fee) return 1;\n        if (this._value > o._value) return -1;\n        if (this._value < o._value) return 1;\n        const senderCompare = this._sender.compare(o._sender);\n        if (senderCompare !== 0) return senderCompare;\n        if (this._recipientType < o._recipientType) return -1;\n        if (this._recipientType > o._recipientType) return 1;\n        if (this._senderType < o._senderType) return -1;\n        if (this._senderType > o._senderType) return 1;\n        if (this._flags < o._flags) return -1;\n        if (this._flags > o._flags) return 1;\n        return BufferUtils.compare(this._data, o._data);\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {boolean}\n     */\n    equals(o) {\n        // This ignores format and proof to be consistent with hash():\n        //   tx1.hash() == tx2.hash() iff tx1.equals(t2)\n        return o instanceof Transaction\n            && this._sender.equals(o._sender)\n            && this._senderType === o._senderType\n            && this._recipient.equals(o._recipient)\n            && this._recipientType === o._recipientType\n            && this._value === o._value\n            && this._fee === o._fee\n            && this._validityStartHeight === o._validityStartHeight\n            && this._networkId === o._networkId\n            && this._flags === o._flags\n            && BufferUtils.equals(this._data, o._data);\n    }\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return `Transaction{`\n            + `sender=${this._sender.toBase64()}, `\n            + `recipient=${this._recipient.toBase64()}, `\n            + `value=${this._value}, `\n            + `fee=${this._fee}, `\n            + `validityStartHeight=${this._validityStartHeight}, `\n            + `networkId=${this._networkId}`\n            + `}`;\n    }\n\n    /**\n     * @return {Address}\n     */\n    getContractCreationAddress() {\n        const tx = Transaction.unserialize(this.serialize());\n        tx._recipient = Address.NULL;\n        tx._hash = null;\n        return Address.fromHash(tx.hash());\n    }\n\n    /** @type {Address} */\n    get sender() {\n        return this._sender;\n    }\n\n    /** @type {Account.Type} */\n    get senderType() {\n        return this._senderType;\n    }\n\n    /** @type {Address} */\n    get recipient() {\n        return this._recipient;\n    }\n\n    /** @type {Account.Type} */\n    get recipientType() {\n        return this._recipientType;\n    }\n\n    /** @type {number} */\n    get value() {\n        return this._value;\n    }\n\n    /** @type {number} */\n    get fee() {\n        return this._fee;\n    }\n\n    /** @type {number} */\n    get feePerByte() {\n        return this._fee / this.serializedSize;\n    }\n\n    /** @type {number} */\n    get networkId() {\n        return this._networkId;\n    }\n\n    /** @type {number} */\n    get validityStartHeight() {\n        return this._validityStartHeight;\n    }\n\n    /** @type {number} */\n    get flags() {\n        return this._flags;\n    }\n\n    /**\n     * @param {Transaction.Flag} flag\n     * @returns {boolean}\n     */\n    hasFlag(flag) {\n        return (this._flags & flag) > 0;\n    }\n\n    /** @type {Uint8Array} */\n    get data() {\n        return this._data;\n    }\n\n    /** @type {Uint8Array} */\n    get proof() {\n        return this._proof;\n    }\n\n    // Sender proof is set by the Wallet after signing a transaction.\n    /** @type {Uint8Array} */\n    set proof(proof) {\n        this._proof = proof;\n    }\n}\n\n/**\n * Enum for Transaction formats.\n * @enum\n */\nTransaction.Format = {\n    BASIC: 0,\n    EXTENDED: 1\n};\n/**\n * @enum\n */\nTransaction.Flag = {\n    NONE: 0,\n    CONTRACT_CREATION: 0b1,\n    ALL: 0b1\n};\n/** @type {Map.<Transaction.Format, {unserialize: function(buf: SerialBuffer):Transaction}>} */\nTransaction.FORMAT_MAP = new Map();\n\nClass.register(Transaction);\n","class SignatureProof {\n    /**\n     * @param {Transaction} transaction\n     * @returns {boolean}\n     */\n    static verifyTransaction(transaction) {\n        try {\n            const buffer = new SerialBuffer(transaction.proof);\n            const proof = SignatureProof.unserialize(buffer);\n\n            // Reject proof if it is longer than needed.\n            if (buffer.readPos !== buffer.byteLength) {\n                Log.w(SignatureProof, 'Invalid SignatureProof - overlong');\n                return false;\n            }\n\n            return proof.verify(transaction.sender, transaction.serializeContent());\n        } catch (e) {\n            Log.w(SignatureProof, `Failed to verify transaction: ${e.message || e}`, e);\n            return false;\n        }\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Signature} signature\n     * @returns {SignatureProof}\n     */\n    static singleSig(publicKey, signature) {\n        return new SignatureProof(publicKey, new MerklePath([]), signature);\n    }\n\n    /**\n     * @param {PublicKey} signerKey\n     * @param {Array.<PublicKey>} publicKeys\n     * @param {Signature} signature\n     * @returns {SignatureProof}\n     */\n    static multiSig(signerKey, publicKeys, signature) {\n        const merklePath = MerklePath.compute(publicKeys, signerKey);\n        return new SignatureProof(signerKey, merklePath, signature);\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {MerklePath} merklePath\n     * @param {Signature} signature\n     */\n    constructor(publicKey, merklePath, signature) {\n        if (!(publicKey instanceof PublicKey)) throw new Error('Malformed publickKey');\n        if (!(merklePath instanceof MerklePath)) throw new Error('Malformed merklePath');\n        if (signature && !(signature instanceof Signature)) throw new Error('Malformed signature');\n\n        /**\n         * @type {PublicKey}\n         * @private\n         */\n        this._publicKey = publicKey;\n        /**\n         * @type {MerklePath}\n         * @private\n         */\n        this._merklePath = merklePath;\n        /**\n         * @type {Signature}\n         * @private\n         */\n        this._signature = signature;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {SignatureProof}\n     */\n    static unserialize(buf) {\n        const publicKey = PublicKey.unserialize(buf);\n        const merklePath = MerklePath.unserialize(buf);\n        const signature = Signature.unserialize(buf);\n        return new SignatureProof(publicKey, merklePath, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._publicKey.serialize(buf);\n        this._merklePath.serialize(buf);\n\n        // The SignatureProof is sometimes serialized before the signature is set (e.g. when creating transactions).\n        // Simply don't serialize the signature if it's missing as this should never go over the wire.\n        // We always expect the signature to be present when unserializing.\n        if (this._signature) {\n            this._signature.serialize(buf);\n        }\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._publicKey.serializedSize\n            + this._merklePath.serializedSize\n            + (this._signature ? this._signature.serializedSize : 0);\n    }\n\n    /**\n     * @param {SignatureProof} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof SignatureProof\n            && this._publicKey.equals(o._publicKey)\n            && this._merklePath.equals(o._merklePath)\n            && (this._signature ? this._signature.equals(o._signature) : this._signature === o._signature);\n    }\n\n    /**\n     * @param {?Address} sender\n     * @param {Uint8Array} data\n     * @returns {boolean}\n     */\n    verify(sender, data) {\n        if (sender !== null && !this.isSignedBy(sender)) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signer does not match sender address');\n            return false;\n        }\n\n        if (!this._signature) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signature is missing');\n            return false;\n        }\n\n        if (!this._signature.verify(this._publicKey, data)) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signature is invalid');\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {Address} sender\n     * @returns {boolean}\n     */\n    isSignedBy(sender) {\n        const merkleRoot = this._merklePath.computeRoot(this._publicKey);\n        const signerAddr = Address.fromHash(merkleRoot);\n        return signerAddr.equals(sender);\n    }\n\n    /** @type {PublicKey} */\n    get publicKey() {\n        return this._publicKey;\n    }\n\n    /** @type {MerklePath} */\n    get merklePath() {\n        return this._merklePath;\n    }\n\n    /** @type {Signature} */\n    get signature() {\n        return this._signature;\n    }\n\n    /** @type {Signature} */\n    set signature(signature) {\n        this._signature = signature;\n    }\n}\n\nClass.register(SignatureProof);\n","class BasicTransaction extends Transaction {\n    /**\n     * @param {PublicKey} senderPubKey\n     * @param {Address} recipient\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Signature} [signature]\n     * @param {number} [networkId]\n     */\n    constructor(senderPubKey, recipient, value, fee, validityStartHeight, signature, networkId) {\n        if (!(senderPubKey instanceof PublicKey)) throw new Error('Malformed senderPubKey');\n        // Signature may be initially empty and can be set later.\n        if (signature !== undefined && !(signature instanceof Signature)) throw new Error('Malformed signature');\n\n        const proof = SignatureProof.singleSig(senderPubKey, signature);\n        super(Transaction.Format.BASIC, senderPubKey.toAddress(), Account.Type.BASIC, recipient, Account.Type.BASIC, value, fee, validityStartHeight, Transaction.Flag.NONE, new Uint8Array(0), proof.serialize(), networkId);\n\n        /**\n         * @type {SignatureProof}\n         * @private\n         */\n        this._signatureProof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        Assert.that(type === Transaction.Format.BASIC);\n\n        const senderPubKey = PublicKey.unserialize(buf);\n        const recipient = Address.unserialize(buf);\n        const value = buf.readUint64();\n        const fee = buf.readUint64();\n        const validityStartHeight = buf.readUint32();\n        const networkId = buf.readUint8();\n        const signature = Signature.unserialize(buf);\n        return new BasicTransaction(senderPubKey, recipient, value, fee, validityStartHeight, signature, networkId);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(Transaction.Format.BASIC);\n        this.senderPubKey.serialize(buf);\n        this._recipient.serialize(buf);\n        buf.writeUint64(this._value);\n        buf.writeUint64(this._fee);\n        buf.writeUint32(this._validityStartHeight);\n        buf.writeUint8(this._networkId);\n        this.signature.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*type*/ 1\n            + this.senderPubKey.serializedSize\n            + this._recipient.serializedSize\n            + /*value*/ 8\n            + /*fee*/ 8\n            + /*validityStartHeight*/ 4\n            + /*networkId*/ 1\n            + this.signature.serializedSize;\n    }\n\n    /**\n     * @type {PublicKey}\n     */\n    get senderPubKey() {\n        return this._signatureProof.publicKey;\n    }\n\n    /**\n     * @type {Signature}\n     */\n    get signature() {\n        return this._signatureProof.signature;\n    }\n\n    /**\n     * @type {Signature}\n     */\n    set signature(signature) {\n        this._signatureProof.signature = signature;\n        this._proof = this._signatureProof.serialize();\n    }\n}\nTransaction.FORMAT_MAP.set(Transaction.Format.BASIC, BasicTransaction);\nClass.register(BasicTransaction);\n","class ExtendedTransaction extends Transaction {\n\n    /**\n     * @param {Address} sender\n     * @param {Account.Type} senderType\n     * @param {Address} recipient\n     * @param {Account.Type} recipientType\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Transaction.Flag | *} flags\n     * @param {Uint8Array} data\n     * @param {Uint8Array} [proof]\n     * @param {number} [networkId]\n     */\n    constructor(sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof = new Uint8Array(0), networkId) {\n        super(Transaction.Format.EXTENDED, sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof, networkId);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const type = /** @type {Transaction.Format} */ buf.readUint8();\n        Assert.that(type === Transaction.Format.EXTENDED);\n\n        const dataSize = buf.readUint16();\n        const data = buf.read(dataSize);\n        const sender = Address.unserialize(buf);\n        const senderType = /** @type {Account.Type} */ buf.readUint8();\n        const recipient = Address.unserialize(buf);\n        const recipientType = /** @type {Account.Type} */ buf.readUint8();\n        const value = buf.readUint64();\n        const fee = buf.readUint64();\n        const validityStartHeight = buf.readUint32();\n        const networkId = buf.readUint8();\n        const flags = buf.readUint8();\n        const proofSize = buf.readUint16();\n        const proof = buf.read(proofSize);\n        return new ExtendedTransaction(sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof, networkId);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(Transaction.Format.EXTENDED);\n        this.serializeContent(buf);\n        buf.writeUint16(this._proof.byteLength);\n        buf.write(this._proof);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*type*/ 1\n            + this.serializedContentSize\n            + /*proofSize*/ 2\n            + this._proof.byteLength;\n    }\n}\n\nTransaction.FORMAT_MAP.set(Transaction.Format.EXTENDED, ExtendedTransaction);\nClass.register(ExtendedTransaction);\n","class TransactionsProof {\n    /**\n     * @param {Array.<Transaction>} transactions\n     * @param {MerkleProof} proof\n     */\n    constructor(transactions, proof) {\n        if (!Array.isArray(transactions) || !NumberUtils.isUint16(transactions.length)\n            || transactions.some(it => !(it instanceof Transaction))) throw new Error('Malformed transactions');\n        if (!(proof instanceof MerkleProof)) throw new Error('Malformed merkle proof');\n\n        /** @type {Array.<Transaction>} */\n        this._transactions = transactions;\n        /** @type {MerkleProof} */\n        this._proof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {TransactionsProof}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint16();\n        const transactions = [];\n        for (let i = 0; i < count; ++i) {\n            transactions.push(Transaction.unserialize(buf));\n        }\n        const proof = MerkleProof.unserialize(buf);\n        return new TransactionsProof(transactions, proof);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._transactions.length);\n        for (const transaction of this._transactions) {\n            transaction.serialize(buf);\n        }\n        this._proof.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*count*/ 2\n            + this._transactions.reduce((sum, transaction) => sum + transaction.serializedSize, 0)\n            + this._proof.serializedSize;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `TransactionsProof{length=${this.length}}`;\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    root() {\n        return this._proof.computeRoot(this._transactions);\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._transactions.length;\n    }\n\n    /** @type {Array.<Transaction>} */\n    get transactions() {\n        return this._transactions;\n    }\n\n    /** @type {MerkleProof} */\n    get proof() {\n        return this._proof;\n    }\n}\nClass.register(TransactionsProof);\n","class TransactionCache {\n    /**\n     * @param {Iterable.<Transaction>} [transactions]\n     * @param {Array.<Block>} [blockOrder]\n     */\n    constructor(transactions = [], blockOrder = []) {\n        /** @type {HashSet.<Transaction>} */\n        this._transactions = new HashSet(tx => tx.hash().toBase64());\n        this._transactions.addAll(transactions);\n        /** @type {Array.<Block>} */\n        this._blockOrder = blockOrder;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @returns {boolean}\n     */\n    containsTransaction(transaction) {\n        return this._transactions.contains(transaction);\n    }\n\n    /**\n     * @param {Block} block\n     */\n    pushBlock(block) {\n        this._blockOrder.push(block);\n        this._transactions.addAll(block.transactions);\n\n        if (this._blockOrder.length > Policy.TRANSACTION_VALIDITY_WINDOW) {\n            this.shiftBlock();\n        }\n    }\n\n    shiftBlock() {\n        const block = this._blockOrder.shift();\n        if (block) {\n            this._transactions.removeAll(block.transactions);\n        }\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {number}\n     */\n    revertBlock(block) {\n        if (this._transactions.isEmpty()) {\n            return this.missingBlocks;\n        }\n\n        const blockFromOrder = this._blockOrder.pop();\n        Assert.that(blockFromOrder.equals(block), 'Invalid block to revert');\n        if (block) {\n            this._transactions.removeAll(block.transactions);\n        }\n\n        return this.missingBlocks;\n    }\n\n    /**\n     * @param {Array.<Block>} blocks\n     */\n    prependBlocks(blocks) {\n        if (blocks.length + this._blockOrder.length > Policy.TRANSACTION_VALIDITY_WINDOW) {\n            throw new Error('Exceeding transaction cache size');\n        }\n        this._blockOrder.unshift(...blocks);\n        blocks.forEach(b => this._transactions.addAll(b.transactions));\n    }\n\n    /** @type {number} */\n    get missingBlocks() {\n        return Policy.TRANSACTION_VALIDITY_WINDOW - this._blockOrder.length;\n    }\n\n    /** @type {HashSet.<Transaction>} */\n    get transactions() {\n        return this._transactions;\n    }\n\n    /**\n     * @returns {TransactionCache}\n     */\n    clone() {\n        return new TransactionCache(/** @type {Iterable.<Transaction>} */ this._transactions, this._blockOrder.slice());\n    }\n}\nClass.register(TransactionCache);\n","class TransactionStoreEntry {\n    /**\n     * @param {Hash} transactionHash\n     * @param {Address} sender\n     * @param {Address} recipient\n     * @param {number} blockHeight\n     * @param {Hash} blockHash\n     * @param {number} index\n     */\n    constructor(transactionHash, sender, recipient, blockHeight, blockHash, index) {\n        this._transactionHash = transactionHash;\n        this._sender = sender;\n        this._recipient = recipient;\n        this._blockHeight = blockHeight;\n        this._blockHash = blockHash;\n        this._index = index;\n        this.senderBuffer = this._sender.serialize();\n        this.recipientBuffer = this._recipient.serialize();\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Array.<TransactionStoreEntry>}\n     */\n    static fromBlock(block) {\n        const blockHash = block.hash();\n        /** @type {Array.<TransactionStoreEntry>} */\n        const entries = [];\n        for (let i = 0; i < block.transactions.length; ++i) {\n            const transaction = block.transactions[i];\n            entries.push(new TransactionStoreEntry(transaction.hash(), transaction.sender, transaction.recipient, block.height, blockHash, i));\n        }\n        return entries;\n    }\n\n    /**\n     * @param {string} transactionKey\n     * @param {{senderBuffer: Uint8Array, recipientBuffer: Uint8Array, blockHeight: number, blockHash: string, index: number}} o\n     * @returns {TransactionStoreEntry}\n     */\n    static fromJSON(transactionKey, o) {\n        return new TransactionStoreEntry(\n            Hash.fromBase64(transactionKey),\n            Address.unserialize(new SerialBuffer(o.senderBuffer)),\n            Address.unserialize(new SerialBuffer(o.recipientBuffer)),\n            o.blockHeight,\n            Hash.fromBase64(o.blockHash),\n            o.index\n        );\n    }\n\n    /**\n     * @returns {{sender: Uint8Array, recipient: Uint8Array, blockHeight: number, blockHash: string, index: number}}\n     */\n    toJSON() {\n        return {\n            senderBuffer: this.senderBuffer,\n            recipientBuffer: this.recipientBuffer,\n            blockHeight: this.blockHeight,\n            blockHash: this.blockHash.toBase64(),\n            index: this.index\n        };\n    }\n\n    /** @type {Hash} */\n    get transactionHash() {\n        return this._transactionHash;\n    }\n\n    /** @type {Address} */\n    get sender() {\n        return this._sender;\n    }\n\n    /** @type {Address} */\n    get recipient() {\n        return this._recipient;\n    }\n\n    /** @type {number} */\n    get blockHeight() {\n        return this._blockHeight;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n\n    /** @type {number} */\n    get index() {\n        return this._index;\n    }\n\n    /** @type {string} */\n    get key() {\n        return this.transactionHash.toBase64();\n    }\n}\nClass.register(TransactionStoreEntry);\n","class TransactionStore {\n    /**\n     * @param {JungleDB} jdb\n     */\n    static initPersistent(jdb) {\n        const store = jdb.createObjectStore('Transactions', { codec: new TransactionStoreCodec() });\n        store.createIndex('sender', ['senderBuffer'], { lmdbKeyEncoding: JDB.JungleDB.BINARY_ENCODING });\n        store.createIndex('recipient', ['recipientBuffer'], { lmdbKeyEncoding: JDB.JungleDB.BINARY_ENCODING });\n    }\n\n    /**\n     * @param {JungleDB} jdb\n     * @returns {TransactionStore}\n     */\n    static getPersistent(jdb) {\n        return new TransactionStore(jdb.getObjectStore('Transactions'));\n    }\n\n    /**\n     * @returns {TransactionStore}\n     */\n    static createVolatile() {\n        const store = JDB.JungleDB.createVolatileObjectStore();\n        store.createIndex('sender', ['senderBuffer']);\n        store.createIndex('recipient', ['recipientBuffer']);\n        return new TransactionStore(store);\n    }\n\n    /**\n     * @param {IObjectStore} store\n     */\n    constructor(store) {\n        this._store = store;\n    }\n\n    /**\n     * @param {Hash} transactionHash\n     * @returns {Promise.<TransactionStoreEntry>}\n     */\n    get(transactionHash) {\n        return this._store.get(transactionHash.toBase64());\n    }\n\n    /**\n     * @param {Address} sender\n     * @returns {Promise.<Array.<TransactionStoreEntry>>}\n     */\n    getBySender(sender) {\n        const index = this._store.index('sender');\n        return index.values(JDB.KeyRange.only(sender.serialize()));\n    }\n\n    /**\n     * @param {Address} recipient\n     * @returns {Promise.<Array.<TransactionStoreEntry>>}\n     */\n    getByRecipient(recipient) {\n        const index = this._store.index('recipient');\n        return index.values(JDB.KeyRange.only(recipient.serialize()));\n    }\n\n    /**\n     * @override\n     * @param {Block} block\n     * @returns {Promise}\n     */\n    async put(block) {\n        const indexedTransactions = TransactionStoreEntry.fromBlock(block);\n        const tx = this._store.transaction();\n        for (const indexedTransaction of indexedTransactions) {\n            tx.putSync(indexedTransaction.key, indexedTransaction);\n        }\n        return tx.commit();\n    }\n\n    /**\n     * @override\n     * @param {Block} block\n     * @returns {Promise}\n     */\n    async remove(block) {\n        const tx = this._store.transaction();\n        for (const transaction of block.transactions) {\n            tx.removeSync(transaction.hash().toBase64());\n        }\n        return tx.commit();\n    }\n\n    /**\n     * @param {TransactionStore} [tx]\n     * @returns {TransactionStore}\n     */\n    snapshot(tx) {\n        const snapshot = this._store.snapshot();\n        if (tx) {\n            snapshot.inherit(tx._store);\n        }\n        return new TransactionStore(snapshot);\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {TransactionStore}\n     */\n    transaction(enableWatchdog = true) {\n        const tx = this._store.transaction(enableWatchdog);\n        return new TransactionStore(tx);\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    truncate() {\n        return this._store.truncate();\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    commit() {\n        return this._store.commit();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    abort() {\n        return this._store.abort();\n    }\n\n    /** @type {Transaction} */\n    get tx() {\n        if (this._store instanceof JDB.Transaction) {\n            return this._store;\n        }\n        return undefined;\n    }\n}\nClass.register(TransactionStore);\n\n/**\n * @implements {ICodec}\n */\nclass TransactionStoreCodec {\n    /**\n     * @param {*} obj The object to encode before storing it.\n     * @returns {*} Encoded object.\n     */\n    encode(obj) {\n        return obj.toJSON();\n    }\n\n    /**\n     * @param {*} obj The object to decode.\n     * @param {string} key The object's primary key.\n     * @returns {*} Decoded object.\n     */\n    decode(obj, key) {\n        return TransactionStoreEntry.fromJSON(key, obj);\n    }\n\n    /**\n     * @type {{encode: function(val:*):*, decode: function(val:*):*, buffer: boolean, type: string}|void}\n     */\n    get valueEncoding() {\n        return JDB.JungleDB.JSON_ENCODING;\n    }\n}\n","class TransactionReceipt {\n    /**\n     * @param {Hash} transactionHash\n     * @param {Hash} blockHash\n     * @param {number} blockHeight\n     */\n    constructor(transactionHash, blockHash, blockHeight) {\n        this._transactionHash = transactionHash;\n        this._blockHash = blockHash;\n        this._blockHeight = blockHeight;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {TransactionReceipt}\n     */\n    static unserialize(buf) {\n        const transactionHash = Hash.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const blockHeight = buf.readUint32();\n        return new TransactionReceipt(transactionHash, blockHash, blockHeight);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._transactionHash.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeUint32(this._blockHeight);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._transactionHash.serializedSize\n            + this._blockHash.serializedSize\n            + /*blockHeight*/ 4;\n    }\n\n    /** @type {Hash} */\n    get transactionHash() {\n        return this._transactionHash;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n\n    /** @type {number} */\n    get blockHeight() {\n        return this._blockHeight;\n    }\n}\nClass.register(TransactionReceipt);\n","class Block {\n    /**\n     * @param {Block} o\n     * @returns {Block}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new Block(\n            BlockHeader.copy(o._header),\n            BlockInterlink.copy(o._interlink),\n            BlockBody.copy(o._body)\n        );\n    }\n\n    /**\n     * @param {BlockHeader} header\n     * @param {BlockInterlink} interlink\n     * @param {BlockBody} [body]\n     */\n    constructor(header, interlink, body) {\n        if (!(header instanceof BlockHeader)) throw 'Malformed header';\n        if (!(interlink instanceof BlockInterlink)) throw 'Malformed interlink';\n        if (body && !(body instanceof BlockBody)) throw 'Malformed body';\n\n        /** @type {BlockHeader} */\n        this._header = header;\n        /** @type {BlockInterlink} */\n        this._interlink = interlink;\n        /** @type {BlockBody} */\n        this._body = body;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {Block}\n     */\n    static unserialize(buf) {\n        const header = BlockHeader.unserialize(buf);\n        const interlink = BlockInterlink.unserialize(buf, header.prevHash);\n\n        let body = undefined;\n        const bodyPresent = buf.readUint8();\n        if (bodyPresent) {\n            body = BlockBody.unserialize(buf);\n        }\n\n        return new Block(header, interlink, body);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._header.serialize(buf);\n        this._interlink.serialize(buf);\n\n        if (this._body) {\n            buf.writeUint8(1);\n            this._body.serialize(buf);\n        } else {\n            buf.writeUint8(0);\n        }\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._header.serializedSize\n            + this._interlink.serializedSize\n            + /*bodyPresent*/ 1\n            + (this._body ? this._body.serializedSize : 0);\n    }\n\n    /**\n     * @param {Time} time\n     * @returns {Promise.<boolean>}\n     */\n    async verify(time) {\n        if (this._valid === undefined) {\n            if (this.isLight() || this.body.transactions.length < 150 || !IWorker.areWorkersAsync) {\n                // worker overhead doesn't pay off for small transaction numbers\n                this._valid = await this._verify(time.now());\n            } else {\n                const transactionValid = this.body.transactions.map(t => t._valid);\n                const worker = await CryptoWorker.getInstanceAsync();\n                const {valid, pow, interlinkHash, bodyHash} = await worker.blockVerify(this.serialize(),\n                    transactionValid, time.now(), GenesisConfig.GENESIS_HASH.serialize(), GenesisConfig.NETWORK_ID);\n                this._valid = valid;\n                this.header._pow = Hash.unserialize(new SerialBuffer(pow));\n                this.interlink._hash = Hash.unserialize(new SerialBuffer(interlinkHash));\n                this.body._hash = Hash.unserialize(new SerialBuffer(bodyHash));\n            }\n        }\n        return this._valid;\n    }\n\n    /**\n     * @param {number} timeNow\n     * @returns {Promise.<boolean>}\n     */\n    async _verify(timeNow) {\n        // Check that the timestamp is not too far into the future.\n        if (this._header.timestamp * 1000 > timeNow + Block.TIMESTAMP_DRIFT_MAX * 1000) {\n            Log.w(Block, 'Invalid block - timestamp too far in the future');\n            return false;\n        }\n\n        // Check that the header hash matches the difficulty.\n        if (!(await this._header.verifyProofOfWork())) {\n            Log.w(Block, 'Invalid block - PoW verification failed');\n            return false;\n        }\n\n        // Check that the maximum block size is not exceeded.\n        if (this.serializedSize > Policy.BLOCK_SIZE_MAX) {\n            Log.w(Block, 'Invalid block - max block size exceeded');\n            return false;\n        }\n\n        // Verify that the interlink is valid.\n        if (!this._verifyInterlink()) {\n            return false;\n        }\n\n        // XXX Verify the body only if it is present.\n        if (this.isFull() && !this._verifyBody()) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n    _verifyInterlink() {\n        // Skip check for genesis block due to the cyclic dependency (since the interlink hash contains the genesis block hash).\n        if (this.height === 1 && this._header.interlinkHash.equals(new Hash(null))) {\n            return true;\n        }\n\n        // Check that the interlinkHash given in the header matches the actual interlinkHash.\n        const interlinkHash = this._interlink.hash();\n        if (!this._header.interlinkHash.equals(interlinkHash)) {\n            Log.w(Block, 'Invalid block - interlink hash mismatch');\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n    _verifyBody() {\n        // Check that the body is valid.\n        if (!this._body.verify()) {\n            return false;\n        }\n\n        // Check that bodyHash given in the header matches the actual body hash.\n        const bodyHash = this._body.hash();\n        if (!this._header.bodyHash.equals(bodyHash)) {\n            Log.w(Block, 'Invalid block - body hash mismatch');\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {Block} predecessor\n     * @returns {Promise.<boolean>}\n     */\n    async isImmediateSuccessorOf(predecessor) {\n        // Check the header.\n        if (!this._header.isImmediateSuccessorOf(predecessor.header)) {\n            return false;\n        }\n\n        // Check that the interlink is correct.\n        const interlink = await predecessor.getNextInterlink(this.target, this.version);\n        if (!this._interlink.equals(interlink)) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {Block} predecessor\n     * @returns {Promise.<boolean>}\n     */\n    async isInterlinkSuccessorOf(predecessor) {\n        // Check that the height is higher than the predecessor's.\n        if (this._header.height <= predecessor.header.height) {\n            Log.v(Block, 'No interlink successor - height');\n            return false;\n        }\n\n        // Check that the timestamp is greater or equal to the predecessor's timestamp.\n        if (this._header.timestamp < predecessor.header.timestamp) {\n            Log.v(Block, 'No interlink successor - timestamp');\n            return false;\n        }\n\n        // Check that the predecessor is contained in this block's interlink and verify its position.\n        const prevHash = predecessor.hash();\n        if (!GenesisConfig.GENESIS_HASH.equals(prevHash)) {\n            const prevPow = await predecessor.pow();\n            const targetHeight = BlockUtils.getTargetHeight(this.target);\n            let blockFound = false;\n\n            let depth = 0;\n            for (; depth < this._interlink.length; depth++) {\n                if (prevHash.equals(this._interlink.hashes[depth])) {\n                    blockFound = true;\n                    if (!BlockUtils.isProofOfWork(prevPow, Math.pow(2, targetHeight - depth))) {\n                        Log.v(Block, 'No interlink successor - invalid position in interlink');\n                        return false;\n                    }\n                }\n            }\n\n            if (!blockFound) {\n                Log.v(Block, 'No interlink successor - not in interlink');\n                return false;\n            }\n        }\n\n        // If the predecessor happens to be the immediate predecessor, check additionally:\n        // - that the height of the successor is one higher\n        // - that the interlink is correct.\n        if (this._header.prevHash.equals(prevHash)) {\n            if (this._header.height !== predecessor.header.height + 1) {\n                Log.v(Block, 'No interlink successor - immediate height');\n                return false;\n            }\n\n            const interlink = await predecessor.getNextInterlink(this.target, this.version);\n            const interlinkHash = interlink.hash();\n            if (!this._header.interlinkHash.equals(interlinkHash)) {\n                Log.v(Block, 'No interlink successor - immediate interlink');\n                return false;\n            }\n        }\n        // Otherwise, if the prevHash doesn't match but the blocks should be adjacent according to their height fields,\n        // this cannot be a valid successor of predecessor.\n        else if (this._header.height === predecessor.height.height + 1) {\n            Log.v(Block, 'No interlink successor - immediate height (2)');\n            return false;\n        }\n        // Otherwise, check that the interlink construction is valid given the information we have.\n        else {\n            // TODO Take different targets into account.\n\n            // The number of new blocks in the interlink is bounded by the height difference.\n            /** @type {HashSet.<Hash>} */\n            const hashes = new HashSet();\n            hashes.addAll(this._interlink.hashes);\n            hashes.removeAll(predecessor.interlink.hashes);\n            if (hashes.length > this._header.height - predecessor.header.height) {\n                Log.v(Block, 'No interlink successor - too many new blocks');\n                return false;\n            }\n\n            // Check that the interlink is not too short.\n            const thisDepth = BlockUtils.getTargetDepth(this.target);\n            const prevDepth = BlockUtils.getTargetDepth(predecessor.target);\n            const depthDiff = thisDepth - prevDepth;\n            if (this._interlink.length < predecessor.interlink.length - depthDiff) {\n                Log.v(Block, 'No interlink successor - interlink too short');\n                return false;\n            }\n\n            // If the same block is found in both interlinks, all blocks at lower depths must be the same in both interlinks.\n            let commonBlock = false;\n            const thisInterlink = this._interlink.hashes;\n            const prevInterlink = predecessor.interlink.hashes;\n            for (let i = 1; i < prevInterlink.length && i - depthDiff < thisInterlink.length; i++) {\n                if (prevInterlink[i].equals(thisInterlink[i - depthDiff])) {\n                    commonBlock = true;\n                }\n                else if (commonBlock) {\n                    Log.v(Block, 'No interlink successor - invalid common suffix');\n                    return false;\n                }\n            }\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {Block} predecessor\n     * @returns {Promise.<boolean>}\n     */\n    async isSuccessorOf(predecessor) {\n        // TODO Improve this! Lots of duplicate checks.\n        return (await this.isImmediateSuccessorOf(predecessor)) || (await this.isInterlinkSuccessorOf(predecessor));\n    }\n\n    /**\n     * @param {number} nextTarget\n     * @param {number} [nextVersion]\n     * @returns {Promise.<BlockInterlink>}\n     */\n    async getNextInterlink(nextTarget, nextVersion = BlockHeader.CURRENT_VERSION) {\n        /** @type {Array.<Hash>} */\n        const hashes = [];\n        const hash = this.hash();\n\n        // Compute how many times this blockHash should be included in the next interlink.\n        const thisPowDepth = BlockUtils.getHashDepth(await this.pow());\n        const nextTargetDepth = BlockUtils.getTargetDepth(nextTarget);\n        const numOccurrences = Math.max(thisPowDepth - nextTargetDepth + 1, 0);\n\n        // Push this blockHash numOccurrences times onto the next interlink.\n        for (let i = 0; i < numOccurrences; i++) {\n            hashes.push(hash);\n        }\n\n        // Compute how many blocks to omit from the beginning of this interlink.\n        const thisTargetDepth = BlockUtils.getTargetDepth(this.target);\n        const targetOffset = nextTargetDepth - thisTargetDepth;\n        const interlinkOffset = numOccurrences + targetOffset;\n\n        // Push the remaining hashes from this interlink.\n        for (let i = interlinkOffset; i < this.interlink.length; i++) {\n            hashes.push(this.interlink.hashes[i]);\n        }\n        \n        return new BlockInterlink(hashes, hash);\n    }\n\n    /**\n     * @param {Block|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof Block\n            && this._header.equals(o._header)\n            && this._interlink.equals(o._interlink)\n            && (this._body ? this._body.equals(o._body) : !o._body);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isLight() {\n        return !this._body;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isFull() {\n        return !!this._body;\n    }\n\n    /**\n     * @returns {Block}\n     */\n    toLight() {\n        return this.isLight() ? this : new Block(this._header, this._interlink);\n    }\n\n    /**\n     * @param {BlockBody} body\n     * @returns {Block}\n     */\n    toFull(body) {\n        return this.isFull() ? this : new Block(this._header, this._interlink, body);\n    }\n\n    /**\n     * @type {BlockHeader}\n     */\n    get header() {\n        return this._header;\n    }\n\n    /**\n     * @type {BlockInterlink}\n     */\n    get interlink() {\n        return this._interlink;\n    }\n\n    /**\n     * @type {BlockBody}\n     */\n    get body() {\n        if (this.isLight()) {\n            throw 'Cannot access body of light block';\n        }\n        return this._body;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get version() {\n        return this._header.version;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    get prevHash() {\n        return this._header.prevHash;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    get bodyHash() {\n        return this._header.bodyHash;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    get accountsHash() {\n        return this._header.accountsHash;\n    }\n\n    /**\n     * @type {number}\n     */\n    get nBits() {\n        return this._header.nBits;\n    }\n\n    /**\n     * @type {number}\n     */\n    get target() {\n        return this._header.target;\n    }\n\n    /**\n     * @type {number}\n     */\n    get difficulty() {\n        return this._header.difficulty;\n    }\n\n    /**\n     * @type {number}\n     */\n    get height() {\n        return this._header.height;\n    }\n    \n    /**\n     * @type {number}\n     */\n    get timestamp() {\n        return this._header.timestamp;\n    }\n\n    /**\n     * @type {number}\n     */\n    get nonce() {\n        return this._header.nonce;\n    }\n\n    /**\n     * @type {Address}\n     */\n    get minerAddr() {\n        return this._body.minerAddr;\n    }\n\n    /**\n     * @type {Array.<Transaction>}\n     */\n    get transactions() {\n        return this._body.transactions;\n    }\n\n    /**\n     * @type {number}\n     */\n    get transactionCount() {\n        return this._body.transactionCount;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {Hash}\n     */\n    hash(buf) {\n        return this._header.hash(buf);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {Promise.<Hash>}\n     */\n    pow(buf) {\n        return this._header.pow(buf);\n    }\n\n}\nBlock.TIMESTAMP_DRIFT_MAX = 600 /* seconds */; // 10 minutes\nClass.register(Block);\n","/**\n * @interface\n */\nclass IBlockchain extends Observable {\n    /**\n     * @abstract\n     * @type {Block}\n     */\n    get head() {}\n\n    /**\n     * @abstract\n     * @type {Hash}\n     */\n    get headHash() {}\n\n    /**\n     * @abstract\n     * @type {number}\n     */\n    get height() {}\n}\nClass.register(IBlockchain);\n","/**\n * @abstract\n */\nclass BaseChain extends IBlockchain {\n    /**\n     * @param {ChainDataStore} store\n     */\n    constructor(store) {\n        super();\n        this._store = store;\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {boolean} [includeForks]\n     * @param {boolean} [includeBody]\n     * @returns {Promise.<?Block>}\n     */\n    async getBlock(hash, includeForks = false, includeBody = false) {\n        const chainData = await this._store.getChainData(hash, includeBody);\n        return chainData && (chainData.onMainChain || includeForks) ? chainData.head : null;\n    }\n\n    /**\n     * @param {number} height\n     * @param {boolean} [includeBody]\n     * @returns {Promise.<?Block>}\n     */\n    getBlockAt(height, includeBody = false) {\n        return this._store.getBlockAt(height, includeBody) || null;\n    }\n\n    /**\n     * @param {number} height\n     * @param {boolean} [lower]\n     * @returns {Promise.<?Block>}\n     */\n    getNearestBlockAt(height, lower = true) {\n        return this._store.getNearestBlockAt(height, lower) || null;\n    }\n\n    /**\n     * @returns {Promise.<Array.<Hash>>}\n     */\n    async getBlockLocators() {\n        // Push top 10 hashes first, then back off exponentially.\n        /** @type {Array.<Hash>} */\n        const locators = [this.headHash];\n\n        let block = this.head;\n        for (let i = Math.min(10, this.height) - 1; i > 0; i--) {\n            if (!block) {\n                break;\n            }\n            locators.push(block.prevHash);\n            block = await this.getBlock(block.prevHash); // eslint-disable-line no-await-in-loop\n        }\n\n        let step = 2;\n        for (let i = this.height - 10 - step; i > 0; i -= step) {\n            block = await this.getBlockAt(i); // eslint-disable-line no-await-in-loop\n            if (block) {\n                locators.push(await block.hash()); // eslint-disable-line no-await-in-loop\n            }\n            step *= 2;\n        }\n\n        // Push the genesis block hash.\n        if (locators.length === 0 || !locators[locators.length - 1].equals(GenesisConfig.GENESIS_HASH)) {\n            locators.push(GenesisConfig.GENESIS_HASH);\n        }\n\n        return locators;\n    }\n\n    /**\n     * Computes the target value for the block after the given block or the head of this chain if no block is given.\n     * @param {Block} [block]\n     * @returns {Promise.<number>}\n     */\n    async getNextTarget(block) {\n        /** @type {ChainData} */\n        let headData;\n        if (block) {\n            const hash = block.hash();\n            headData = await this._store.getChainData(hash);\n            Assert.that(!!headData);\n        } else {\n            block = this.head;\n            headData = this._mainChain;\n        }\n\n        // Retrieve the timestamp of the block that appears DIFFICULTY_BLOCK_WINDOW blocks before the given block in the chain.\n        // The block might not be on the main chain.\n        const tailHeight = Math.max(block.height - Policy.DIFFICULTY_BLOCK_WINDOW, 1);\n        /** @type {ChainData} */\n        let tailData;\n        if (headData.onMainChain) {\n            tailData = await this._store.getChainDataAt(tailHeight);\n        } else {\n            let prevData = headData;\n            for (let i = 0; i < Policy.DIFFICULTY_BLOCK_WINDOW && !prevData.onMainChain; i++) {\n                prevData = await this._store.getChainData(prevData.head.prevHash);\n                if (!prevData) {\n                    // Not enough blocks are available to compute the next target, fail.\n                    return -1;\n                }\n            }\n\n            if (prevData.onMainChain && prevData.head.height > tailHeight) {\n                tailData = await this._store.getChainDataAt(tailHeight);\n            } else {\n                tailData = prevData;\n            }\n        }\n\n        if (!tailData || tailData.totalDifficulty < 1) {\n            // Not enough blocks are available to compute the next target, fail.\n            return -1;\n        }\n\n        const deltaTotalDifficulty = headData.totalDifficulty - tailData.totalDifficulty;\n        return BlockUtils.getNextTarget(headData.head.header, tailData.head.header, deltaTotalDifficulty);\n    }\n\n\n\n    /* NIPoPoW Prover functions */\n\n    /**\n     * MUST be synchronized with .pushBlock() and variants!\n     * @returns {Promise.<ChainProof>}\n     * @protected\n     */\n    _getChainProof() {\n        return this._prove(Policy.M, Policy.K, Policy.DELTA);\n    }\n\n    /**\n     * The \"Prove\" algorithm from the NIPoPow paper.\n     * @param {number} m\n     * @param {number} k\n     * @param {number} delta\n     * @returns {Promise.<ChainProof>}\n     * @private\n     */\n    async _prove(m, k, delta) {\n        Assert.that(m >= 1, 'm must be >= 1');\n        Assert.that(delta > 0, 'delta must be > 0');\n        let prefix = new BlockChain([]);\n\n        // B <- C[0]\n        let startHeight = 1;\n\n        /** @type {ChainData} */\n        const headData = await this._store.getChainDataAt(Math.max(this.height - k, 1)); // C[-k]\n        const maxDepth = headData.superBlockCounts.getCandidateDepth(m);\n\n        // for mu = |C[-k].interlink| down to 0 do\n        for (let depth = maxDepth; depth >= 0; depth--) {\n            // alpha = C[:-k]{B:}|^mu\n            /** @type {Array.<ChainData>} */\n            const alpha = await this._getSuperChain(depth, headData, startHeight); // eslint-disable-line no-await-in-loop\n\n            // pi = pi (union) alpha\n            prefix = BlockChain.merge(prefix, new BlockChain(alpha.map(data => data.head.toLight())));\n\n            // if good_(delta,m)(C, alpha, mu) then\n            if (BaseChain._isGoodSuperChain(alpha, depth, m, delta)) {\n                Assert.that(alpha.length >= m, `Good superchain expected to be at least ${m} long`);\n                Log.v(BaseChain, `Found good superchain at depth ${depth} with length ${alpha.length} (#${startHeight} - #${headData.head.height})`);\n                // B <- alpha[-m]\n                startHeight = alpha[alpha.length - m].head.height;\n            }\n        }\n\n        // X <- C[-k:]\n        const suffix = await this._getHeaderChain(this.height - headData.head.height);\n\n        // return piX\n        return new ChainProof(prefix, suffix);\n    }\n\n    /**\n     * @param {number} depth\n     * @param {ChainData} headData\n     * @param {number} [tailHeight]\n     * @returns {Promise.<Array.<ChainData>>}\n     * @private\n     */\n    async _getSuperChain(depth, headData, tailHeight = 1) {\n        Assert.that(tailHeight >= 1, 'tailHeight must be >= 1');\n        /** @type {Array.<ChainData>} */\n        const chain = [];\n\n        // Include head if it is at the requested depth or below.\n        const headDepth = BlockUtils.getHashDepth(await headData.head.pow());\n        if (headDepth >= depth) {\n            chain.push(headData);\n        }\n\n        // Follow the interlink pointers back at the requested depth.\n        /** @type {ChainData} */\n        let chainData = headData;\n        let j = Math.max(depth - BlockUtils.getTargetDepth(chainData.head.target), -1);\n        while (j < chainData.head.interlink.hashes.length && chainData.head.height > tailHeight) {\n            const reference = j < 0 ? chainData.head.prevHash : chainData.head.interlink.hashes[j];\n            chainData = await this._store.getChainData(reference); // eslint-disable-line no-await-in-loop\n            if (!chainData) {\n                // This can happen in the light/nano client if chain superquality is harmed.\n                // Return a best-effort chain in this case.\n                Log.w(BaseChain, `Failed to find block ${reference} while constructing SuperChain at depth ${depth} - returning truncated chain`);\n                break;\n            }\n            chain.push(chainData);\n\n            j = Math.max(depth - BlockUtils.getTargetDepth(chainData.head.target), -1);\n        }\n\n        if ((chain.length === 0 || chain[chain.length - 1].head.height > 1) && tailHeight === 1) {\n            chain.push(await ChainData.initial(GenesisConfig.GENESIS_BLOCK));\n        }\n\n        return chain.reverse();\n    }\n\n    /**\n     * @param {Array.<ChainData>} superchain\n     * @param {number} depth\n     * @param {number} m\n     * @param {number} delta\n     * @returns {boolean}\n     */\n    static _isGoodSuperChain(superchain, depth, m, delta) {\n        return BaseChain._hasSuperQuality(superchain, depth, m, delta)\n            && BaseChain._hasMultiLevelQuality(superchain, depth, m, delta);\n    }\n\n    /**\n     * @param {Array.<ChainData>} superchain\n     * @param {number} depth\n     * @param {number} m\n     * @param {number} delta\n     * @returns {boolean}\n     * @private\n     */\n    static _hasSuperQuality(superchain, depth, m, delta) {\n        Assert.that(m >= 1, 'm must be >= 1');\n        if (superchain.length < m) {\n            return false;\n        }\n\n        for (let i = m; i <= superchain.length; i++) {\n            const underlyingLength = superchain[superchain.length - 1].head.height - superchain[superchain.length - i].head.height + 1;\n            if (!BaseChain._isLocallyGood(i, underlyingLength, depth, delta)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     *\n     * @param {Array.<ChainData>} superchain\n     * @param {number} depth\n     * @param {number} k1\n     * @param {number} delta\n     * @returns {boolean}\n     * @private\n     */\n    static _hasMultiLevelQuality(superchain, depth, k1, delta) {\n        if (depth <= 0) {\n            return true;\n        }\n\n        for (let i = 0; i < superchain.length - k1; i++) {\n            const tailData = superchain[i];\n            const headData = superchain[i + k1];\n\n            for (let mu = depth; mu >= 1; mu--) {\n                const upperChainLength = headData.superBlockCounts.get(mu) - tailData.superBlockCounts.get(mu);\n                /*\n                // Original paper badness check:\n                const lowerChainLength = headData.superBlockCounts.get(mu - 1) - tailData.superBlockCounts.get(mu - 1);\n                if (lowerChainLength > Math.pow(1 + delta, 1 / depth) * 2 * upperChainLength) {\n                    Log.d(BaseChain, `Chain badness detected at depth ${depth}, failing at ${mu}/${mu - 1}`\n                        + ` with ${upperChainLength}/${Math.pow(1 + delta, 1 / depth) * 2 * upperChainLength}/${lowerChainLength} blocks`);\n                    return false;\n                }\n                */\n\n                /*\n                // Alternative badness check:\n                const lowerChainLength = headData.superBlockCounts.get(mu - 1) - tailData.superBlockCounts.get(mu - 1);\n                if (2 * upperChainLength < Math.pow(1 - delta, 1 / depth) * lowerChainLength) {\n                    Log.d(BaseChain, `Chain badness detected at depth ${depth}, failing at ${mu}/${mu - 1}`\n                        + ` with ${upperChainLength}/${Math.pow(1 - delta, 1 / depth) * lowerChainLength}/${lowerChainLength} blocks`);\n                    return false;\n                }\n                */\n\n                // Relaxed badness check:\n                for (let j = mu - 1; j >= 0; j--) {\n                    const lowerChainLength = headData.superBlockCounts.get(j) - tailData.superBlockCounts.get(j);\n                    if (!BaseChain._isLocallyGood(upperChainLength, lowerChainLength, mu - j, delta)) {\n                        Log.d(BaseChain, `Chain badness detected at depth ${depth}[${i}:${i + k1}], failing at ${mu}/${j}`);\n                        return false;\n                    }\n                }\n\n                /*\n                // Local goodness only:\n                const lowerChainLength = headData.superBlockCounts.get(mu - 1) - tailData.superBlockCounts.get(mu - 1);\n                if (!BaseChain._isLocallyGood(lowerChainLength, headData.head.height - tailData.head.height, depth, delta)) {\n                    Log.d(BaseChain, `Chain badness detected at depth ${depth}[${i}:${i + k1}], failing at ${mu}`);\n                    return false;\n                }\n                */\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {number} superLength\n     * @param {number} underlyingLength\n     * @param {number} depth\n     * @param {number} delta\n     * @returns {boolean}\n     * @private\n     */\n    static _isLocallyGood(superLength, underlyingLength, depth, delta) {\n        // |C'| > (1 - delta) * 2^(-mu) * |C|\n        return superLength > (1 - delta) * Math.pow(2, -depth) * underlyingLength;\n    }\n\n    /**\n     * @param {number} length\n     * @param {Block} [head]\n     * @returns {Promise.<HeaderChain>}\n     * @private\n     */\n    async _getHeaderChain(length, head = this.head) {\n        const headers = [];\n        while (head && headers.length < length) {\n            headers.push(head.header);\n            head = await this.getBlock(head.prevHash); // eslint-disable-line no-await-in-loop\n        }\n        return new HeaderChain(headers.reverse());\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @param {BlockHeader} header\n     * @param {boolean} [failOnBadness]\n     * @returns {Promise.<ChainProof>}\n     * @protected\n     */\n    async _extendChainProof(proof, header, failOnBadness = true) {\n        // Append new header to proof suffix.\n        const suffix = proof.suffix.headers.slice();\n        suffix.push(header);\n\n        // If the suffix is not long enough (short chain), we're done.\n        const prefix = proof.prefix.blocks.slice();\n        if (suffix.length <= Policy.K) {\n            return new ChainProof(new BlockChain(prefix), new HeaderChain(suffix));\n        }\n\n        // Cut the tail off the suffix.\n        const suffixTail = suffix.shift();\n\n        // Construct light block out of the old suffix tail.\n        const interlink = await proof.prefix.head.getNextInterlink(suffixTail.target, suffixTail.version);\n        const prefixHead = new Block(suffixTail, interlink);\n\n        // Append old suffix tail block to prefix.\n        prefix.push(prefixHead);\n\n        // Extract layered superchains from prefix. Make a copy because we are going to change the chains array.\n        const chains = (await proof.prefix.getSuperChains()).slice();\n\n        // Append new prefix head to chains.\n        const depth = BlockUtils.getHashDepth(await prefixHead.pow());\n        for (let i = depth; i >= 0; i--) {\n            // Append block. Don't modify the chain, create a copy.\n            if (!chains[i]) {\n                chains[i] = new BlockChain([prefixHead]);\n            } else {\n                chains[i] = new BlockChain([...chains[i].blocks, prefixHead]);\n            }\n        }\n\n        // If the new header isn't a superblock, we're done.\n        if (depth - BlockUtils.getTargetDepth(prefixHead.target) <= 0) {\n            return new ChainProof(new BlockChain(prefix, chains), new HeaderChain(suffix));\n        }\n\n        // Prune unnecessary blocks if the chain is good.\n        // Try to extend proof if the chain is bad.\n        const deletedBlockHeights = new Set();\n        for (let i = depth; i >= 0; i--) {\n            const superchain = chains[i];\n            if (superchain.length < Policy.M) {\n                continue;\n            }\n\n            // XXX Hack: Convert BlockChain to array of pseudo-ChainData for the super quality check.\n            const _superchain = superchain.blocks.map(block => ({ head: block }));\n            if (!BaseChain._hasSuperQuality(_superchain, i, Policy.M, Policy.DELTA)) {\n                Log.w(BaseChain, `Chain quality badness detected at depth ${i}`);\n                // TODO extend superchains at lower levels\n                if (failOnBadness) {\n                    return null;\n                }\n                continue;\n            }\n\n            // Remove all blocks in lower chains up to (including) superchain[-m].\n            const referenceBlock = superchain.blocks[superchain.length - Policy.M];\n            for (let j = i - 1; j >= 0; j--) {\n                let numBlocksToDelete = 0;\n                let candidateBlock = chains[j].blocks[numBlocksToDelete];\n                while (candidateBlock.height <= referenceBlock.height) {\n                    // eslint-disable-next-line no-await-in-loop\n                    const candidateDepth = BlockUtils.getHashDepth(await candidateBlock.pow());\n                    if (candidateDepth === j && candidateBlock.height > 1) {\n                        deletedBlockHeights.add(candidateBlock.height);\n                    }\n\n                    numBlocksToDelete++;\n                    candidateBlock = chains[j].blocks[numBlocksToDelete];\n                }\n\n                if (numBlocksToDelete > 0) {\n                    // Don't modify the chain, create a copy.\n                    chains[j] = new BlockChain(chains[j].blocks.slice(numBlocksToDelete));\n                }\n            }\n        }\n\n        // Remove all deleted blocks from prefix.\n        const newPrefix = new BlockChain(prefix.filter(block => !deletedBlockHeights.has(block.height)), chains);\n\n        // Return the extended proof.\n        return new ChainProof(newPrefix, new HeaderChain(suffix));\n    }\n\n    /**\n     * MUST be synchronized with .pushBlock() and variants!\n     * @param {Block} blockToProve\n     * @param {Block} knownBlock\n     * @returns {Promise.<?BlockChain>}\n     * @protected\n     */\n    async _getBlockProof(blockToProve, knownBlock) {\n        /**\n         * @param {Block} block\n         * @param {number} depth\n         * @returns {Hash}\n         */\n        const getInterlinkReference = (block, depth) => {\n            const index = Math.min(depth - BlockUtils.getTargetDepth(block.target), block.interlink.length - 1);\n            return index < 0 ? block.prevHash : block.interlink.hashes[index];\n        };\n\n        const blocks = [];\n        const hashToProve = blockToProve.hash();\n\n        const proveTarget = BlockUtils.hashToTarget(await blockToProve.pow());\n        const proveDepth = BlockUtils.getTargetDepth(proveTarget);\n\n        let depth = BlockUtils.getTargetDepth(knownBlock.target) + knownBlock.interlink.length - 1;\n        let block = knownBlock;\n\n        let reference = getInterlinkReference(block, depth);\n        while (!hashToProve.equals(reference)) {\n            const nextBlock = await this.getBlock(reference); // eslint-disable-line no-await-in-loop\n            if (!nextBlock) {\n                // This can happen in the light/nano client if the blockToProve is known but blocks between tailBlock\n                // and blockToProve are missing.\n                Log.w(BaseChain, `Failed to find block ${reference} while constructing inclusion proof`);\n                return null;\n            }\n\n            if (nextBlock.height < blockToProve.height) {\n                // We have gone past the blockToProve, but are already at proveDepth, fail.\n                if (depth <= proveDepth) {\n                    return null;\n                }\n\n                // Decrease depth and thereby step size.\n                depth--;\n                reference = getInterlinkReference(block, depth);\n            } else if (nextBlock.height > blockToProve.height) {\n                // We are still in front of blockToProve, add block to result and advance.\n                blocks.push(nextBlock.toLight());\n\n                block = nextBlock;\n                reference = getInterlinkReference(block, depth);\n            } else {\n                // We found a reference to a different block than blockToProve at its height.\n                Log.w(BaseChain, `Failed to prove block ${hashToProve} - different block ${reference} at its height ${block.height}`);\n                return null;\n            }\n        }\n\n        // Include the blockToProve in the result.\n        blocks.push(blockToProve.toLight());\n\n        return new BlockChain(blocks.reverse());\n    }\n\n    /**\n     * @param {Array.<BlockHeader>} headers\n     * @return {Promise.<void>}\n     */\n    static async manyPow(headers) {\n        const worker = await CryptoWorker.getInstanceAsync();\n        const size = worker.poolSize || 1;\n        const partitions = [];\n        let j = 0;\n        for (let i = 0; i < size; ++i) {\n            partitions.push([]);\n            for (; j < ((i + 1) / size) * headers.length; ++j) {\n                partitions[i].push(headers[j].serialize());\n            }\n        }\n        const promises = [];\n        for (const part of partitions) {\n            promises.push(worker.computeArgon2dBatch(part));\n        }\n        const pows = (await Promise.all(promises)).reduce((a, b) => [...a, ...b], []);\n        for(let i = 0; i < headers.length; ++i) {\n            headers[i]._pow = new Hash(pows[i]);\n        }\n    }\n\n\n    /* NiPoPoW Verifier functions */\n\n    /**\n     * @param {ChainProof} proof1\n     * @param {ChainProof} proof2\n     * @param {number} m\n     * @returns {boolean}\n     */\n    static async isBetterProof(proof1, proof2, m) {\n        const lca = BlockChain.lowestCommonAncestor(proof1.prefix, proof2.prefix);\n        const score1 = await NanoChain._getProofScore(proof1.prefix, lca, m);\n        const score2 = await NanoChain._getProofScore(proof2.prefix, lca, m);\n        return score1 === score2\n            ? proof1.suffix.totalDifficulty() >= proof2.suffix.totalDifficulty()\n            : score1 > score2;\n    }\n\n    /**\n     *\n     * @param {BlockChain} chain\n     * @param {Block} lca\n     * @param {number} m\n     * @returns {Promise.<number>}\n     * @protected\n     */\n    static async _getProofScore(chain, lca, m) {\n        const counts = [];\n        for (const block of chain.blocks) {\n            if (block.height < lca.height) {\n                continue;\n            }\n\n            const depth = BlockUtils.getHashDepth(await block.pow()); // eslint-disable-line no-await-in-loop\n            counts[depth] = counts[depth] ? counts[depth] + 1 : 1;\n        }\n\n        let sum = 0;\n        let depth;\n        for (depth = counts.length - 1; sum < m && depth >= 0; depth--) {\n            sum += counts[depth] ? counts[depth] : 0;\n        }\n\n        let maxScore = Math.pow(2, depth + 1) * sum;\n        let length = sum;\n        for (let i = depth; i >= 0; i--) {\n            length += counts[i] ? counts[i] : 0;\n            const score = Math.pow(2, i) * length;\n            maxScore = Math.max(maxScore, score);\n        }\n\n        return maxScore;\n    }\n}\nClass.register(BaseChain);\n","class BlockChain {\n    /**\n     * @param {BlockChain} chain1\n     * @param {BlockChain} chain2\n     * @returns {BlockChain}\n     */\n    static merge(chain1, chain2) {\n        const merged = [];\n        let i1 = 0, i2 = 0;\n        while (i1 < chain1.length && i2 < chain2.length) {\n            const block1 = chain1.blocks[i1];\n            const block2 = chain2.blocks[i2];\n\n            if (block1.height === block2.height) {\n                Assert.that(block1.equals(block2), 'Encountered different blocks at same height during chain merge');\n                merged.push(block1);\n                i1++;\n                i2++;\n            } else if (block1.height < block2.height) {\n                merged.push(block1);\n                i1++;\n            } else {\n                merged.push(block2);\n                i2++;\n            }\n        }\n\n        for (; i1 < chain1.length; i1++) {\n            merged.push(chain1.blocks[i1]);\n        }\n        for (; i2 < chain2.length; i2++) {\n            merged.push(chain2.blocks[i2]);\n        }\n\n        return new BlockChain(merged);\n    }\n\n    /**\n     * @param {BlockChain} chain1\n     * @param {BlockChain} chain2\n     * @returns {?Block}\n     */\n    static lowestCommonAncestor(chain1, chain2) {\n        let i1 = chain1.length - 1;\n        let i2 = chain2.length - 1;\n        while (i1 >= 0 && i2 >= 0) {\n            const block1 = chain1.blocks[i1];\n            const block2 = chain2.blocks[i2];\n\n            if (block1.equals(block2)) {\n                return block1;\n            } else if (block1.height > block2.height) {\n                i1--;\n            } else {\n                i2--;\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * @param {Array.<Block>} blocks\n     * @param {Array.<BlockChain>} [superChains]\n     */\n    constructor(blocks, superChains) {\n        if (!Array.isArray(blocks) || !NumberUtils.isUint16(blocks.length)\n            || blocks.some(it => !(it instanceof Block) || !it.isLight())) throw new Error('Malformed blocks');\n\n        /** @type {Array.<Block>} */\n        this._blocks = blocks;\n        /** @type {Array.<BlockChain>} */\n        this._chains = superChains;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {BlockChain}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint16();\n        const blocks = [];\n        for (let i = 0; i < count; i++) {\n            blocks.push(Block.unserialize(buf));\n        }\n        return new BlockChain(blocks);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._blocks.length);\n        for (const block of this._blocks) {\n            block.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*count*/ 2\n            + this._blocks.reduce((sum, block) => sum + block.serializedSize, 0);\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    async verify() {\n        // For performance reasons, we DO NOT VERIFY the validity of the blocks in the chain here.\n        // Block validity is checked by the Nano/LightChain upon receipt of a ChainProof.\n\n        // Check that all blocks in the chain are valid successors of one another.\n        for (let i = this._blocks.length - 1; i >= 1; i--) {\n            if (!(await this._blocks[i].isSuccessorOf(this._blocks[i - 1]))) { // eslint-disable-line no-await-in-loop\n                return false;\n            }\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {Array.<Block>}\n     */\n    denseSuffix() {\n        // Compute the dense suffix.\n        const denseSuffix = [this.head];\n        let denseSuffixHead = this.head;\n        for (let i = this.length - 2; i >= 0; i--) {\n            const block = this.blocks[i];\n            const hash = block.hash();\n            if (!hash.equals(denseSuffixHead.prevHash)) {\n                break;\n            }\n\n            denseSuffix.push(block);\n            denseSuffixHead = block;\n        }\n        denseSuffix.reverse();\n        return denseSuffix;\n    }\n\n    /**\n     * @returns {Promise.<Array.<BlockChain>>}\n     */\n    async getSuperChains() {\n        if (!this._chains) {\n            this._chains = [];\n            for (let i = 0; i < this.length; i++) {\n                const block = this.blocks[i];\n                const depth = BlockUtils.getHashDepth(await block.pow());\n\n                if (this._chains[depth]) {\n                    this._chains[depth].blocks.push(block);\n                } else if (!this._chains[depth]) {\n                    this._chains[depth] = new BlockChain([block]);\n                }\n\n                for (let j = depth - 1; j >= 0; j--) {\n                    if (this._chains[j]) {\n                        this._chains[j].blocks.push(block);\n                    }\n                }\n            }\n\n            for (let i = 0; i < this._chains.length; i++) {\n                if (!this._chains[i]) {\n                    this._chains[i] = new BlockChain([]);\n                }\n            }\n        }\n        return this._chains;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isAnchored() {\n        return GenesisConfig.GENESIS_HASH.equals(this.tail.hash());\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `BlockChain{length=${this.length}}`;\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._blocks.length;\n    }\n\n    /** @type {Array.<Block>} */\n    get blocks() {\n        return this._blocks;\n    }\n\n    /** @type {Block} */\n    get head() {\n        return this._blocks[this.length - 1];\n    }\n\n    /** @type {Block} */\n    get tail() {\n        return this._blocks[0];\n    }\n\n    /**\n     * @returns {number}\n     */\n    totalDifficulty() {\n        return this._blocks.reduce((sum, block) => sum + BlockUtils.targetToDifficulty(block.target), 0);\n    }\n}\nClass.register(BlockChain);\n","class HeaderChain {\n    /**\n     * @param {Array.<BlockHeader>} headers\n     */\n    constructor(headers) {\n        if (!headers || !Array.isArray(headers) || !NumberUtils.isUint16(headers.length)\n            || headers.some(it => !(it instanceof BlockHeader))) throw new Error('Malformed headers');\n\n        /** @type {Array.<BlockHeader>} */\n        this._headers = headers;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {HeaderChain}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint16();\n        const headers = [];\n        for (let i = 0; i < count; i++) {\n            headers.push(BlockHeader.unserialize(buf));\n        }\n        return new HeaderChain(headers);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._headers.length);\n        for (const header of this._headers) {\n            header.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*count*/ 2\n            + this._headers.reduce((sum, header) => sum + header.serializedSize, 0);\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    async verify() {\n        // For performance reasons, we DO NOT VERIFY the validity of the blocks in the chain here.\n        // Block validity is checked by the Nano/LightChain upon receipt of a ChainProof.\n\n        // Check that all headers in the chain are valid successors of one another.\n        for (let i = this._headers.length - 1; i >= 1; i--) {\n            if (!this._headers[i].isImmediateSuccessorOf(this._headers[i - 1])) {\n                return false;\n            }\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `HeaderChain{length=${this.length}}`;\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._headers.length;\n    }\n\n    /** @type {Array.<BlockHeader>} */\n    get headers() {\n        return this._headers;\n    }\n\n    /** @type {BlockHeader} */\n    get head() {\n        return this._headers[this.length - 1];\n    }\n\n    /** @type {BlockHeader} */\n    get tail() {\n        return this._headers[0];\n    }\n\n    /**\n     * @returns {number}\n     */\n    totalDifficulty() {\n        return this._headers.reduce((sum, header) => sum + BlockUtils.targetToDifficulty(header.target), 0);\n    }\n}\nClass.register(HeaderChain);\n","class ChainProof {\n    /**\n     * @param {BlockChain} prefix\n     * @param {HeaderChain} suffix\n     */\n    constructor(prefix, suffix) {\n        if (!(prefix instanceof BlockChain) || !prefix.length) throw new Error('Malformed prefix');\n        if (!(suffix instanceof HeaderChain)) throw new Error('Malformed suffix');\n\n        /** @type {BlockChain} */\n        this._prefix = prefix;\n        /** @type {HeaderChain} */\n        this._suffix = suffix;\n    }\n\n    static unserialize(buf) {\n        const prefix = BlockChain.unserialize(buf);\n        const suffix = HeaderChain.unserialize(buf);\n        return new ChainProof(prefix, suffix);\n    }\n\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._prefix.serialize(buf);\n        this._suffix.serialize(buf);\n        return buf;\n    }\n\n    get serializedSize() {\n        return this._prefix.serializedSize\n            + this._suffix.serializedSize;\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    async verify() {\n        // Check that the prefix chain is anchored.\n        if (!this._prefix.isAnchored()) {\n            return false;\n        }\n\n        // Check that both prefix and suffix are valid chains.\n        if (!(await this._prefix.verify()) || !(await this._suffix.verify())) {\n            return false;\n        }\n\n        // Check that the suffix connects to the prefix.\n        if (this._suffix.length > 0 && !this._suffix.tail.isImmediateSuccessorOf(this._prefix.head.header)) {\n            return false;\n        }\n\n        // Verify the block targets where possible.\n        if (!this._verifyDifficulty()) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n    _verifyDifficulty() {\n        // Extract the dense suffix of the prefix.\n        /** Array.<BlockHeader> */\n        const denseSuffix = this.prefix.denseSuffix().map(block => block.header);\n        /** Array.<BlockHeader> */\n        const denseChain = denseSuffix.concat(this.suffix.headers);\n\n        // Compute totalDifficulty for each block of the dense chain.\n        let totalDifficulty = 0;\n        const totalDifficulties = [];\n        for (let i = 0; i < denseChain.length; i++) {\n            totalDifficulty += denseChain[i].difficulty;\n            totalDifficulties[i] = totalDifficulty;\n        }\n\n        let headIndex = denseChain.length - 2;\n        let tailIndex = headIndex - Policy.DIFFICULTY_BLOCK_WINDOW;\n        while (tailIndex >= 0 && headIndex >= 0) {\n            const headBlock = denseChain[headIndex];\n            const tailBlock = denseChain[tailIndex];\n            const deltaTotalDifficulty = totalDifficulties[headIndex] - totalDifficulties[tailIndex];\n            const target = BlockUtils.getNextTarget(headBlock, tailBlock, deltaTotalDifficulty);\n            const nBits = BlockUtils.targetToCompact(target);\n\n            /** @type {BlockHeader} */\n            const checkBlock = denseChain[headIndex + 1];\n            if (checkBlock.nBits !== nBits) {\n                Log.w(ChainProof, `Block target mismatch: expected=${nBits}, got=${checkBlock.nBits}`);\n                return false;\n            }\n\n            --headIndex;\n            if (tailIndex !== 0 || tailBlock.height !== 1) {\n                --tailIndex;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `ChainProof{prefix=${this._prefix.length}, suffix=${this._suffix.length}, height=${this.head.height}}`;\n    }\n\n    /** @type {BlockChain} */\n    get prefix() {\n        return this._prefix;\n    }\n\n    /** @type {HeaderChain} */\n    get suffix() {\n        return this._suffix;\n    }\n\n    /** @type {BlockHeader} */\n    get head() {\n        return this._suffix.length > 0 ? this._suffix.head : this._prefix.head.header;\n    }\n}\nClass.register(ChainProof);\n","class ChainData {\n    /**\n     * @param {Block} block\n     * @param {SuperBlockCounts} [superBlockCounts]\n     * @returns {Promise.<ChainData>}\n     */\n    static async initial(block, superBlockCounts) {\n        const pow = await block.pow();\n        const totalWork = BlockUtils.realDifficulty(pow);\n\n        const depth = BlockUtils.getHashDepth(pow);\n        if (superBlockCounts) {\n            superBlockCounts = superBlockCounts.copyAndAdd(depth);\n        } else {\n            superBlockCounts = new SuperBlockCounts();\n            superBlockCounts.add(depth);\n        }\n\n        return new ChainData(block, block.difficulty, totalWork, superBlockCounts, true);\n    }\n\n    /**\n     * @param {Block} head\n     * @param {number} totalDifficulty\n     * @param {number} totalWork\n     * @param {SuperBlockCounts} superBlockCounts\n     * @param {boolean} [onMainChain]\n     * @param {Hash} [mainChainSuccessor]\n     */\n    constructor(head, totalDifficulty, totalWork, superBlockCounts, onMainChain = false, mainChainSuccessor = null) {\n        this._head = head;\n        this._totalDifficulty = totalDifficulty;\n        this._totalWork = totalWork;\n        this._superBlockCounts = superBlockCounts;\n        this._onMainChain = onMainChain;\n        this._mainChainSuccessor = mainChainSuccessor;\n        this._height = head.height;\n    }\n\n    /**\n     * @returns {{_head: SerialBuffer, _totalDifficulty: number, _totalWork: number, _superBlockCounts: Array.<number>, _onMainChain: boolean, _mainChainSuccessor: ?SerialBuffer, _height: number, _pow: SerialBuffer}}\n     */\n    toObj() {\n        Assert.that(this._head.header._pow instanceof Hash, 'Expected cached PoW hash');\n        return {\n            _head: this._head.toLight().serialize(),\n            _totalDifficulty: this._totalDifficulty,\n            _totalWork: this._totalWork,\n            _superBlockCounts: this._superBlockCounts.array,\n            _onMainChain: this._onMainChain,\n            _mainChainSuccessor: this._mainChainSuccessor ? this._mainChainSuccessor.serialize() : null,\n            _height: this._head.height,\n            _pow: this._head.header._pow.serialize()\n        };\n    }\n\n    /**\n     * @param {{_head: Uint8Array, _totalDifficulty: number, _totalWork: number, _superBlockCounts: Array.<number>, _onMainChain: boolean, _mainChainSuccessor: ?Uint8Array, _height: number, _pow: Uint8Array}} obj\n     * @param {string} [hashBase64]\n     * @returns {ChainData}\n     */\n    static fromObj(obj, hashBase64) {\n        if (!obj) return obj;\n        const head = Block.unserialize(new SerialBuffer(obj._head));\n        head.header._pow = Hash.unserialize(new SerialBuffer(obj._pow));\n        head.header._hash = hashBase64 ? Hash.fromBase64(hashBase64) : null;\n        const superBlockCounts = new SuperBlockCounts(obj._superBlockCounts);\n        const successor = obj._mainChainSuccessor ? Hash.unserialize(new SerialBuffer(obj._mainChainSuccessor)) : null;\n        return new ChainData(\n            head,\n            obj._totalDifficulty,\n            obj._totalWork,\n            superBlockCounts,\n            obj._onMainChain,\n            successor\n        );\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<ChainData>}\n     */\n    async nextChainData(block) {\n        Assert.that(this._totalDifficulty > 0);\n\n        const pow = await block.pow();\n        const totalDifficulty = this.totalDifficulty + block.difficulty;\n        const totalWork = this.totalWork + BlockUtils.realDifficulty(pow);\n        const superBlockCounts = this.superBlockCounts.copyAndAdd(BlockUtils.getHashDepth(pow));\n        return new ChainData(block, totalDifficulty, totalWork, superBlockCounts);\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<ChainData>}\n     */\n    async previousChainData(block) {\n        Assert.that(this._totalDifficulty > 0);\n\n        const pow = await this.head.pow();\n        const totalDifficulty = this.totalDifficulty - this.head.difficulty;\n        const totalWork = this.totalWork - BlockUtils.realDifficulty(pow);\n        const superBlockCounts = this.superBlockCounts.copyAndSubtract(BlockUtils.getHashDepth(pow));\n        return new ChainData(block, totalDifficulty, totalWork, superBlockCounts);\n    }\n\n    /** @type {Block} */\n    get head() {\n        return this._head;\n    }\n\n    /** @type {number} */\n    get totalDifficulty() {\n        return this._totalDifficulty;\n    }\n\n    /** @type {number} */\n    get totalWork() {\n        return this._totalWork;\n    }\n\n    /** @type {SuperBlockCounts} */\n    get superBlockCounts() {\n        return this._superBlockCounts;\n    }\n\n    /** @type {boolean} */\n    get onMainChain() {\n        return this._onMainChain;\n    }\n\n    /** @type {boolean} */\n    set onMainChain(onMainChain) {\n        this._onMainChain = onMainChain;\n    }\n\n    /** @type {Hash} */\n    get mainChainSuccessor() {\n        return this._mainChainSuccessor;\n    }\n\n    /** @type {Hash} */\n    set mainChainSuccessor(mainChainSuccessor) {\n        this._mainChainSuccessor = mainChainSuccessor;\n    }\n}\nClass.register(ChainData);\n\nclass SuperBlockCounts {\n    /**\n     * @constructor\n     * @param {Array.<number>} array\n     */\n    constructor(array = []) {\n        this._arr = array;\n    }\n\n    /**\n     * @param {number} depth\n     */\n    add(depth) {\n        Assert.that(NumberUtils.isUint8(depth));\n        for (let i = 0; i <= depth; i++) {\n            this._arr[i] = this.get(i) + 1;\n        }\n    }\n\n    /**\n     * @param {number} depth\n     */\n    subtract(depth) {\n        Assert.that(NumberUtils.isUint8(depth));\n        for (let i = 0; i <= depth; i++) {\n            this._arr[i]--;\n            Assert.that(this._arr[i] >= 0);\n        }\n    }\n\n    /**\n     * @param {number} depth\n     * @returns {SuperBlockCounts}\n     */\n    copyAndAdd(depth) {\n        const copy = new SuperBlockCounts(this._arr.slice());\n        copy.add(depth);\n        return copy;\n    }\n\n    /**\n     * @param {number} depth\n     * @returns {SuperBlockCounts}\n     */\n    copyAndSubtract(depth) {\n        const copy = new SuperBlockCounts(this._arr.slice());\n        copy.subtract(depth);\n        return copy;\n    }\n\n    /**\n     * @param {number} depth\n     * @returns {number}\n     */\n    get(depth) {\n        Assert.that(NumberUtils.isUint8(depth));\n        return this._arr[depth] || 0;\n    }\n\n    /**\n     * @param {number} m\n     * @returns {number}\n     */\n    getCandidateDepth(m) {\n        for (let i = this._arr.length - 1; i >= 0; i--) {\n            if (this._arr[i] >= m) {\n                return i;\n            }\n        }\n        return 0;\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._arr.length;\n    }\n\n    /** @type {Array.<number>} */\n    get array() {\n        return this._arr;\n    }\n}\nClass.register(SuperBlockCounts);\n","class ChainDataStore {\n    /**\n     * @param {JungleDB} jdb\n     */\n    static initPersistent(jdb) {\n        const chainStore = jdb.createObjectStore('ChainData', { codec: new ChainDataStoreCodec() });\n        ChainDataStore._createIndexes(chainStore);\n\n        jdb.createObjectStore('Block', { codec: new BlockStoreCodec() });\n    }\n\n    /**\n     * @param {JungleDB} jdb\n     * @returns {ChainDataStore}\n     */\n    static getPersistent(jdb) {\n        const chainStore = jdb.getObjectStore('ChainData');\n        const blockStore = jdb.getObjectStore('Block');\n        return new ChainDataStore(chainStore, blockStore);\n    }\n\n    /**\n     * @returns {ChainDataStore}\n     */\n    static createVolatile() {\n        const chainStore = JDB.JungleDB.createVolatileObjectStore();\n        const blockStore = JDB.JungleDB.createVolatileObjectStore();\n        ChainDataStore._createIndexes(chainStore);\n        return new ChainDataStore(chainStore, blockStore);\n    }\n\n    /**\n     * @param {IObjectStore} chainStore\n     * @private\n     */\n    static _createIndexes(chainStore) {\n        chainStore.createIndex('height', ['_height'], { lmdbKeyEncoding: JDB.JungleDB.NUMBER_ENCODING, leveldbKeyEncoding: JDB.JungleDB.NUMBER_ENCODING });\n    }\n\n    /**\n     * @param {IObjectStore} chainStore\n     * @param {IObjectStore} blockStore\n     */\n    constructor(chainStore, blockStore) {\n        /** @type {IObjectStore} */\n        this._chainStore = chainStore;\n        /** @type {IObjectStore} */\n        this._blockStore = blockStore;\n    }\n\n    /**\n     * @param {Hash} key\n     * @param {boolean} [includeBody]\n     * @returns {Promise.<?ChainData>}\n     */\n    async getChainData(key, includeBody = false) {\n        /** @type {ChainData} */\n        const chainData = await this._chainStore.get(key.toBase64());\n        if (!chainData || !includeBody) {\n            return chainData;\n        }\n\n        const block = await this._blockStore.get(key.toBase64());\n        if (block && block.isFull()) {\n            chainData.head._body = block.body;\n        }\n\n        return chainData;\n    }\n\n    /**\n     * @param {Hash} key\n     * @param {ChainData} chainData\n     * @param {boolean} [includeBody]\n     * @returns {Promise.<void>}\n     */\n    putChainData(key, chainData, includeBody = true) {\n        if (this._chainStore instanceof JDB.Transaction) {\n            this._chainStore.putSync(key.toBase64(), chainData);\n            if (includeBody && chainData.head.isFull()) {\n                this._blockStore.putSync(key.toBase64(), chainData.head);\n            }\n            return Promise.resolve(true);\n        }\n\n        if (includeBody && chainData.head.isFull()) {\n            const chainTx = this._chainStore.synchronousTransaction();\n            chainTx.putSync(key.toBase64(), chainData);\n            const blockTx = this._blockStore.synchronousTransaction();\n            blockTx.putSync(key.toBase64(), chainData.head);\n            return JDB.JungleDB.commitCombined(chainTx, blockTx);\n        }\n\n        return this._chainStore.put(key.toBase64(), chainData);\n    }\n\n    /**\n     * @param {Hash} key\n     * @param {ChainData} chainData\n     * @param {boolean} [includeBody]\n     * @returns {void}\n     */\n    putChainDataSync(key, chainData, includeBody = true) {\n        Assert.that(this._chainStore instanceof JDB.Transaction);\n        this._chainStore.putSync(key.toBase64(), chainData);\n        if (includeBody && chainData.head.isFull()) {\n            this._blockStore.putSync(key.toBase64(), chainData.head);\n        }\n    }\n\n    /**\n     * @param {Hash} key\n     * @param {boolean} [includeBody]\n     * @returns {?Block}\n     */\n    async getBlock(key, includeBody = false) {\n        if (includeBody) {\n            const block = await this._blockStore.get(key.toBase64());\n            if (block) {\n                return block;\n            }\n        }\n\n        const chainData = await this._chainStore.get(key.toBase64());\n        return chainData ? chainData.head : null;\n    }\n\n    /**\n     * @param {number} height\n     * @param {boolean} [includeBody]\n     * @returns {Promise.<?ChainData>}\n     */\n    async getChainDataAt(height, includeBody = false) {\n        /** @type {Array.<ChainData>} */\n        const candidates = await this._chainStore.values(JDB.Query.eq('height', height));\n        if (!candidates || !candidates.length) {\n            return undefined;\n        }\n\n        for (const chainData of candidates) {\n            if (chainData.onMainChain) {\n                if (includeBody) {\n                    // eslint-disable-next-line no-await-in-loop\n                    const block = await this._blockStore.get(chainData.head.hash().toBase64());\n                    if (block) {\n                        chainData._head = block;\n                    }\n                }\n                return chainData;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @param {number} height\n     * @param {boolean} [includeBody]\n     * @returns {Promise.<?Block>}\n     */\n    async getBlockAt(height, includeBody = false) {\n        const chainData = await this.getChainDataAt(height, includeBody);\n        return chainData ? chainData.head : null;\n    }\n\n    /**\n     * @param {number} height\n     * @param {boolean} [lower]\n     * @returns {Promise.<?Block>}\n     */\n    async getNearestBlockAt(height, lower = true) {\n        const index = this._chainStore.index('height');\n        /** @type {Array.<ChainData>} */\n        const candidates = lower ?\n            await index.maxValues(JDB.KeyRange.upperBound(height)) :\n            await index.minValues(JDB.KeyRange.lowerBound(height));\n        if (!candidates || !candidates.length) {\n            return undefined;\n        }\n\n        for (const chainData of candidates) {\n            if (chainData.onMainChain) {\n                return chainData.head;\n            }\n        }\n\n        return null;\n    }\n\n    // /**\n    //  * @param {number} startHeight\n    //  * @param {number} [count]\n    //  * @param {boolean} [forward]\n    //  * @returns {Promise.<Array.<Block>>}\n    //  */\n    // async getBlocks(startHeight, count = 500, forward = true) {\n    //     if (count <= 0) {\n    //         return [];\n    //     }\n    //     if (!forward) {\n    //         startHeight = startHeight - count;\n    //     }\n    //     /** @type {Array.<ChainData>} */\n    //     let candidates = await this._chainStore.values(JDB.Query.within('height', startHeight, startHeight + count - 1));\n    //     candidates = candidates\n    //         .filter(chainData => chainData.onMainChain)\n    //         .map(chainData => chainData.head);\n    //     const sortNumber = forward ? ((a, b) => a.height - b.height) : ((a, b) => b.height - a.height);\n    //     candidates.sort(sortNumber);\n    //     return candidates;\n    // }\n\n    /**\n     * @param {Hash} startBlockHash\n     * @param {number} [count]\n     * @param {boolean} [forward]\n     * @returns {Promise.<Array.<Block>>}\n     */\n    getBlocks(startBlockHash, count = 500, forward = true) {\n        if (count <= 0) {\n            return Promise.resolve([]);\n        }\n\n        if (forward) {\n            return this.getBlocksForward(startBlockHash, count);\n        } else {\n            return this.getBlocksBackward(startBlockHash, count);\n        }\n    }\n\n    /**\n     * @param {Hash} startBlockHash\n     * @param {number} count\n     * @returns {Promise.<Array.<Block>>}\n     */\n    async getBlocksForward(startBlockHash, count = 500) {\n        /** @type {ChainData} */\n        let chainData = await this._chainStore.get(startBlockHash.toBase64());\n        if (!chainData) {\n            return [];\n        }\n\n        const blocks = [];\n        while (blocks.length < count && chainData.mainChainSuccessor) {\n            chainData = await this._chainStore.get(chainData.mainChainSuccessor.toBase64());\n            if (!chainData) {\n                return blocks;\n            }\n            blocks.push(chainData.head);\n        }\n        return blocks;\n    }\n\n    /**\n     * @param {Hash} startBlockHash\n     * @param {number} count\n     * @param {boolean} includeBody\n     * @returns {Promise.<Array.<Block>>}\n     */\n    async getBlocksBackward(startBlockHash, count = 500, includeBody = false) {\n        const getBlock = includeBody\n            ? key => this._blockStore.get(key)\n            : key => this._chainStore.get(key).then(data => data.head);\n\n        /** @type {ChainData} */\n        const chainData = await this._chainStore.get(startBlockHash.toBase64());\n        if (!chainData) {\n            return [];\n        }\n\n        /** @type {Block} */\n        let block = chainData.head;\n        const blocks = [];\n        while (blocks.length < count && block.height > 1) {\n            block = await getBlock(block.prevHash.toBase64());\n            if (!block) {\n                return blocks;\n            }\n            blocks.push(block);\n        }\n        return blocks;\n    }\n\n    /**\n    /**\n     * @returns {Promise.<Hash|undefined>}\n     */\n    async getHead() {\n        const key = await this._chainStore.get('main');\n        return key ? Hash.fromBase64(key) : undefined;\n    }\n\n    /**\n     * @param {Hash} key\n     * @returns {Promise.<void>}\n     */\n    setHead(key) {\n        return this._chainStore.put('main', key.toBase64());\n    }\n\n    /**\n     * @param {Hash} key\n     * @returns {void}\n     */\n    setHeadSync(key) {\n        Assert.that(this._chainStore instanceof JDB.SynchronousTransaction);\n        this._chainStore.putSync('main', key.toBase64());\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {ChainDataStore}\n     */\n    transaction(enableWatchdog = true) {\n        const chainTx = this._chainStore.transaction(enableWatchdog);\n        const blockTx = this._blockStore.transaction(enableWatchdog);\n        return new ChainDataStore(chainTx, blockTx);\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {ChainDataStore}\n     */\n    synchronousTransaction(enableWatchdog = true) {\n        const chainTx = this._chainStore.synchronousTransaction(enableWatchdog);\n        const blockTx = this._blockStore.synchronousTransaction(enableWatchdog);\n        return new ChainDataStore(chainTx, blockTx);\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    commit() {\n        if (this._chainStore instanceof JDB.Transaction) {\n            return JDB.JungleDB.commitCombined(this._chainStore, this._blockStore);\n        }\n        return Promise.resolve();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    abort() {\n        return Promise.all([this._chainStore.abort(), this._blockStore.abort()]);\n    }\n\n    /**\n     * @returns {ChainDataStore}\n     */\n    snapshot() {\n        const chainSnapshot = this._chainStore.snapshot();\n        const blockSnapshot = this._blockStore.snapshot();\n        return new ChainDataStore(chainSnapshot, blockSnapshot);\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    truncate() {\n        if (this._chainStore instanceof JDB.Transaction) {\n            this._chainStore.truncateSync();\n            this._blockStore.truncateSync();\n            return Promise.resolve(true);\n        }\n\n        const chainTx = this._chainStore.transaction();\n        chainTx.truncateSync();\n        const blockTx = this._blockStore.transaction();\n        blockTx.truncateSync();\n        return JDB.JungleDB.commitCombined(chainTx, blockTx);\n    }\n\n    /** @type {Array.<JDB.Transaction>} */\n    get txs() {\n        if (this._chainStore instanceof JDB.Transaction) {\n            return [this._chainStore, this._blockStore];\n        }\n        return [];\n    }\n}\nClass.register(ChainDataStore);\n\n/**\n * @implements {ICodec}\n */\nclass ChainDataStoreCodec {\n    /**\n     * @param {*} obj The object to encode before storing it.\n     * @returns {*} Encoded object.\n     */\n    encode(obj) {\n        return typeof obj === 'string' ? obj : obj.toObj();\n    }\n\n    /**\n     * @param {*} obj The object to decode.\n     * @param {string} key The object's primary key.\n     * @returns {*} Decoded object.\n     */\n    decode(obj, key) {\n        return typeof obj === 'string' ? obj : ChainData.fromObj(obj, key);\n    }\n\n    /**\n     * @type {{encode: function(val:*):*, decode: function(val:*):*, buffer: boolean, type: string}|void}\n     */\n    get valueEncoding() {\n        return JDB.JungleDB.JSON_ENCODING;\n    }\n}\n\n/**\n * @implements {ICodec}\n */\nclass BlockStoreCodec {\n    /**\n     * @param {*} obj The object to encode before storing it.\n     * @returns {*} Encoded object.\n     */\n    encode(obj) {\n        return obj.serialize();\n    }\n\n    /**\n     * @param {*} obj The object to decode.\n     * @param {string} key The object's primary key.\n     * @returns {*} Decoded object.\n     */\n    decode(obj, key) {\n        const block = Block.unserialize(new SerialBuffer(obj));\n        block.header._hash = Hash.fromBase64(key);\n        return block;\n    }\n\n    /**\n     * @type {{encode: function(val:*):*, decode: function(val:*):*, buffer: boolean, type: string}|void}\n     */\n    get valueEncoding() {\n        return JDB.JungleDB.BINARY_ENCODING;\n    }\n}\n","class MempoolTransactionSet {\n    /**\n     * @param {Array.<Transaction>} [sortedTransactions]\n     */\n    constructor(sortedTransactions) {\n        /** @type {SortedList.<Transaction>} */\n        this._transactions = new SortedList(sortedTransactions);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {MempoolTransactionSet}\n     */\n    add(transaction) {\n        this._transactions.add(transaction);\n        return this;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {MempoolTransactionSet}\n     */\n    remove(transaction) {\n        this._transactions.remove(transaction);\n        return this;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {MempoolTransactionSet}\n     */\n    copyAndAdd(transaction) {\n        const transactions = this._transactions.copy();\n        transactions.add(transaction);\n        return new MempoolTransactionSet(transactions.values());\n    }\n\n    /** @type {Array.<Transaction>} */\n    get transactions() {\n        return this._transactions.values();\n    }\n\n    /** @type {Address} */\n    get sender() {\n        return this._transactions.length > 0 ? this._transactions.values()[0].sender : null;\n    }\n\n    /** @type {?Account.Type} */\n    get senderType() {\n        return this._transactions.length > 0 ? this._transactions.values()[0].senderType : undefined;\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._transactions.length;\n    }\n\n    /**\n     * @param {number} feePerByte\n     * @return {number}\n     */\n    numBelowFeePerByte(feePerByte) {\n        return this._transactions.values().filter(t => t.fee / t.serializedSize < feePerByte).length;\n    }\n\n    toString() {\n        return `MempoolTransactionSet{length=${this.length}}`;\n    }\n}\n\nClass.register(MempoolTransactionSet);\n","class Mempool extends Observable {\n    /**\n     * @param {IBlockchain} blockchain\n     * @param {Accounts} accounts\n     */\n    constructor(blockchain, accounts) {\n        super();\n        /** @type {IBlockchain} */\n        this._blockchain = blockchain;\n        /** @type {Accounts} */\n        this._accounts = accounts;\n\n        // Our pool of transactions.\n        /** @type {SortedList.<Transaction>} */\n        this._transactionsByFeePerByte = new SortedList(); // uses Transaction.compare, by fee descending\n        /** @type {HashMap.<Hash, Transaction>} */\n        this._transactionsByHash = new HashMap();\n        /** @type {HashMap.<Address, MempoolTransactionSet>} */\n        this._transactionSetBySender = new HashMap();\n        /** @type {HashMap.<Address, HashSet.<Hash>>} */\n        this._transactionSetByRecipient = new HashMap();\n        /** @type {Synchronizer} */\n        this._synchronizer = new Synchronizer();\n\n        // Listen for changes in the blockchain head to evict transactions that have become invalid.\n        blockchain.on('head-changed', () => this._evictTransactions());\n        blockchain.on('block-reverted', (block) => this._restoreTransactions(block));\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @fires Mempool#transaction-added\n     * @returns {Promise.<Mempool.ReturnCode>}\n     */\n    pushTransaction(transaction) {\n        return this._synchronizer.push(() => this._pushTransaction(transaction));\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @returns {Promise.<Mempool.ReturnCode>}\n     * @private\n     */\n    async _pushTransaction(transaction) {\n        // Check if we already know this transaction.\n        const hash = transaction.hash();\n        if (this._transactionsByHash.contains(hash)) {\n            return Mempool.ReturnCode.KNOWN;\n        }\n\n        const set = this._transactionSetBySender.get(transaction.sender) || new MempoolTransactionSet();\n        // Check limit for free transactions.\n        if (transaction.fee / transaction.serializedSize < Mempool.TRANSACTION_RELAY_FEE_MIN\n            && set.numBelowFeePerByte(Mempool.TRANSACTION_RELAY_FEE_MIN) >= Mempool.FREE_TRANSACTIONS_PER_SENDER_MAX) {\n            return Mempool.ReturnCode.FEE_TOO_LOW;\n        }\n\n        // Intrinsic transaction verification\n        if (!transaction.verify()) {\n            return Mempool.ReturnCode.INVALID;\n        }\n\n        // Retrieve recipient account and test incoming transaction.\n        /** @type {Account} */\n        let recipientAccount;\n        try {\n            recipientAccount = await this._accounts.get(transaction.recipient);\n            recipientAccount.withIncomingTransaction(transaction, this._blockchain.height + 1);\n        } catch (e) {\n            Log.w(Mempool, `Rejected transaction - ${e.message}`, transaction);\n            return Mempool.ReturnCode.INVALID;\n        }\n\n        // Retrieve sender account.\n        /** @type {Account} */\n        let senderAccount;\n        try {\n            senderAccount = await this._accounts.get(transaction.sender, transaction.senderType);\n        } catch (e) {\n            Log.w(Mempool, `Rejected transaction - ${e.message}`, transaction);\n            return Mempool.ReturnCode.INVALID;\n        }\n\n        // Add new transaction to the sender's pending transaction set. Then re-check all transactions in the set\n        // in fee/byte order against the sender account state. Adding high fee transactions may thus invalidate\n        // low fee transactions in the set.\n        const transactions = [];\n        let tmpAccount = senderAccount;\n        for (const tx of set.copyAndAdd(transaction).transactions) {\n            let error = 'transactions per sender exceeded';\n            try {\n                if (transactions.length < Mempool.TRANSACTIONS_PER_SENDER_MAX) {\n                    tmpAccount = tmpAccount.withOutgoingTransaction(tx, this._blockchain.height + 1, this._blockchain.transactionCache);\n                    transactions.push(tx);\n\n                    // Transaction ok, move to next one.\n                    continue;\n                }\n            } catch (e) {\n                error = e.message;\n            }\n\n            // An error occurred processing this transaction.\n            // If the rejected transaction is the one we're pushing, fail.\n            // Otherwise, evict the rejected transaction from the mempool.\n            if (tx.equals(transaction)) {\n                Log.w(Mempool, `Rejected transaction - ${error}`, transaction);\n                return Mempool.ReturnCode.INVALID;\n            } else {\n                // Remove transaction\n                this._removeTransaction(tx);\n            }\n        }\n\n        if (this._transactionsByFeePerByte.length >= Mempool.SIZE_MAX) {\n            this._popLowFeeTransaction();\n        }\n\n        // Transaction is valid, add it to the mempool.\n        this._transactionsByFeePerByte.add(transaction);\n        this._transactionsByHash.put(hash, transaction);\n        this._transactionSetBySender.put(transaction.sender, new MempoolTransactionSet(transactions));\n        /** @type {HashSet.<Hash>} */\n        const byRecipient = this._transactionSetByRecipient.get(transaction.recipient) || new HashSet();\n        byRecipient.add(transaction.hash());\n        this._transactionSetByRecipient.put(transaction.recipient, byRecipient);\n\n        // Tell listeners about the new valid transaction we received.\n        this.fire('transaction-added', transaction);\n\n        return Mempool.ReturnCode.ACCEPTED;\n    }\n\n    /**\n     * @private\n     */\n    _popLowFeeTransaction() {\n        // Remove transaction\n        const transaction = this._transactionsByFeePerByte.pop();\n\n        /** @type {MempoolTransactionSet} */\n        const set = this._transactionSetBySender.get(transaction.sender);\n        set.remove(transaction);\n\n        /** @type {HashSet.<Hash>} */\n        const byRecipient = this._transactionSetByRecipient.get(transaction.recipient);\n        if (byRecipient) {\n            if (byRecipient.length === 1) {\n                this._transactionSetByRecipient.remove(transaction.recipient);\n            } else {\n                byRecipient.remove(transaction.hash());\n            }\n        } else {\n            Log.e(Mempool, `Invalid state: no transactionsByRecipient for ${transaction}`);\n        }\n\n        this._transactionsByHash.remove(transaction.hash());\n    }\n\n    /**\n     * Does *not* remove transaction from transactionsBySender!\n     * @param {Transaction} transaction\n     * @private\n     */\n    _removeTransaction(transaction) {\n        this._transactionsByHash.remove(transaction.hash());\n\n        // TODO: Optimise remove from this._transactionsByMinFee.\n        this._transactionsByFeePerByte.remove(transaction);\n\n        /** @type {HashSet.<Hash>} */\n        const byRecipient = this._transactionSetByRecipient.get(transaction.recipient);\n        if (byRecipient) {\n            if (byRecipient.length === 1) {\n                this._transactionSetByRecipient.remove(transaction.recipient);\n            } else {\n                byRecipient.remove(transaction.hash());\n            }\n        } else {\n            Log.e(Mempool, `Invalid state: no transactionsByRecipient for ${transaction}`);\n        }\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Transaction}\n     */\n    getTransaction(hash) {\n        return this._transactionsByHash.get(hash);\n    }\n\n    /**\n     * @param {number} [maxSize]\n     * @param {number} [minFeePerByte]\n     * @returns {Array.<Transaction>}\n     */\n    *transactionGenerator(maxSize = Infinity, minFeePerByte = 0) {\n        let size = 0;\n        for (const /** @type {Transaction} */ tx of this._transactionsByFeePerByte) {\n            const txSize = tx.serializedSize;\n            if (size + txSize >= maxSize) continue;\n            if (tx.feePerByte < minFeePerByte) break;\n\n            yield tx;\n            size += txSize;\n        }\n    }\n\n    /**\n     * @param {number} [maxSize]\n     * @param {number} [minFeePerByte]\n     * @returns {Array.<Transaction>}\n     */\n    getTransactions(maxSize = Infinity, minFeePerByte = 0) {\n        return Array.from(this.transactionGenerator(maxSize, minFeePerByte));\n    }\n\n    /**\n     * @param {number} maxSize\n     * @returns {Promise.<Array.<Transaction>>}\n     */\n    async getTransactionsForBlock(maxSize) {\n        const transactions = this.getTransactions(maxSize);\n        const prunedAccounts = await this._accounts.gatherToBePrunedAccounts(transactions, this._blockchain.height + 1, this._blockchain.transactionCache);\n        const prunedAccountsSize = prunedAccounts.reduce((sum, acc) => sum + acc.serializedSize, 0);\n\n        let size = prunedAccountsSize + transactions.reduce((sum, tx) => sum + tx.serializedSize, 0);\n        while (size > maxSize) {\n            size -= transactions.pop().serializedSize;\n        }\n\n        transactions.sort((a, b) => a.compareBlockOrder(b));\n        return transactions;\n    }\n\n    /**\n     * @param {Address} address\n     * @return {Array.<Transaction>}\n     */\n    getPendingTransactions(address) {\n        return this.getTransactionsBySender(address);\n    }\n\n    /**\n     * @param {Address} address\n     * @return {Array.<Transaction>}\n     */\n    getTransactionsBySender(address) {\n        /** @type {MempoolTransactionSet} */\n        const set = this._transactionSetBySender.get(address);\n        return set ? set.transactions : [];\n    }\n\n    /**\n     * @param {Address} address\n     * @return {Array.<Transaction>}\n     */\n    getTransactionsByRecipient(address) {\n        /** @type {HashSet.<Hash>} */\n        const set = this._transactionSetByRecipient.get(address);\n        if (!set) {\n            return [];\n        }\n\n        /** @type {Array.<Transaction>} */\n        const transactions = [];\n        for (const hash of set.valueIterator()) {\n            const tx = this._transactionsByHash.get(hash);\n            Assert.that(!!tx);\n            transactions.push(tx);\n        }\n        return transactions;\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     * @param {number} [maxTransactions]\n     * @return {Array.<Transaction>}\n     */\n    getTransactionsByAddresses(addresses, maxTransactions = Infinity) {\n        const transactions = [];\n        for (const address of addresses) {\n            // Fetch transactions by sender first\n            /** @type {Array.<Transaction>} */\n            const bySender = this.getTransactionsBySender(address);\n            for (const tx of bySender) {\n                if (transactions.length >= maxTransactions) return transactions;\n                transactions.push(tx);\n            }\n\n            // Fetch transactions by recipient second\n            /** @type {Array.<Transaction>} */\n            const byRecipient = this.getTransactionsByRecipient(address);\n            for (const tx of byRecipient) {\n                if (transactions.length >= maxTransactions) return transactions;\n                transactions.push(tx);\n            }\n        }\n        return transactions;\n    }\n\n    /**\n     * @param {number} minFeePerByte\n     */\n    evictBelowMinFeePerByte(minFeePerByte) {\n        /** @type {Transaction} */\n        let transaction = this._transactionsByFeePerByte.peekLast();\n        while (transaction && transaction.feePerByte < minFeePerByte) {\n            this._transactionsByFeePerByte.pop();\n\n            this._transactionsByHash.remove(transaction.hash());\n\n            /** @type {MempoolTransactionSet} */\n            const bySender = this._transactionSetBySender.get(transaction.sender);\n            if (bySender.length === 1) {\n                this._transactionSetBySender.remove(transaction.sender);\n            } else {\n                bySender.remove(transaction);\n            }\n            /** @type {HashSet.<Hash>} */\n            const byRecipient = this._transactionSetByRecipient.get(transaction.recipient);\n            if (byRecipient.length === 1) {\n                this._transactionSetByRecipient.remove(transaction.recipient);\n            } else {\n                byRecipient.remove(transaction.hash());\n            }\n\n            transaction = this._transactionsByFeePerByte.peekLast();\n        }\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise}\n     * @private\n     */\n    _restoreTransactions(block) {\n        return this._synchronizer.push(async () => {\n            for (const tx of block.transactions) {\n                await this._pushTransaction(tx);\n            }\n        });\n    }\n\n    /**\n     * @fires Mempool#transactions-ready\n     * @returns {Promise}\n     * @private\n     */\n    _evictTransactions() {\n        return this._synchronizer.push(() => this.__evictTransactions());\n    }\n\n    /**\n     * @fires Mempool#transactions-ready\n     * @returns {Promise}\n     * @private\n     */\n    async __evictTransactions() {\n        // Evict all transactions from the pool that have become invalid due\n        // to changes in the account state (i.e. typically because the were included\n        // in a newly mined block). No need to re-check signatures.\n        for (const sender of this._transactionSetBySender.keys()) {\n            /** @type {MempoolTransactionSet} */\n            const set = this._transactionSetBySender.get(sender);\n\n            try {\n                const senderAccount = await this._accounts.get(set.sender, set.senderType);\n\n                // If a transaction in the set is not valid anymore,\n                // we try to construct a new set based on the heuristic of including\n                // high fee/byte transactions first.\n                const transactions = [];\n                let account = senderAccount;\n                for (const tx of set.transactions) {\n                    try {\n                        const tmpAccount = account.withOutgoingTransaction(tx, this._blockchain.height + 1, this._blockchain.transactionCache);\n\n                        const recipientAccount = await this._accounts.get(tx.recipient);\n                        recipientAccount.withIncomingTransaction(tx, this._blockchain.height + 1);\n\n                        transactions.push(tx);\n                        account = tmpAccount;\n                    } catch (e) {\n                        // Remove transaction\n                        this._removeTransaction(tx);\n                    }\n                }\n                if (transactions.length === 0) {\n                    this._transactionSetBySender.remove(sender);\n                } else {\n                    this._transactionSetBySender.put(sender, new MempoolTransactionSet(transactions));\n                }\n            } catch (e) {\n                // In case of an error, remove all transactions of this set.\n                for (const tx of set.transactions) {\n                    this._removeTransaction(tx);\n                }\n                this._transactionSetBySender.remove(sender);\n            }\n        }\n\n        // Tell listeners that the pool has updated after a blockchain head change.\n        /**\n         * @event Mempool#transactions-ready\n         */\n        this.fire('transactions-ready');\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._transactionsByHash.length;\n    }\n}\n\n/**\n * Fee threshold in sat/byte below which transactions are considered \"free\".\n * @type {number}\n */\nMempool.TRANSACTION_RELAY_FEE_MIN = 1;\n/**\n * Maximum number of transactions per sender.\n * @type {number}\n */\nMempool.TRANSACTIONS_PER_SENDER_MAX = 500;\n/**\n * Maximum number of \"free\" transactions per sender.\n * @type {number}\n */\nMempool.FREE_TRANSACTIONS_PER_SENDER_MAX = 10;\n/**\n * Maximum number of transactions in the mempool.\n * @type {number}\n */\nMempool.SIZE_MAX = 100000;\n\n/** @enum {number} */\nMempool.ReturnCode = {\n    FEE_TOO_LOW: -2,\n    INVALID: -1,\n\n    ACCEPTED: 1,\n    KNOWN: 2\n};\n\nClass.register(Mempool);\n","/**\n * @abstract\n */\nclass BaseConsensusAgent extends Observable {\n    /**\n     * @param {Time} time\n     * @param {Peer} peer\n     * @param {Subscription} [targetSubscription]\n     */\n    constructor(time, peer, targetSubscription) {\n        super();\n        /** @type {Time} */\n        this._time = time;\n        /** @type {Peer} */\n        this._peer = peer;\n\n        // Flag indicating that have synced our blockchain with the peer's.\n        /** @type {boolean} */\n        this._synced = false;\n\n        // Set of all objects (InvVectors) that we think the remote peer knows.\n        /** @type {HashSet.<InvVector>} */\n        this._knownObjects = new HashSet();\n        this._knownObjects.add(new InvVector(InvVector.Type.BLOCK, peer.headHash));\n\n        // InvVectors we want to request via getData are collected here and\n        // periodically requested.\n        /** @type {UniqueQueue.<InvVector>} */\n        this._blocksToRequest = new UniqueQueue();\n        /** @type {ThrottledQueue.<InvVector>} */\n        this._txsToRequest = new ThrottledQueue(\n            BaseConsensusAgent.TRANSACTIONS_AT_ONCE + BaseConsensusAgent.FREE_TRANSACTIONS_AT_ONCE,\n            BaseConsensusAgent.TRANSACTIONS_PER_SECOND + BaseConsensusAgent.FREE_TRANSACTIONS_PER_SECOND,\n            1000, BaseConsensusAgent.REQUEST_TRANSACTIONS_WAITING_MAX);\n\n        // Objects that are currently being requested from the peer.\n        /** @type {HashSet.<InvVector>} */\n        this._objectsInFlight = new HashSet();\n\n        // All objects that were requested from the peer but not received yet.\n        /** @type {HashSet.<InvVector>} */\n        this._objectsThatFlew = new HashSet();\n\n        // Objects that are currently being processed by the blockchain/mempool.\n        /** @type {HashSet.<InvVector>} */\n        this._objectsProcessing = new HashSet();\n\n        // A Subscription object specifying which objects should be announced to the peer.\n        // Initially, we don't announce anything to the peer until it tells us otherwise.\n        /** @type {Subscription} */\n        this._remoteSubscription = Subscription.NONE;\n        // Subscribe to all announcements from the peer.\n        /** @type {Subscription} */\n        this._localSubscription = Subscription.NONE;\n        this._lastSubscriptionChange = null;\n        /** @type {Subscription} */\n        this._targetSubscription = targetSubscription || Subscription.ANY;\n\n        // Helper object to keep track of timeouts & intervals.\n        /** @type {Timers} */\n        this._timers = new Timers();\n\n        // Queue of transaction inv vectors waiting to be sent out\n        /** @type {ThrottledQueue.<InvVector>} */\n        this._waitingInvVectors = new ThrottledQueue(\n            BaseConsensusAgent.TRANSACTIONS_AT_ONCE,\n            BaseConsensusAgent.TRANSACTIONS_PER_SECOND,\n            1000, BaseConsensusAgent.REQUEST_TRANSACTIONS_WAITING_MAX);\n        this._timers.setInterval('invVectors', () => this._sendWaitingInvVectors(), BaseConsensusAgent.TRANSACTION_RELAY_INTERVAL);\n\n        // Queue of \"free\" transaction inv vectors waiting to be sent out\n        /** @type {ThrottledQueue.<{serializedSize:number, vector:InvVector}>} */\n        this._waitingFreeInvVectors = new ThrottledQueue(\n            BaseConsensusAgent.FREE_TRANSACTIONS_AT_ONCE,\n            BaseConsensusAgent.FREE_TRANSACTIONS_PER_SECOND,\n            1000, BaseConsensusAgent.REQUEST_TRANSACTIONS_WAITING_MAX);\n        this._timers.setInterval('freeInvVectors', () => this._sendFreeWaitingInvVectors(), BaseConsensusAgent.FREE_TRANSACTION_RELAY_INTERVAL);\n\n        // Helper object to keep track of block proofs we're requesting.\n        this._blockProofRequest = null;\n\n        // Helper object to keep track of transaction proofs we're requesting.\n        this._transactionsProofRequest = null;\n\n        // Helper object to keep track of transaction receipts we're requesting.\n        this._transactionReceiptsRequest = null;\n\n        /** @type {MultiSynchronizer} */\n        this._synchronizer = new MultiSynchronizer();\n\n        // Listen to consensus messages from the peer.\n        peer.channel.on('inv', msg => this._onInv(msg));\n        peer.channel.on('block', msg => this._onBlock(msg));\n        peer.channel.on('header', msg => this._onHeader(msg));\n        peer.channel.on('tx', msg => this._onTx(msg));\n        peer.channel.on('not-found', msg => this._onNotFound(msg));\n\n        peer.channel.on('subscribe', msg => this._onSubscribe(msg));\n        peer.channel.on('get-data', msg => this._onGetData(msg));\n        peer.channel.on('get-header', msg => this._onGetHeader(msg));\n\n        peer.channel.on('block-proof', msg => this._onBlockProof(msg));\n        peer.channel.on('transactions-proof', msg => this._onTransactionsProof(msg));\n        peer.channel.on('transaction-receipts', msg => this._onTransactionReceipts(msg));\n\n        peer.channel.on('get-head', msg => this._onGetHead(msg));\n        peer.channel.on('head', msg => this._onHead(msg));\n\n        // Clean up when the peer disconnects.\n        peer.channel.on('close', () => this._onClose());\n\n        this._requestHead();\n    }\n\n    _requestHead() {\n        this._peer.channel.getHead();\n    }\n\n    onHeadUpdated() {\n        this._timers.resetTimeout('get-next-head', () => this._requestHead(), BaseConsensusAgent.HEAD_REQUEST_INTERVAL);\n    }\n\n    /**\n     * @param {GetHeadMessage} msg\n     * @private\n     */\n    _onGetHead(msg) {\n        this._peer.channel.head(this._blockchain.head.header);\n    }\n\n    /**\n     * @param {HeadMessage} msg\n     */\n    _onHead(msg) {\n        this._peer.head = msg.header;\n        this.onHeadUpdated();\n    }\n\n    /**\n     * @param {Subscription} subscription\n     */\n    subscribe(subscription) {\n        this._targetSubscription = subscription;\n        this._subscribe(subscription);\n    }\n\n    _subscribeTarget() {\n        this._subscribe(this._targetSubscription);\n    }\n\n    /**\n     * @param {Subscription} subscription\n     */\n    _subscribe(subscription) {\n        this._localSubscription = subscription;\n        this._lastSubscriptionChange = Date.now();\n        this._peer.channel.subscribe(this._localSubscription);\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {boolean}\n     */\n    relayBlock(block) {\n        // Don't relay block if have not synced with the peer yet.\n        if (!this._synced) {\n            return false;\n        }\n\n        // Only relay block if it matches the peer's subscription.\n        if (!this._remoteSubscription.matchesBlock(block)) {\n            return false;\n        }\n\n        // Create InvVector.\n        const vector = InvVector.fromBlock(block);\n\n        // Don't relay block to this peer if it already knows it.\n        if (this._knownObjects.contains(vector)) {\n            return false;\n        }\n\n        // Relay block to peer.\n        this._peer.channel.inv([vector, ...this._waitingInvVectors.dequeueMulti(BaseInventoryMessage.VECTORS_MAX_COUNT - 1)]);\n\n        // Assume that the peer knows this block now.\n        this._knownObjects.add(vector);\n\n        return true;\n    }\n\n    _sendWaitingInvVectors() {\n        const invVectors = this._waitingInvVectors.dequeueMulti(BaseInventoryMessage.VECTORS_MAX_COUNT);\n        if (invVectors.length > 0) {\n            this._peer.channel.inv(invVectors);\n            Log.v(BaseConsensusAgent, () => `[INV] Sent ${invVectors.length} vectors to ${this._peer.peerAddress}`);\n        }\n    }\n\n    _sendFreeWaitingInvVectors() {\n        const invVectors = [];\n        let size = 0;\n        while (invVectors.length <= BaseInventoryMessage.VECTORS_MAX_COUNT && this._waitingFreeInvVectors.length > 0\n            && size < BaseConsensusAgent.FREE_TRANSACTION_SIZE_PER_INTERVAL) {\n            const {serializedSize, vector} = this._waitingFreeInvVectors.dequeue();\n            invVectors.push(vector);\n            size += serializedSize;\n        }\n        if (invVectors.length > 0) {\n            this._peer.channel.inv(invVectors);\n            Log.v(BaseConsensusAgent, () => `[INV] Sent ${invVectors.length} vectors to ${this._peer.peerAddress}`);\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    relayTransaction(transaction) {\n        // Only relay transaction if it matches the peer's subscription.\n        if (!this._remoteSubscription.matchesTransaction(transaction)) {\n            return false;\n        }\n\n        // Create InvVector.\n        const vector = InvVector.fromTransaction(transaction);\n\n        // Don't relay transaction to this peer if it already knows it.\n        if (this._knownObjects.contains(vector)) {\n            return false;\n        }\n\n        // Relay transaction to peer later.\n        const serializedSize = transaction.serializedSize;\n        if (transaction.fee / serializedSize < BaseConsensusAgent.TRANSACTION_RELAY_FEE_MIN) {\n            this._waitingFreeInvVectors.enqueue({serializedSize, vector});\n        } else {\n            this._waitingInvVectors.enqueue(vector);\n        }\n\n        // Assume that the peer knows this transaction now.\n        this._knownObjects.add(vector);\n\n        return true;\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @returns {boolean}\n     */\n    knowsBlock(blockHash) {\n        const vector = new InvVector(InvVector.Type.BLOCK, blockHash);\n        return this._knownObjects.contains(vector);\n    }\n\n    /**\n     * @param {SubscribeMessage} msg\n     * @protected\n     */\n    _onSubscribe(msg) {\n        Log.d(BaseConsensusAgent, `[SUBSCRIBE] ${this._peer.peerAddress} ${msg.subscription}`);\n        this._remoteSubscription = msg.subscription;\n    }\n\n    /**\n     * @param {InvMessage} msg\n     * @returns {Promise.<void>}\n     * @protected\n     */\n    async _onInv(msg) {\n        // Keep track of the objects the peer knows.\n        for (const vector of msg.vectors) {\n            this._knownObjects.add(vector);\n            this._waitingInvVectors.remove(vector);\n            this._waitingFreeInvVectors.remove(vector);\n        }\n\n        // Check which of the advertised objects we know\n        // Request unknown objects, ignore known ones.\n        const unknownBlocks = [];\n        const unknownTxs = [];\n        for (const vector of msg.vectors) {\n            // Ignore objects that we are currently requesting / processing.\n            if (this._objectsInFlight.contains(vector) || this._objectsProcessing.contains(vector)) {\n                continue;\n            }\n\n            // Filter out objects that we are not interested in.\n            if (!this._shouldRequestData(vector)) {\n                continue;\n            }\n\n            switch (vector.type) {\n                case InvVector.Type.BLOCK: {\n                    const block = await this._getBlock(vector.hash, /*includeForks*/ true); // eslint-disable-line no-await-in-loop\n                    if (!block) {\n                        unknownBlocks.push(vector);\n                        this._onNewBlockAnnounced(vector.hash);\n                    } else {\n                        this._onKnownBlockAnnounced(vector.hash, block);\n                    }\n                    break;\n                }\n                case InvVector.Type.TRANSACTION: {\n                    const transaction = await this._getTransaction(vector.hash); // eslint-disable-line no-await-in-loop\n                    if (!transaction) {\n                        unknownTxs.push(vector);\n                        this._onNewTransactionAnnounced(vector.hash);\n                    } else {\n                        this._onKnownTransactionAnnounced(vector.hash, transaction);\n                    }\n                    break;\n                }\n                default:\n                    throw `Invalid inventory type: ${vector.type}`;\n            }\n        }\n\n        Log.v(BaseConsensusAgent, () => `[INV] ${msg.vectors.length} vectors (${unknownBlocks.length} new blocks, ${unknownTxs.length} new txs) received from ${this._peer.peerAddress}`);\n\n        if (unknownBlocks.length > 0 || unknownTxs.length > 0) {\n            // Store unknown vectors in objectsToRequest.\n            this._blocksToRequest.enqueueAllNew(unknownBlocks);\n            this._txsToRequest.enqueueAllNew(unknownTxs);\n\n            // Clear the request throttle timeout.\n            this._timers.clearTimeout('inv');\n\n            // If there are enough objects queued up, send out a getData request.\n            if (this._blocksToRequest.length + this._txsToRequest.available >= BaseConsensusAgent.REQUEST_THRESHOLD) {\n                this._requestData();\n            }\n            // Otherwise, wait a short time for more inv messages to arrive, then request.\n            else {\n                this._timers.setTimeout('inv', () => this._requestData(), BaseConsensusAgent.REQUEST_THROTTLE);\n            }\n        } else {\n            this._onNoUnknownObjects();\n        }\n    }\n\n    /**\n     * @param {InvVector} vector\n     * @returns {boolean}\n     * @protected\n     */\n    _shouldRequestData(vector) {\n        return true;\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {boolean} [includeForks]\n     * @param {boolean} [includeBody]\n     * @returns {Promise.<?Block>}\n     * @protected\n     * @abstract\n     */\n    _getBlock(hash, includeForks = false, includeBody = false) {\n        // MUST be implemented by subclasses.\n        throw new Error('not implemented');\n    }\n    /**\n     * @param {Hash} hash\n     * @returns {Promise.<?Transaction>}\n     * @protected\n     * @abstract\n     */\n    _getTransaction(hash) {\n        // MUST be implemented by subclasses.\n        throw new Error('not implemented');\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {void}\n     * @protected\n     */\n    _onNewBlockAnnounced(hash) {\n    }\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @returns {void}\n     * @protected\n     */\n    _onKnownBlockAnnounced(hash, block) {\n    }\n    /**\n     * @param {Hash} hash\n     * @returns {void}\n     * @protected\n     */\n    _onNewTransactionAnnounced(hash) {\n    }\n    /**\n     * @param {Hash} hash\n     * @param {Transaction} transaction\n     * @returns {void}\n     * @protected\n     */\n    _onKnownTransactionAnnounced(hash, transaction) {\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     */\n    _requestData() {\n        // Only one request at a time.\n        if (!this._objectsInFlight.isEmpty()) return;\n\n        // Don't do anything if there are no objects queued to request.\n        if (this._blocksToRequest.isEmpty() && !this._txsToRequest.isAvailable()) return;\n\n        // Request queued objects from the peer. Only request up to VECTORS_MAX_COUNT objects at a time.\n        const vectorsMaxCount = BaseInventoryMessage.VECTORS_MAX_COUNT;\n        /** @type {Array.<InvVector>} */\n        let vectors = this._blocksToRequest.dequeueMulti(vectorsMaxCount);\n        if (vectors.length < vectorsMaxCount) {\n            vectors = vectors.concat(this._txsToRequest.dequeueMulti(vectorsMaxCount - vectors.length));\n        }\n\n        // Mark the requested objects as in-flight.\n        this._objectsInFlight.addAll(vectors);\n\n        // Request data from peer.\n        this._doRequestData(vectors);\n\n        // Set timer to detect end of request / missing objects\n        this._timers.setTimeout('getData', () => this._noMoreData(), BaseConsensusAgent.REQUEST_TIMEOUT);\n    }\n\n    /**\n     * @param {Array.<InvVector>} vectors\n     * @returns {void}\n     * @protected\n     */\n    _doRequestData(vectors) {\n        this._peer.channel.getData(vectors);\n    }\n\n    /**\n     * @param {BlockMessage} msg\n     * @return {Promise.<void>}\n     * @protected\n     */\n    async _onBlock(msg) {\n        const hash = msg.block.hash();\n\n        // Check if we have requested this block.\n        const vector = new InvVector(InvVector.Type.BLOCK, hash);\n        if (!this._objectsInFlight.contains(vector) && !this._objectsThatFlew.contains(vector)) {\n            Log.w(BaseConsensusAgent, `Unsolicited block ${hash} received from ${this._peer.peerAddress}, discarding`);\n            return;\n        }\n\n        // Reuse already known (verified) transactions\n        const transactions = msg.block.isFull() ? msg.block.body.transactions : [];\n        const transactionPromises = transactions.map(t => this._getTransaction(t.hash()));\n        for (let i = 0; i < transactions.length; i++) {\n            const transaction = await transactionPromises[i]; // eslint-disable-line no-await-in-loop\n            if (transaction) {\n                transactions[i] = transaction;\n            }\n        }\n\n        if ((!this._peer.head && this._peer.headHash.equals(hash)) || (this._peer.head && this._peer.head.height < msg.block.height)) {\n            this._peer.head = msg.block.header;\n            this.onHeadUpdated();\n        }\n\n        // Mark object as received.\n        this._onObjectReceived(vector);\n\n        // Process block.\n        this._objectsProcessing.add(vector);\n        await this._processBlock(hash, msg.block);\n\n        // Mark object as processed.\n        this._onObjectProcessed(vector);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @returns {Promise.<void>}\n     * @protected\n     */\n    async _processBlock(hash, block) {\n    }\n\n    /**\n     * @param {HeaderMessage} msg\n     * @return {Promise.<void>}\n     * @protected\n     */\n    async _onHeader(msg) {\n        const hash = msg.header.hash();\n\n        // Check if we have requested this header.\n        const vector = new InvVector(InvVector.Type.BLOCK, hash);\n        if (!this._objectsInFlight.contains(vector) && !this._objectsThatFlew.contains(vector)) {\n            Log.w(BaseConsensusAgent, `Unsolicited header ${hash} received from ${this._peer.peerAddress}, discarding`);\n            return;\n        }\n\n        if ((!this._peer.head && this._peer.headHash.equals(hash)) || (this._peer.head && this._peer.head.height < msg.header.height)) {\n            this._peer.head = msg.header;\n            this.onHeadUpdated();\n        }\n\n        // Mark object as received.\n        this._onObjectReceived(vector);\n\n        // Process header.\n        this._objectsProcessing.add(vector);\n        await this._processHeader(hash, msg.header);\n\n        // Mark object as processed.\n        this._onObjectProcessed(vector);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {BlockHeader} header\n     * @returns {Promise.<void>}\n     * @protected\n     */\n    async _processHeader(hash, header) {\n    }\n\n    /**\n     * @param {TxMessage} msg\n     * @return {Promise}\n     * @protected\n     */\n    async _onTx(msg) {\n        const hash = msg.transaction.hash();\n        //Log.d(BaseConsensusAgent, () => `[TX] Received transaction ${hash} from ${this._peer.peerAddress}`);\n\n        // Check if we have requested this transaction.\n        const vector = new InvVector(InvVector.Type.TRANSACTION, hash);\n        if (!this._objectsInFlight.contains(vector) && !this._objectsThatFlew.contains(vector)) {\n            Log.w(BaseConsensusAgent, `Unsolicited transaction ${hash} received from ${this._peer.peerAddress}, discarding`);\n            return;\n        }\n\n        // Mark object as received.\n        this._onObjectReceived(vector);\n\n        // Process transaction.\n        this._objectsProcessing.add(vector);\n\n        // Check whether we subscribed for this transaction.\n        if (this._localSubscription.matchesTransaction(msg.transaction)) {\n            await this._processTransaction(hash, msg.transaction);\n        } else if (this._lastSubscriptionChange + BaseConsensusAgent.SUBSCRIPTION_CHANGE_GRACE_PERIOD > Date.now()) {\n            this._peer.channel.close(CloseType.RECEIVED_TRANSACTION_NOT_MATCHING_OUR_SUBSCRIPTION, 'received transaction not matching our subscription');\n        }\n\n        // Mark object as processed.\n        this._onObjectProcessed(vector);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Transaction} transaction\n     * @returns {Promise.<void>}\n     * @protected\n     */\n    async _processTransaction(hash, transaction) {\n    }\n\n    /**\n     * @param {NotFoundMessage} msg\n     * @returns {void}\n     * @protected\n     */\n    _onNotFound(msg) {\n        Log.d(BaseConsensusAgent, `[NOTFOUND] ${msg.vectors.length} unknown objects received from ${this._peer.peerAddress}`);\n\n        // Remove unknown objects from in-flight list.\n        for (const vector of msg.vectors) {\n            if (!this._objectsInFlight.contains(vector)) {\n                continue;\n            }\n\n            // Mark object as received.\n            this._onObjectReceived(vector);\n        }\n    }\n\n    /**\n     * @param {InvVector} vector\n     * @returns {void}\n     * @protected\n     */\n    _onObjectReceived(vector) {\n        if (this._objectsInFlight.isEmpty()) return;\n\n        // Remove the vector from objectsInFlight.\n        this._objectsInFlight.remove(vector);\n\n        // Reset the request timeout if we expect more objects to come.\n        if (!this._objectsInFlight.isEmpty()) {\n            this._timers.resetTimeout('getData', () => this._noMoreData(), BaseConsensusAgent.REQUEST_TIMEOUT);\n        } else {\n            this._noMoreData();\n        }\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     */\n    _noMoreData() {\n        // Cancel the request timeout timer.\n        this._timers.clearTimeout('getData');\n\n        // Reset objects in flight.\n        this._objectsThatFlew.addAll(this._objectsInFlight.values());\n        this._objectsInFlight.clear();\n\n        // If there are more objects to request, request them.\n        if (!this._blocksToRequest.isEmpty() || this._txsToRequest.isAvailable()) {\n            this._requestData();\n        } else {\n            this._onAllObjectsReceived();\n        }\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     */\n    _onNoUnknownObjects() {\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     */\n    _onAllObjectsReceived() {\n    }\n\n    /**\n     * @param {InvVector} vector\n     * @returns {void}\n     * @protected\n     */\n    _onObjectProcessed(vector) {\n        // Remove the vector from objectsProcessing.\n        this._objectsProcessing.remove(vector);\n\n        if (this._objectsProcessing.isEmpty()) {\n            this._onAllObjectsProcessed();\n        }\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     */\n    _onAllObjectsProcessed() {\n    }\n\n    /**\n     * @param {GetDataMessage} msg\n     * @returns {Promise}\n     * @protected\n     */\n    async _onGetData(msg) {\n        // Keep track of the objects the peer knows.\n        for (const vector of msg.vectors) {\n            this._knownObjects.add(vector);\n        }\n\n        // Check which of the requested objects we know.\n        // Send back all known objects.\n        // Send notFound for unknown objects.\n        const unknownObjects = [];\n        for (const vector of msg.vectors) {\n            switch (vector.type) {\n                case InvVector.Type.BLOCK: {\n                    const block = await this._getBlock(vector.hash, /*includeForks*/ false, /*includeBody*/ true); // eslint-disable-line no-await-in-loop\n                    if (block && block.isFull()) {\n                        // We have found a requested block, send it back to the sender.\n                        this._peer.channel.block(block);\n                    } else {\n                        // Requested block is unknown.\n                        unknownObjects.push(vector);\n                    }\n                    break;\n                }\n                case InvVector.Type.TRANSACTION: {\n                    const tx = await this._getTransaction(vector.hash); // eslint-disable-line no-await-in-loop\n                    if (tx) {\n                        // We have found a requested transaction, send it back to the sender.\n                        this._peer.channel.tx(tx);\n                    } else {\n                        // Requested transaction is unknown.\n                        unknownObjects.push(vector);\n                    }\n                    break;\n                }\n                default:\n                    throw `Invalid inventory type: ${vector.type}`;\n            }\n        }\n\n        // Report any unknown objects back to the sender.\n        if (unknownObjects.length) {\n            this._peer.channel.notFound(unknownObjects);\n        }\n    }\n\n    /**\n     * @param {GetHeaderMessage} msg\n     * @returns {Promise}\n     * @protected\n     */\n    async _onGetHeader(msg) {\n        // Keep track of the objects the peer knows.\n        for (const vector of msg.vectors) {\n            this._knownObjects.add(vector);\n        }\n\n        // Check which of the requested objects we know.\n        // Send back all known objects.\n        // Send notFound for unknown objects.\n        const unknownObjects = [];\n        for (const vector of msg.vectors) {\n            switch (vector.type) {\n                case InvVector.Type.BLOCK: {\n                    const block = await this._getBlock(vector.hash); // eslint-disable-line no-await-in-loop\n                    if (block) {\n                        // We have found a requested block, send it back to the sender.\n                        this._peer.channel.header(block.header);\n                    } else {\n                        // Requested block is unknown.\n                        unknownObjects.push(vector);\n                    }\n                    break;\n                }\n                case InvVector.Type.TRANSACTION:\n                default:\n                    throw `Invalid inventory type: ${vector.type}`;\n            }\n        }\n\n        // Report any unknown objects back to the sender.\n        if (unknownObjects.length) {\n            this._peer.channel.notFound(unknownObjects);\n        }\n    }\n\n    /**\n     * @param {Hash} blockHashToProve\n     * @param {Block} knownBlock\n     * @returns {Promise.<Block>}\n     */\n    getBlockProof(blockHashToProve, knownBlock) {\n        return this._synchronizer.push('getBlockProof',\n            this._getBlockProof.bind(this, blockHashToProve, knownBlock));\n    }\n\n    /**\n     * @param {Hash} blockHashToProve\n     * @param {Block} knownBlock\n     * @returns {Promise.<Block>}\n     * @private\n     */\n    _getBlockProof(blockHashToProve, knownBlock) {\n        Assert.that(this._blockProofRequest === null);\n\n        Log.d(BaseConsensusAgent, () => `Requesting BlockProof for ${blockHashToProve} from ${this._peer.peerAddress}`);\n\n        return new Promise((resolve, reject) => {\n            this._blockProofRequest = {\n                blockHashToProve,\n                knownBlock,\n                resolve,\n                reject\n            };\n\n            // Request BlockProof from peer.\n            this._peer.channel.getBlockProof(blockHashToProve, knownBlock.hash());\n\n            this._peer.channel.expectMessage(Message.Type.BLOCK_PROOF, () => {\n                reject(new Error('timeout'));\n            }, BaseConsensusAgent.BLOCK_PROOF_REQUEST_TIMEOUT);\n        });\n    }\n\n    /**\n     * @param {BlockProofMessage} msg\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _onBlockProof(msg) {\n        Log.d(BaseConsensusAgent, () => `[BLOCK-PROOF] Received from ${this._peer.peerAddress}: proof=${msg.proof} (${msg.serializedSize} bytes)`);\n\n        // Check if we have requested a header proof, reject unsolicited ones.\n        if (!this._blockProofRequest) {\n            Log.w(BaseConsensusAgent, `Unsolicited header proof received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n\n        const { blockHashToProve, /** @type {Block} */ knownBlock, resolve, reject } = this._blockProofRequest;\n        this._blockProofRequest = null;\n\n        if (!msg.hasProof() || msg.proof.length === 0) {\n            reject(new Error('Block proof request was rejected'));\n            return;\n        }\n\n        // Check that the tail of the proof corresponds to the requested block.\n        const proof = msg.proof;\n        if (!blockHashToProve.equals(proof.tail.hash())) {\n            Log.w(BaseConsensusAgent, `Received BlockProof with invalid tail block from ${this._peer.peerAddress}`);\n            reject(new Error('Invalid tail block'));\n            return;\n        }\n\n        // Check that the proof links up to our reference block.\n        if (!(await knownBlock.isInterlinkSuccessorOf(proof.head))) {\n            Log.w(BaseConsensusAgent, `Received BlockProof with invalid head block from ${this._peer.peerAddress}`);\n            reject(new Error('Invalid head block'));\n            return;\n        }\n\n        // Verify the proof.\n        if (!(await proof.verify())) {\n            Log.w(BaseConsensusAgent, `Invalid BlockProof received from ${this._peer.peerAddress}`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.INVALID_BLOCK_PROOF, 'Invalid BlockProof');\n            reject(new Error('Invalid BlockProof'));\n            return;\n        }\n\n        // Verify individual blocks.\n        const verificationResults = await Promise.all(proof.blocks.map(block => block.verify(this._time)));\n        if (!verificationResults.every(result => result)) {\n            Log.w(BaseConsensusAgent, `Invalid BlockProof received from ${this._peer.peerAddress}`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.INVALID_BLOCK_PROOF, 'Invalid BlockProof');\n            reject(new Error('Invalid BlockProof'));\n            return;\n        }\n\n        // Return the proven block.\n        resolve(proof.tail);\n    }\n\n    /**\n     * @param {Block} block\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<Array.<Transaction>>}\n     */\n    getTransactionsProof(block, addresses) {\n        return this._synchronizer.push('getTransactionsProof',\n            this._getTransactionsProof.bind(this, block, addresses));\n    }\n\n    /**\n     * @param {Block} block\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<Array.<Transaction>>}\n     * @private\n     */\n    _getTransactionsProof(block, addresses) {\n        Assert.that(this._transactionsProofRequest === null);\n\n        Log.d(BaseConsensusAgent, () => `Requesting TransactionsProof for ${addresses}@${block.height} from ${this._peer.peerAddress}`);\n\n        return new Promise((resolve, reject) => {\n            this._transactionsProofRequest = {\n                addresses,\n                block,\n                resolve,\n                reject,\n            };\n\n            // Request TransactionProof from peer.\n            this._peer.channel.getTransactionsProof(block.hash(), addresses);\n\n            // Drop the peer if it doesn't send the TransactionProof within the timeout.\n            this._peer.channel.expectMessage(Message.Type.TRANSACTIONS_PROOF, () => {\n                this._peer.channel.close(CloseType.GET_TRANSACTIONS_PROOF_TIMEOUT, 'getTransactionsProof timeout');\n                reject(new Error('timeout'));\n            }, BaseConsensusAgent.TRANSACTIONS_PROOF_REQUEST_TIMEOUT);\n        });\n    }\n\n    /**\n     * @param {TransactionsProofMessage} msg\n     * @returns {void}\n     * @private\n     */\n    _onTransactionsProof(msg) {\n        Log.d(BaseConsensusAgent, () => `[TRANSACTIONS-PROOF] Received from ${this._peer.peerAddress}: blockHash=${msg.blockHash}, proof=${msg.proof} (${msg.serializedSize} bytes)`);\n\n        // Check if we have requested a transactions proof, reject unsolicited ones.\n        if (!this._transactionsProofRequest) {\n            Log.w(BaseConsensusAgent, `Unsolicited transactions proof received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n\n        const {/** @type {Block} */ block, resolve, reject} = this._transactionsProofRequest;\n        this._transactionsProofRequest = null;\n\n        if (!msg.hasProof()) {\n            Log.w(BaseConsensusAgent, `TransactionsProof request was rejected by ${this._peer.peerAddress}`);\n            reject(new Error('TransactionsProof request was rejected'));\n            return;\n        }\n\n        // Check that the reference block corresponds to the one we requested.\n        if (!block.hash().equals(msg.blockHash)) {\n            Log.w(BaseConsensusAgent, `Received TransactionsProof for invalid reference block from ${this._peer.peerAddress}`);\n            reject(new Error('Invalid reference block'));\n            return;\n        }\n\n        // Verify the proof.\n        const proof = msg.proof;\n        if (!block.bodyHash.equals(proof.root())) {\n            Log.w(BaseConsensusAgent, `Invalid TransactionsProof received from ${this._peer.peerAddress}`);\n            this._peer.channel.close(CloseType.INVALID_TRANSACTION_PROOF, 'Invalid TransactionsProof');\n            reject(new Error('Invalid TransactionsProof'));\n            return;\n        }\n\n        // TODO Verify that the proof only contains transactions that match the given addresses.\n\n        // Return the retrieved transactions.\n        resolve(proof.transactions);\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise.<Array.<TransactionReceipt>>}\n     */\n    getTransactionReceipts(address) {\n        return this._synchronizer.push('getTransactionReceipts',\n            this._getTransactionReceipts.bind(this, address));\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise.<Array.<TransactionReceipt>>}\n     * @private\n     */\n    _getTransactionReceipts(address) {\n        Assert.that(this._transactionReceiptsRequest === null);\n\n        return new Promise((resolve, reject) => {\n            this._transactionReceiptsRequest = {\n                address,\n                resolve,\n                reject\n            };\n\n            this._peer.channel.getTransactionReceipts(address);\n\n            this._peer.channel.expectMessage(Message.Type.TRANSACTION_RECEIPTS, () => {\n                this._peer.channel.close(CloseType.GET_TRANSACTION_RECEIPTS_TIMEOUT, 'getTransactionReceipts timeout');\n                reject(new Error('timeout'));\n            }, BaseConsensusAgent.TRANSACTION_RECEIPTS_REQUEST_TIMEOUT);\n        });\n    }\n\n    /**\n     * @param {TransactionReceiptsMessage} msg\n     * @returns {void}\n     * @private\n     */\n    _onTransactionReceipts(msg) {\n        Log.d(BaseConsensusAgent, () => `[TRANSACTION-RECEIPTS] Received from ${this._peer.peerAddress}: ${msg.transactionReceipts.length}`);\n\n        // Check if we have requested transaction receipts, reject unsolicited ones.\n        if (!this._transactionReceiptsRequest) {\n            Log.w(BaseConsensusAgent, `Unsolicited transaction receipts received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n\n        const {resolve} = this._transactionReceiptsRequest;\n        this._transactionReceiptsRequest = null;\n\n        // TODO Verify that the transaction receipts match the given address.\n\n        resolve(msg.transactionReceipts);\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     */\n    _onClose() {\n        this._synchronizer.clear();\n\n        // Clear all timers and intervals when the peer disconnects.\n        this._timers.clearAll();\n        this._txsToRequest.stop();\n        this._waitingInvVectors.stop();\n        this._waitingFreeInvVectors.stop();\n\n        // Notify listeners that the peer has disconnected.\n        this.fire('close', this);\n    }\n\n    /** @type {Peer} */\n    get peer() {\n        return this._peer;\n    }\n\n    /** @type {boolean} */\n    get synced() {\n        return this._synced;\n    }\n}\n/**\n * Number of InvVectors in invToRequest pool to automatically trigger a get-data request.\n * @type {number}\n */\nBaseConsensusAgent.REQUEST_THRESHOLD = 50;\n/**\n * Time (ms) to wait after the last received inv message before sending get-data.\n * @type {number}\n */\nBaseConsensusAgent.REQUEST_THROTTLE = 500;\n/**\n * Maximum time (ms) to wait after sending out get-data or receiving the last object for this request.\n * @type {number}\n */\nBaseConsensusAgent.REQUEST_TIMEOUT = 1000 * 10;\nBaseConsensusAgent.REQUEST_TRANSACTIONS_WAITING_MAX = 5000;\nBaseConsensusAgent.REQUEST_BLOCKS_WAITING_MAX = 5000;\n/**\n * Maximum time (ms) to wait for block-proof.\n * @type {number}\n */\nBaseConsensusAgent.BLOCK_PROOF_REQUEST_TIMEOUT = 1000 * 10;\n/**\n * Maximum time (ms) to wait for transactions-proof.\n * @type {number}\n */\nBaseConsensusAgent.TRANSACTIONS_PROOF_REQUEST_TIMEOUT = 1000 * 10;\n/**\n * Maximum time (ms) to wait for transactions-receipts.\n * @type {number}\n */\nBaseConsensusAgent.TRANSACTION_RECEIPTS_REQUEST_TIMEOUT = 1000 * 15;\n/**\n * Time interval (ms) to wait between sending out transactions.\n * @type {number}\n */\nBaseConsensusAgent.TRANSACTION_RELAY_INTERVAL = 5000;\nBaseConsensusAgent.TRANSACTIONS_AT_ONCE = 100;\nBaseConsensusAgent.TRANSACTIONS_PER_SECOND = 10;\n/**\n * Time interval (ms) to wait between sending out \"free\" transactions.\n * @type {number}\n */\nBaseConsensusAgent.FREE_TRANSACTION_RELAY_INTERVAL = 6000;\nBaseConsensusAgent.FREE_TRANSACTIONS_AT_ONCE = 10;\nBaseConsensusAgent.FREE_TRANSACTIONS_PER_SECOND = 1;\n/**\n * Soft limit for the total size (bytes) of free transactions per relay interval.\n * @type {number}\n */\nBaseConsensusAgent.FREE_TRANSACTION_SIZE_PER_INTERVAL = 15000; // ~100 legacy transactions\n/**\n * Minimum fee per byte (sat/byte) such that a transaction is not considered free.\n * @type {number}\n */\nBaseConsensusAgent.TRANSACTION_RELAY_FEE_MIN = 1;\n/**\n * Number of ms the peer may send non-matching transactions/blocks after a subscription change.\n * @type {number}\n */\nBaseConsensusAgent.SUBSCRIPTION_CHANGE_GRACE_PERIOD = 1000 * 2;\nBaseConsensusAgent.HEAD_REQUEST_INTERVAL = 100 * 1000; // 100 seconds, give client time to announce new head without request\nClass.register(BaseConsensusAgent);\n","/**\n * @abstract\n */\nclass BaseConsensus extends Observable {\n    /**\n     * @param {BaseChain} blockchain\n     * @param {Observable} mempool\n     * @param {Network} network\n     */\n    constructor(blockchain, mempool, network) {\n        super();\n        /** @type {BaseChain} */\n        this._blockchain = blockchain;\n        /** @type {Network} */\n        this._network = network;\n\n        /** @type {HashMap.<Peer,BaseConsensusAgent>} */\n        this._agents = new HashMap();\n\n        /** @type {Timers} */\n        this._timers = new Timers();\n\n        /** @type {boolean} */\n        this._established = false;\n\n        /** @type {Peer} */\n        this._syncPeer = null;\n\n        /** @type {Subscription} */\n        this._subscription = Subscription.ANY;\n\n        network.on('peer-joined', peer => this._onPeerJoined(peer));\n        network.on('peer-left', peer => this._onPeerLeft(peer));\n\n        // Notify peers when our blockchain head changes.\n        blockchain.on('head-changed', head => this._onHeadChanged(head));\n\n        // Relay new (verified) transactions to peers.\n        mempool.on('transaction-added', tx => this._onTransactionAdded(tx));\n    }\n\n    /**\n     * @param {Subscription} subscription\n     */\n    subscribe(subscription) {\n        this._subscription = subscription;\n        for (const /** @type {BaseConsensusAgent} */ agent of this._agents.values()) {\n            agent.subscribe(subscription);\n        }\n    }\n\n    /**\n     * @param {Peer} peer\n     * @returns {BaseConsensusAgent}\n     * @protected\n     */\n    _newConsensusAgent(peer) {\n        throw new Error('not implemented');\n    }\n\n    /**\n     * @param {Peer} peer\n     * @returns {BaseConsensusAgent}\n     * @protected\n     */\n    _onPeerJoined(peer) {\n        // Create a ConsensusAgent for each peer that connects.\n        const agent = this._newConsensusAgent(peer);\n        this._agents.put(peer.id, agent);\n\n        // Register agent event listeners.\n        agent.on('close', () => this._onPeerLeft(agent.peer));\n        agent.on('sync', () => this._onPeerSynced(agent.peer));\n        agent.on('out-of-sync', () => this._onPeerOutOfSync(agent.peer));\n\n        // If no more peers connect within the specified timeout, start syncing.\n        this._timers.resetTimeout('sync', this._syncBlockchain.bind(this), BaseConsensus.SYNC_THROTTLE);\n\n        return agent;\n    }\n\n    /**\n     * @param {Peer} peer\n     * @protected\n     */\n    _onPeerLeft(peer) {\n        // Reset syncPeer if it left during the sync.\n        if (peer.equals(this._syncPeer)) {\n            Log.d(BaseConsensus, `Peer ${peer.peerAddress} left during sync`);\n            this._syncPeer = null;\n            this.fire('sync-failed', peer.peerAddress);\n        }\n\n        this._agents.remove(peer.id);\n        this._syncBlockchain();\n    }\n\n    /**\n     * @protected\n     */\n    _syncBlockchain() {\n        const candidates = [];\n        let numSyncedFullNodes = 0;\n        for (const /** @type {BaseConsensusAgent} */ agent of this._agents.valueIterator()) {\n            if (!agent.synced) {\n                candidates.push(agent);\n            } else if (Services.isFullNode(agent.peer.peerAddress.services)) {\n                numSyncedFullNodes++;\n            }\n        }\n\n        // Report consensus-lost if we are synced with less than the minimum number of full nodes or have no connections at all.\n        if (this._established && (numSyncedFullNodes < BaseConsensus.MIN_FULL_NODES || this._agents.length === 0)) {\n            this._established = false;\n            this.fire('lost');\n        }\n\n        // Wait for ongoing sync to finish.\n        if (this._syncPeer) {\n            return;\n        }\n\n        // Choose a random peer which we aren't sync'd with yet.\n        const agent = ArrayUtils.randomElement(candidates);\n        if (!agent) {\n            // We are synced with all connected peers.\n\n            // Report consensus-established if we are connected to the minimum number of full nodes.\n            if (numSyncedFullNodes >= BaseConsensus.MIN_FULL_NODES) {\n                if (!this._established) {\n                    Log.i(BaseConsensus, `Synced with all connected peers (${this._agents.length}), consensus established.`);\n                    Log.d(BaseConsensus, `Blockchain: height=${this._blockchain.height}, headHash=${this._blockchain.headHash}`);\n\n                    // Report consensus-established.\n                    this._established = true;\n                    this.fire('established');\n\n                    // Allow inbound network connections after establishing consensus.\n                    this._network.allowInboundConnections = true;\n                }\n            }\n            // Otherwise, wait until more peer connections are established.\n            else {\n                this.fire('waiting');\n            }\n\n            return;\n        }\n\n        this._syncPeer = agent.peer;\n\n        // Notify listeners when we start syncing and have not established consensus yet.\n        if (!this._established) {\n            this.fire('syncing');\n        }\n\n        Log.v(BaseConsensus, `Syncing blockchain with peer ${agent.peer.peerAddress}`);\n        agent.syncBlockchain().catch(Log.w.tag(BaseConsensusAgent));\n    }\n\n    /**\n     * @param {Peer} peer\n     * @protected\n     */\n    _onPeerSynced(peer) {\n        // Reset syncPeer if we finished syncing with it.\n        if (peer.equals(this._syncPeer)) {\n            Log.v(BaseConsensus, `Finished sync with peer ${peer.peerAddress}`);\n            this._syncPeer = null;\n        }\n        this._syncBlockchain();\n    }\n\n    /**\n     * @param {Peer} peer\n     * @protected\n     */\n    _onPeerOutOfSync(peer) {\n        Log.w(BaseConsensus, `Peer ${peer.peerAddress} out of sync, resyncing`);\n        this._syncBlockchain();\n    }\n\n    /**\n     * @param {Block} head\n     * @protected\n     */\n    _onHeadChanged(head) {\n        // Don't announce head changes if we are not synced yet.\n        if (!this._established) return;\n\n        for (const agent of this._agents.values()) {\n            agent.relayBlock(head);\n        }\n    }\n\n    /**\n     * @param {Transaction} tx\n     * @protected\n     */\n    _onTransactionAdded(tx) {\n        // Don't relay transactions if we are not synced yet.\n        if (!this._established) return;\n\n        for (const agent of this._agents.values()) {\n            agent.relayTransaction(tx);\n        }\n    }\n\n    /**\n     * @param {Hash} blockHashToProve\n     * @param {number} blockHeightToProve\n     * @returns {Promise.<Block>}\n     * @protected\n     */\n    async _requestBlockProof(blockHashToProve, blockHeightToProve) {\n        /** @type {Block} */\n        const knownBlock = await this._blockchain.getNearestBlockAt(blockHeightToProve, /*lower*/ false);\n        if (!knownBlock) {\n            throw new Error('No suitable reference block found for BlockProof');\n        }\n\n        if (blockHashToProve.equals(knownBlock.hash())) {\n            return knownBlock;\n        }\n\n        const agents = this._agents.values().filter(agent =>\n            agent.synced\n            && Services.isFullNode(agent.peer.peerAddress.services)\n        );\n\n        // Try agents first that (we think) know the reference block hash.\n        const knownBlockHash = knownBlock.hash();\n        agents.sort((a, b) => b.knowsBlock(knownBlockHash) - a.knowsBlock(knownBlockHash));\n\n        for (const /** @type {BaseConsensusAgent} */ agent of agents) {\n            try {\n                return await agent.getBlockProof(blockHashToProve, knownBlock); // eslint-disable-line no-await-in-loop\n            } catch (e) {\n                Log.w(BaseConsensus, `Failed to retrieve block proof for ${blockHashToProve}@${blockHeightToProve} from ${agent.peer.peerAddress}: ${e.message || e}`);\n                // Try the next peer.\n            }\n        }\n\n        // No peer supplied the requested account, fail.\n        throw new Error(`Failed to retrieve block proof for ${blockHashToProve}`);\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     * @param {Block} [block]\n     * @returns {Promise.<Array<Transaction>>}\n     * @protected\n     */\n    async _requestTransactionsProof(addresses, block = this._blockchain.head) {\n        if (addresses.length === 0) {\n            return [];\n        }\n\n        const agents = this._agents.values().filter(agent =>\n            agent.synced\n            && !Services.isNanoNode(agent.peer.peerAddress.services)\n        );\n\n        // Try agents first that (we think) know the reference block hash.\n        const blockHash = block.hash();\n        agents.sort((a, b) => b.knowsBlock(blockHash) - a.knowsBlock(blockHash));\n\n        for (const /** @type {BaseConsensusAgent} */ agent of agents) {\n            try {\n                return await agent.getTransactionsProof(block, addresses); // eslint-disable-line no-await-in-loop\n            } catch (e) {\n                Log.w(BaseConsensus, `Failed to retrieve transactions proof for ${addresses} from ${agent.peer.peerAddress}: ${e.message || e}`);\n                // Try the next peer.\n            }\n        }\n\n        // No peer supplied the requested proof, fail.\n        throw new Error(`Failed to retrieve transactions proof for ${addresses}`);\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise.<Array.<TransactionReceipt>>}\n     * @protected\n     */\n    async _requestTransactionReceipts(address) {\n        const agents = this._agents.values().filter(agent =>\n            agent.synced\n            && Services.isFullNode(agent.peer.peerAddress.services)\n        );\n\n        for (const /** @type {BaseConsensusAgent} */ agent of agents) {\n            try {\n                return await agent.getTransactionReceipts(address); // eslint-disable-line no-await-in-loop\n            } catch (e) {\n                Log.w(BaseConsensus, `Failed to retrieve transaction receipts for ${address} from ${agent.peer.peerAddress}: ${e.message || e}`);\n                // Try the next peer.\n            }\n        }\n\n        // No peer supplied the requested receipts, fail.\n        throw new Error(`Failed to retrieve transaction receipts for ${address}`);\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise.<Array.<{transaction: Transaction, header: BlockHeader}>>}\n     * @protected\n     */\n    async _requestTransactionHistory(address) {\n        // 1. Get transaction receipts.\n        const receipts = await this._requestTransactionReceipts(address);\n\n        // 2. Request proofs for missing blocks.\n        /** @type {Array.<Promise.<Block>>} */\n        const blockRequests = [];\n        let lastBlockHash = null;\n        for (const receipt of receipts) {\n            if (!receipt.blockHash.equals(lastBlockHash)) {\n                // eslint-disable-next-line no-await-in-loop\n                const block = await this._blockchain.getBlock(receipt.blockHash);\n                if (block) {\n                    blockRequests.push(Promise.resolve(block));\n                } else {\n                    const request = this._requestBlockProof(receipt.blockHash, receipt.blockHeight)\n                        .catch(e => Log.e(BaseConsensus, `Failed to retrieve proof for block ${receipt.blockHash}`\n                            + ` (${e.message || e}) - transaction history may be incomplete`));\n                    blockRequests.push(request);\n                }\n\n                lastBlockHash = receipt.blockHash;\n            }\n        }\n        const blocks = await Promise.all(blockRequests);\n\n        // 3. Request transaction proofs.\n        const transactionRequests = [];\n        for (const block of blocks) {\n            if (!block) continue;\n\n            const request = this._requestTransactionsProof([address], block)\n                .then(txs => txs.map(tx => ({ transaction: tx, header: block.header })))\n                .catch(e => Log.e(BaseConsensus, `Failed to retrieve transactions for block ${block.hash}`\n                    + ` (${e.message || e}) - transaction history may be incomplete`));\n            transactionRequests.push(request);\n        }\n\n        const transactions = await Promise.all(transactionRequests);\n        return transactions\n            .reduce((flat, it) => it ? flat.concat(it) : flat, [])\n            .sort((a, b) => a.header.height - b.header.height);\n    }\n\n    /** @type {boolean} */\n    get established() {\n        return this._established;\n    }\n\n    /** @type {Network} */\n    get network() {\n        return this._network;\n    }\n}\nBaseConsensus.SYNC_THROTTLE = 1500; // ms\nBaseConsensus.MIN_FULL_NODES = 1;\nClass.register(BaseConsensus);\n","/**\n * An anchored, contiguous chain of full blocks.\n */\nclass FullChain extends BaseChain {\n    /**\n     * @param {JungleDB} jdb\n     * @param {Accounts} accounts\n     * @param {Time} time\n     * @param {TransactionStore} [transactionStore]\n     * @returns {Promise.<FullChain>}\n     */\n    static getPersistent(jdb, accounts, time, transactionStore) {\n        const store = ChainDataStore.getPersistent(jdb);\n        const chain = new FullChain(store, accounts, time, transactionStore);\n        return chain._init();\n    }\n\n    /**\n     * @param {Accounts} accounts\n     * @param {Time} time\n     * @param {TransactionStore} [transactionStore]\n     * @returns {Promise.<FullChain>}\n     */\n    static createVolatile(accounts, time, transactionStore) {\n        const store = ChainDataStore.createVolatile();\n        const chain = new FullChain(store, accounts, time, transactionStore);\n        return chain._init();\n    }\n\n    /**\n     * @param {ChainDataStore} store\n     * @param {Accounts} accounts\n     * @param {Time} time\n     * @param {TransactionStore} [transactionStore]\n     * @returns {FullChain}\n     */\n    constructor(store, accounts, time, transactionStore) {\n        super(store);\n        this._accounts = accounts;\n        this._time = time;\n\n        /** @type {HashMap.<Hash,Accounts>} */\n        this._snapshots = new HashMap();\n        /** @type {Array.<Hash>} */\n        this._snapshotOrder = [];\n\n        /** @type {ChainData} */\n        this._mainChain = null;\n\n        /** @type {ChainProof} */\n        this._proof = null;\n\n        /** @type {TransactionCache} */\n        this._transactionCache = new TransactionCache();\n\n        /** @type {TransactionStore} */\n        this._transactionStore = transactionStore;\n\n        /** @type {PrioritySynchronizer} */\n        this._synchronizer = new PrioritySynchronizer(2);\n\n        /** @type {number} */\n        this._blockKnownCount = this._blockInvalidCount = this._blockOrphanCount = this._blockExtendedCount = this._blockRebranchedCount = this._blockForkedCount = 0;\n    }\n\n    /**\n     * @returns {Promise.<FullChain>}\n     * @protected\n     */\n    async _init() {\n        this._headHash = await this._store.getHead();\n        if (this._headHash) {\n            // Check that the correct genesis block is stored.\n            const genesis = await this._store.getChainData(GenesisConfig.GENESIS_HASH);\n            if (!genesis || !genesis.onMainChain) {\n                throw new Error('Invalid genesis block stored. Reset your consensus database.');\n            }\n\n            // Load main chain from store.\n            this._mainChain = await this._store.getChainData(this._headHash, /*includeBody*/ true);\n            Assert.that(!!this._mainChain, 'Failed to load main chain from storage');\n\n            // Check that chain/accounts state is consistent.\n            if (!this._mainChain.head.accountsHash.equals(await this._accounts.hash())) {\n                throw new Error('Corrupted store: Inconsistent chain/accounts state');\n            }\n\n            // Initialize TransactionCache.\n            const blocks = await this._store.getBlocksBackward(this.headHash, this._transactionCache.missingBlocks - 1, /*includeBody*/ true);\n            this._transactionCache.prependBlocks([...blocks.reverse(), this._mainChain.head]);\n        } else {\n            // Initialize chain & accounts with Genesis block.\n            this._mainChain = await ChainData.initial(GenesisConfig.GENESIS_BLOCK);\n            this._headHash = GenesisConfig.GENESIS_HASH;\n\n            const tx = this._store.synchronousTransaction();\n            tx.putChainDataSync(GenesisConfig.GENESIS_HASH, this._mainChain);\n            tx.setHeadSync(GenesisConfig.GENESIS_HASH);\n            await tx.commit();\n\n            await this._accounts.initialize(GenesisConfig.GENESIS_BLOCK, GenesisConfig.GENESIS_ACCOUNTS);\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     */\n    pushBlock(block) {\n        return this._synchronizer.push(/*priority*/ 0,\n            this._pushBlock.bind(this, block));\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     * @protected\n     */\n    async _pushBlock(block) {\n        // Check if we already know this block.\n        const hash = block.hash();\n        const knownBlock = await this._store.getBlock(hash);\n        if (knownBlock) {\n            this._blockKnownCount++;\n            return FullChain.OK_KNOWN;\n        }\n\n        // Check that the given block is a full block (includes block body).\n        if (!block.isFull()) {\n            Log.w(FullChain, 'Rejecting block - body missing');\n            this._blockInvalidCount++;\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check all intrinsic block invariants.\n        if (!(await block.verify(this._time))) {\n            this._blockInvalidCount++;\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check that all known interlink blocks are valid predecessors of the given block.\n        // if (!(await this._verifyInterlink(block))) {\n        //     Log.w(FullChain, 'Rejecting block - interlink verification failed');\n        //     return FullChain.ERR_INVALID;\n        // }\n\n        // Check if the block's immediate predecessor is part of the chain.\n        /** @type {ChainData} */\n        const prevData = await this._store.getChainData(block.prevHash);\n        if (!prevData) {\n            Log.w(FullChain, 'Rejecting block - unknown predecessor');\n            this._blockOrphanCount++;\n            return FullChain.ERR_ORPHAN;\n        }\n\n        // Check that the block is a valid successor of its immediate predecessor.\n        const predecessor = prevData.head;\n        if (!(await block.isImmediateSuccessorOf(predecessor))) {\n            Log.w(FullChain, 'Rejecting block - not a valid immediate successor');\n            this._blockInvalidCount++;\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check that the difficulty is correct.\n        const nextTarget = await this.getNextTarget(predecessor);\n        Assert.that(BlockUtils.isValidTarget(nextTarget), 'Failed to compute next target in FullChain');\n        if (block.nBits !== BlockUtils.targetToCompact(nextTarget)) {\n            Log.w(FullChain, 'Rejecting block - difficulty mismatch');\n            this._blockInvalidCount++;\n            return FullChain.ERR_INVALID;\n        }\n\n        // Block looks good, create ChainData.\n        const chainData = await prevData.nextChainData(block);\n\n        // Check if the block extends our current main chain.\n        if (block.prevHash.equals(this.headHash)) {\n            // Append new block to the main chain.\n            if (!(await this._extend(hash, chainData, prevData))) {\n                this._blockInvalidCount++;\n                return FullChain.ERR_INVALID;\n            }\n            this._blockExtendedCount++;\n            return FullChain.OK_EXTENDED;\n        }\n\n        // Otherwise, check if the new chain is harder than our current main chain.\n        if (chainData.totalDifficulty > this.totalDifficulty) {\n            // A fork has become the hardest chain, rebranch to it.\n            if (!(await this._rebranch(hash, chainData))) {\n                this._blockInvalidCount++;\n                return FullChain.ERR_INVALID;\n            }\n            this._blockRebranchedCount++;\n            return FullChain.OK_REBRANCHED;\n        }\n\n        // Otherwise, we are creating/extending a fork. Store chain data.\n        Log.v(FullChain, `Creating/extending fork with block ${hash}, height=${block.height}, totalDifficulty=${chainData.totalDifficulty}, totalWork=${chainData.totalWork}`);\n        await this._store.putChainData(hash, chainData);\n\n        this._blockForkedCount++;\n        return FullChain.OK_FORKED;\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<boolean>}\n     * @protected\n     */\n    async _verifyInterlink(block) {\n        // Check that all blocks referenced in the interlink of the given block are valid predecessors of that block.\n        for (let i = 0; i < block.interlink.length; i++) {\n            const predecessor = await this._store.getBlock(block.interlink.hashes[i]); // eslint-disable-line no-await-in-loop\n            if (!predecessor || !(await block.isInterlinkSuccessorOf(predecessor))) { // eslint-disable-line no-await-in-loop\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {ChainData} chainData\n     * @param {ChainData} prevData\n     * @returns {Promise.<boolean>}\n     * @fires FullChain#head-changed\n     * @private\n     */\n    async _extend(blockHash, chainData, prevData) {\n        const accountsTx = await this._accounts.transaction();\n        try {\n            await accountsTx.commitBlock(chainData.head, this._transactionCache);\n        } catch (e) {\n            // AccountsHash mismatch. This can happen if someone gives us an invalid block.\n            // TODO error handling\n            Log.w(FullChain, `Rejecting block - failed to commit to AccountsTree: ${e.message || e}`);\n            accountsTx.abort().catch(Log.w.tag(FullChain));\n            return false;\n        }\n\n        chainData.onMainChain = true;\n        prevData.mainChainSuccessor = blockHash;\n\n        const storeTx = await this._store.synchronousTransaction();\n        storeTx.putChainDataSync(blockHash, chainData);\n        storeTx.putChainDataSync(chainData.head.prevHash, prevData, /*includeBody*/ false);\n        storeTx.setHeadSync(blockHash);\n\n        if (this._transactionStore) {\n            const transactionStoreTx = this._transactionStore.transaction();\n            await transactionStoreTx.put(chainData.head);\n            await JDB.JungleDB.commitCombined(...storeTx.txs, accountsTx.tx, transactionStoreTx.tx);\n        } else {\n            await JDB.JungleDB.commitCombined(...storeTx.txs, accountsTx.tx);\n        }\n\n        // New block on main chain, so store a new snapshot.\n        await this._saveSnapshot(blockHash);\n\n        // Update transactions cache.\n        this._transactionCache.pushBlock(chainData.head);\n\n        if (this._shouldExtendChainProof() && this._proof) {\n            // If we want to maintain our proof by extending it and have a cached proof, extend it.\n            this._proof = await this._extendChainProof(this._proof, chainData.head.header);\n        } else {\n            // Otherwise, clear the proof and recompute it the next time it is needed.\n            this._proof = null;\n        }\n\n        // Update head.\n        this._mainChain = chainData;\n        this._headHash = blockHash;\n\n        // Tell listeners that the head of the chain has changed.\n        this.fire('head-changed', this.head, /*rebranching*/ false);\n\n        return true;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n    _shouldExtendChainProof() {\n        return false;\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {ChainData} chainData\n     * @returns {Promise.<boolean>}\n     * @protected\n     */\n    async _rebranch(blockHash, chainData) {\n        Log.v(FullChain, `Rebranching to fork ${blockHash}, height=${chainData.head.height}, totalDifficulty=${chainData.totalDifficulty}, totalWork=${chainData.totalWork}`);\n\n        // Drop all snapshots.\n        for (const hash of this._snapshotOrder) {\n            const snapshot = this._snapshots.get(hash);\n            snapshot.abort(); // We do not need to wait for the abortion as long as it has been triggered.\n        }\n        this._snapshots.clear();\n        this._snapshotOrder = [];\n\n        // Find the common ancestor between our current main chain and the fork chain.\n        // Walk up the fork chain until we find a block that is part of the main chain.\n        // Store the chain along the way.\n        /** @type {Array.<ChainData>} */\n        const forkChain = [];\n        /** @type {Array.<Hash>} */\n        const forkHashes = [];\n\n        /** @type {ChainData} */\n        let curData = chainData;\n        /** @type {Hash} */\n        let curHash = blockHash;\n        while (!curData.onMainChain) {\n            forkChain.push(curData);\n            forkHashes.push(curHash);\n\n            curHash = curData.head.prevHash;\n            // TODO FIXME This can fail in the light client. It might not have the requested block at all or only the light block.\n            curData = await this._store.getChainData(curHash, /*includeBody*/ true); // eslint-disable-line no-await-in-loop\n            Assert.that(!!curData, 'Corrupted store: Failed to find fork predecessor while rebranching');\n        }\n\n        Log.v(FullChain, () => `Found common ancestor ${curHash.toBase64()} ${forkChain.length} blocks up`);\n\n        /** @type {ChainData} */\n        const ancestorData = curData;\n        /** @type {Hash} */\n        const ancestorHash = curHash;\n\n        // Validate all accountsHashes on the fork. Revert the AccountsTree to the common ancestor state first.\n        const accountsTx = await this._accounts.transaction(false);\n        const transactionCacheTx = this._transactionCache.clone();\n        // Also update transactions in index.\n        const transactionStoreTx = this._transactionStore ? this._transactionStore.transaction() : null;\n\n        /** @type {Array.<ChainData>} */\n        const revertChain = [];\n        /** @type {Hash} */\n        let headHash = this._headHash;\n        /** @type {ChainData} */\n        let headData = this._mainChain;\n        while (!headHash.equals(ancestorHash)) {\n            try {\n                // This only works in the light client if we revert less than Policy.TRANSACTION_VALIDITY_WINDOW blocks.\n                await accountsTx.revertBlock(headData.head, transactionCacheTx);\n                transactionCacheTx.revertBlock(headData.head);\n\n                // Also update transactions in index.\n                if (this._transactionStore) {\n                    await transactionStoreTx.remove(headData.head);\n                }\n                revertChain.push(headData);\n            } catch (e) {\n                Log.e(FullChain, 'Failed to revert main chain while rebranching', e);\n                accountsTx.abort().catch(Log.w.tag(FullChain));\n                if (this._transactionStore) {\n                    transactionStoreTx.abort().catch(Log.w.tag(FullChain));\n                }\n                return false;\n            }\n\n            headHash = headData.head.prevHash;\n            headData = await this._store.getChainData(headHash, /*includeBody*/ true);\n            Assert.that(!!headData, 'Corrupted store: Failed to find main chain predecessor while rebranching');\n            Assert.that(headData.head.accountsHash.equals(await accountsTx.hash()), 'Failed to revert main chain - inconsistent state');\n        }\n\n        // Try to fetch missing transactions for the cache.\n        // TODO FIXME The light client might not have all necessary blocks.\n        const numMissingBlocks = transactionCacheTx.missingBlocks;\n        const blocks = await this._store.getBlocksBackward(headHash, numMissingBlocks, /*includeBody*/ true);\n        transactionCacheTx.prependBlocks(blocks.reverse());\n\n        // Try to apply all fork blocks.\n        for (let i = forkChain.length - 1; i >= 0; i--) {\n            try {\n                await accountsTx.commitBlock(forkChain[i].head, transactionCacheTx);\n                transactionCacheTx.pushBlock(forkChain[i].head);\n\n                // Also update transactions in index.\n                if (this._transactionStore) {\n                    await transactionStoreTx.put(forkChain[i].head);\n                }\n            } catch (e) {\n                // A fork block is invalid.\n                // TODO delete invalid block and its successors from store.\n                Log.e(FullChain, 'Failed to apply fork block while rebranching', e);\n                accountsTx.abort().catch(Log.w.tag(FullChain));\n                if (this._transactionStore) {\n                    transactionStoreTx.abort().catch(Log.w.tag(FullChain));\n                }\n                return false;\n            }\n        }\n\n        // Fork looks good.\n        // Unset onMainChain flag / mainChainSuccessor on the current main chain up to (excluding) the common ancestor.\n        /** @type {ChainDataStore} */\n        const chainTx = this._store.synchronousTransaction(false);\n        for (const revertedData of revertChain) {\n            revertedData.onMainChain = false;\n            revertedData.mainChainSuccessor = null;\n            chainTx.putChainDataSync(revertedData.head.hash(), revertedData, /*includeBody*/ false);\n        }\n\n        // Update the mainChainSuccessor of the common ancestor block.\n        ancestorData.mainChainSuccessor = forkHashes[forkHashes.length - 1];\n        chainTx.putChainDataSync(ancestorHash, ancestorData, /*includeBody*/ false);\n\n        // Set onMainChain flag / mainChainSuccessor on the fork.\n        for (let i = forkChain.length - 1; i >= 0; i--) {\n            const forkData = forkChain[i];\n            forkData.onMainChain = true;\n            forkData.mainChainSuccessor = i > 0 ? forkHashes[i - 1] : null;\n            // Include the body of the new block (at position 0).\n            chainTx.putChainDataSync(forkHashes[i], forkData, /*includeBody*/ i === 0);\n        }\n\n        // Update head & commit transactions.\n        chainTx.setHeadSync(blockHash);\n        if (this._transactionStore) {\n            await JDB.JungleDB.commitCombined(...chainTx.txs, accountsTx.tx, transactionStoreTx.tx);\n        } else {\n            await JDB.JungleDB.commitCombined(...chainTx.txs, accountsTx.tx);\n        }\n        this._transactionCache = transactionCacheTx;\n\n        // Reset chain proof. We don't recompute the chain proof here, but do it lazily the next time it is needed.\n        // TODO modify chain proof directly, don't recompute.\n        this._proof = null;\n\n        // Fire block-reverted event for each block reverted during rebranch\n        for (const revertedData of revertChain) {\n            this.fire('block-reverted', revertedData.head);\n        }\n\n        // Fire head-changed event for each fork block.\n        for (let i = forkChain.length - 1; i >= 0; i--) {\n            this._mainChain = forkChain[i];\n            this._headHash = forkHashes[i];\n            this.fire('head-changed', this.head, /*rebranching*/ i > 0);\n        }\n\n        return true;\n    }\n\n    /**\n     *\n     * @param {Hash} startBlockHash\n     * @param {number} count\n     * @param {boolean} forward\n     * @returns {Promise.<Array.<Block>>}\n     */\n    getBlocks(startBlockHash, count = 500, forward = true) {\n        return this._store.getBlocks(startBlockHash, count, forward);\n    }\n\n    /**\n     * @returns {Promise.<ChainProof>}\n     * @override\n     */\n    getChainProof() {\n        return this._synchronizer.push(/*priority*/ 1, async () => {\n            if (!this._proof) {\n                this._proof = await this._getChainProof();\n            }\n            return this._proof;\n        });\n    }\n\n    /**\n     * @param {Block} blockToProve\n     * @param {Block} knownBlock\n     * @returns {Promise.<?BlockChain>}\n     **/\n    getBlockProof(blockToProve, knownBlock) {\n        return this._synchronizer.push(/*priority*/ 1,\n            this._getBlockProof.bind(this, blockToProve, knownBlock));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {string} startPrefix\n     * @returns {Promise.<?AccountsTreeChunk>}\n     */\n    async getAccountsTreeChunk(blockHash, startPrefix) {\n        const snapshot = await this._getSnapshot(blockHash);\n        return snapshot && await snapshot.getAccountsTreeChunk(startPrefix);\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<?AccountsProof>}\n     */\n    async getAccountsProof(blockHash, addresses) {\n        const snapshot = await this._getSnapshot(blockHash);\n        return snapshot && await snapshot.getAccountsProof(addresses);\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<?TransactionsProof>}\n     */\n    async getTransactionsProof(blockHash, addresses) {\n        const block = await this.getBlock(blockHash, /*includeForks*/ false, /*includeBody*/ true);\n        if (!block || !block.isFull()) {\n            return null;\n        }\n\n        const matches = [];\n        const addressesSet = new HashSet();\n        addressesSet.addAll(addresses);\n        for (const transaction of block.transactions) {\n            if (addressesSet.contains(transaction.sender) || addressesSet.contains(transaction.recipient)) {\n                matches.push(transaction);\n            }\n        }\n\n        const proof = MerkleProof.compute(block.body.getMerkleLeafs(), matches);\n        return new TransactionsProof(matches, proof);\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise.<Array.<TransactionReceipt>>}\n     */\n    async getTransactionReceiptsByAddress(address) {\n        if (!this._transactionStore) {\n            throw new Error('Invalid request');\n        }\n\n        const transactionReceipts = [];\n\n        const entriesBySender = await this._transactionStore.getBySender(address);\n        const entriesByRecipient = await this._transactionStore.getByRecipient(address);\n\n        entriesBySender.forEach(entry => {\n            transactionReceipts.push(new TransactionReceipt(entry.transactionHash, entry.blockHash, entry.blockHeight));\n        });\n\n        entriesByRecipient.forEach(entry => {\n            transactionReceipts.push(new TransactionReceipt(entry.transactionHash, entry.blockHash, entry.blockHeight));\n        });\n\n        return transactionReceipts;\n    }\n\n    /**\n     * @param {Hash} transactionHash\n     * @returns {Promise.<?TransactionStoreEntry>}\n     */\n    async getTransactionInfoByHash(transactionHash) {\n        if (!this._transactionStore) {\n            throw new Error('Invalid request');\n        }\n\n        const txStoreEntry = await this._transactionStore.get(transactionHash);\n        if (!txStoreEntry) {\n            return null;\n        }\n\n        return txStoreEntry;\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @returns {Promise.<?Accounts>}\n     */\n    _getSnapshot(blockHash) {\n        // TODO Does this have to be synchronized with pushBlock() ?\n        return this._synchronizer.push(/*priority*/ 1, async () => {\n            const block = await this.getBlock(blockHash);\n            // Check if blockHash is a block on the main chain within the allowed window.\n            if (!block || this._mainChain.head.height - block.height > Policy.NUM_SNAPSHOTS_MAX) {\n                return null;\n            }\n\n            // Check if there already is a snapshot, otherwise create it.\n            let snapshot = null;\n            if (!this._snapshots.contains(blockHash)) {\n                const tx = await this._accounts.transaction();\n                const transactionsTx = this._transactionCache.clone();\n                let currentHash = this._headHash;\n                // Save all snapshots up to blockHash (and stop when its predecessor would be next).\n                while (!block.prevHash.equals(currentHash)) {\n                    const currentBlock = await this.getBlock(currentHash, /*includeForks*/ false, /*includeBody*/ true);\n\n                    if (!this._snapshots.contains(currentHash)) {\n                        snapshot = await this._accounts.snapshot(tx);\n                        this._snapshots.put(currentHash, snapshot);\n                        this._snapshotOrder.unshift(currentHash);\n                    }\n\n                    await tx.revertBlock(currentBlock, transactionsTx);\n                    transactionsTx.revertBlock(currentBlock);\n                    currentHash = currentBlock.prevHash;\n                }\n                await tx.abort();\n            } else {\n                snapshot = this._snapshots.get(blockHash);\n            }\n\n            Assert.that(block.accountsHash.equals(await snapshot.hash()), 'AccountsHash mismatch for snapshot of block ${blockHash}');\n\n            return snapshot;\n        });\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _saveSnapshot(blockHash) {\n        // Replace oldest snapshot if possible.\n        // This ensures snapshots are only created lazily.\n        if (this._snapshotOrder.length > 0) {\n            const oldestHash = this._snapshotOrder.shift();\n            // If the hash is not reused, remove it.\n            const oldestSnapshot = this._snapshots.get(oldestHash);\n            if (oldestSnapshot) {\n                await oldestSnapshot.abort();\n            } else {\n                Log.e(FullChain, () => `Snapshot with hash ${oldestHash.toBase64()} not found.`);\n            }\n            this._snapshots.remove(oldestHash);\n\n            // Add new snapshot.\n            const snapshot = await this._accounts.snapshot();\n            this._snapshots.put(blockHash, snapshot);\n            this._snapshotOrder.push(blockHash);\n        }\n    }\n\n    /** @type {Block} */\n    get head() {\n        return this._mainChain.head;\n    }\n\n    /** @type {Hash} */\n    get headHash() {\n        return this._headHash;\n    }\n\n    get height() {\n        return this._mainChain.head.height;\n    }\n\n    /** @type {number} */\n    get totalDifficulty() {\n        return this._mainChain.totalDifficulty;\n    }\n\n    /** @type {number} */\n    get totalWork() {\n        return this._mainChain.totalWork;\n    }\n\n    /** @type {Accounts} */\n    // XXX Do we really want to expose this?\n    get accounts() {\n        return this._accounts;\n    }\n\n    /** @type {TransactionCache} */\n    get transactionCache() {\n        return this._transactionCache;\n    }\n\n    /** @type {number} */\n    get blockForkedCount() {\n        return this._blockForkedCount;\n    }\n\n    /** @type {number} */\n    get blockRebranchedCount() {\n        return this._blockRebranchedCount;\n    }\n\n    /** @type {number} */\n    get blockExtendedCount() {\n        return this._blockExtendedCount;\n    }\n\n    /** @type {number} */\n    get blockOrphanCount() {\n        return this._blockOrphanCount;\n    }\n\n    /** @type {number} */\n    get blockInvalidCount() {\n        return this._blockInvalidCount;\n    }\n\n    /** @type {number} */\n    get blockKnownCount() {\n        return this._blockKnownCount;\n    }\n\n    /**\n     * @returns {Promise.<Hash>}\n     */\n    // XXX Do we really want to expose this?\n    accountsHash() {\n        return this._accounts.hash();\n    }\n}\n\nFullChain.ERR_ORPHAN = -2;\nFullChain.ERR_INVALID = -1;\nFullChain.OK_KNOWN = 0;\nFullChain.OK_EXTENDED = 1;\nFullChain.OK_REBRANCHED = 2;\nFullChain.OK_FORKED = 3;\nClass.register(FullChain);\n","class FullConsensusAgent extends BaseConsensusAgent {\n    /**\n     * @param {FullChain} blockchain\n     * @param {Mempool} mempool\n     * @param {Time} time\n     * @param {Peer} peer\n     * @param {Subscription} targetSubscription\n     */\n    constructor(blockchain, mempool, time, peer, targetSubscription) {\n        super(time, peer, targetSubscription);\n        /** @type {FullChain} */\n        this._blockchain = blockchain;\n        /** @type {Mempool} */\n        this._mempool = mempool;\n\n        // Flag indicating that we are currently syncing our blockchain with the peer's.\n        /** @type {boolean} */\n        this._syncing = false;\n\n        // The number of blocks that extended our blockchain since the last requestBlocks().\n        /** @type {number} */\n        this._numBlocksExtending = -1;\n        // The number of blocks that forked our blockchain since the last requestBlocks().\n        /** @type {number} */\n        this._numBlocksForking = -1;\n        // The last fork block the peer has sent us.\n        /** @type {Block} */\n        this._forkHead = null;\n\n        // The number of failed blockchain sync attempts.\n        /** @type {number} */\n        this._failedSyncs = 0;\n\n        // The block hash that we want to learn to consider the sync complete.\n        /** @type {Hash} */\n        this._syncTarget = peer.headHash;\n\n        /** @type {RateLimit} */\n        this._chainProofLimit = new RateLimit(FullConsensusAgent.CHAIN_PROOF_RATE_LIMIT);\n        /** @type {RateLimit} */\n        this._accountsProofLimit = new RateLimit(FullConsensusAgent.ACCOUNTS_PROOF_RATE_LIMIT);\n        /** @type {RateLimit} */\n        this._accountsTreeChunkLimit = new RateLimit(FullConsensusAgent.ACCOUNTS_TREE_CHUNK_RATE_LIMIT);\n        /** @type {RateLimit} */\n        this._transactionsProofLimit = new RateLimit(FullConsensusAgent.TRANSACTION_PROOF_RATE_LIMIT);\n        /** @type {RateLimit} */\n        this._transactionReceiptsLimit = new RateLimit(FullConsensusAgent.TRANSACTION_RECEIPTS_RATE_LIMIT);\n\n        // Listen to consensus messages from the peer.\n        peer.channel.on('get-blocks', msg => this._onGetBlocks(msg));\n        peer.channel.on('get-chain-proof', msg => this._onGetChainProof(msg));\n        peer.channel.on('get-accounts-proof', msg => this._onGetAccountsProof(msg));\n        peer.channel.on('get-accounts-tree-chunk', msg => this._onGetAccountsTreeChunk(msg));\n        peer.channel.on('get-transactions-proof', msg => this._onGetTransactionsProof(msg));\n        peer.channel.on('get-transaction-receipts', msg => this._onGetTransactions(msg));\n        peer.channel.on('get-block-proof', msg => this._onGetBlockProof(msg));\n        peer.channel.on('mempool', msg => this._onMempool(msg));\n    }\n\n    async syncBlockchain() {\n        this._syncing = true;\n\n        // We only sync with other full nodes.\n        if (!Services.isFullNode(this._peer.peerAddress.services)) {\n            this._syncFinished();\n            return;\n        }\n\n        // Wait for all objects to arrive.\n        if (!this._objectsInFlight.isEmpty()) {\n            Log.v(FullConsensusAgent, `Waiting for ${this._objectsInFlight.length} objects to arrive ...`);\n            return;\n        }\n\n        // Wait for all objects to be processed.\n        if (!this._objectsProcessing.isEmpty()) {\n            Log.v(FullConsensusAgent, `Waiting for ${this._objectsProcessing.length} objects to be processed ...`);\n            return;\n        }\n\n        // If we know our sync target block, the sync process is finished.\n        const head = await this._blockchain.getBlock(this._syncTarget, /*includeForks*/ true);\n        if (head) {\n            this._syncFinished();\n            return;\n        }\n\n        // If the peer didn't send us any blocks that extended our chain, count it as a failed sync attempt.\n        // This sets a maximum length for forks that the full client will accept:\n        //   FullConsensusAgent.SYNC_ATTEMPTS_MAX * BaseInvectoryMessage.VECTORS_MAX_COUNT\n        if (this._numBlocksExtending === 0 && ++this._failedSyncs >= FullConsensusAgent.SYNC_ATTEMPTS_MAX) {\n            this._peer.channel.close(CloseType.BLOCKCHAIN_SYNC_FAILED, 'blockchain sync failed');\n            return;\n        }\n\n        // We don't know the peer's head block, request blocks from it.\n        this._requestBlocks().catch(Log.w.tag(FullConsensusAgent));\n    }\n\n    _syncFinished() {\n        // Subscribe to all announcements from the peer.\n        this._subscribeTarget();\n\n        // Request the peer's mempool.\n        // XXX Use a random delay here to prevent requests to multiple peers at once.\n        const delay = FullConsensusAgent.MEMPOOL_DELAY_MIN\n            + Math.random() * (FullConsensusAgent.MEMPOOL_DELAY_MAX - FullConsensusAgent.MEMPOOL_DELAY_MIN);\n        setTimeout(() => this._peer.channel.mempool(), delay);\n\n        this._syncing = false;\n        this._synced = true;\n\n        this._numBlocksExtending = 0;\n        this._numBlocksForking = 0;\n        this._forkHead = null;\n        this._failedSyncs = 0;\n\n        this.fire('sync');\n    }\n\n    async _requestBlocks(maxInvSize) {\n        // Only one getBlocks request at a time.\n        if (this._peer.channel.isExpectingMessage(Message.Type.INV)) {\n            return;\n        }\n\n        // Drop the peer if it doesn't start sending InvVectors for its chain within the timeout.\n        // Set timeout early to prevent re-entering the method.\n        this._peer.channel.expectMessage(Message.Type.INV, () => {\n            this._peer.channel.close(CloseType.GET_BLOCKS_TIMEOUT, 'getBlocks timeout');\n        }, BaseConsensusAgent.REQUEST_TIMEOUT);\n\n        // Check if the peer is sending us a fork.\n        const onFork = this._forkHead && this._numBlocksExtending === 0 && this._numBlocksForking > 0;\n\n        /** @type {Array.<Hash>} */\n        let locators;\n        if (onFork) {\n            // Only send the fork head as locator if the peer is sending us a fork.\n            locators = [this._forkHead.hash()];\n        } else {\n            locators = await this._blockchain.getBlockLocators();\n        }\n\n        // Reset block counters.\n        this._numBlocksExtending = 0;\n        this._numBlocksForking = 0;\n\n        // Request blocks from peer.\n        this._peer.channel.getBlocks(locators, maxInvSize);\n    }\n\n    /**\n     * @param {InvMessage} msg\n     * @returns {Promise}\n     * @protected\n     * @override\n     */\n    _onInv(msg) {\n        return super._onInv(msg);\n    }\n\n    /**\n     * @param {InvVector} vector\n     * @returns {boolean}\n     * @protected\n     * @override\n     */\n    _shouldRequestData(vector) {\n        // Ignore block announcements from nano clients as they will ignore our getData requests anyways (they only know headers).\n        return !(Services.isNanoNode(this._peer.peerAddress.services) && vector.type === InvVector.Type.BLOCK);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {boolean} [includeForks]\n     * @param {boolean} [includeBody]\n     * @returns {Promise.<?Block>}\n     * @protected\n     * @override\n     */\n    _getBlock(hash, includeForks = false, includeBody = false) {\n        return this._blockchain.getBlock(hash, includeForks, includeBody);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Promise.<?Transaction>}\n     * @protected\n     * @override\n     */\n    _getTransaction(hash) {\n        return Promise.resolve(this._mempool.getTransaction(hash));\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @returns {void}\n     * @protected\n     * @override\n     */\n    async _onKnownBlockAnnounced(hash, block) {\n        if (!this._syncing) return;\n\n        this._numBlocksForking++;\n        this._forkHead = block;\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     * @override\n     */\n    _onNoUnknownObjects() {\n        // The peer does not have any new inv vectors for us.\n        if (this._syncing) {\n            this.syncBlockchain().catch(Log.w.tag(FullConsensusAgent));\n        }\n    }\n\n    /**\n     * @protected\n     * @override\n     */\n    _onAllObjectsReceived() {\n        // If all objects have been received, request more if we're syncing the blockchain.\n        if (this._syncing) {\n            this.syncBlockchain().catch(Log.w.tag(FullConsensusAgent));\n        }\n    }\n\n    /**\n     * @param {HeaderMessage} msg\n     * @return {Promise.<void>}\n     * @protected\n     * @override\n     */\n    _onHeader(msg) {\n        // Ignore header messages.\n        Log.w(FullConsensusAgent, `Unsolicited header message received from ${this._peer.peerAddress}, discarding`);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @returns {Promise.<void>}\n     * @protected\n     * @override\n     */\n    async _processBlock(hash, block) {\n        // TODO send reject message if we don't like the block\n        const status = await this._blockchain.pushBlock(block);\n        switch (status) {\n            case FullChain.ERR_INVALID:\n                this._peer.channel.close(CloseType.RECEIVED_INVALID_BLOCK, 'received invalid block');\n                break;\n\n            case FullChain.OK_EXTENDED:\n            case FullChain.OK_REBRANCHED:\n                if (this._syncing) this._numBlocksExtending++;\n                break;\n\n            case FullChain.OK_FORKED:\n                if (this._syncing) {\n                    this._numBlocksForking++;\n                    this._forkHead = block;\n                }\n                break;\n\n            case FullChain.ERR_ORPHAN:\n                this._onOrphanBlock(hash, block);\n                break;\n\n            case FullChain.OK_KNOWN:\n                Log.v(FullConsensusAgent, `Received known block ${hash} (height=${block.height}, prevHash=${block.prevHash}) from ${this._peer.peerAddress}`);\n                break;\n        }\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @protected\n     */\n    _onOrphanBlock(hash, block) {\n        // Ignore orphan blocks if we're not synced yet. This shouldn't happen.\n        if (!this._synced) {\n            Log.w(FullConsensusAgent, `Received orphan block ${hash} (height=${block.height}, prevHash=${block.prevHash}) while syncing`);\n            return;\n        }\n\n        // The peer has announced an orphaned block after the initial sync. We're probably out of sync.\n        Log.d(FullConsensusAgent, `Received orphan block ${hash} (height=${block.height}, prevHash=${block.prevHash}) from ${this._peer.peerAddress}`);\n\n        // Disable announcements from the peer once.\n        if (!this._timers.timeoutExists('outOfSync')) {\n            this._subscribe(Subscription.NONE);\n        }\n\n        // Set the orphaned block as the new sync target.\n        this._syncTarget = hash;\n\n        // Wait a short time for:\n        // - our (un-)subscribe message to be sent\n        // - potentially more orphaned blocks to arrive\n        this._timers.resetTimeout('outOfSync', () => this._outOfSync(), FullConsensusAgent.RESYNC_THROTTLE);\n    }\n\n    /**\n     * @private\n     */\n    _outOfSync() {\n        this._timers.clearTimeout('outOfSync');\n\n        this._synced = false;\n\n        this.fire('out-of-sync');\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Transaction} transaction\n     * @returns {Promise.<boolean>}\n     * @protected\n     * @override\n     */\n    async _processTransaction(hash, transaction) {\n        const result = await this._mempool.pushTransaction(transaction);\n        switch (result) {\n            case Mempool.ReturnCode.ACCEPTED:\n                return true;\n            case Mempool.ReturnCode.KNOWN:\n                return false;\n            case Mempool.ReturnCode.FEE_TOO_LOW:\n                this.peer.channel.reject(Message.Type.TX, RejectMessage.Code.REJECT_INSUFFICIENT_FEE,\n                    'Sender has too many free transactions', transaction.hash().serialize());\n                return false;\n            case Mempool.ReturnCode.INVALID:\n                this.peer.channel.reject(Message.Type.TX, RejectMessage.Code.REJECT_INVALID, 'Invalid transaction',\n                    transaction.hash().serialize());\n                return false;\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * @protected\n     * @override\n     */\n    _onAllObjectsProcessed() {\n        // If all objects have been processed, request more if we're syncing the blockchain.\n        if (this._syncing) {\n            this.syncBlockchain().catch(Log.w.tag(FullConsensusAgent));\n        }\n    }\n\n\n    /* Request endpoints */\n\n    /**\n     * @param {GetBlocksMessage} msg\n     * @return {Promise}\n     * @private\n     */\n    async _onGetBlocks(msg) {\n        Log.v(FullConsensusAgent, `[GETBLOCKS] ${msg.locators.length} block locators maxInvSize ${msg.maxInvSize} received from ${this._peer.peerAddress}`);\n\n        // A peer has requested blocks. Check all requested block locator hashes\n        // in the given order and pick the first hash that is found on our main\n        // chain, ignore the rest. If none of the requested hashes is found,\n        // pick the genesis block hash. Send the main chain starting from the\n        // picked hash back to the peer.\n        let startBlock = GenesisConfig.GENESIS_BLOCK;\n        for (const locator of msg.locators) {\n            const block = await this._blockchain.getBlock(locator);\n            if (block) {\n                // We found a block, ignore remaining block locator hashes.\n                startBlock = block;\n                break;\n            }\n        }\n\n        // Collect up to GETBLOCKS_VECTORS_MAX inventory vectors for the blocks starting right\n        // after the identified block on the main chain.\n        const blocks = await this._blockchain.getBlocks(startBlock.hash(),\n            Math.min(msg.maxInvSize, FullConsensusAgent.GETBLOCKS_VECTORS_MAX),\n            msg.direction === GetBlocksMessage.Direction.FORWARD);\n        const vectors = [];\n        for (const block of blocks) {\n            vectors.push(InvVector.fromBlock(block));\n        }\n\n        // Send the vectors back to the requesting peer.\n        this._peer.channel.inv(vectors);\n    }\n\n    /**\n     * @param {GetChainProofMessage} msg\n     * @private\n     */\n    async _onGetChainProof(msg) {\n        if (!this._chainProofLimit.note()) {\n            Log.w(FullConsensusAgent, 'Rejecting GetChainProof message - rate-limit exceeded');\n            this._peer.channel.close(CloseType.RATE_LIMIT_EXCEEDED, 'rate-limit exceeded');\n            return;\n        }\n        const proof = await this._blockchain.getChainProof();\n        this._peer.channel.chainProof(proof);\n    }\n\n    /**\n     * @param {GetBlockProofMessage} msg\n     * @private\n     */\n    async _onGetBlockProof(msg) {\n        const blockToProve = await this._blockchain.getBlock(msg.blockHashToProve);\n        const knownBlock = await this._blockchain.getBlock(msg.knownBlockHash);\n        if (!blockToProve || !knownBlock) {\n            this._peer.channel.blockProof();\n            return;\n        }\n\n        const proof = await this._blockchain.getBlockProof(blockToProve, knownBlock);\n        this._peer.channel.blockProof(proof);\n    }\n\n    /**\n     * @param {GetAccountsProofMessage} msg\n     * @private\n     */\n    async _onGetAccountsProof(msg) {\n        if (!this._accountsProofLimit.note()) {\n            Log.w(FullConsensusAgent, 'Rejecting GetAccountsProof message - rate-limit exceeded');\n            this._peer.channel.close(CloseType.RATE_LIMIT_EXCEEDED, 'rate-limit exceeded');\n            return;\n        }\n        const proof = await this._blockchain.getAccountsProof(msg.blockHash, msg.addresses);\n        this._peer.channel.accountsProof(msg.blockHash, proof);\n    }\n\n    /**\n     * @param {GetTransactionsProofMessage} msg\n     * @private\n     */\n    async _onGetTransactionsProof(msg) {\n        if (!this._transactionsProofLimit.note()) {\n            Log.w(FullConsensusAgent, 'Rejecting GetTransactionsProof message - rate-limit exceeded');\n            this._peer.channel.close(CloseType.RATE_LIMIT_EXCEEDED, 'rate-limit exceeded');\n            return;\n        }\n        const proof = await this._blockchain.getTransactionsProof(msg.blockHash, msg.addresses);\n        this._peer.channel.transactionsProof(msg.blockHash, proof);\n    }\n\n    /**\n     * @param {GetAccountsTreeChunkMessage} msg\n     * @private\n     */\n    async _onGetAccountsTreeChunk(msg) {\n        if (!this._accountsTreeChunkLimit.note()) {\n            Log.w(FullConsensusAgent, 'Rejecting GetAccountsTreeChunk message - rate-limit exceeded');\n            this._peer.channel.close(CloseType.RATE_LIMIT_EXCEEDED, 'rate-limit exceeded');\n            return;\n        }\n        const chunk = await this._blockchain.getAccountsTreeChunk(msg.blockHash, msg.startPrefix);\n        this._peer.channel.accountsTreeChunk(msg.blockHash, chunk);\n    }\n\n    /**\n     * @param {GetTransactionReceiptsMessage} msg\n     * @private\n     */\n    async _onGetTransactions(msg) {\n        if (!this._transactionReceiptsLimit.note()) {\n            Log.w(FullConsensusAgent, 'Rejecting GetTransactionReceipts message - rate-limit exceeded');\n            this._peer.channel.close(CloseType.RATE_LIMIT_EXCEEDED, 'rate-limit exceeded');\n            return;\n        }\n        const transactionReceipts = await this._blockchain.getTransactionReceiptsByAddress(msg.address);\n\n        let i = 0;\n        while (i < TransactionReceiptsMessage.RECEIPTS_MAX_COUNT) {\n            const receipts = transactionReceipts.slice(i, i + TransactionReceiptsMessage.RECEIPTS_MAX_COUNT);\n            this._peer.channel.transactionReceipts(receipts);\n            i += TransactionReceiptsMessage.RECEIPTS_MAX_COUNT;\n        }\n    }\n\n    /**\n     * @param {MempoolMessage} msg\n     * @return {Promise}\n     * @private\n     */\n    async _onMempool(msg) {\n        // Query mempool for transactions\n        let transactions = [];\n        switch (this._remoteSubscription.type) {\n            case Subscription.Type.ADDRESSES:\n                transactions = this._mempool.getTransactionsByAddresses(this._remoteSubscription.addresses, FullConsensusAgent.MEMPOOL_ENTRIES_MAX);\n                break;\n            case Subscription.Type.MIN_FEE:\n                transactions = new LimitIterable(this._mempool.transactionGenerator(/*maxSize*/ undefined, this._remoteSubscription.minFeePerByte), FullConsensusAgent.MEMPOOL_ENTRIES_MAX);\n                break;\n            case Subscription.Type.ANY:\n                transactions = new LimitIterable(this._mempool.transactionGenerator(), FullConsensusAgent.MEMPOOL_ENTRIES_MAX);\n                break;\n        }\n\n        // Send an InvVector for each transaction in the mempool.\n        // Split into multiple Inv messages if the mempool is large.\n        let vectors = [];\n        for (const tx of transactions) {\n            vectors.push(InvVector.fromTransaction(tx));\n\n            if (vectors.length >= BaseInventoryMessage.VECTORS_MAX_COUNT) {\n                this._peer.channel.inv(vectors);\n                vectors = [];\n                await new Promise((resolve) => setTimeout(resolve, FullConsensusAgent.MEMPOOL_THROTTLE));\n            }\n        }\n\n        if (vectors.length > 0) {\n            this._peer.channel.inv(vectors);\n        }\n    }\n}\n/**\n * Maximum number of blockchain sync retries before closing the connection.\n * XXX If the peer is on a long fork, it will count as a failed sync attempt\n * if our blockchain doesn't switch to the fork within 500 (max InvVectors returned by getBlocks)\n * blocks.\n * @type {number}\n */\nFullConsensusAgent.SYNC_ATTEMPTS_MAX = 25;\n/**\n * Maximum number of inventory vectors to sent in the response for onGetBlocks.\n * @type {number}\n */\nFullConsensusAgent.GETBLOCKS_VECTORS_MAX = 500;\n/**\n * Time {ms} to wait before triggering a blockchain re-sync with the peer.\n * @type {number}\n */\nFullConsensusAgent.RESYNC_THROTTLE = 1000 * 3; // 3 seconds\n/**\n * Minimum time {ms} to wait before triggering the initial mempool request.\n * @type {number}\n */\nFullConsensusAgent.MEMPOOL_DELAY_MIN = 1000 * 2; // 2 seconds\n/**\n * Maximum time {ms} to wait before triggering the initial mempool request.\n * @type {number}\n */\nFullConsensusAgent.MEMPOOL_DELAY_MAX = 1000 * 20; // 20 seconds\n/**\n * Time {ms} to wait between sending full inv vectors of transactions during Mempool request\n * @type {number}\n */\nFullConsensusAgent.MEMPOOL_THROTTLE = 1000;\n/**\n * Number of transaction vectors to send\n * @type {number}\n */\nFullConsensusAgent.MEMPOOL_ENTRIES_MAX = 10000;\nFullConsensusAgent.CHAIN_PROOF_RATE_LIMIT = 3;\nFullConsensusAgent.ACCOUNTS_PROOF_RATE_LIMIT = 60;\nFullConsensusAgent.ACCOUNTS_TREE_CHUNK_RATE_LIMIT = 120;\nFullConsensusAgent.TRANSACTION_PROOF_RATE_LIMIT = 120;\nFullConsensusAgent.TRANSACTION_RECEIPTS_RATE_LIMIT = 60;\nClass.register(FullConsensusAgent);\n","class FullConsensus extends BaseConsensus {\n    /**\n     * @param {FullChain} blockchain\n     * @param {Mempool} mempool\n     * @param {Network} network\n     */\n    constructor(blockchain, mempool, network) {\n        super(blockchain, mempool, network);\n        /** @type {FullChain} */\n        this._blockchain = blockchain;\n        /** @type {Mempool} */\n        this._mempool = mempool;\n    }\n\n    /**\n     * @param {number} minFeePerByte\n     */\n    subscribeMinFeePerByte(minFeePerByte) {\n        this.subscribe(Subscription.fromMinFeePerByte(minFeePerByte));\n        this.mempool.evictBelowMinFeePerByte(minFeePerByte);\n    }\n\n    /**\n     * @type {number} minFeePerByte\n     */\n    get minFeePerByte() {\n        return this._subscription.type === Subscription.Type.MIN_FEE ? this._subscription.minFeePerByte : 0;\n    }\n\n    /**\n     * @param {Peer} peer\n     * @returns {BaseConsensusAgent}\n     * @override\n     */\n    _newConsensusAgent(peer) {\n        return new FullConsensusAgent(this._blockchain, this._mempool, this._network.time, peer, this._subscription);\n    }\n\n    /** @type {FullChain} */\n    get blockchain() {\n        return this._blockchain;\n    }\n\n    /** @type {Mempool} */\n    get mempool() {\n        return this._mempool;\n    }\n}\nClass.register(FullConsensus);\n","/**\n * A LightChain is initialized by using NiPoPoWs instead of the full\n * blockchain history, but after initialization, it behaves as a regular\n * full blockchain.\n */\nclass LightChain extends FullChain {\n    /**\n    * @param {JungleDB} jdb\n    * @param {Accounts} accounts\n    * @param {Time} time\n    * @returns {Promise.<LightChain>}\n    */\n    static getPersistent(jdb, accounts, time) {\n        const store = ChainDataStore.getPersistent(jdb);\n        const chain = new LightChain(store, accounts, time);\n        return chain._init();\n    }\n\n    /**\n     * @param {Accounts} accounts\n     * @param {Time} time\n     * @returns {Promise.<LightChain>}\n     */\n    static createVolatile(accounts, time) {\n        const store = ChainDataStore.createVolatile();\n        const chain = new LightChain(store, accounts, time);\n        return chain._init();\n    }\n\n    /**\n     * @param {ChainDataStore} store\n     * @param {Accounts} accounts\n     * @param {Time} time\n     * @returns {PartialLightChain}\n     */\n    constructor(store, accounts, time) {\n        super(store, accounts, time);\n    }\n\n    /**\n     * @override\n     * @protected\n     */\n    async _init() {\n        // FIXME: this is a workaround as Babel doesn't understand await super().\n        await FullChain.prototype._init.call(this);\n        if (!this._proof) {\n            this._proof = await this._getChainProof();\n        }\n        return this;\n    }\n\n    /**\n     * @return {PartialLightChain}\n     */\n    async partialChain() {\n        const proof = await this.getChainProof();\n        const partialChain = new PartialLightChain(this._store, this._accounts, this._time, proof);\n        partialChain.on('committed', (proof, headHash, mainChain) => {\n            this._proof = proof;\n            this._headHash = headHash;\n            this._mainChain = mainChain;\n            this.fire('head-changed', this.head);\n        });\n        await partialChain._init();\n        return partialChain;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     * @override\n     */\n    _shouldExtendChainProof() {\n        return true;\n    }\n}\nClass.register(LightChain);\n","class LightConsensusAgent extends FullConsensusAgent {\n    /**\n     * @param {LightChain} blockchain\n     * @param {Mempool} mempool\n     * @param {Time} time\n     * @param {Peer} peer\n     * @param {Subscription} targetSubscription\n     */\n    constructor(blockchain, mempool, time, peer, targetSubscription) {\n        super(blockchain, mempool, time, peer, targetSubscription);\n        /** @type {LightChain} */\n        this._blockchain = blockchain;\n        /** @type {PartialLightChain} */\n        this._partialChain = null;\n\n        /** @type {boolean} */\n        this._syncing = false;\n\n        // Flag indicating whether we do a full catchup or request a proof.\n        /** @type {boolean} */\n        this._catchup = false;\n\n        // Flag indicating whether we believe to be on the main chain of the client.\n        /** @type {boolean} */\n        this._onMainChain = false;\n\n        /** @type {Array.<Block>} */\n        this._orphanedBlocks = [];\n\n        /** @type {boolean} */\n        this._busy = false;\n\n        // Helper object to keep track of the accounts we're requesting from the peer.\n        this._accountsRequest = null;\n\n        // Flag to track chain proof requests.\n        this._requestedChainProof = false;\n\n        // Number of weak proofs we have received from the peer.\n        this._numWeakProofs = 0;\n\n        // Listen to consensus messages from the peer.\n        peer.channel.on('chain-proof', msg => this._onChainProof(msg));\n        peer.channel.on('accounts-tree-chunk', msg => this._onAccountsTreeChunk(msg));\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     * @override\n     */\n    async syncBlockchain() {\n        // We don't sync with nano nodes.\n        if (Services.isNanoNode(this._peer.peerAddress.services)) {\n            this._syncFinished();\n            return;\n        }\n\n        // Wait for all objects to arrive.\n        if (!this._objectsInFlight.isEmpty()) {\n            Log.v(LightConsensusAgent, `Waiting for ${this._objectsInFlight.length} objects to arrive ...`);\n            return;\n        }\n\n        // Wait for all objects to be processed.\n        if (!this._objectsProcessing.isEmpty()) {\n            Log.v(LightConsensusAgent, `Waiting for ${this._objectsProcessing.length} objects to be processed ...`);\n            return;\n        }\n\n        // Ban peer if the sync failed more often than allowed.\n        if (this._failedSyncs >= LightConsensusAgent.SYNC_ATTEMPTS_MAX) {\n            this._peer.channel.close(CloseType.BLOCKCHAIN_SYNC_FAILED, 'blockchain sync failed');\n            if (this._partialChain) {\n                await this._partialChain.abort();\n                this._partialChain = null;\n            }\n            return;\n        }\n\n        // Check if we know head block.\n        const block = await this._blockchain.getBlock(this._syncTarget, /*includeForks*/ true);\n\n        /*\n         * Three cases:\n         * 1) We know block and are not yet syncing: All is done.\n         * 2) We don't know the block and are not yet syncing: Start syncing.\n         *    and determine sync mode (full catchup or not).\n         * 3) We are syncing. Behave differently based on sync mode.\n         *    Note that we can switch from catchup to proof if we notice that\n         *    we're on a fork and get an INV vector starting from the genesis block.\n         */\n\n        // Case 1: We're up to date.\n        if (block && !this._syncing) {\n            this._syncFinished();\n            return;\n        }\n\n        // Case 2: Check header.\n        if (!block && !this._syncing) {\n            this._syncing = true;\n            this._onMainChain = false;\n\n            let header;\n            try {\n                header = await this.getHeader(this._syncTarget);\n            } catch (e) {\n                this._peer.channel.close(CloseType.DID_NOT_GET_REQUESTED_HEADER, 'Did not get requested header');\n                return;\n            }\n\n            // Check how to sync based on heuristic:\n            this._catchup = header.height >= this._blockchain.height\n                && header.height - this._blockchain.height <= Policy.NUM_BLOCKS_VERIFICATION;\n            Log.d(LightConsensusAgent, `Start syncing, catchup mode: ${this._catchup}`);\n        }\n\n        // Case 3: We are syncing.\n        if (this._syncing && !this._busy) {\n            if (this._catchup) {\n                await FullConsensusAgent.prototype.syncBlockchain.call(this);\n            } else {\n                // Initialize partial chain on first call.\n                if (!this._partialChain) {\n                    await this._initChainProofSync();\n                }\n\n                switch (this._partialChain.state) {\n                    case PartialLightChain.State.PROVE_CHAIN:\n                        this._requestChainProof();\n                        this.fire('sync-chain-proof', this._peer.peerAddress);\n                        break;\n                    case PartialLightChain.State.PROVE_ACCOUNTS_TREE:\n                        this._requestAccountsTree();\n                        this.fire('sync-accounts-tree', this._peer.peerAddress);\n                        break;\n                    case PartialLightChain.State.PROVE_BLOCKS:\n                        this._requestProofBlocks();\n                        this.fire('verify-accounts-tree', this._peer.peerAddress);\n                        break;\n                    case PartialLightChain.State.COMPLETE:\n                        // Commit state on success.\n                        this.fire('sync-finalize', this._peer.peerAddress);\n                        this._busy = true;\n                        await this._partialChain.commit();\n                        await this._applyOrphanedBlocks();\n                        this._syncFinished();\n                        break;\n                    case PartialLightChain.State.ABORTED:\n                        this._peer.channel.close(CloseType.ABORTED_SYNC, 'aborted sync');\n                        break;\n                    case PartialLightChain.State.WEAK_PROOF:\n                        Log.d(LightConsensusAgent, `Not syncing with ${this._peer.peerAddress} - weaker proof`);\n                        this._numWeakProofs++;\n                        if (this._numWeakProofs >= LightConsensusAgent.WEAK_PROOFS_MAX) {\n                            this._peer.channel.close(CloseType.BLOCKCHAIN_SYNC_FAILED, 'too many weak proofs');\n                        } else {\n                            this._syncFinished();\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _initChainProofSync() {\n        // Subscribe to all announcements from the peer.\n        this._subscribeTarget();\n\n        this._syncing = true;\n        this._synced = false;\n        this._catchup = false;\n        this._onMainChain = true;\n\n        if (this._partialChain) {\n            await this._partialChain.abort();\n        }\n\n        this._partialChain = await this._blockchain.partialChain();\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _syncFinished() {\n        if (this._partialChain) {\n            this._partialChain = null;\n        }\n\n        this._busy = false;\n        super._syncFinished();\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _applyOrphanedBlocks() {\n        for (const block of this._orphanedBlocks) {\n            const status = await this._blockchain.pushBlock(block);\n            if (status === LightChain.ERR_INVALID) {\n                this._peer.channel.close(CloseType.RECEIVED_INVALID_BLOCK, 'received invalid block');\n                break;\n            }\n        }\n        this._orphanedBlocks = [];\n    }\n\n    // Syncing stages.\n    // Stage 1: Chain proof.\n    /**\n     * @returns {void}\n     * @private\n     */\n    _requestChainProof() {\n        Assert.that(this._partialChain && this._partialChain.state === PartialLightChain.State.PROVE_CHAIN);\n        Assert.that(!this._requestedChainProof);\n        this._busy = true;\n\n        // Request ChainProof from peer.\n        this._peer.channel.getChainProof();\n        this._requestedChainProof = true;\n\n        // Drop the peer if it doesn't send the chain proof within the timeout.\n        // TODO should we ban here instead?\n        this._peer.channel.expectMessage(Message.Type.CHAIN_PROOF, () => {\n            this._peer.channel.close(CloseType.GET_CHAIN_PROOF_TIMEOUT, 'getChainProof timeout');\n        }, LightConsensusAgent.CHAINPROOF_REQUEST_TIMEOUT, LightConsensusAgent.CHAINPROOF_CHUNK_TIMEOUT);\n    }\n\n    /**\n     * @param {ChainProofMessage} msg\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _onChainProof(msg) {\n        Assert.that(this._partialChain && this._partialChain.state === PartialLightChain.State.PROVE_CHAIN);\n        Log.d(LightConsensusAgent, `[CHAIN-PROOF] Received from ${this._peer.peerAddress}: ${msg.proof}`);\n\n        // Check if we have requested an interlink chain, reject unsolicited ones.\n        if (!this._requestedChainProof) {\n            Log.w(LightConsensusAgent, `Unsolicited chain proof received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n        this._requestedChainProof = false;\n\n        if (this._syncing) {\n            this.fire('verify-chain-proof', this._peer.peerAddress);\n        }\n\n        // Push the proof into the LightChain.\n        if (!(await this._partialChain.pushProof(msg.proof))) {\n            Log.w(LightConsensusAgent, `Invalid chain proof received from ${this._peer.peerAddress} - verification failed`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.INVALID_CHAIN_PROOF, 'invalid chain proof');\n            return;\n        }\n\n        // TODO add all blocks from the chain proof to knownObjects.\n        this._busy = false;\n        this.syncBlockchain().catch(Log.w.tag(LightConsensusAgent));\n    }\n\n    // Stage 2: Request AccountsTree.\n    /**\n     * @private\n     */\n    _requestAccountsTree() {\n        Assert.that(this._partialChain && this._partialChain.state === PartialLightChain.State.PROVE_ACCOUNTS_TREE);\n        Assert.that(!this._accountsRequest);\n        this._busy = true;\n\n        const startPrefix = this._partialChain.getMissingAccountsPrefix();\n        const headHash = this._partialChain.headHash;\n        Log.d(LightConsensusAgent, `Requesting AccountsTreeChunk starting at ${startPrefix} from ${this._peer.peerAddress}`);\n\n        this._accountsRequest = {\n            startPrefix: startPrefix,\n            blockHash: headHash\n        };\n\n        // Request AccountsProof from peer.\n        this._peer.channel.getAccountsTreeChunk(headHash, startPrefix);\n\n        // Drop the peer if it doesn't send the accounts proof within the timeout.\n        this._peer.channel.expectMessage(Message.Type.ACCOUNTS_TREE_CHUNK, () => {\n            this._peer.channel.close(CloseType.GET_ACCOUNTS_TREE_CHUNK_TIMEOUT, 'getAccountsTreeChunk timeout');\n        }, LightConsensusAgent.ACCOUNTS_TREE_CHUNK_REQUEST_TIMEOUT);\n    }\n\n    /**\n     * @param {AccountsTreeChunkMessage} msg\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _onAccountsTreeChunk(msg) {\n        Log.d(LightConsensusAgent, `[ACCOUNTS-TREE-CHUNK] Received from ${this._peer.peerAddress}: blockHash=${msg.blockHash}, proof=${msg.chunk}`);\n\n        // Check if we have requested an accounts proof, reject unsolicited ones.\n        if (!this._accountsRequest) {\n            Log.w(LightConsensusAgent, `Unsolicited accounts tree chunk received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n\n        Assert.that(this._partialChain && this._partialChain.state === PartialLightChain.State.PROVE_ACCOUNTS_TREE);\n\n        const startPrefix = this._accountsRequest.startPrefix;\n        const blockHash = this._accountsRequest.blockHash;\n\n        // Reset accountsRequest.\n        this._accountsRequest = null;\n\n        if (!msg.hasChunk()) {\n            // Restart syncing.\n            await this._partialChain.abort();\n            this._partialChain = null;\n            this._busy = false;\n            this._failedSyncs++;\n            return;\n        }\n\n        // Check that we know the reference block.\n        if (!blockHash.equals(msg.blockHash) || msg.chunk.head.prefix <= startPrefix) {\n            Log.w(LightConsensusAgent, `Received AccountsTreeChunk for block != head or wrong start prefix from ${this._peer.peerAddress}`);\n            this._peer.channel.close(CloseType.INVALID_ACCOUNTS_TREE_CHUNK, 'Invalid AccountsTreeChunk');\n            return;\n        }\n\n        // Verify the proof.\n        const chunk = msg.chunk;\n        if (!chunk.verify()) {\n            Log.w(LightConsensusAgent, `Invalid AccountsTreeChunk received from ${this._peer.peerAddress}`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.INVALID_ACCOUNTS_TREE_CHUNK, 'Invalid AccountsTreeChunk');\n            return;\n        }\n\n        // Check that the proof root hash matches the accountsHash in the reference block.\n        const rootHash = chunk.root();\n        const block = await this._partialChain.getBlock(blockHash);\n        if (!block.accountsHash.equals(rootHash)) {\n            Log.w(LightConsensusAgent, `Invalid AccountsTreeChunk (root hash) received from ${this._peer.peerAddress}`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.ACCOUNTS_TREE_CHUNCK_ROOT_HASH_MISMATCH, 'AccountsTreeChunk root hash mismatch');\n            return;\n        }\n\n        // Return the retrieved accounts.\n        const result = await this._partialChain.pushAccountsTreeChunk(chunk);\n\n        // Something went wrong!\n        if (result < 0) {\n            // TODO maybe ban?\n            Log.e(`AccountsTree sync failed with error code ${result} from ${this._peer.peerAddress}`);\n            this._peer.channel.close(CloseType.ACCOUNTS_TREE_CHUNCK_ROOT_HASH_MISMATCH, 'AccountsTreeChunk root hash mismatch');\n        }\n\n        this._busy = false;\n        this.syncBlockchain().catch(Log.w.tag(LightConsensusAgent));\n    }\n\n    // Stage 3: Request proof blocks.\n    /**\n     * @private\n     */\n    _requestProofBlocks() {\n        Assert.that(this._partialChain && this._partialChain.state === PartialLightChain.State.PROVE_BLOCKS);\n\n        // If nothing happend since the last request, increase failed syncs.\n        if (this._lastChainHeight === this._partialChain.proofHeadHeight) {\n            this._failedSyncs++;\n        }\n        this._lastChainHeight = this._partialChain.proofHeadHeight;\n\n        // XXX Only one getBlocks request at a time.\n        if (this._peer.channel.isExpectingMessage(Message.Type.INV)) {\n            Log.e(LightConsensusAgent, 'Duplicate _requestProofBlocks()');\n            return;\n        }\n\n        // Drop the peer if it doesn't start sending InvVectors for its chain within the timeout.\n        this._peer.channel.expectMessage(Message.Type.INV, () => {\n            this._peer.channel.close(CloseType.GET_BLOCKS_TIMEOUT, 'getBlocks timeout');\n        }, BaseConsensusAgent.REQUEST_TIMEOUT);\n\n        // Request blocks from peer.\n        this._peer.channel.getBlocks(this._partialChain.getBlockLocators(), this._partialChain.numBlocksNeeded(), false);\n    }\n\n    // Block processing.\n    /**\n     * @returns {Promise.<void>}\n     * @private\n     */\n    _requestBlocks() {\n        // If we are syncing and not yet sure whether our blocks are on the main chain, just sync one block for now.\n        if (this._syncing && !this._onMainChain) {\n            return super._requestBlocks(1);\n        }\n        return super._requestBlocks();\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @returns {Promise.<void>}\n     * @protected\n     * @override\n     */\n    async _processBlock(hash, block) {\n        // If we find that we are on a fork far away from our chain, resync.\n        if (block.height < this._chain.height - Policy.NUM_BLOCKS_VERIFICATION\n            && (!this._partialChain || this._partialChain.state !== PartialLightChain.State.PROVE_BLOCKS)) {\n            this._onMainChain = false;\n            await this._initChainProofSync();\n            this.syncBlockchain().catch(Log.w.tag(LightConsensusAgent));\n            return;\n        } else {\n            this._onMainChain = true;\n        }\n\n        // Put block into blockchain.\n        const status = await this._chain.pushBlock(block);\n\n        switch (status) {\n            case FullChain.ERR_INVALID:\n                this._peer.channel.close(CloseType.RECEIVED_INVALID_BLOCK, 'received invalid block');\n                break;\n\n            case FullChain.OK_EXTENDED:\n            case FullChain.OK_REBRANCHED:\n                if (this._syncing) this._numBlocksExtending++;\n                break;\n\n            case FullChain.OK_FORKED:\n                if (this._syncing) {\n                    this._numBlocksForking++;\n                    this._forkHead = block;\n                }\n                break;\n\n            case LightChain.ERR_ORPHAN:\n                this._onOrphanBlock(hash, block);\n                break;\n        }\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @returns {void}\n     * @protected\n     * @override\n     */\n    async _onKnownBlockAnnounced(hash, block) {\n        if (this._syncing && this._catchup) {\n            // If we find that we are on a fork far away from our chain, resync.\n            if (block.height < this._chain.height - Policy.NUM_BLOCKS_VERIFICATION\n                && (!this._partialChain || this._partialChain.state !== PartialLightChain.State.PROVE_BLOCKS)) {\n                this._onMainChain = false;\n                await this._initChainProofSync();\n                this.syncBlockchain().catch(e => Log.e(LightConsensusAgent, e));\n                return;\n            } else {\n                this._onMainChain = true;\n            }\n\n            FullConsensusAgent.prototype._onKnownBlockAnnounced.call(this, hash, block);\n        }\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @private\n     * @override\n     */\n    _onOrphanBlock(hash, block) {\n        if (this._syncing && !this._catchup) {\n            this._orphanedBlocks.push(block);\n        } else {\n            super._onOrphanBlock(hash, block);\n        }\n    }\n\n    // Header processing.\n    /**\n     * @param {Hash} hash\n     * @return {Promise.<BlockHeader>}\n     */\n    getHeader(hash) {\n        Assert.that(!this._headerRequest);\n\n        return new Promise((resolve, reject) => {\n            const vector = new InvVector(InvVector.Type.BLOCK, hash);\n            this._headerRequest = {\n                hash: hash,\n                resolve: resolve,\n                reject: reject\n            };\n\n            this._peer.channel.getHeader([vector]);\n\n            // Drop the peer if it doesn't send the accounts proof within the timeout.\n            this._peer.channel.expectMessage(Message.Type.HEADER, () => {\n                this._headerRequest = null;\n                this._peer.channel.close(CloseType.GET_HEADER_TIMEOUT, 'getHeader timeout');\n                reject(new Error('timeout')); // TODO error handling\n            }, BaseConsensusAgent.REQUEST_TIMEOUT);\n        });\n    }\n\n    /**\n     * @param {HeaderMessage} msg\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _onHeader(msg) {\n        const header = msg.header;\n        const hash = header.hash();\n\n        // Check if we have requested this block.\n        if (!this._headerRequest) {\n            Log.w(NanoConsensusAgent, `Unsolicited header ${hash} received from ${this._peer.peerAddress}, discarding`);\n            // TODO What should happen here? ban? drop connection?\n            return;\n        }\n\n        const requestedHash = this._headerRequest.hash;\n        const resolve = this._headerRequest.resolve;\n        const reject = this._headerRequest.reject;\n\n        // Reset headerRequest.\n        this._headerRequest = null;\n\n        // Check that it is the correct hash.\n        if (!requestedHash.equals(hash)) {\n            Log.w(LightConsensusAgent, `Received wrong header from ${this._peer.peerAddress}`);\n            this._peer.channel.close(CloseType.RECEIVED_WRONG_HEADER, 'Received wrong header');\n            reject(new Error('Received wrong header'));\n            return;\n        }\n\n        resolve(header);\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     * @override\n     */\n    _onClose() {\n        if (this._partialChain) {\n            this._partialChain.abort().catch(Log.w.tag(LightConsensusAgent));\n        }\n\n        super._onClose();\n    }\n\n    /** @type {LightChain} */\n    get _chain() {\n        if (this._syncing && !this._catchup && this._partialChain) {\n            return this._partialChain;\n        }\n        return this._blockchain;\n    }\n}\n/**\n * Maximum time (ms) to wait for chain-proof after sending out get-chain-proof before dropping the peer.\n * @type {number}\n */\nLightConsensusAgent.CHAINPROOF_REQUEST_TIMEOUT = 1000 * 45;\n/**\n * Maximum time (ms) to wait for between chain-proof chunks before dropping the peer.\n * @type {number}\n */\nLightConsensusAgent.CHAINPROOF_CHUNK_TIMEOUT = 1000 * 10;\n/**\n * Maximum time (ms) to wait for accounts-tree-chunk after sending out get-accounts-tree-chunk before dropping the peer.\n * @type {number}\n */\nLightConsensusAgent.ACCOUNTS_TREE_CHUNK_REQUEST_TIMEOUT = 1000 * 8;\n/**\n * Maximum number of blockchain sync retries before closing the connection.\n * @type {number}\n */\nLightConsensusAgent.SYNC_ATTEMPTS_MAX = 5;\n/**\n * Maximum number of inventory vectors to sent in the response for onGetBlocks.\n * @type {number}\n */\nLightConsensusAgent.GETBLOCKS_VECTORS_MAX = 500;\n/**\n * Maximum number of weak proofs we allow before closing the connection.\n * @type {number}\n */\nLightConsensusAgent.WEAK_PROOFS_MAX = 3;\n\nClass.register(LightConsensusAgent);\n","class LightConsensus extends BaseConsensus {\n    /**\n     * @param {LightChain} blockchain\n     * @param {Mempool} mempool\n     * @param {Network} network\n     */\n    constructor(blockchain, mempool, network) {\n        super(blockchain, mempool, network);\n        /** @type {LightChain} */\n        this._blockchain = blockchain;\n        /** @type {Mempool} */\n        this._mempool = mempool;\n    }\n\n    /**\n     * @param {Peer} peer\n     * @returns {BaseConsensusAgent}\n     * @override\n     */\n    _newConsensusAgent(peer) {\n        return new LightConsensusAgent(this._blockchain, this._mempool, this._network.time, peer, this._subscription);\n    }\n\n    /**\n     * @param {Peer} peer\n     * @override\n     */\n    _onPeerJoined(peer) {\n        const agent = super._onPeerJoined(peer);\n\n        // Forward sync events.\n        this.bubble(agent, 'sync-chain-proof', 'verify-chain-proof', 'sync-accounts-tree', 'verify-accounts-tree', 'sync-finalize');\n\n        return agent;\n    }\n\n    /** @type {LightChain} */\n    get blockchain() {\n        return this._blockchain;\n    }\n\n    /** @type {Mempool} */\n    get mempool() {\n        return this._mempool;\n    }\n}\nClass.register(LightConsensus);\n","class PartialLightChain extends LightChain {\n    /**\n     * @param {ChainDataStore} store\n     * @param {Accounts} accounts\n     * @param {Time} time\n     * @param {ChainProof} proof\n     * @returns {PartialLightChain}\n     */\n    constructor(store, accounts, time, proof) {\n        const tx = store.transaction(false);\n        super(tx, accounts, time);\n\n        /** @type {ChainProof} */\n        this._proof = proof;\n\n        /** @type {PartialLightChain.State} */\n        this._state = PartialLightChain.State.PROVE_CHAIN;\n        /** @type {PartialAccountsTree} */\n        this._partialTree = null;\n        /** @type {Accounts} */\n        this._accountsTx = null;\n        /** @type {ChainData} */\n        this._proofHead = null;\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @returns {Promise.<boolean>}\n     */\n    pushProof(proof) {\n        // Synchronize with .pushBlock()\n        return this._synchronizer.push(/*priority*/ 0,\n            this._pushProof.bind(this, proof));\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @returns {Promise.<boolean>}\n     * @private\n     */\n    async _pushProof(proof) {\n        const toDo = [];\n        for (let i = 0; i < proof.prefix.length; ++i) {\n            const block = proof.prefix.blocks[i];\n            const hash = block.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (!knownBlock && !block.header._pow) {\n                toDo.push(block.header);\n            }\n        }\n        for (let i = 0; i < proof.suffix.length; ++i) {\n            const header = proof.suffix.headers[i];\n            const hash = header.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (!knownBlock && !header._pow) {\n                toDo.push(header);\n            }\n        }\n        await BaseChain.manyPow(toDo);\n\n        // Verify all prefix blocks that we don't know yet.\n        for (let i = 0; i < proof.prefix.length; i++) {\n            const block = proof.prefix.blocks[i];\n            const hash = block.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (knownBlock) {\n                proof.prefix.blocks[i] = knownBlock.toLight();\n            } else if (!(await block.verify(this._time))) {\n                Log.w(PartialLightChain, 'Rejecting proof - prefix contains invalid block');\n                return false;\n            }\n        }\n\n        // Verify all suffix headers that we don't know yet.\n        for (let i = 0; i < proof.suffix.length; i++) {\n            const header = proof.suffix.headers[i];\n            const hash = header.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (knownBlock) {\n                proof.suffix.headers[i] = knownBlock.header;\n            } else if (!(await header.verifyProofOfWork())) {\n                Log.w(PartialLightChain, 'Rejecting proof - suffix contains invalid header');\n                return false;\n            }\n        }\n\n        // Check that the proof is valid.\n        if (!(await proof.verify())) {\n            Log.w(PartialLightChain, 'Rejecting proof - verification failed');\n            return false;\n        }\n\n        // Check that the suffix is long enough.\n        if (proof.suffix.length !== Policy.K && proof.suffix.length !== proof.head.height - 1) {\n            Log.w(PartialLightChain, 'Rejecting proof - invalid suffix length');\n            return false;\n        }\n\n        // Check that the dense suffix of the prefix is long enough.\n        // The paper doesn't require this, we however need a sufficiently long dense suffix\n        // to be able to verify block difficulties.\n        const denseSuffix = proof.prefix.denseSuffix();\n        if (denseSuffix.length < Policy.M && proof.prefix.length > 0 && proof.prefix.head.height >= Policy.M) {\n            Log.w(NanoChain, 'Rejecting proof - dense suffix too short');\n            return false;\n        }\n\n        // Compute and verify interlinks for the suffix.\n        const suffixBlocks = [];\n        let head = proof.prefix.head;\n        for (const header of proof.suffix.headers) {\n            const interlink = await head.getNextInterlink(header.target, header.version);\n            const interlinkHash = interlink.hash();\n            if (!header.interlinkHash.equals(interlinkHash)) {\n                Log.w(PartialLightChain, 'Rejecting proof - invalid interlink hash in proof suffix');\n                return false;\n            }\n\n            head = new Block(header, interlink);\n            suffixBlocks.push(head);\n        }\n\n        // If the given proof is better than our current proof, adopt the given proof as the new best proof.\n        const currentProof = this._proof || await this._getChainProof();\n        if (await BaseChain.isBetterProof(proof, currentProof, Policy.M)) {\n            await this._acceptProof(proof, suffixBlocks);\n        } else {\n            await this.abort();\n            this._state = PartialLightChain.State.WEAK_PROOF;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @param {Array.<Block>} suffix\n     * @returns {Promise.<void>}\n     * @protected\n     */\n    async _acceptProof(proof, suffix) {\n        // If the proof prefix head is not part of our current dense chain suffix, reset store and start over.\n        // TODO use a store transaction here?\n        const head = proof.prefix.head;\n        const headHash = head.hash();\n        const headData = await this._store.getChainData(headHash);\n        if (!headData || headData.totalDifficulty <= 0) {\n            // Delete our current chain.\n            await this._store.truncate();\n\n            /** @type {Array.<Block>} */\n            const denseSuffix = proof.prefix.denseSuffix();\n\n            // Put all other prefix blocks in the store as well (so they can be retrieved via getBlock()/getBlockAt()),\n            // but don't allow blocks to be appended to them by setting totalDifficulty = -1;\n            let superBlockCounts = new SuperBlockCounts();\n            for (let i = 0; i < proof.prefix.length - denseSuffix.length; i++) {\n                const block = proof.prefix.blocks[i];\n                const hash = block.hash();\n                const depth = BlockUtils.getHashDepth(await block.pow());\n                superBlockCounts = superBlockCounts.copyAndAdd(depth);\n\n                const data = new ChainData(block, /*totalDifficulty*/ -1, /*totalWork*/ -1, superBlockCounts, true);\n                await this._store.putChainData(hash, data);\n            }\n\n            // Set the tail end of the dense suffix of the prefix as the new chain head.\n            const tailEnd = denseSuffix[0];\n            this._headHash = tailEnd.hash();\n            this._mainChain = await ChainData.initial(tailEnd, superBlockCounts);\n            await this._store.putChainData(this._headHash, this._mainChain);\n\n            // Only in the dense suffix of the prefix we can calculate the difficulties.\n            for (let i = 1; i < denseSuffix.length; i++) {\n                const block = denseSuffix[i];\n                const result = await this._pushLightBlock(block); // eslint-disable-line no-await-in-loop\n                Assert.that(result >= 0);\n            }\n        }\n\n        // Push all suffix blocks.\n        for (const block of suffix) {\n            const result = await this._pushLightBlock(block); // eslint-disable-line no-await-in-loop\n            Assert.that(result >= 0);\n        }\n\n        this._state = PartialLightChain.State.PROVE_ACCOUNTS_TREE;\n        this._partialTree = await this._accounts.partialAccountsTree();\n        this._proofHead = this._mainChain;\n        await this._store.setHead(this.headHash);\n\n        this._proof = proof;\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushLightBlock(block) {\n        // Check if we already know this header/block.\n        const hash = block.hash();\n        const knownBlock = await this._store.getBlock(hash);\n        if (knownBlock) {\n            return NanoChain.OK_KNOWN;\n        }\n\n        // Retrieve the immediate predecessor.\n        /** @type {ChainData} */\n        const prevData = await this._store.getChainData(block.prevHash);\n        if (!prevData || prevData.totalDifficulty <= 0) {\n            return NanoChain.ERR_ORPHAN;\n        }\n\n        return this._pushBlockInternal(block, hash, prevData);\n    }\n\n    /**\n     * @param {Block} block\n     * @param {Hash} blockHash\n     * @param {ChainData} prevData\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushBlockInternal(block, blockHash, prevData) {\n        // Block looks good, create ChainData.\n        const chainData = await prevData.nextChainData(block);\n\n        // Check if the block extends our current main chain.\n        if (block.prevHash.equals(this.headHash)) {\n            // Append new block to the main chain.\n            chainData.onMainChain = true;\n            prevData.mainChainSuccessor = blockHash;\n\n            await this._store.putChainData(blockHash, chainData);\n            await this._store.putChainData(block.prevHash, prevData, /*includeBody*/ false);\n\n            // Update head.\n            this._mainChain = chainData;\n            this._headHash = blockHash;\n\n            // Append new block to chain proof.\n            if (this._proof) {\n                const proofHeadHash = this._proof.head.hash();\n                if (block.prevHash.equals(proofHeadHash)) {\n                    this._proof = await this._extendChainProof(this._proof, block.header);\n                }\n            }\n\n            // Tell listeners that the head of the chain has changed.\n            this.fire('head-changed', this.head, /*rebranching*/ false);\n\n            return NanoChain.OK_EXTENDED;\n        }\n\n        // Otherwise, check if the new chain is harder than our current main chain.\n        if (chainData.totalDifficulty > this._mainChain.totalDifficulty) {\n            // A fork has become the hardest chain, rebranch to it.\n            await this._rebranch(blockHash, chainData);\n\n            return NanoChain.OK_REBRANCHED;\n        }\n\n        // Otherwise, we are creating/extending a fork. Store chain data.\n        Log.v(NanoChain, `Creating/extending fork with block ${blockHash}, height=${block.height}, totalDifficulty=${chainData.totalDifficulty}, totalWork=${chainData.totalWork}`);\n        await this._store.putChainData(blockHash, chainData);\n\n        return NanoChain.OK_FORKED;\n    }\n\n    /**\n     * @override\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     */\n    _pushBlock(block) {\n        // Queue new blocks while syncing.\n        if (this._state === PartialLightChain.State.PROVE_BLOCKS) {\n            const blockHash = block.hash();\n            if (this._proofHead.head.prevHash.equals(blockHash)) {\n                return this._pushBlockBackwards(block);\n            } else if (this._proofHead.head.hash().equals(blockHash)) {\n                return this._pushHeadBlock(block);\n            }\n        }\n\n        return FullChain.ERR_ORPHAN;\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushHeadBlock(block) {\n        // Check if we already know this block.\n        const hash = block.hash();\n\n        // Check that the given block is a full block (includes block body).\n        if (!block.isFull()) {\n            Log.w(PartialLightChain, 'Rejecting block - body missing');\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check all intrinsic block invariants.\n        if (!(await block.verify(this._time))) {\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check that all known interlink blocks are valid predecessors of the given block.\n        if (!(await this._verifyInterlink(block))) {\n            Log.w(PartialLightChain, 'Rejecting block - interlink verification failed');\n            return FullChain.ERR_INVALID;\n        }\n\n        // We know that the current proof head is the successor.\n        // Check that the block is a valid predecessor of its immediate successor.\n        const prevData = await this._store.getChainData(block.prevHash);\n        if (!prevData) {\n            Log.w(PartialLightChain, 'Rejecting block - unknown predecessor');\n            return FullChain.ERR_ORPHAN;\n        }\n\n        // Check that the block is a valid successor of its immediate predecessor.\n        const predecessor = prevData.head;\n        if (!(await block.isImmediateSuccessorOf(predecessor))) {\n            Log.w(PartialLightChain, 'Rejecting block - not a valid immediate successor');\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check that the difficulty is correct.\n        const nextTarget = await this.getNextTarget(predecessor);\n        if (BlockUtils.isValidTarget(nextTarget)) {\n            if (block.nBits !== BlockUtils.targetToCompact(nextTarget)) {\n                Log.w(PartialLightChain, 'Rejecting block - difficulty mismatch');\n                return FullChain.ERR_INVALID;\n            }\n        } else {\n            Log.w(PartialLightChain, 'Skipping difficulty verification - not enough blocks available');\n        }\n\n        // Block looks good, create ChainData.\n        const chainData = await prevData.nextChainData(block);\n\n        // Prepend new block to the main chain.\n        if (!(await this._prepend(hash, chainData))) {\n            return FullChain.ERR_INVALID;\n        }\n\n        this._mainChain = chainData;\n        this._proofHead = chainData; // So now it is a full block.\n        this._headHash = hash;\n\n        // Check whether we're complete.\n        if (!this.needsMoreBlocks()) {\n            await this._complete();\n        }\n\n        return FullChain.OK_EXTENDED;\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushBlockBackwards(block) {\n        // Check if we already know this block.\n        const hash = block.hash();\n\n        // Check that the given block is a full block (includes block body).\n        if (!block.isFull()) {\n            Log.w(PartialLightChain, 'Rejecting block - body missing');\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check all intrinsic block invariants.\n        if (!(await block.verify(this._time))) {\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check that all known interlink blocks are valid predecessors of the given block.\n        if (!(await this._verifyInterlink(block))) {\n            Log.w(PartialLightChain, 'Rejecting block - interlink verification failed');\n            return FullChain.ERR_INVALID;\n        }\n\n        // We know that the current proof head is the successor.\n        // Check that the block is a valid predecessor of its immediate successor.\n        if (!(await this._proofHead.head.isImmediateSuccessorOf(block))) {\n            Log.w(PartialLightChain, 'Rejecting block - not a valid immediate predecessor');\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check that the difficulty is correct.\n        const nextTarget = await this.getNextTarget(block);\n        if (BlockUtils.isValidTarget(nextTarget)) {\n            if (this._proofHead.head.nBits !== BlockUtils.targetToCompact(nextTarget)) {\n                Log.w(PartialLightChain, 'Rejecting block - difficulty mismatch');\n                return FullChain.ERR_INVALID;\n            }\n        } else {\n            Log.w(NanoChain, 'Skipping difficulty verification - not enough blocks available');\n        }\n\n        // Block looks good, create ChainData.\n        const chainData = await this._proofHead.previousChainData(block);\n\n        // Prepend new block to the main chain.\n        if (!(await this._prepend(hash, chainData))) {\n            return FullChain.ERR_INVALID;\n        }\n\n        return FullChain.OK_EXTENDED;\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {ChainData} chainData\n     * @returns {Promise.<boolean>}\n     * @private\n     */\n    async _prepend(blockHash, chainData) {\n        try {\n            const transactionCache = new TransactionCache();\n            await this._accountsTx.revertBlock(chainData.head, transactionCache);\n        } catch (e) {\n            // AccountsHash mismatch. This can happen if someone gives us an invalid block.\n            // TODO error handling\n            Log.w(PartialLightChain, `Rejecting block - failed to commit to AccountsTree: ${e.message || e}`);\n            return false;\n        }\n\n        chainData.onMainChain = true;\n        chainData.mainChainSuccessor = this._proofHead.head.hash();\n        await this._store.putChainData(blockHash, chainData);\n\n        this._proofHead = chainData;\n\n        // Check whether we're complete.\n        if (!this.needsMoreBlocks()) {\n            await this._complete();\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {AccountsTreeChunk} chunk\n     * @returns {Promise.<PartialAccountsTree.Status>}\n     */\n    async pushAccountsTreeChunk(chunk) {\n        if (this._state !== PartialLightChain.State.PROVE_ACCOUNTS_TREE) {\n            return PartialAccountsTree.Status.ERR_INCORRECT_PROOF;\n        }\n\n        const result = await this._partialTree.pushChunk(chunk);\n\n        // If we're done, prepare next phase.\n        if (result === PartialAccountsTree.Status.OK_COMPLETE) {\n            this._state = PartialLightChain.State.PROVE_BLOCKS;\n            this._accountsTx = new Accounts(this._partialTree.transaction(false));\n        }\n\n        return result;\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _complete() {\n        this._state = PartialLightChain.State.COMPLETE;\n        if (this._accountsTx) {\n            await this._accountsTx.abort();\n            this._accountsTx = null;\n        }\n\n        const currentProof = this._proof || await this._getChainProof();\n        this.fire('complete', currentProof, this._headHash, this._mainChain);\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    async commit() {\n        if (this._accountsTx) {\n            await this._accountsTx.abort();\n        }\n\n        const result = await JDB.JungleDB.commitCombined(...this._store.txs, this._partialTree.tx);\n        this._partialTree = null;\n\n        const currentProof = this._proof || await this._getChainProof();\n        this.fire('committed', currentProof, this._headHash, this._mainChain);\n\n        return result;\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     */\n    async abort() {\n        this._state = PartialLightChain.State.ABORTED;\n        if (this._accountsTx) {\n            await this._accountsTx.abort();\n        }\n        if (this._partialTree) {\n            await this._partialTree.abort();\n        }\n        await this._store.abort();\n        this.fire('aborted');\n    }\n\n    /**\n     * @returns {string}\n     */\n    getMissingAccountsPrefix() {\n        if (this._partialTree) {\n            return this._partialTree.missingPrefix;\n        }\n        return '';\n    }\n\n    /**\n     * @returns {Array.<Hash>}\n     */\n    getBlockLocators() {\n        return this._proofHead ? [this._proofHead.head.hash()] : [this.headHash];\n    }\n\n    /**\n     * @returns {number}\n     */\n    numBlocksNeeded() {\n        if (!this._proofHead) {\n            return Policy.NUM_BLOCKS_VERIFICATION;\n        }\n        let numBlocks = Policy.NUM_BLOCKS_VERIFICATION - (this.height - this._proofHead.head.height + 1);\n        // If we begin syncing, we need one block additionally.\n        if (!this._proofHead.head.isFull()) {\n            numBlocks++;\n        }\n        return numBlocks;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    needsMoreBlocks() {\n        return this.numBlocksNeeded() > 0;\n    }\n\n    /** @type {PartialLightChain.State} */\n    get state() {\n        return this._state;\n    }\n\n    /** @type {number} */\n    get proofHeadHeight() {\n        return this._proofHead.head.height;\n    }\n}\n/**\n * @enum {number}\n */\nPartialLightChain.State = {\n    WEAK_PROOF: -2,\n    ABORTED: -1,\n    PROVE_CHAIN: 0,\n    PROVE_ACCOUNTS_TREE: 1,\n    PROVE_BLOCKS: 2,\n    COMPLETE: 3\n};\nClass.register(PartialLightChain);\n","class NanoChain extends BaseChain {\n    /**\n     * @param {Time} time\n     * @returns {Promise.<NanoChain>}\n     */\n    constructor(time) {\n        super(ChainDataStore.createVolatile());\n\n        /** @type {Time} */\n        this._time = time;\n\n        /** @type {ChainProof} */\n        this._proof = new ChainProof(new BlockChain([GenesisConfig.GENESIS_BLOCK.toLight()]), new HeaderChain([]));\n\n        /** @type {Hash} */\n        this._headHash = GenesisConfig.GENESIS_HASH;\n\n        /** @type {PrioritySynchronizer} */\n        this._synchronizer = new PrioritySynchronizer(2);\n\n        return this._init();\n    }\n\n    async _init() {\n        this._mainChain = await ChainData.initial(GenesisConfig.GENESIS_BLOCK);\n        await this._store.putChainData(GenesisConfig.GENESIS_HASH, this._mainChain);\n\n        return this;\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @returns {Promise.<boolean>}\n     */\n    pushProof(proof) {\n        return this._synchronizer.push(/*priority*/ 0,\n            this._pushProof.bind(this, proof));\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @returns {Promise.<boolean>}\n     * @private\n     */\n    async _pushProof(proof) {\n        const toDo = [];\n        for (let i = 0; i < proof.prefix.length; ++i) {\n            const block = proof.prefix.blocks[i];\n            const hash = block.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (!knownBlock && !block.header._pow) {\n                toDo.push(block.header);\n            }\n        }\n        for (let i = 0; i < proof.suffix.length; ++i) {\n            const header = proof.suffix.headers[i];\n            const hash = header.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (!knownBlock && !header._pow) {\n                toDo.push(header);\n            }\n        }\n        await BaseChain.manyPow(toDo);\n\n        // Verify all prefix blocks that we don't know yet.\n        for (let i = 0; i < proof.prefix.length; i++) {\n            const block = proof.prefix.blocks[i];\n            const hash = block.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (knownBlock) {\n                proof.prefix.blocks[i] = knownBlock.toLight();\n            } else if (!(await block.verify(this._time))) {\n                Log.w(NanoChain, 'Rejecting proof - prefix contains invalid block');\n                return false;\n            }\n        }\n\n        // Verify all suffix headers that we don't know yet.\n        for (let i = 0; i < proof.suffix.length; i++) {\n            const header = proof.suffix.headers[i];\n            const hash = header.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (knownBlock) {\n                proof.suffix.headers[i] = knownBlock.header;\n            } else if (!(await header.verifyProofOfWork())) {\n                Log.w(NanoChain, 'Rejecting proof - suffix contains invalid header');\n                return false;\n            }\n        }\n\n        // Check that the proof is valid.\n        if (!(await proof.verify())) {\n            Log.w(NanoChain, 'Rejecting proof - verification failed');\n            return false;\n        }\n\n        // Check that the suffix is long enough.\n        if (proof.suffix.length !== Policy.K && proof.suffix.length !== proof.head.height - 1) {\n            Log.w(NanoChain, 'Rejecting proof - invalid suffix length');\n            return false;\n        }\n\n        // Check that the dense suffix of the prefix is long enough.\n        // The paper doesn't require this, we however need a sufficiently long dense suffix\n        // to be able to verify block difficulties.\n        const denseSuffix = proof.prefix.denseSuffix();\n        if (denseSuffix.length < Policy.M && proof.prefix.length > 0 && proof.prefix.head.height >= Policy.M) {\n            Log.w(NanoChain, 'Rejecting proof - dense suffix too short');\n            return false;\n        }\n\n        // Compute and verify interlinks for the suffix.\n        const suffixBlocks = [];\n        let head = proof.prefix.head;\n        for (const header of proof.suffix.headers) {\n            const interlink = await head.getNextInterlink(header.target, header.version);\n            const interlinkHash = interlink.hash();\n            if (!header.interlinkHash.equals(interlinkHash)) {\n                Log.w(NanoChain, 'Rejecting proof - invalid interlink hash in proof suffix');\n                return false;\n            }\n\n            head = new Block(header, interlink);\n            suffixBlocks.push(head);\n        }\n\n        // If the given proof is better than our current proof, adopt the given proof as the new best proof.\n        const currentProof = this._proof || await this._getChainProof();\n        if (await BaseChain.isBetterProof(proof, currentProof, Policy.M)) {\n            await this._acceptProof(proof, suffixBlocks);\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @param {Array.<Block>} suffix\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _acceptProof(proof, suffix) {\n        this._proof = proof;\n\n        // If the proof prefix head is not part of our current dense chain suffix, reset store and start over.\n        // TODO use a store transaction here?\n        const head = proof.prefix.head;\n        const headHash = head.hash();\n        const headData = await this._store.getChainData(headHash);\n        if (!headData || headData.totalDifficulty <= 0) {\n            // Delete our current chain.\n            await this._store.truncate();\n\n            /** @type {Array.<Block>} */\n            const denseSuffix = proof.prefix.denseSuffix();\n\n            // Store all prefix blocks so they can be retrieved via getBlock()/getBlockAt()),\n            // but don't allow blocks to be appended to them by setting totalDifficulty = -1;\n            let superBlockCounts = new SuperBlockCounts();\n            for (let i = 0; i < proof.prefix.length - denseSuffix.length; i++) {\n                const block = proof.prefix.blocks[i];\n                const hash = block.hash();\n                const depth = BlockUtils.getHashDepth(await block.pow());\n                superBlockCounts = superBlockCounts.copyAndAdd(depth);\n\n                const data = new ChainData(block, /*totalDifficulty*/ -1, /*totalWork*/ -1, superBlockCounts, true);\n                await this._store.putChainData(hash, data);\n            }\n\n            // Set the tail end of the dense suffix of the prefix as the new chain head.\n            const tailEnd = denseSuffix[0];\n            this._headHash = tailEnd.hash();\n            this._mainChain = await ChainData.initial(tailEnd, superBlockCounts);\n            await this._store.putChainData(this._headHash, this._mainChain);\n\n            // Only in the dense suffix of the prefix we can calculate the difficulties.\n            for (let i = 1; i < denseSuffix.length; i++) {\n                const block = denseSuffix[i];\n                const result = await this._pushBlock(block); // eslint-disable-line no-await-in-loop\n                Assert.that(result >= 0);\n            }\n        }\n\n        // Push all suffix blocks.\n        for (const block of suffix) {\n            const result = await this._pushBlock(block); // eslint-disable-line no-await-in-loop\n            Assert.that(result >= 0);\n        }\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushBlock(block) {\n        // Check if we already know this header/block.\n        const hash = await block.hash();\n        const knownBlock = await this._store.getBlock(hash);\n        if (knownBlock) {\n            return NanoChain.OK_KNOWN;\n        }\n\n        // Retrieve the immediate predecessor.\n        /** @type {ChainData} */\n        const prevData = await this._store.getChainData(block.prevHash);\n        if (!prevData || prevData.totalDifficulty <= 0) {\n            return NanoChain.ERR_ORPHAN;\n        }\n\n        return this._pushBlockInternal(block, hash, prevData);\n    }\n\n    /**\n     * @param {BlockHeader} header\n     * @returns {Promise.<number>}\n     */\n    pushHeader(header) {\n        // Synchronize with .pushProof()\n        return this._synchronizer.push(/*priority*/ 0,\n            this._pushHeader.bind(this, header));\n    }\n\n    /**\n     * @param {BlockHeader} header\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushHeader(header) {\n        // Check if we already know this header/block.\n        const hash = header.hash();\n        const knownBlock = await this._store.getBlock(hash);\n        if (knownBlock) {\n            return NanoChain.OK_KNOWN;\n        }\n\n        // Verify proof of work.\n        if (!(await header.verifyProofOfWork())) {\n            Log.w(NanoChain, 'Rejecting header - PoW verification failed');\n            return NanoChain.ERR_INVALID;\n        }\n\n        // Retrieve the immediate predecessor.\n        /** @type {ChainData} */\n        const prevData = await this._store.getChainData(header.prevHash);\n        if (!prevData || prevData.totalDifficulty <= 0) {\n            Log.w(NanoChain, 'Rejecting header - unknown predecessor');\n            return NanoChain.ERR_ORPHAN;\n        }\n\n        // Check that the block is valid successor to its predecessor.\n        /** @type {Block} */\n        const predecessor = prevData.head;\n        if (!header.isImmediateSuccessorOf(predecessor.header)) {\n            Log.w(NanoChain, 'Rejecting header - not a valid successor');\n            return NanoChain.ERR_INVALID;\n        }\n\n        // Check that the difficulty is correct (if we can compute the next target)\n        const nextTarget = await this.getNextTarget(predecessor);\n        if (BlockUtils.isValidTarget(nextTarget)) {\n            if (header.nBits !== BlockUtils.targetToCompact(nextTarget)) {\n                Log.w(NanoChain, 'Rejecting header - difficulty mismatch');\n                return NanoChain.ERR_INVALID;\n            }\n        } else {\n            Log.w(NanoChain, 'Skipping difficulty verification - not enough blocks available');\n        }\n\n        // Compute and verify interlink.\n        const interlink = await predecessor.getNextInterlink(header.target, header.version);\n        const interlinkHash = interlink.hash();\n        if (!interlinkHash.equals(header.interlinkHash)) {\n            Log.w(NanoChain, 'Rejecting header - interlink verification failed');\n            return NanoChain.ERR_INVALID;\n        }\n\n        const block = new Block(header, interlink);\n        return this._pushBlockInternal(block, hash, prevData);\n    }\n\n    /**\n     * @param {Block} block\n     * @param {Hash} blockHash\n     * @param {ChainData} prevData\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushBlockInternal(block, blockHash, prevData) {\n        // Block looks good, create ChainData.\n        const chainData = await prevData.nextChainData(block);\n\n        // Check if the block extends our current main chain.\n        if (block.prevHash.equals(this.headHash)) {\n            // Append new block to the main chain.\n            chainData.onMainChain = true;\n            prevData.mainChainSuccessor = blockHash;\n\n            const storeTx = this._store.synchronousTransaction();\n            storeTx.putChainDataSync(blockHash, chainData);\n            storeTx.putChainDataSync(block.prevHash, prevData);\n            await storeTx.commit();\n\n            // Update head.\n            this._mainChain = chainData;\n            this._headHash = blockHash;\n\n            // Append new block to chain proof.\n            if (this._proof) {\n                const proofHeadHash = this._proof.head.hash();\n                if (block.prevHash.equals(proofHeadHash)) {\n                    this._proof = await this._extendChainProof(this._proof, block.header);\n                }\n            }\n\n            // Tell listeners that the head of the chain has changed.\n            this.fire('head-changed', this.head, /*rebranching*/ false);\n\n            return NanoChain.OK_EXTENDED;\n        }\n\n        // Otherwise, check if the new chain is harder than our current main chain.\n        if (chainData.totalDifficulty > this._mainChain.totalDifficulty) {\n            // A fork has become the hardest chain, rebranch to it.\n            await this._rebranch(blockHash, chainData);\n\n            return NanoChain.OK_REBRANCHED;\n        }\n\n        // Otherwise, we are creating/extending a fork. Store chain data.\n        Log.v(NanoChain, `Creating/extending fork with block ${blockHash}, height=${block.height}, totalDifficulty=${chainData.totalDifficulty}, totalWork=${chainData.totalWork}`);\n        await this._store.putChainData(blockHash, chainData);\n\n        return NanoChain.OK_FORKED;\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {ChainData} chainData\n     * @returns {Promise}\n     * @private\n     */\n    async _rebranch(blockHash, chainData) {\n        Log.v(NanoChain, `Rebranching to fork ${blockHash}, height=${chainData.head.height}, totalDifficulty=${chainData.totalDifficulty}, totalWork=${chainData.totalWork}`);\n\n        // Find the common ancestor between our current main chain and the fork chain.\n        // Walk up the fork chain until we find a block that is part of the main chain.\n        // Store the chain along the way.\n        const forkChain = [];\n        const forkHashes = [];\n\n        let curData = chainData;\n        let curHash = blockHash;\n        while (!curData.onMainChain) {\n            forkChain.push(curData);\n            forkHashes.push(curHash);\n\n            curHash = curData.head.prevHash;\n            curData = await this._store.getChainData(curHash); // eslint-disable-line no-await-in-loop\n            Assert.that(!!curData, 'Failed to find fork predecessor while rebranching');\n        }\n\n        Log.v(NanoChain, () => `Found common ancestor ${curHash.toBase64()} ${forkChain.length} blocks up`);\n\n        /** @type {ChainData} */\n        const ancestorData = curData;\n        /** @type {Hash} */\n        const ancestorHash = curHash;\n\n        /** @type {ChainDataStore} */\n        const chainTx = this._store.synchronousTransaction(false);\n        /** @type {Array.<ChainData>} */\n        const revertChain = [];\n        /** @type {Hash} */\n        let headHash = this._headHash;\n        /** @type {ChainData} */\n        let headData = this._mainChain;\n\n        // Unset onMainChain flag / mainChainSuccessor on the current main chain up to (excluding) the common ancestor.\n        while (!headHash.equals(ancestorHash)) {\n            headData.onMainChain = false;\n            headData.mainChainSuccessor = null;\n            chainTx.putChainDataSync(headHash, headData);\n            revertChain.push(headData);\n\n            headHash = headData.head.prevHash;\n            headData = await this._store.getChainData(headHash);\n            Assert.that(!!headData, 'Failed to find main chain predecessor while rebranching');\n        }\n\n        // Update the mainChainSuccessor of the common ancestor block.\n        ancestorData.mainChainSuccessor = forkHashes[forkHashes.length - 1];\n        chainTx.putChainDataSync(ancestorHash, ancestorData);\n\n        // Set onMainChain flag / mainChainSuccessor on the fork.\n        for (let i = forkChain.length - 1; i >= 0; i--) {\n            const forkData = forkChain[i];\n            forkData.onMainChain = true;\n            forkData.mainChainSuccessor = i > 0 ? forkHashes[i - 1] : null;\n            chainTx.putChainDataSync(forkHashes[i], forkData);\n        }\n\n        await chainTx.commit();\n\n        // Reset chain proof. We don't recompute the chain proof here, but do it lazily the next time it is needed.\n        // TODO modify chain proof directly, don't recompute.\n        this._proof = null;\n\n        // Fire block-reverted event for each block reverted during rebranch\n        for (const revertedData of revertChain) {\n            this.fire('block-reverted', revertedData.head);\n        }\n\n        // Fire head-changed event for each fork block.\n        for (let i = forkChain.length - 1; i >= 0; i--) {\n            this._mainChain = forkChain[i];\n            this._headHash = forkHashes[i];\n            this.fire('head-changed', this.head, /*rebranching*/ i > 0);\n        }\n    }\n\n    /**\n     * @returns {Promise.<ChainProof>}\n     * @override\n     */\n    getChainProof() {\n        return this._synchronizer.push(/*priority*/ 1, async () => {\n            if (!this._proof) {\n                this._proof = await this._getChainProof();\n            }\n            return this._proof;\n        });\n    }\n\n    /** @type {Block} */\n    get head() {\n        return this._mainChain.head;\n    }\n\n    /** @type {Hash} */\n    get headHash() {\n        return this._headHash;\n    }\n\n    /** @type {number} */\n    get height() {\n        return this._mainChain.head.height;\n    }\n}\nNanoChain.ERR_ORPHAN = -2;\nNanoChain.ERR_INVALID = -1;\nNanoChain.OK_KNOWN = 0;\nNanoChain.OK_EXTENDED = 1;\nNanoChain.OK_REBRANCHED = 2;\nNanoChain.OK_FORKED = 3;\nClass.register(NanoChain);\n","class NanoConsensusAgent extends BaseConsensusAgent {\n    /**\n     * @param {NanoChain} blockchain\n     * @param {NanoMempool} mempool\n     * @param {Time} time\n     * @param {Peer} peer\n     * @param {Subscription} targetSubscription\n     */\n    constructor(blockchain, mempool, time, peer, targetSubscription) {\n        super(time, peer, targetSubscription);\n        /** @type {NanoChain} */\n        this._blockchain = blockchain;\n        /** @type {NanoMempool} */\n        this._mempool = mempool;\n\n        // Flag indicating that we are currently syncing our blockchain with the peer's.\n        /** @type {boolean} */\n        this._syncing = false;\n\n        /** @type {Array.<BlockHeader>} */\n        this._orphanedBlocks = [];\n\n        // Helper object to keep track of the accounts we're requesting from the peer.\n        this._accountsRequest = null;\n\n        // Flag to track chain proof requests.\n        this._requestedChainProof = false;\n\n        // Listen to consensus messages from the peer.\n        peer.channel.on('chain-proof', msg => this._onChainProof(msg));\n        peer.channel.on('accounts-proof', msg => this._onAccountsProof(msg));\n\n        peer.channel.on('get-chain-proof', msg => this._onGetChainProof(msg));\n\n        // Subscribe to all announcements from the peer.\n        this._subscribeTarget();\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     */\n    async syncBlockchain() {\n        this._syncing = true;\n\n        const headBlock = await this._blockchain.getBlock(this._peer.headHash);\n        if (!headBlock) {\n            this._requestChainProof();\n            this.fire('sync-chain-proof', this._peer.peerAddress);\n        } else {\n            this._syncFinished();\n        }\n    }\n\n    requestMempool() {\n        // Request the peer's mempool.\n        // XXX Use a random delay here to prevent requests to multiple peers at once.\n        const delay = NanoConsensusAgent.MEMPOOL_DELAY_MIN\n            + Math.random() * (NanoConsensusAgent.MEMPOOL_DELAY_MAX - NanoConsensusAgent.MEMPOOL_DELAY_MIN);\n        setTimeout(() => this._peer.channel.mempool(), delay);\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _syncFinished() {\n        this._syncing = false;\n        this._synced = true;\n\n        this.requestMempool();\n\n        this.fire('sync');\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _requestChainProof() {\n        // Only one chain proof request at a time.\n        if (this._requestedChainProof) {\n            return;\n        }\n\n        // Request ChainProof from peer.\n        this._peer.channel.getChainProof();\n        this._requestedChainProof = true;\n\n        // Drop the peer if it doesn't send the chain proof within the timeout.\n        this._peer.channel.expectMessage(Message.Type.CHAIN_PROOF, () => {\n            this._peer.channel.close(CloseType.GET_CHAIN_PROOF_TIMEOUT, 'getChainProof timeout');\n        }, NanoConsensusAgent.CHAINPROOF_REQUEST_TIMEOUT, NanoConsensusAgent.CHAINPROOF_CHUNK_TIMEOUT);\n    }\n\n    /**\n     * @param {ChainProofMessage} msg\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _onChainProof(msg) {\n        Log.d(NanoConsensusAgent, `[CHAIN-PROOF] Received from ${this._peer.peerAddress}: ${msg.proof}`);\n\n        // Check if we have requested a chain proof, reject unsolicited ones.\n        // FIXME\n        if (!this._requestedChainProof) {\n            Log.w(NanoConsensusAgent, `Unsolicited chain proof received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n        this._requestedChainProof = false;\n\n        if (this._syncing) {\n            this.fire('verify-chain-proof', this._peer.peerAddress);\n        }\n\n        // Push the proof into the NanoChain.\n        if (!(await this._blockchain.pushProof(msg.proof))) {\n            Log.w(NanoConsensusAgent, `Invalid chain proof received from ${this._peer.peerAddress} - verification failed`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.INVALID_CHAIN_PROOF, 'invalid chain proof');\n            return;\n        }\n\n        // TODO add all blocks from the chain proof to knownObjects.\n\n        // Apply any orphaned blocks we received while waiting for the chain proof.\n        await this._applyOrphanedBlocks();\n\n        if (this._syncing) {\n            this._syncFinished();\n        }\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _applyOrphanedBlocks() {\n        for (const header of this._orphanedBlocks) {\n            const status = await this._blockchain.pushHeader(header);\n            if (status === NanoChain.ERR_INVALID) {\n                this._peer.channel.close(CloseType.RECEIVED_INVALID_BLOCK, 'received invalid block');\n                break;\n            }\n        }\n        this._orphanedBlocks = [];\n    }\n\n    /**\n     * @param {Array.<InvVector>} vectors\n     * @returns {void}\n     * @protected\n     * @override\n     */\n    _doRequestData(vectors) {\n        /** @type {Array.<InvVector>} */\n        const blocks = [];\n        /** @type {Array.<InvVector>} */\n        const transactions = [];\n        for (const vector of vectors) {\n            if (vector.type === InvVector.Type.BLOCK) {\n                blocks.push(vector);\n            } else {\n                transactions.push(vector);\n            }\n        }\n\n        // Request headers and transactions from peer.\n        this._peer.channel.getHeader(blocks);\n        this._peer.channel.getData(transactions);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {boolean} [includeForks]\n     * @returns {Promise.<?Block>}\n     * @protected\n     * @override\n     */\n    _getBlock(hash, includeForks = false) {\n        return this._blockchain.getBlock(hash, includeForks);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Promise.<?Transaction>}\n     * @protected\n     * @override\n     */\n    _getTransaction(hash) {\n        return Promise.resolve(this._mempool.getTransaction(hash));\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {BlockHeader} header\n     * @returns {Promise.<void>}\n     * @protected\n     * @override\n     */\n    async _processHeader(hash, header) {\n        // TODO send reject message if we don't like the block\n        const status = await this._blockchain.pushHeader(header);\n        if (status === NanoChain.ERR_INVALID) {\n            this._peer.channel.close(CloseType.RECEIVED_INVALID_HEADER, 'received invalid header');\n        }\n        // Re-sync with this peer if it starts sending orphan blocks after the initial sync.\n        else if (status === NanoChain.ERR_ORPHAN) {\n            this._orphanedBlocks.push(header);\n            if (this._synced) {\n                this._requestChainProof();\n            }\n        }\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Transaction} transaction\n     * @returns {Promise.<void>}\n     * @protected\n     * @override\n     */\n    _processTransaction(hash, transaction) {\n        return this._mempool.pushTransaction(transaction);\n    }\n\n    /**\n     * @param {GetChainProofMessage} msg\n     * @private\n     */\n    async _onGetChainProof(msg) {\n        const proof = await this._blockchain.getChainProof();\n        if (proof) {\n            this._peer.channel.chainProof(proof);\n        }\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<Array.<Account>>}\n     */\n    getAccounts(blockHash, addresses) {\n        return this._synchronizer.push('getAccounts',\n            this._getAccounts.bind(this, blockHash, addresses));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<Array<Account>>}\n     * @private\n     */\n    _getAccounts(blockHash, addresses) {\n        Assert.that(this._accountsRequest === null);\n\n        Log.d(NanoConsensusAgent, `Requesting AccountsProof for ${addresses} from ${this._peer.peerAddress}`);\n\n        return new Promise((resolve, reject) => {\n            this._accountsRequest = {\n                addresses: addresses,\n                blockHash: blockHash,\n                resolve: resolve,\n                reject: reject\n            };\n\n            // Request AccountsProof from peer.\n            this._peer.channel.getAccountsProof(blockHash, addresses);\n\n            // Drop the peer if it doesn't send the accounts proof within the timeout.\n            this._peer.channel.expectMessage(Message.Type.ACCOUNTS_PROOF, () => {\n                this._peer.channel.close(CloseType.GET_ACCOUNTS_PROOF_TIMEOUT, 'getAccountsProof timeout');\n                reject(new Error('timeout')); // TODO error handling\n            }, NanoConsensusAgent.ACCOUNTSPROOF_REQUEST_TIMEOUT);\n        });\n    }\n\n    /**\n     * @param {AccountsProofMessage} msg\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _onAccountsProof(msg) {\n        Log.d(NanoConsensusAgent, `[ACCOUNTS-PROOF] Received from ${this._peer.peerAddress}: blockHash=${msg.blockHash}, proof=${msg.proof} (${msg.serializedSize} bytes)`);\n\n        // Check if we have requested an accounts proof, reject unsolicited ones.\n        if (!this._accountsRequest) {\n            Log.w(NanoConsensusAgent, `Unsolicited accounts proof received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n\n        const addresses = this._accountsRequest.addresses;\n        const blockHash = this._accountsRequest.blockHash;\n        const resolve = this._accountsRequest.resolve;\n        const reject = this._accountsRequest.reject;\n\n        // Reset accountsRequest.\n        this._accountsRequest = null;\n\n        if (!msg.hasProof()) {\n            reject(new Error('Accounts request was rejected'));\n            return;\n        }\n\n        // Check that the reference block corresponds to the one we requested.\n        if (!blockHash.equals(msg.blockHash)) {\n            Log.w(NanoConsensusAgent, `Received AccountsProof for invalid reference block from ${this._peer.peerAddress}`);\n            reject(new Error('Invalid reference block'));\n            return;\n        }\n\n        // Verify the proof.\n        const proof = msg.proof;\n        if (!proof.verify()) {\n            Log.w(NanoConsensusAgent, `Invalid AccountsProof received from ${this._peer.peerAddress}`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.INVALID_ACCOUNTS_PROOF, 'Invalid AccountsProof');\n            reject(new Error('Invalid AccountsProof'));\n            return;\n        }\n\n        // Check that the proof root hash matches the accountsHash in the reference block.\n        const rootHash = proof.root();\n        const block = await this._blockchain.getBlock(blockHash);\n        if (!block.accountsHash.equals(rootHash)) {\n            Log.w(NanoConsensusAgent, `Invalid AccountsProof (root hash) received from ${this._peer.peerAddress}`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.ACCOUNTS_PROOF_ROOT_HASH_MISMATCH, 'AccountsProof root hash mismatch');\n            reject(new Error('AccountsProof root hash mismatch'));\n            return;\n        }\n\n        // Check that all requested accounts are part of this proof.\n        // XXX return a map address -> account instead?\n        const accounts = [];\n        for (const address of addresses) {\n            try {\n                const account = proof.getAccount(address);\n                accounts.push(account);\n            } catch (e) {\n                Log.w(NanoConsensusAgent, `Incomplete AccountsProof received from ${this._peer.peerAddress}`);\n                // TODO ban instead?\n                this._peer.channel.close(CloseType.INCOMPLETE_ACCOUNTS_PROOF, 'Incomplete AccountsProof');\n                reject(new Error('Incomplete AccountsProof'));\n                return;\n            }\n        }\n\n        // Return the retrieved accounts.\n        resolve(accounts);\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     * @override\n     */\n    _onClose() {\n        // Clear the synchronizer queue.\n        this._synchronizer.clear();\n        super._onClose();\n    }\n}\n/**\n * Maximum time (ms) to wait for chain-proof after sending out get-chain-proof before dropping the peer.\n * @type {number}\n */\nNanoConsensusAgent.CHAINPROOF_REQUEST_TIMEOUT = 1000 * 45;\n/**\n * Maximum time (ms) to wait for between chain-proof chunks before dropping the peer.\n * @type {number}\n */\nNanoConsensusAgent.CHAINPROOF_CHUNK_TIMEOUT = 1000 * 10;\n/**\n * Maximum time (ms) to wait for accounts-proof after sending out get-accounts-proof before dropping the peer.\n * @type {number}\n */\nNanoConsensusAgent.ACCOUNTSPROOF_REQUEST_TIMEOUT = 1000 * 5;\n/**\n * Minimum time {ms} to wait before triggering the initial mempool request.\n * @type {number}\n */\nNanoConsensusAgent.MEMPOOL_DELAY_MIN = 1000 * 2; // 2 seconds\n/**\n * Maximum time {ms} to wait before triggering the initial mempool request.\n * @type {number}\n */\nNanoConsensusAgent.MEMPOOL_DELAY_MAX = 1000 * 20; // 20 seconds\nClass.register(NanoConsensusAgent);\n","class NanoConsensus extends BaseConsensus {\n    /**\n     * @param {NanoChain} blockchain\n     * @param {NanoMempool} mempool\n     * @param {Network} network\n     */\n    constructor(blockchain, mempool, network) {\n        super(blockchain, mempool, network);\n        /** @type {NanoChain} */\n        this._blockchain = blockchain;\n        /** @type {NanoMempool} */\n        this._mempool = mempool;\n\n        /** @type {Subscription} */\n        this._subscription = Subscription.BLOCKS_ONLY;\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     */\n    subscribeAccounts(addresses) {\n        this.subscribe(Subscription.fromAddresses(addresses));\n        this._mempool.evictExceptAddresses(addresses);\n        for (const /** @type {NanoConsensusAgent} */ agent of this._agents.valueIterator()) {\n            agent.requestMempool();\n        }\n    }\n\n    /**\n     * @param {Peer} peer\n     * @returns {BaseConsensusAgent}\n     * @override\n     */\n    _newConsensusAgent(peer) {\n        return new NanoConsensusAgent(this._blockchain, this._mempool, this._network.time, peer, this._subscription);\n    }\n\n    /**\n     * @param {Peer} peer\n     * @override\n     */\n    _onPeerJoined(peer) {\n        const agent = super._onPeerJoined(peer);\n\n        // Forward sync events.\n        this.bubble(agent, 'sync-chain-proof', 'verify-chain-proof');\n\n        return agent;\n    }\n\n    /**\n     * @param {Block} head\n     * @override\n     */\n    async _onHeadChanged(head) {\n        if (!this._established) return;\n\n        // Update mempool.\n        try {\n            const includedTransactions = await this._requestTransactionsProof(this._subscription.addresses, head);\n            this._mempool.changeHead(head, includedTransactions);\n        } catch (e) {\n            Log.e(NanoConsensus, `Failed to retrieve transaction proof to update mempool: ${e.message || e}`);\n        }\n\n        // Relay block *after* requesting the TransactionsProof. Otherwise, we might\n        // send the request to a peer (first) that has not adopted the new block yet.\n        super._onHeadChanged(head);\n    }\n\n    /**\n     * @param {Transaction} tx\n     * @protected\n     */\n    _onTransactionAdded(tx) {\n        // Don't relay transactions added to the mempool.\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Hash} [blockHash]\n     * @returns {Promise.<Account>}\n     */\n    async getAccount(address, blockHash = null) {\n        return (await this.getAccounts([address], blockHash))[0];\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     * @param {Hash} [blockHash]\n     * @returns {Promise.<Array<Account>>}\n     */\n    async getAccounts(addresses, blockHash) {\n        blockHash = blockHash ? blockHash : this._blockchain.headHash;\n        const agents = this._agents.values().filter(agent =>\n            agent.synced\n            && agent.knowsBlock(blockHash)\n            && !Services.isNanoNode(agent.peer.peerAddress.services)\n        );\n\n        for (const /** @type {NanoConsensusAgent} */ agent of agents) {\n            try {\n                return await agent.getAccounts(blockHash, addresses); // eslint-disable-line no-await-in-loop\n            } catch (e) {\n                Log.w(NanoConsensus, `Failed to retrieve accounts ${addresses} from ${agent.peer.peerAddress}: ${e}`);\n                // Try the next peer.\n            }\n        }\n\n        // No peer supplied the requested account, fail.\n        throw new Error(`Failed to retrieve accounts ${addresses}`);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @returns {Promise.<void>}\n     */\n    async relayTransaction(transaction) {\n        // Fail if we are not connected to at least one full/light node.\n        if (!this._agents.values().some(agent => !Services.isNanoNode(agent.peer.peerAddress.services))) {\n            throw new Error('Failed to relay transaction - only nano nodes connected');\n        }\n\n        // Store transaction in mempool.\n        if (!(await this._mempool.pushTransaction(transaction))) {\n            throw new Error('Failed to relay transaction - mempool rejected transaction');\n        }\n\n        // Relay transaction to all connected peers.\n        let relayed = false;\n        for (const agent of this._agents.values()) {\n            relayed = agent.relayTransaction(transaction) || relayed;\n        }\n\n        // Fail if the transaction was not relayed.\n        if (!relayed) {\n            throw new Error('Failed to relay transaction - no agent relayed transaction');\n        }\n    }\n\n    /** @type {NanoChain} */\n    get blockchain() {\n        return this._blockchain;\n    }\n\n    /** @type {NanoMempool} */\n    get mempool() {\n        return this._mempool;\n    }\n}\nClass.register(NanoConsensus);\n","class NanoMempool extends Observable {\n    /**\n     * @param {IBlockchain} blockchain\n     */\n    constructor(blockchain) {\n        super();\n\n        /** @type {IBlockchain} */\n        this._blockchain = blockchain;\n\n        // Our pool of transactions.\n        /** @type {HashMap.<Hash, Transaction>} */\n        this._transactionsByHash = new HashMap();\n        /** @type {HashMap.<Address, MempoolTransactionSet>} */\n        this._transactionSetByAddress = new HashMap();\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @fires Mempool#transaction-added\n     * @returns {Promise.<boolean>}\n     */\n    async pushTransaction(transaction) {\n        // Check if we already know this transaction.\n        const hash = transaction.hash();\n        if (this._transactionsByHash.contains(hash)) {\n            Log.v(Mempool, () => `Ignoring known transaction ${hash.toBase64()}`);\n            return false;\n        }\n\n        // Check validity based on startHeight.\n        if (this._blockchain.height >= transaction.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n            Log.v(Mempool, () => `Ignoring expired transaction ${hash.toBase64()}`);\n            return false;\n        }\n\n        // Verify transaction.\n        if (!transaction.verify()) {\n            return false;\n        }\n\n        // Transaction is valid, add it to the mempool.\n        this._transactionsByHash.put(hash, transaction);\n        const set = this._transactionSetByAddress.get(transaction.sender) || new MempoolTransactionSet();\n        set.add(transaction);\n        this._transactionSetByAddress.put(transaction.sender, set);\n\n        // Tell listeners about the new transaction we received.\n        this.fire('transaction-added', transaction);\n\n        return true;\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Transaction}\n     */\n    getTransaction(hash) {\n        return this._transactionsByHash.get(hash);\n    }\n\n    /**\n     * @param {number} maxCount\n     * @returns {Array.<Transaction>}\n     */\n    getTransactions(maxCount = 5000) {\n        return this._transactionsByHash.values().sort((a, b) => a.compare(b)).slice(0, maxCount);\n    }\n\n    /**\n     * @param {Address} address\n     * @return {Array.<Transaction>}\n     */\n    getPendingTransactions(address) {\n        const set = this._transactionSetByAddress.get(address);\n        return set ? set.transactions : [];\n    }\n\n    /**\n     * @param {Block} block\n     * @param {Array.<Transaction>} transactions\n     */\n    changeHead(block, transactions) {\n        this._evictTransactions(block.header, transactions);\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     */\n    evictExceptAddresses(addresses) {\n        const addressSet = new HashSet();\n        addressSet.addAll(addresses);\n        for (const /** @type {Transaction} */ tx of this._transactionsByHash.values()) {\n            if (!addressSet.contains(tx.sender) && !addressSet.contains(tx.recipient)) {\n                this._transactionsByHash.remove(tx.hash());\n\n                /** @type {MempoolTransactionSet} */\n                const set = this._transactionSetByAddress.get(tx.sender);\n                set.remove(tx);\n\n                if (set.length === 0) {\n                    this._transactionSetByAddress.remove(tx.sender);\n                }\n            }\n        }\n    }\n\n    /**\n     * @param {BlockHeader} blockHeader\n     * @param {Array.<Transaction>} transactions\n     * @private\n     */\n    _evictTransactions(blockHeader, transactions) {\n        // Remove expired transactions.\n        for (const /** @type {Transaction} */ tx of this._transactionsByHash.values()) {\n            const txHash = tx.hash();\n            if (blockHeader.height >= tx.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n                this._transactionsByHash.remove(txHash);\n\n                /** @type {MempoolTransactionSet} */\n                const set = this._transactionSetByAddress.get(tx.sender);\n                set.remove(tx);\n\n                if (set.length === 0) {\n                    this._transactionSetByAddress.remove(tx.sender);\n                }\n\n                this.fire('transaction-expired', tx);\n            }\n        }\n\n        // Remove mined transactions.\n        for (const /** @type {Transaction} */ tx of transactions) {\n            const txHash = tx.hash();\n            if (this._transactionsByHash.contains(txHash)) {\n                this._transactionsByHash.remove(txHash);\n\n                /** @type {MempoolTransactionSet} */\n                const set = this._transactionSetByAddress.get(tx.sender);\n                set.remove(tx);\n\n                if (set.length === 0) {\n                    this._transactionSetByAddress.remove(tx.sender);\n                }\n\n                this.fire('transaction-mined', tx, blockHeader);\n            }\n        }\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._transactionsByHash.length;\n    }\n}\nClass.register(NanoMempool);\n","class ConsensusDB extends JDB.JungleDB {\n    /**\n     * @param {string} [dbPrefix]\n     * @returns {Promise.<ConsensusDB>}\n     */\n    static async getFull(dbPrefix = '') {\n        if (!ConsensusDB._instance) {\n            ConsensusDB._instance = await new ConsensusDB(`${dbPrefix}full-consensus`);\n        }\n        return ConsensusDB._instance;\n    }\n\n    /**\n     * @param {string} dbPrefix\n     * @returns {Promise.<ConsensusDB>}\n     */\n    static async getLight(dbPrefix = '') {\n        if (!ConsensusDB._instance) {\n            ConsensusDB._instance = await new ConsensusDB(`${dbPrefix}light-consensus`);\n        }\n        return ConsensusDB._instance;\n    }\n\n    /**\n     * @param {string} dbName\n     * @returns {Promise.<ConsensusDB>}\n     */\n    constructor(dbName) {\n        // Start with 500MB and resize at least 1GB at a time.\n        super(dbName, ConsensusDB.VERSION, {\n            maxDbSize: ConsensusDB.INITIAL_DB_SIZE,\n            autoResize: true,\n            minResize: ConsensusDB.MIN_RESIZE\n        });\n        return this._init();\n    }\n\n    /**\n     * @returns {Promise.<ConsensusDB>}\n     * @private\n     */\n    async _init() {\n        // Initialize object stores.\n        AccountsTreeStore.initPersistent(this);\n        ChainDataStore.initPersistent(this);\n        TransactionStore.initPersistent(this);\n\n        // Establish connection to database.\n        await this.connect();\n\n        return this;\n    }\n}\nConsensusDB._instance = null;\nConsensusDB.VERSION = 3;\nConsensusDB.INITIAL_DB_SIZE = 1024*1024*500; // 500 MB initially\nConsensusDB.MIN_RESIZE = 1 << 30; // 1 GB\nClass.register(ConsensusDB);\n","class Consensus {\n    /**\n     * @param {NetworkConfig} [netconfig]\n     * @return {Promise.<FullConsensus>}\n     */\n    static async full(netconfig = NetworkConfig.getDefault()) {\n        netconfig.services = new Services(Services.FULL, Services.FULL);\n        await netconfig.initPersistent();\n\n        /** @type {Time} */\n        const time = new Time();\n        /** @type {ConsensusDB} */\n        const db = await ConsensusDB.getFull(`${GenesisConfig.NETWORK_NAME}-`);\n        /** @type {Accounts} */\n        const accounts = await Accounts.getPersistent(db);\n        /** @type {TransactionStore} */\n        const transactionStore = await TransactionStore.getPersistent(db);\n        /** @type {FullChain} */\n        const blockchain = await FullChain.getPersistent(db, accounts, time, transactionStore);\n        /** @type {Mempool} */\n        const mempool = new Mempool(blockchain, accounts);\n        /** @type {Network} */\n        const network = new Network(blockchain, netconfig, time);\n\n        return new FullConsensus(blockchain, mempool, network);\n    }\n\n    /**\n     * @param {NetworkConfig} [netconfig]\n     * @return {Promise.<LightConsensus>}\n     */\n    static async light(netconfig = NetworkConfig.getDefault()) {\n        netconfig.services = new Services(Services.LIGHT, Services.LIGHT | Services.FULL);\n        await netconfig.initPersistent();\n\n        /** @type {Time} */\n        const time = new Time();\n        /** @type {ConsensusDB} */\n        const db = await ConsensusDB.getLight(`${GenesisConfig.NETWORK_NAME}-`);\n        /** @type {Accounts} */\n        const accounts = await Accounts.getPersistent(db);\n        /** @type {LightChain} */\n        const blockchain = await LightChain.getPersistent(db, accounts, time);\n        /** @type {Mempool} */\n        const mempool = new Mempool(blockchain, accounts);\n        /** @type {Network} */\n        const network = new Network(blockchain, netconfig, time);\n\n        return new LightConsensus(blockchain, mempool, network);\n    }\n\n    /**\n     * @param {NetworkConfig} [netconfig]\n     * @return {Promise.<NanoConsensus>}\n     */\n    static async nano(netconfig = NetworkConfig.getDefault()) {\n        netconfig.services = new Services(Services.NANO, Services.NANO | Services.LIGHT | Services.FULL);\n        await netconfig.initPersistent();\n\n        /** @type {Time} */\n        const time = new Time();\n        /** @type {NanoChain} */\n        const blockchain = await new NanoChain(time);\n        /** @type {NanoMempool} */\n        const mempool = new NanoMempool(blockchain);\n        /** @type {Network} */\n        const network = new Network(blockchain, netconfig, time);\n\n        return new NanoConsensus(blockchain, mempool, network);\n    }\n\n    /**\n     * @param {NetworkConfig} [netconfig]\n     * @return {Promise.<FullConsensus>}\n     */\n    static async volatileFull(netconfig = NetworkConfig.getDefault()) {\n        netconfig.services = new Services(Services.FULL, Services.FULL);\n        await netconfig.initVolatile();\n\n        /** @type {Time} */\n        const time = new Time();\n        /** @type {Accounts} */\n        const accounts = await Accounts.createVolatile();\n        /** @type {TransactionStore} */\n        const transactionStore = await TransactionStore.createVolatile();\n        /** @type {FullChain} */\n        const blockchain = await FullChain.createVolatile(accounts, time, transactionStore);\n        /** @type {Mempool} */\n        const mempool = new Mempool(blockchain, accounts);\n        /** @type {Network} */\n        const network = new Network(blockchain, netconfig, time);\n\n        return new FullConsensus(blockchain, mempool, network);\n    }\n\n    /**\n     * @param {NetworkConfig} [netconfig]\n     * @return {Promise.<LightConsensus>}\n     */\n    static async volatileLight(netconfig = NetworkConfig.getDefault()) {\n        netconfig.services = new Services(Services.LIGHT, Services.LIGHT | Services.FULL);\n        await netconfig.initVolatile();\n\n        /** @type {Time} */\n        const time = new Time();\n        /** @type {Accounts} */\n        const accounts = await Accounts.createVolatile();\n        /** @type {LightChain} */\n        const blockchain = await LightChain.createVolatile(accounts, time);\n        /** @type {Mempool} */\n        const mempool = new Mempool(blockchain, accounts);\n        /** @type {Network} */\n        const network = new Network(blockchain, netconfig, time);\n\n        return new LightConsensus(blockchain, mempool, network);\n    }\n\n    /**\n     * @param {NetworkConfig} [netconfig]\n     * @return {Promise.<NanoConsensus>}\n     */\n    static async volatileNano(netconfig = NetworkConfig.getDefault()) {\n        netconfig.services = new Services(Services.NANO, Services.NANO | Services.LIGHT | Services.FULL);\n        await netconfig.initVolatile();\n\n        /** @type {Time} */\n        const time = new Time();\n        /** @type {NanoChain} */\n        const blockchain = await new NanoChain(time);\n        /** @type {NanoMempool} */\n        const mempool = new NanoMempool(blockchain);\n        /** @type {Network} */\n        const network = new Network(blockchain, netconfig, time);\n\n        return new NanoConsensus(blockchain, mempool, network);\n    }\n}\n\nClass.register(Consensus);\n","class Protocol {\n}\nProtocol.DUMB = 0;\nProtocol.WS = 1;\nProtocol.RTC = 2;\nClass.register(Protocol);\n","class Message {\n    /**\n     * Create a new Message instance. This is usually not called directly but by subclasses.\n     * @param {Message.Type} type Message type\n     */\n    constructor(type) {\n        if (!NumberUtils.isUint64(type)) throw new Error('Malformed type');\n        /** @type {Message.Type} */\n        this._type = type;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {Message.Type}\n     */\n    static peekType(buf) {\n        // Store current read position.\n        const pos = buf.readPos;\n\n        // Set read position past the magic to the beginning of the type string.\n        buf.readPos = 4;\n\n        // Read the type.\n        const type = buf.readVarUint();\n\n        // Reset the read position to original.\n        buf.readPos = pos;\n\n        return type;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {number}\n     */\n    static peekLength(buf) {\n        // Store current read position.\n        const pos = buf.readPos;\n\n        // Set read position past the magic to the beginning of the type string.\n        buf.readPos = 4;\n\n        // Read the type and ignore it.\n        buf.readVarUint();\n        // Read the length.\n        const length = buf.readUint32();\n\n        // Reset the read position to original.\n        buf.readPos = pos;\n\n        return length;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {Message}\n     */\n    static unserialize(buf) {\n        // XXX Direct buffer manipulation currently requires this.\n        Assert.that(buf.readPos === 0, 'Message.unserialize() requires buf.readPos == 0');\n\n        const magic = buf.readUint32();\n        const type = buf.readVarUint();\n        buf.readUint32(); // length is ignored\n        const checksum = buf.readUint32();\n\n        // Validate magic.\n        if (magic !== Message.MAGIC) throw 'Malformed magic';\n\n        // Validate checksum.\n        Message._writeChecksum(type, buf, 0);\n        const calculatedChecksum = CRC32.compute(buf);\n        if (checksum !== calculatedChecksum) throw new Error('Invalid checksum');\n\n        return new Message(type);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        // XXX Direct buffer manipulation currently requires this.\n        Assert.that(buf.writePos === 0, 'Message.serialize() requires buf.writePos == 0');\n\n        buf.writeUint32(Message.MAGIC);\n        buf.writeVarUint(this._type);\n        buf.writeUint32(this.serializedSize);\n        buf.writeUint32(0); // written later by _setChecksum()\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*magic*/ 4\n            + /*type*/ SerialBuffer.varUintSize(this._type)\n            + /*length*/ 4\n            + /*checksum*/ 4;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {void}\n     * @protected\n     */\n    _setChecksum(buf) {\n        const checksum = CRC32.compute(buf);\n        Message._writeChecksum(this._type, buf, checksum);\n    }\n\n    /**\n     * @param {Message.Type} type\n     * @param {SerialBuffer} buf\n     * @param {number} value\n     * @returns {void}\n     * @private\n     */\n    static _writeChecksum(type, buf, value) {\n        // Store current write position.\n        const pos = buf.writePos;\n\n        // Set write position past the magic, type, and length fields to the\n        // beginning of the checksum value.\n        buf.writePos = /*magic*/ 4\n            + /*type*/ SerialBuffer.varUintSize(type)\n            + /*length*/ 4;\n\n        // Write the checksum value.\n        buf.writeUint32(value);\n\n        // Reset the write position to original.\n        buf.writePos = pos;\n    }\n\n    /** @type {Message.Type} */\n    get type() {\n        return this._type;\n    }\n}\nMessage.MAGIC = 0x42042042;\n/**\n * Enum for message types.\n * @enum {number}\n */\nMessage.Type = {\n    VERSION:    0,\n    INV:        1,\n    GET_DATA:   2,\n    GET_HEADER: 3,\n    NOT_FOUND:  4,\n    GET_BLOCKS: 5,\n    BLOCK:      6,\n    HEADER:     7,\n    TX:         8,\n    MEMPOOL:    9,\n    REJECT:     10,\n    SUBSCRIBE:  11,\n\n    ADDR:       20,\n    GET_ADDR:   21,\n    PING:       22,\n    PONG:       23,\n\n    SIGNAL:     30,\n\n    GET_CHAIN_PROOF:            40,\n    CHAIN_PROOF:                41,\n    GET_ACCOUNTS_PROOF:         42,\n    ACCOUNTS_PROOF:             43,\n    GET_ACCOUNTS_TREE_CHUNK:    44,\n    ACCOUNTS_TREE_CHUNK:        45,\n    GET_TRANSACTIONS_PROOF:     47,\n    TRANSACTIONS_PROOF:         48,\n    GET_TRANSACTION_RECEIPTS:   49,\n    TRANSACTION_RECEIPTS:       50,\n    GET_BLOCK_PROOF:            51,\n    BLOCK_PROOF:                52,\n\n    GET_HEAD:   60,\n    HEAD:       61,\n\n    VERACK:   90\n};\nClass.register(Message);\n","class AddrMessage extends Message {\n    /**\n     * @param {Array.<PeerAddress>} addresses\n     */\n    constructor(addresses) {\n        super(Message.Type.ADDR);\n        if (!addresses || !NumberUtils.isUint16(addresses.length)\n            || addresses.some(it => !(it instanceof PeerAddress))) throw 'Malformed addresses';\n        this._addresses = addresses;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {AddrMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const addresses = [];\n        for (let i = 0; i < count; ++i) {\n            addresses.push(PeerAddress.unserialize(buf));\n        }\n        return new AddrMessage(addresses);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint16(this._addresses.length);\n        for (const addr of this._addresses) {\n            addr.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let size = super.serializedSize\n            + /*count*/ 2;\n        for (const addr of this._addresses) {\n            size += addr.serializedSize;\n        }\n        return size;\n    }\n\n    /** @type {Array.<PeerAddress>} */\n    get addresses() {\n        return this._addresses;\n    }\n}\nClass.register(AddrMessage);\n","class BlockMessage extends Message {\n    /**\n     * @param {Block} block\n     */\n    constructor(block) {\n        super(Message.Type.BLOCK);\n        // TODO Bitcoin block messages start with a block version\n        /** @type {Block} */\n        this._block = block;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {BlockMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const block = Block.unserialize(buf);\n        return new BlockMessage(block);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._block.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._block.serializedSize;\n    }\n\n    /** @type {Block} */\n    get block() {\n        return this._block;\n    }\n}\nClass.register(BlockMessage);\n","class GetAddrMessage extends Message {\n    /**\n     * @param {number} protocolMask\n     * @param {number} serviceMask\n     */\n    constructor(protocolMask, serviceMask) {\n        super(Message.Type.GET_ADDR);\n        if (!NumberUtils.isUint8(protocolMask)) throw 'Malformed protocolMask';\n        if (!NumberUtils.isUint32(serviceMask)) throw 'Malformed serviceMask';\n        this._protocolMask = protocolMask;\n        this._serviceMask = serviceMask;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {GetAddrMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const protocolMask = buf.readUint8();\n        const serviceMask = buf.readUint32();\n        return new GetAddrMessage(protocolMask, serviceMask);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint8(this._protocolMask);\n        buf.writeUint32(this._serviceMask);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*protocolMask*/ 1\n            + /*serviceMask*/ 4;\n    }\n\n    /** @type {number} */\n    get protocolMask() {\n        return this._protocolMask;\n    }\n\n    /** @type {number} */\n    get serviceMask() {\n        return this._serviceMask;\n    }\n}\nClass.register(GetAddrMessage);\n","class GetBlocksMessage extends Message {\n    /**\n     * @param {Array.<Hash>} locators\n     * @param {number} maxInvSize\n     * @param {GetBlocksMessage.Direction} direction\n     */\n    constructor(locators, maxInvSize=BaseInventoryMessage.VECTORS_MAX_COUNT, direction=GetBlocksMessage.Direction.FORWARD) {\n        super(Message.Type.GET_BLOCKS);\n        if (!locators || !NumberUtils.isUint16(locators.length)\n            || locators.some(it => !Hash.isHash(it))) throw 'Malformed locators';\n        if (!NumberUtils.isUint16(maxInvSize)) throw 'Malformed maxInvSize';\n        if (!NumberUtils.isUint8(direction)) throw 'Malformed direction';\n        /** @type {Array.<Hash>} */\n        this._locators = locators;\n        this._maxInvSize = maxInvSize;\n        this._direction = direction;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {GetBlocksMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const locators = [];\n        for (let i = 0; i < count; i++) {\n            locators.push(Hash.unserialize(buf));\n        }\n        const maxInvSize = buf.readUint16();\n        const direction = buf.readUint8();\n        return new GetBlocksMessage(locators, maxInvSize, direction);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint16(this._locators.length);\n        for (const locator of this._locators) {\n            locator.serialize(buf);\n        }\n        buf.writeUint16(this._maxInvSize);\n        buf.writeUint8(this._direction);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let size = super.serializedSize\n            + /*count*/ 2\n            + /*direction*/ 1\n            + /*maxInvSize*/ 2;\n        for (const locator of this._locators) {\n            size += locator.serializedSize;\n        }\n        return size;\n    }\n\n    /** @type {Array.<Hash>} */\n    get locators() {\n        return this._locators;\n    }\n\n    /** @type {GetBlocksMessage.Direction} */\n    get direction() {\n        return this._direction;\n    }\n\n    /** @type {number} */\n    get maxInvSize() {\n        return this._maxInvSize;\n    }\n}\n/**\n * @enum {number}\n */\nGetBlocksMessage.Direction = {\n    FORWARD: 0x1,\n    BACKWARD: 0x2\n};\nClass.register(GetBlocksMessage);\n","class HeaderMessage extends Message {\n    /**\n     * @param {BlockHeader} header\n     */\n    constructor(header) {\n        super(Message.Type.HEADER);\n        /** @type {BlockHeader} */\n        this._header = header;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {HeaderMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const header = BlockHeader.unserialize(buf);\n        return new HeaderMessage(header);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._header.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._header.serializedSize;\n    }\n\n    /** @type {BlockHeader} */\n    get header() {\n        return this._header;\n    }\n}\nClass.register(HeaderMessage);\n","class InvVector {\n    /**\n     * @param {Block} block\n     * @returns {InvVector}\n     */\n    static fromBlock(block) {\n        const hash = block.hash();\n        return new InvVector(InvVector.Type.BLOCK, hash);\n    }\n\n    /**\n     * @param {BlockHeader} header\n     * @returns {InvVector}\n     */\n    static fromHeader(header) {\n        const hash = header.hash();\n        return new InvVector(InvVector.Type.BLOCK, hash);\n    }\n\n    /**\n     * @param {Transaction} tx\n     * @returns {InvVector}\n     */\n    static fromTransaction(tx) {\n        const hash = tx.hash();\n        return new InvVector(InvVector.Type.TRANSACTION, hash);\n    }\n\n    /**\n     * @param {InvVector.Type} type\n     * @param {Hash} hash\n     */\n    constructor(type, hash) {\n        // TODO validate type\n        if (!Hash.isHash(hash)) throw 'Malformed hash';\n        /** @type {InvVector.Type} */\n        this._type = type;\n        /** @type {Hash} */\n        this._hash = hash;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {InvVector}\n     */\n    static unserialize(buf) {\n        const type = InvVector.Type.unserialize(buf);\n        const hash = Hash.unserialize(buf);\n        return new InvVector(type, hash);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint32(this._type);\n        this._hash.serialize(buf);\n        return buf;\n    }\n\n    /**\n     * @param {InvVector} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof InvVector\n            && this._type === o.type\n            && this._hash.equals(o.hash);\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return `${this._type}|${this._hash.toBase64()}`;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `InvVector{type=${this._type}, hash=${this._hash}}`;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*invType*/ 4\n            + this._hash.serializedSize;\n    }\n\n    /** @type {InvVector.Type} */\n    get type() {\n        return this._type;\n    }\n\n    /** @type {Hash} */\n    get hash() {\n        return this._hash;\n    }\n}\n/**\n * @enum {number}\n */\nInvVector.Type = {\n    ERROR: 0,\n    TRANSACTION: 1,\n    BLOCK: 2,\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {InvVector.Type}\n     */\n    unserialize: function (buf) {\n        return /** @type {InvVector.Type} */ (buf.readUint32());\n    }\n};\nClass.register(InvVector);\n\nclass BaseInventoryMessage extends Message {\n    /**\n     * @param {Message.Type} type\n     * @param {Array.<InvVector>} vectors\n     */\n    constructor(type, vectors) {\n        super(type);\n        if (!vectors || !NumberUtils.isUint16(vectors.length)\n            || vectors.some(it => !(it instanceof InvVector))\n            || vectors.length > BaseInventoryMessage.VECTORS_MAX_COUNT) throw 'Malformed vectors';\n        /** @type {Array.<InvVector>} */\n        this._vectors = vectors;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint16(this._vectors.length);\n        for (const vector of this._vectors) {\n            vector.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let size = super.serializedSize\n            + /*count*/ 2;\n        for (const vector of this._vectors) {\n            size += vector.serializedSize;\n        }\n        return size;\n    }\n\n    /** @type {Array.<InvVector>} */\n    get vectors() {\n        return this._vectors;\n    }\n}\nBaseInventoryMessage.VECTORS_MAX_COUNT = 1000;\nClass.register(BaseInventoryMessage);\n\nclass InvMessage extends BaseInventoryMessage {\n    /**\n     * @param {Array.<InvVector>} vectors\n     */\n    constructor(vectors) {\n        super(Message.Type.INV, vectors);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {InvMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const vectors = [];\n        for (let i = 0; i < count; ++i) {\n            vectors.push(InvVector.unserialize(buf));\n        }\n        return new InvMessage(vectors);\n    }\n}\nClass.register(InvMessage);\n\nclass GetDataMessage extends BaseInventoryMessage {\n    /**\n     * @param {Array.<InvVector>} vectors\n     */\n    constructor(vectors) {\n        super(Message.Type.GET_DATA, vectors);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetDataMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const vectors = [];\n        for (let i = 0; i < count; ++i) {\n            vectors.push(InvVector.unserialize(buf));\n        }\n        return new GetDataMessage(vectors);\n    }\n}\nClass.register(GetDataMessage);\n\nclass GetHeaderMessage extends BaseInventoryMessage {\n    /**\n     * @param {Array.<InvVector>} vectors\n     */\n    constructor(vectors) {\n        super(Message.Type.GET_HEADER, vectors);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetHeaderMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const vectors = [];\n        for (let i = 0; i < count; ++i) {\n            vectors.push(InvVector.unserialize(buf));\n        }\n        return new GetHeaderMessage(vectors);\n    }\n}\nClass.register(GetHeaderMessage);\n\nclass NotFoundMessage extends BaseInventoryMessage {\n    /**\n     * @param {Array.<InvVector>} vectors\n     */\n    constructor(vectors) {\n        super(Message.Type.NOT_FOUND, vectors);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {NotFoundMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const vectors = [];\n        for (let i = 0; i < count; ++i) {\n            vectors.push(InvVector.unserialize(buf));\n        }\n        return new NotFoundMessage(vectors);\n    }\n}\nClass.register(NotFoundMessage);\n","class MempoolMessage extends Message {\n    constructor() {\n        super(Message.Type.MEMPOOL);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {MempoolMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        return new MempoolMessage();\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize;\n    }\n}\nClass.register(MempoolMessage);\n","class PingMessage extends Message {\n    /**\n     * @param {number} nonce\n     */\n    constructor(nonce) {\n        super(Message.Type.PING);\n        if (!NumberUtils.isUint32(nonce)) throw 'Malformed nonce';\n        /** @type {number} */\n        this._nonce = nonce;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {PingMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const nonce = buf.readUint32();\n        return new PingMessage(nonce);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint32(this._nonce);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*nonce*/ 4;\n    }\n\n    /** @type {number} */\n    get nonce() {\n        return this._nonce;\n    }\n}\nClass.register(PingMessage);\n","class PongMessage extends Message {\n    /**\n     * @param {number} nonce\n     */\n    constructor(nonce) {\n        super(Message.Type.PONG);\n        if (!NumberUtils.isUint32(nonce)) throw 'Malformed nonce';\n\n        this._nonce = nonce;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {PongMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const nonce = buf.readUint32();\n        return new PongMessage(nonce);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint32(this._nonce);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*nonce*/ 4;\n    }\n\n    /** @type {number} */\n    get nonce() {\n        return this._nonce;\n    }\n}\nClass.register(PongMessage);\n","class RejectMessage extends Message {\n    /**\n     * @param {Message.Type} messageType\n     * @param {RejectMessage.Code} code\n     * @param {string} reason\n     * @param {Uint8Array} [extraData]\n     */\n    constructor(messageType, code, reason, extraData=new Uint8Array(0)) {\n        super(Message.Type.REJECT);\n        if (!NumberUtils.isUint64(messageType)) throw new Error('Malformed type');\n        if (!NumberUtils.isUint8(code)) throw new Error('Malformed code');\n        if (StringUtils.isMultibyte(reason) || reason.length > 255) throw new Error('Malformed reason');\n        if (!(extraData instanceof Uint8Array) || !NumberUtils.isUint16(extraData.byteLength)) throw new Error('Malformed extraData');\n\n        /** @type {Message.Type} */\n        this._messageType = messageType;\n        /** @type {RejectMessage.Code} */\n        this._code = code;\n        /** @type {string} */\n        this._reason = reason;\n        /** @type {Uint8Array} */\n        this._extraData = extraData;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {RejectMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const messageType = /** @type {Message.Type} */ buf.readVarUint();\n        const code = /** @type {RejectMessage.Code} */ buf.readUint8();\n        const reason = buf.readVarLengthString();\n        const length = buf.readUint16();\n        const extraData = buf.read(length);\n        return new RejectMessage(messageType, code, reason, extraData);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeVarUint(this._messageType);\n        buf.writeUint8(this._code);\n        buf.writeVarLengthString(this._reason);\n        buf.writeUint16(this._extraData.byteLength);\n        buf.write(this._extraData);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + SerialBuffer.varUintSize(this._messageType)\n            + /*code*/ 1\n            + SerialBuffer.varLengthStringSize(this._reason)\n            + /*extraDataLength*/ 2\n            + this._extraData.byteLength;\n    }\n\n    /** @type {Message.Type} */\n    get messageType() {\n        return this._messageType;\n    }\n\n    /** @type {RejectMessage.Code} */\n    get code() {\n        return this._code;\n    }\n\n    /** @type {string} */\n    get reason() {\n        return this._reason;\n    }\n\n    /** @type {Uint8Array} */\n    get extraData() {\n        return this._extraData;\n    }\n}\n/**\n * @enum {number}\n */\nRejectMessage.Code = {\n    REJECT_MALFORMED: 0x01,\n    REJECT_INVALID: 0x10,\n    REJECT_OBSOLETE: 0x11,\n    REJECT_DOUBLE: 0x12,\n    REJECT_DUST: 0x41,\n    REJECT_INSUFFICIENT_FEE: 0x42\n};\nClass.register(RejectMessage);\n","class SignalMessage extends Message {\n    /**\n     * @param {PeerId} senderId\n     * @param {PeerId} recipientId\n     * @param {number} nonce\n     * @param {number} ttl\n     * @param {SignalMessage.Flags|number} flags\n     * @param {Uint8Array} [payload]\n     * @param {PublicKey} [senderPubKey]\n     * @param {Signature} [signature]\n     */\n    constructor(senderId, recipientId, nonce, ttl, flags = 0, payload = new Uint8Array(0), senderPubKey, signature) {\n        super(Message.Type.SIGNAL);\n        if (!(senderId instanceof PeerId)) throw 'Malformed senderId';\n        if (!(recipientId instanceof PeerId)) throw 'Malformed recipientId';\n        if (!NumberUtils.isUint32(nonce)) throw 'Malformed nonce';\n        if (!NumberUtils.isUint8(ttl)) throw 'Malformed ttl';\n        if (!NumberUtils.isUint8(flags)) throw 'Malformed flags';\n        if (!(payload instanceof Uint8Array) || !NumberUtils.isUint16(payload.byteLength)) throw 'Malformed payload';\n        const hasPayload = payload.byteLength > 0;\n        if (hasPayload && !(signature instanceof Signature)) throw 'Malformed signature';\n        if (hasPayload && !(senderPubKey instanceof PublicKey)) throw 'Malformed public key';\n\n        // Note that the signature is NOT verified here.\n        // Callers must explicitly invoke verifySignature() to check it.\n\n        /** @type {PeerId} */\n        this._senderId = senderId;\n        /** @type {PeerId} */\n        this._recipientId = recipientId;\n        /** @type {number} */\n        this._nonce = nonce;\n        /** @type {number} */\n        this._ttl = ttl;\n        /** @type {SignalMessage.Flags|number} */\n        this._flags = flags;\n        /** @type {Uint8Array} */\n        this._payload = payload;\n        /** @type {PublicKey} */\n        this._senderPubKey = hasPayload ? senderPubKey : undefined;\n        /** @type {Signature} */\n        this._signature = hasPayload ? signature : undefined;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {SignalMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const senderId = PeerId.unserialize(buf);\n        const recipientId = PeerId.unserialize(buf);\n        const nonce = buf.readUint32();\n        const ttl = buf.readUint8();\n        const flags = buf.readUint8();\n        const length = buf.readUint16();\n        const payload = buf.read(length);\n        const senderPubKey = length > 0 ? PublicKey.unserialize(buf) : undefined;\n        const signature = length > 0 ? Signature.unserialize(buf) : undefined;\n        return new SignalMessage(senderId, recipientId, nonce, ttl, flags, payload, senderPubKey, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._senderId.serialize(buf);\n        this._recipientId.serialize(buf);\n        buf.writeUint32(this._nonce);\n        buf.writeUint8(this._ttl);\n        buf.writeUint8(this._flags);\n        buf.writeUint16(this._payload.byteLength);\n        buf.write(this._payload);\n        if (this._payload.byteLength > 0) {\n            this._senderPubKey.serialize(buf);\n            this._signature.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*senderId*/ this._senderId.serializedSize\n            + /*recipientId*/ this._recipientId.serializedSize\n            + /*nonce*/ 4\n            + /*ttl*/ 1\n            + /*flags*/ 1\n            + /*payloadLength*/ 2\n            + this._payload.byteLength\n            + (this._payload.byteLength > 0 ? this._senderPubKey.serializedSize : 0)\n            + (this._payload.byteLength > 0 ? this._signature.serializedSize : 0);\n    }\n\n    /**\n     * @return {boolean}\n     */\n    verifySignature() {\n        if (!this._signature) {\n            return false;\n        }\n\n        return this._signature.verify(this._senderPubKey, this._payload)\n            && this._senderId.equals(this._senderPubKey.toPeerId());\n    }\n\n    /** @type {PeerId} */\n    get senderId() {\n        return this._senderId;\n    }\n\n    /** @type {PeerId} */\n    get recipientId() {\n        return this._recipientId;\n    }\n\n    /** @type {number} */\n    get nonce() {\n        return this._nonce;\n    }\n\n    /** @type {number} */\n    get ttl() {\n        return this._ttl;\n    }\n\n    /** @type {SignalMessage.Flags|number} */\n    get flags() {\n        return this._flags;\n    }\n\n    /** @type {Uint8Array} */\n    get payload() {\n        return this._payload;\n    }\n\n    /** @type {Signature} */\n    get signature() {\n        return this._signature;\n    }\n\n    /** @type {PublicKey} */\n    get senderPubKey() {\n        return this._senderPubKey;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    hasPayload() {\n        return this._payload.byteLength > 0;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isUnroutable() {\n        return (this._flags & SignalMessage.Flag.UNROUTABLE) !== 0;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isTtlExceeded() {\n        return (this._flags & SignalMessage.Flag.TTL_EXCEEDED) !== 0;\n    }\n}\n/**\n * @enum {number}\n */\nSignalMessage.Flag = {\n    UNROUTABLE: 0x1,\n    TTL_EXCEEDED: 0x2\n};\nClass.register(SignalMessage);\n","class SubscribeMessage extends Message {\n    constructor(subscription) {\n        super(Message.Type.SUBSCRIBE);\n        this._subscription = subscription;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {SubscribeMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const subscription = Subscription.unserialize(buf);\n        return new SubscribeMessage(subscription);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._subscription.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._subscription.serializedSize;\n    }\n\n    /** @type {Subscription} */\n    get subscription() {\n        return this._subscription;\n    }\n}\nClass.register(SubscribeMessage);\n","class TxMessage extends Message {\n    /**\n     * @param {Transaction} transaction\n     * @param {?AccountsProof} [accountsProof]\n     */\n    constructor(transaction, accountsProof) {\n        super(Message.Type.TX);\n        /** @type {Transaction} */\n        this._transaction = transaction;\n        /** @type {AccountsProof} */\n        this._accountsProof = accountsProof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {TxMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const transaction = Transaction.unserialize(buf);\n        const hasAccountsProof = buf.readUint8();\n        if (hasAccountsProof === 1) {\n            const accountsProof = AccountsProof.unserialize(buf);\n            return new TxMessage(transaction, accountsProof);\n        }\n        return new TxMessage(transaction);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._transaction.serialize(buf);\n        buf.writeUint8(this._accountsProof ? 1 : 0);\n        if (this._accountsProof) {\n            this._accountsProof.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let size = super.serializedSize\n            + this._transaction.serializedSize\n            + /*hasAccountsProof*/ 1;\n        if (this._accountsProof) {\n            size += this._accountsProof.serializedSize;\n        }\n        return size;\n    }\n\n    /** @type {Transaction} */\n    get transaction() {\n        return this._transaction;\n    }\n\n    /** @type {boolean} */\n    get hasAccountsProof() {\n        return !!this._accountsProof;\n    }\n\n    /** @type {AccountsProof} */\n    get accountsProof() {\n        return this._accountsProof;\n    }\n}\nClass.register(TxMessage);\n","class VersionMessage extends Message {\n    /**\n     * @param {number} version\n     * @param {PeerAddress} peerAddress\n     * @param {Hash} genesisHash\n     * @param {Hash} headHash\n     * @param {Uint8Array} challengeNonce\n     */\n    constructor(version, peerAddress, genesisHash, headHash, challengeNonce) {\n        super(Message.Type.VERSION);\n        if (!NumberUtils.isUint32(version)) throw new Error('Malformed version');\n        if (!(peerAddress instanceof PeerAddress)) throw new Error('Malformed peerAddress');\n        if (!Hash.isHash(genesisHash)) throw new Error('Malformed genesisHash');\n        if (!Hash.isHash(headHash)) throw new Error('Malformed headHash');\n        if (!(challengeNonce instanceof Uint8Array) || challengeNonce.byteLength !== 32) throw new Error('Malformed challenge nonce');\n\n        /** @type {number} */\n        this._version = version;\n        /** @type {PeerAddress} */\n        this._peerAddress = peerAddress;\n        /** @type {Hash} */\n        this._genesisHash = genesisHash;\n        /** @type {Hash} */\n        this._headHash = headHash;\n        /** @type {Uint8Array} */\n        this._challengeNonce = challengeNonce;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {VersionMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const version = buf.readUint32();\n        const peerAddress = PeerAddress.unserialize(buf);\n        const genesisHash = Hash.unserialize(buf);\n        const headHash = Hash.unserialize(buf);\n        const challengeNonce = buf.read(VersionMessage.CHALLENGE_SIZE);\n        return new VersionMessage(version, peerAddress, genesisHash, headHash, challengeNonce);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint32(this._version);\n        this._peerAddress.serialize(buf);\n        this._genesisHash.serialize(buf);\n        this._headHash.serialize(buf);\n        buf.write(this._challengeNonce);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*version*/ 4\n            + this._peerAddress.serializedSize\n            + this._genesisHash.serializedSize\n            + this._headHash.serializedSize\n            + VersionMessage.CHALLENGE_SIZE;\n    }\n\n    /** @type {number} */\n    get version() {\n        return this._version;\n    }\n\n    /** @type {PeerAddress} */\n    get peerAddress() {\n        return this._peerAddress;\n    }\n\n    /** @type {Hash} */\n    get genesisHash() {\n        return this._genesisHash;\n    }\n\n    /** @type {Hash} */\n    get headHash() {\n        return this._headHash;\n    }\n\n    /** @type {Uint8Array} */\n    get challengeNonce() {\n        return this._challengeNonce;\n    }\n}\n\nVersionMessage.CHALLENGE_SIZE = 32;\nClass.register(VersionMessage);\n","class VerAckMessage extends Message {\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Signature} signature\n     */\n    constructor(publicKey, signature) {\n        super(Message.Type.VERACK);\n        /** @type {PublicKey} */\n        this._publicKey = publicKey;\n        /** @type {Signature} */\n        this._signature = signature;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {VerAckMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const publicKey = PublicKey.unserialize(buf);\n        const signature = Signature.unserialize(buf);\n        return new VerAckMessage(publicKey, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this.publicKey.serialize(buf);\n        this.signature.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._publicKey.serializedSize\n            + this._signature.serializedSize;\n    }\n\n    /** @type {PublicKey} */\n    get publicKey() {\n        return this._publicKey;\n    }\n\n    /** @type {Signature} */\n    get signature() {\n        return this._signature;\n    }\n}\nClass.register(VerAckMessage);\n","class AccountsProofMessage extends Message {\n    /**\n     * @param {Hash} blockHash\n     * @param {AccountsProof} [accountsProof]\n     */\n    constructor(blockHash, accountsProof=null) {\n        super(Message.Type.ACCOUNTS_PROOF);\n        if (!(blockHash instanceof Hash)) throw new Error('Malformed blockHash');\n        if (accountsProof && !(accountsProof instanceof AccountsProof)) throw new Error('Malformed proof');\n        /** @type {Hash} */\n        this._blockHash = blockHash;\n        /** @type {AccountsProof} */\n        this._accountsProof = accountsProof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {AccountsProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const hasProof = buf.readUint8();\n        let accountsProof = null;\n        if (hasProof !== 0) {\n            accountsProof = AccountsProof.unserialize(buf);\n        }\n        return new AccountsProofMessage(blockHash, accountsProof);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeUint8(this.hasProof() ? 1 : 0);\n        if (this.hasProof()) {\n            this._accountsProof.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*success bit*/ 1\n            + this._blockHash.serializedSize\n            + (this.hasProof() ? this._accountsProof.serializedSize : 0);\n    }\n\n    /**\n     * @return {boolean}\n     */\n    hasProof() {\n        return !!this._accountsProof;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n\n    /** @type {AccountsProof} */\n    get proof() {\n        return this._accountsProof;\n    }\n}\nClass.register(AccountsProofMessage);\n","class GetAccountsProofMessage extends Message {\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     */\n    constructor(blockHash, addresses) {\n        super(Message.Type.GET_ACCOUNTS_PROOF);\n        if (!blockHash || !(blockHash instanceof Hash)) throw new Error('Malformed block hash');\n        if (!addresses || !NumberUtils.isUint16(addresses.length)\n            || addresses.length < 1\n            || addresses.some(it => !(it instanceof Address))) throw new Error('Malformed addresses');\n        this._blockHash = blockHash;\n        /** @type {Array.<Address>} */\n        this._addresses = addresses;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetAccountsProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const count = buf.readUint16();\n        const addresses = [];\n        for (let i = 0; i < count; i++) {\n            addresses.push(Address.unserialize(buf));\n        }\n        return new GetAccountsProofMessage(blockHash, addresses);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeUint16(this._addresses.length);\n        for (const address of this._addresses) {\n            address.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._blockHash.serializedSize\n            + /*count*/ 2\n            + this._addresses.reduce((sum, address) => sum + address.serializedSize, 0);\n    }\n\n    /** @type {Array.<Address>} */\n    get addresses() {\n        return this._addresses;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n}\nClass.register(GetAccountsProofMessage);\n","class ChainProofMessage extends Message {\n    /**\n     * @param {ChainProof} proof\n     */\n    constructor(proof) {\n        super(Message.Type.CHAIN_PROOF);\n        if (!(proof instanceof ChainProof)) throw 'Malformed chainProof';\n\n        /** @type {ChainProof} */\n        this._proof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {ChainProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const proof = ChainProof.unserialize(buf);\n        return new ChainProofMessage(proof);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._proof.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._proof.serializedSize;\n    }\n\n    /** @type {ChainProof} */\n    get proof() {\n        return this._proof;\n    }\n}\nClass.register(ChainProofMessage);\n","class GetChainProofMessage extends Message {\n    constructor() {\n        super(Message.Type.GET_CHAIN_PROOF);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetChainProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        return new GetChainProofMessage();\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize;\n    }\n}\nClass.register(GetChainProofMessage);\n","class AccountsTreeChunkMessage extends Message {\n    /**\n     * @param {Hash} blockHash\n     * @param {AccountsTreeChunk} [accountsTreeChunk]\n     */\n    constructor(blockHash, accountsTreeChunk=null) {\n        super(Message.Type.ACCOUNTS_TREE_CHUNK);\n        if (!(blockHash instanceof Hash)) throw 'Malformed blockHash';\n        if (accountsTreeChunk && !(accountsTreeChunk instanceof AccountsTreeChunk)) throw 'Malformed chunk';\n        /** @type {Hash} */\n        this._blockHash = blockHash;\n        /** @type {AccountsTreeChunk} */\n        this._accountsTreeChunk = accountsTreeChunk;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {AccountsTreeChunkMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const hasChunk = buf.readUint8();\n        let accountsTreeChunk = null;\n        if (hasChunk !== 0) {\n            accountsTreeChunk = AccountsTreeChunk.unserialize(buf);\n        }\n        return new AccountsTreeChunkMessage(blockHash, accountsTreeChunk);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeUint8(this.hasChunk() ? 1 : 0);\n        if (this.hasChunk()) {\n            this._accountsTreeChunk.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*success bit*/ 1\n            + this._blockHash.serializedSize\n            + (this.hasChunk() ? this._accountsTreeChunk.serializedSize : 0);\n    }\n\n    /**\n     * @return {boolean}\n     */\n    hasChunk() {\n        return !!this._accountsTreeChunk;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n\n    /** @type {AccountsTreeChunk} */\n    get chunk() {\n        return this._accountsTreeChunk;\n    }\n}\nClass.register(AccountsTreeChunkMessage);\n","class GetAccountsTreeChunkMessage extends Message {\n    /**\n     * @param {Hash} blockHash\n     * @param {string} startPrefix\n     */\n    constructor(blockHash, startPrefix) {\n        super(Message.Type.GET_ACCOUNTS_TREE_CHUNK);\n        if (!blockHash || !(blockHash instanceof Hash)) throw 'Malformed block hash';\n        if (StringUtils.isMultibyte(startPrefix)\n            || !NumberUtils.isUint8(startPrefix.length)) throw 'Malformed start prefix';\n        /** @type {Hash} */\n        this._blockHash = blockHash;\n        this._startPrefix = startPrefix;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetAccountsTreeChunkMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const startPrefix = buf.readVarLengthString();\n        return new GetAccountsTreeChunkMessage(blockHash, startPrefix);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeVarLengthString(this._startPrefix);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._blockHash.serializedSize\n            + SerialBuffer.varLengthStringSize(this._startPrefix);\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n\n    /** @type {string} */\n    get startPrefix() {\n        return this._startPrefix;\n    }\n}\nClass.register(GetAccountsTreeChunkMessage);\n","class TransactionsProofMessage extends Message {\n    /**\n     * @param {Hash} blockHash\n     * @param {TransactionsProof} [proof]\n     */\n    constructor(blockHash, proof=null) {\n        super(Message.Type.TRANSACTIONS_PROOF);\n        if (!(blockHash instanceof Hash)) throw new Error('Malformed blockHash');\n        if (proof && !(proof instanceof TransactionsProof)) throw new Error('Malformed proof');\n        /** @type {Hash} */\n        this._blockHash = blockHash;\n        /** @type {TransactionsProof} */\n        this._proof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {TransactionsProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const hasProof = buf.readUint8();\n        let proof = null;\n        if (hasProof !== 0) {\n            proof = TransactionsProof.unserialize(buf);\n        }\n        return new TransactionsProofMessage(blockHash, proof);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeUint8(this.hasProof() ? 1 : 0);\n        if (this.hasProof()) {\n            this._proof.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*success bit*/ 1\n            + this._blockHash.serializedSize\n            + (this.hasProof() ? this._proof.serializedSize : 0);\n    }\n\n    /**\n     * @return {boolean}\n     */\n    hasProof() {\n        return !!this._proof;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n\n    /** @type {TransactionsProof} */\n    get proof() {\n        return this._proof;\n    }\n}\nClass.register(TransactionsProofMessage);\n","class GetTransactionsProofMessage extends Message {\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     */\n    constructor(blockHash, addresses) {\n        super(Message.Type.GET_TRANSACTIONS_PROOF);\n        if (!blockHash || !(blockHash instanceof Hash)) throw new Error('Malformed block hash');\n        if (!addresses || !NumberUtils.isUint16(addresses.length)\n            || addresses.some(it => !(it instanceof Address))) throw new Error('Malformed addresses');\n        this._blockHash = blockHash;\n        /** @type {Array.<Address>} */\n        this._addresses = addresses;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetTransactionsProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const count = buf.readUint16();\n        const addresses = [];\n        for (let i = 0; i < count; i++) {\n            addresses.push(Address.unserialize(buf));\n        }\n        return new GetTransactionsProofMessage(blockHash, addresses);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeUint16(this._addresses.length);\n        for (const address of this._addresses) {\n            address.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._blockHash.serializedSize\n            + /*count*/ 2\n            + this._addresses.reduce((sum, address) => sum + address.serializedSize, 0);\n    }\n\n    /** @type {Array.<Address>} */\n    get addresses() {\n        return this._addresses;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n}\nClass.register(GetTransactionsProofMessage);\n","class GetTransactionReceiptsMessage extends Message {\n    /**\n     * @param {Address} address\n     */\n    constructor(address) {\n        super(Message.Type.GET_TRANSACTION_RECEIPTS);\n        if (!(address instanceof Address)) throw new Error('Malformed address');\n        /** @type {Address} */\n        this._address = address;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {GetTransactionReceiptsMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const address = Address.unserialize(buf);\n        return new GetTransactionReceiptsMessage(address);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._address.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._address.serializedSize;\n    }\n\n    /** @type {Address} */\n    get address() {\n        return this._address;\n    }\n}\nClass.register(GetTransactionReceiptsMessage);\n","class TransactionReceiptsMessage extends Message {\n    /**\n     * @param {Array.<TransactionReceipt>} transactionReceipts\n     */\n    constructor(transactionReceipts) {\n        super(Message.Type.TRANSACTION_RECEIPTS);\n        if (!Array.isArray(transactionReceipts) || !NumberUtils.isUint16(transactionReceipts.length)\n            || transactionReceipts.some(it => !(it instanceof TransactionReceipt))\n            || transactionReceipts.length > TransactionReceiptsMessage.RECEIPTS_MAX_COUNT) throw new Error('Malformed transactionReceipts');\n        /** @type {Array.<TransactionReceipt>} */\n        this._transactionReceipts = transactionReceipts;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {TransactionReceiptsMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const transactionReceipts = [];\n        for (let i = 0; i < count; ++i) {\n            transactionReceipts.push(TransactionReceipt.unserialize(buf));\n        }\n        return new TransactionReceiptsMessage(transactionReceipts);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint16(this._transactionReceipts.length);\n        for (const receipt of this._transactionReceipts) {\n            receipt.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*count*/ 2\n            + this._transactionReceipts.reduce((sum, receipt) => sum + receipt.serializedSize, 0);\n    }\n\n    /** @type {Array.<TransactionReceipt>} */\n    get transactionReceipts() {\n        return this._transactionReceipts;\n    }\n}\nClass.register(TransactionReceiptsMessage);\nTransactionReceiptsMessage.RECEIPTS_MAX_COUNT = 500;\n","class GetBlockProofMessage extends Message {\n    /**\n     * @param {Hash} blockHashToProve\n     * @param {Hash} knownBlockHash\n     */\n    constructor(blockHashToProve, knownBlockHash) {\n        super(Message.Type.GET_BLOCK_PROOF);\n        if (!(blockHashToProve instanceof Hash)) throw new Error('Malformed blockHashToProve');\n        if (!(knownBlockHash instanceof Hash)) throw new Error('Malformed knownBlockHash');\n        /** @type {Hash} */\n        this._blockHashToProve = blockHashToProve;\n        /** @type {Hash} */\n        this._knownBlockHash = knownBlockHash;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {GetBlockProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHashToProve = Hash.unserialize(buf);\n        const knownBlockHash = Hash.unserialize(buf);\n        return new GetBlockProofMessage(blockHashToProve, knownBlockHash);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHashToProve.serialize(buf);\n        this._knownBlockHash.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._blockHashToProve.serializedSize\n            + this._knownBlockHash.serializedSize;\n    }\n\n    /** @type {Hash} */\n    get blockHashToProve() {\n        return this._blockHashToProve;\n    }\n\n    /** @type {Hash} */\n    get knownBlockHash() {\n        return this._knownBlockHash;\n    }\n}\nClass.register(GetBlockProofMessage);\n","class BlockProofMessage extends Message {\n    /**\n     * @param {BlockChain} [proof]\n     */\n    constructor(proof) {\n        super(Message.Type.BLOCK_PROOF);\n        if (proof && !(proof instanceof BlockChain)) throw new Error('Malformed proof');\n        /** @type {BlockChain} */\n        this._proof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {BlockProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const hasProof = buf.readUint8() === 1;\n        if (hasProof) {\n            const proof = BlockChain.unserialize(buf);\n            return new BlockProofMessage(proof);\n        }\n        return new BlockProofMessage();\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        if (this._proof) {\n            buf.writeUint8(1);\n            this._proof.serialize(buf);\n        } else {\n            buf.writeUint8(0);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*found*/ 1\n            + (this._proof ? this._proof.serializedSize : 0);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    hasProof() {\n        return !!this._proof;\n    }\n\n    /** @type {BlockChain} */\n    get proof() {\n        return this._proof;\n    }\n}\nClass.register(BlockProofMessage);\n","class GetHeadMessage extends Message {\n    constructor() {\n        super(Message.Type.GET_HEAD);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetHeadMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        return new GetHeadMessage();\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n}\nClass.register(GetHeadMessage);\n","class HeadMessage extends Message {\n    /**\n     * @param {BlockHeader} header\n     */\n    constructor(header) {\n        super(Message.Type.HEAD);\n        /** @type {BlockHeader} */\n        this._header = header;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {HeadMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const header = BlockHeader.unserialize(buf);\n        return new HeadMessage(header);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._header.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._header.serializedSize;\n    }\n\n    /** @type {BlockHeader} */\n    get header() {\n        return this._header;\n    }\n}\nClass.register(HeadMessage);\n","class MessageFactory {\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {Message.Type}\n     */\n    static peekType(buf) {\n        return Message.peekType(buf);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {Message}\n     */\n    static parse(buf) {\n        const type = Message.peekType(buf);\n        const clazz = MessageFactory.CLASSES[type];\n        if (!clazz || !clazz.unserialize) throw new Error(`Invalid message type: ${type}`);\n        return clazz.unserialize(buf);\n    }\n}\n/**\n * @dict \n * @type {object}\n */\nMessageFactory.CLASSES = {};\nMessageFactory.CLASSES[Message.Type.VERSION] = VersionMessage;\nMessageFactory.CLASSES[Message.Type.INV] = InvMessage;\nMessageFactory.CLASSES[Message.Type.GET_DATA] = GetDataMessage;\nMessageFactory.CLASSES[Message.Type.GET_HEADER] = GetHeaderMessage;\nMessageFactory.CLASSES[Message.Type.NOT_FOUND] = NotFoundMessage;\nMessageFactory.CLASSES[Message.Type.BLOCK] = BlockMessage;\nMessageFactory.CLASSES[Message.Type.HEADER] = HeaderMessage;\nMessageFactory.CLASSES[Message.Type.TX] = TxMessage;\nMessageFactory.CLASSES[Message.Type.GET_BLOCKS] = GetBlocksMessage;\nMessageFactory.CLASSES[Message.Type.MEMPOOL] = MempoolMessage;\nMessageFactory.CLASSES[Message.Type.REJECT] = RejectMessage;\nMessageFactory.CLASSES[Message.Type.SUBSCRIBE] = SubscribeMessage;\nMessageFactory.CLASSES[Message.Type.ADDR] = AddrMessage;\nMessageFactory.CLASSES[Message.Type.GET_ADDR] = GetAddrMessage;\nMessageFactory.CLASSES[Message.Type.PING] = PingMessage;\nMessageFactory.CLASSES[Message.Type.PONG] = PongMessage;\nMessageFactory.CLASSES[Message.Type.SIGNAL] = SignalMessage;\nMessageFactory.CLASSES[Message.Type.GET_CHAIN_PROOF] = GetChainProofMessage;\nMessageFactory.CLASSES[Message.Type.CHAIN_PROOF] = ChainProofMessage;\nMessageFactory.CLASSES[Message.Type.GET_ACCOUNTS_PROOF] = GetAccountsProofMessage;\nMessageFactory.CLASSES[Message.Type.ACCOUNTS_PROOF] = AccountsProofMessage;\nMessageFactory.CLASSES[Message.Type.GET_ACCOUNTS_TREE_CHUNK] = GetAccountsTreeChunkMessage;\nMessageFactory.CLASSES[Message.Type.ACCOUNTS_TREE_CHUNK] = AccountsTreeChunkMessage;\nMessageFactory.CLASSES[Message.Type.GET_TRANSACTIONS_PROOF] = GetTransactionsProofMessage;\nMessageFactory.CLASSES[Message.Type.TRANSACTIONS_PROOF] = TransactionsProofMessage;\nMessageFactory.CLASSES[Message.Type.GET_TRANSACTION_RECEIPTS] = GetTransactionReceiptsMessage;\nMessageFactory.CLASSES[Message.Type.TRANSACTION_RECEIPTS] = TransactionReceiptsMessage;\nMessageFactory.CLASSES[Message.Type.GET_BLOCK_PROOF] = GetBlockProofMessage;\nMessageFactory.CLASSES[Message.Type.BLOCK_PROOF] = BlockProofMessage;\nMessageFactory.CLASSES[Message.Type.GET_HEAD] = GetHeadMessage;\nMessageFactory.CLASSES[Message.Type.HEAD] = HeadMessage;\nMessageFactory.CLASSES[Message.Type.VERACK] = VerAckMessage;\nClass.register(MessageFactory);\n","class WebRtcConnector extends Observable {\n    /**\n     * @constructor\n     * @param {NetworkConfig} networkConfig\n     */\n    constructor(networkConfig) {\n        super();\n\n        /** @type {NetworkConfig} */\n        this._networkConfig = networkConfig;\n\n        /** @type {HashMap.<PeerId,PeerConnector>} */\n        this._connectors = new HashMap();\n\n        /** @type {Timers} */\n        this._timers = new Timers();\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @param {PeerChannel} signalChannel\n     * @returns {boolean}\n     */\n    connect(peerAddress, signalChannel) {\n        if (peerAddress.protocol !== Protocol.RTC) throw 'Malformed peerAddress';\n\n        const peerId = peerAddress.peerId;\n        if (this._connectors.contains(peerId)) {\n            return false;\n        }\n\n        const connector = new OutboundPeerConnector(this._networkConfig, peerAddress, signalChannel);\n        connector.on('connection', conn => this._onConnection(conn, peerId));\n        this._connectors.put(peerId, connector);\n\n        this._timers.setTimeout(`connect_${peerId}`, () => {\n            this._connectors.remove(peerId);\n            this._timers.clearTimeout(`connect_${peerId}`);\n\n            connector.rtcConnection.close();\n\n            this.fire('error', peerAddress, 'timeout');\n        }, WebRtcConnector.CONNECT_TIMEOUT);\n\n        return true;\n    }\n\n    isValidSignal(msg) {\n        return this._connectors.contains(msg.senderId) && this._connectors.get(msg.senderId).nonce === msg.nonce;\n    }\n\n    onSignal(channel, msg) {\n        // Check if we received an unroutable/ttl exceeded response from one of the signaling peers.\n        if (msg.isUnroutable() || msg.isTtlExceeded()) {\n            // Clear the timeout early if we initiated the connection.\n            if (this.isValidSignal(msg) && this._connectors.get(msg.senderId) instanceof OutboundPeerConnector) {\n                const connector = this._connectors.get(msg.senderId);\n                const peerAddress = connector.peerAddress;\n\n                this._connectors.remove(msg.senderId);\n                this._timers.clearTimeout(`connect_${msg.senderId}`);\n\n                connector.rtcConnection.close();\n\n                // XXX Reason needs to be adapted when more flags are added.\n                const reason = msg.isUnroutable() ? 'unroutable' : 'ttl exceeded';\n                this.fire('error', peerAddress, reason);\n            }\n\n            return;\n        }\n\n        let payload;\n        try {\n            payload = JSON.parse(BufferUtils.toAscii(msg.payload));\n        } catch (e) {\n            Log.e(WebRtcConnector, `Failed to parse signal payload from ${msg.senderId}`);\n            return;\n        }\n\n        if (!payload) {\n            Log.d(WebRtcConnector, `Discarding signal from ${msg.senderId} - empty payload`);\n            return;\n        }\n\n        if (payload.type === 'offer') {\n            // Check if we have received an offer on an ongoing connection.\n            // This can happen if two peers initiate connections to one another\n            // simultaneously. Resolve this by having the peer with the higher\n            // peerId discard the offer while the one with the lower peerId\n            // accepts it.\n            /** @type {PeerConnector} */\n            let connector = this._connectors.get(msg.senderId);\n            if (connector) {\n                if (msg.recipientId.compare(msg.senderId) > 0) {\n                    // Discard the offer.\n                    Log.d(WebRtcConnector, `Simultaneous connection, discarding offer from ${msg.senderId} (<${msg.recipientId})`);\n                    return;\n                } else if (connector instanceof InboundPeerConnector) {\n                    // We have already seen an offer from this peer. Forward it to the existing connector.\n                    Log.w(WebRtcConnector, `Duplicate offer received from ${msg.senderId}`);\n                    connector.onSignal(payload);\n                    return;\n                } else {\n                    // We are going to accept the offer. Clear the connect timeout\n                    // from our previous outbound connection attempt to this peer.\n                    Log.d(WebRtcConnector, `Simultaneous connection, accepting offer from ${msg.senderId} (>${msg.recipientId})`);\n                    this._timers.clearTimeout(`connect_${msg.senderId}`);\n\n                    // Abort the outbound connection attempt.\n                    connector.rtcConnection.close();\n\n                    // Let listeners know that the connection attempt was aborted.\n                    this.fire('error', connector.peerAddress, 'simultaneous inbound connection');\n                }\n            }\n\n            // Accept the offer.\n            connector = new InboundPeerConnector(this._networkConfig, channel, msg.senderId, payload);\n            connector.on('connection', conn => this._onConnection(conn, msg.senderId));\n            this._connectors.put(msg.senderId, connector);\n\n            this._timers.setTimeout(`connect_${msg.senderId}`, () => {\n                this._timers.clearTimeout(`connect_${msg.senderId}`);\n                this._connectors.remove(msg.senderId);\n            }, WebRtcConnector.CONNECT_TIMEOUT);\n        }\n\n        // If we are already establishing a connection with the sender of this\n        // signal, forward it to the corresponding connector.\n        else if (this._connectors.contains(msg.senderId)) {\n            this._connectors.get(msg.senderId).onSignal(payload);\n        }\n\n        // If none of the above conditions is met, the signal is invalid and we discard it.\n    }\n\n    _onConnection(conn, peerId) {\n        // Clear the connect timeout.\n        this._timers.clearTimeout(`connect_${peerId}`);\n\n        // Clean up when this connection closes.\n        conn.on('close', () => this._onClose(peerId));\n\n        // Tell listeners about the new connection.\n        this.fire('connection', conn);\n    }\n\n    _onClose(peerId) {\n        this._connectors.remove(peerId);\n        this._timers.clearTimeout(`connect_${peerId}`);\n    }\n}\nWebRtcConnector.CONNECT_TIMEOUT = 8000; // ms\nClass.register(WebRtcConnector);\n\nclass PeerConnector extends Observable {\n    /**\n     * @param {NetworkConfig} networkConfig\n     * @param {PeerChannel} signalChannel\n     * @param {PeerId} peerId\n     * @param {PeerAddress} peerAddress\n     */\n    constructor(networkConfig, signalChannel, peerId, peerAddress) {\n        super();\n        /** @type {NetworkConfig} */\n        this._networkConfig = networkConfig;\n        /** @type {PeerChannel} */\n        this._signalChannel = signalChannel;\n        /** @type {PeerId} */\n        this._peerId = peerId;\n        /** @type {PeerAddress} */\n        this._peerAddress = peerAddress; // null for inbound connections\n\n        /** @type {number} */\n        this._nonce = NumberUtils.randomUint32();\n\n        /** @type {RTCPeerConnection} */\n        this._rtcConnection = WebRtcFactory.newPeerConnection(this._networkConfig.rtcConfig);\n        this._rtcConnection.onicecandidate = e => this._onIceCandidate(e);\n\n        this._lastIceCandidate = null;\n        this._iceCandidateQueue = [];\n    }\n\n    onSignal(signal) {\n        if (signal.sdp) {\n            this._rtcConnection.setRemoteDescription(WebRtcFactory.newSessionDescription(signal))\n                .then(() => {\n                    if (signal.type === 'offer') {\n                        this._rtcConnection.createAnswer()\n                            .then(description => this._onDescription(description))\n                            .catch(Log.e.tag(PeerConnector));\n                    }\n\n                    this._handleCandidateQueue().catch(Log.w.tag(PeerConnector));\n                })\n                .catch(Log.e.tag(PeerConnector));\n        } else if (signal.candidate) {\n            this._addIceCandidate(signal).catch(Log.w.tag(PeerConnector));\n        }\n    }\n\n    /**\n     * @param {*} signal\n     * @returns {Promise}\n     * @private\n     */\n    _addIceCandidate(signal) {\n        this._lastIceCandidate = WebRtcFactory.newIceCandidate(signal);\n\n        // Do not try to add ICE candidates before the remote description is set.\n        if (!this._rtcConnection.remoteDescription || !this._rtcConnection.remoteDescription.type) {\n            this._iceCandidateQueue.push(signal);\n            return Promise.resolve();\n        }\n\n        return this._rtcConnection.addIceCandidate(this._lastIceCandidate)\n            .catch(Log.e.tag(PeerConnector));\n    }\n\n    async _handleCandidateQueue() {\n        // Handle ICE candidates if they already arrived.\n        for (const candidate of this._iceCandidateQueue) {\n            await this._addIceCandidate(candidate);\n        }\n        this._iceCandidateQueue = [];\n    }\n\n    _signal(signal) {\n        const payload = BufferUtils.fromAscii(JSON.stringify(signal));\n        const keyPair = this._networkConfig.keyPair;\n        const peerId = this._networkConfig.peerId;\n        this._signalChannel.signal(\n            peerId,\n            this._peerId,\n            this._nonce,\n            Network.SIGNAL_TTL_INITIAL,\n            0, /*flags*/\n            payload,\n            keyPair.publicKey,\n            Signature.create(keyPair.privateKey, keyPair.publicKey, payload)\n        );\n    }\n\n    _onIceCandidate(event) {\n        if (event.candidate !== null) {\n            this._signal(event.candidate);\n        }\n    }\n\n    _onDescription(description) {\n        this._rtcConnection.setLocalDescription(description)\n            .then(() => this._signal(this._rtcConnection.localDescription))\n            .catch(Log.e.tag(PeerConnector));\n    }\n\n    _onDataChannel(event) {\n        const channel = new WebRtcDataChannel(event.channel || event.target);\n\n        // There is no API to get the remote IP address. As a crude heuristic, we parse the IP address\n        // from the last ICE candidate seen before the connection was established.\n        // TODO Can we improve this?\n        let netAddress = null;\n        if (this._lastIceCandidate) {\n            try {\n                netAddress = WebRtcUtils.candidateToNetAddress(this._lastIceCandidate);\n            } catch (e) {\n                Log.w(PeerConnector, `Failed to parse IP from ICE candidate: ${this._lastIceCandidate}`);\n            }\n        } else {\n            // XXX Why does this happen?\n            Log.w(PeerConnector, 'No ICE candidate seen for inbound connection');\n        }\n\n        const conn = new NetworkConnection(channel, Protocol.RTC, netAddress, this._peerAddress);\n        this.fire('connection', conn);\n    }\n\n    get nonce() {\n        return this._nonce;\n    }\n\n    get peerAddress() {\n        return this._peerAddress;\n    }\n\n    get rtcConnection() {\n        return this._rtcConnection;\n    }\n}\nClass.register(PeerConnector);\n\nclass OutboundPeerConnector extends PeerConnector {\n    constructor(webRtcConfig, peerAddress, signalChannel) {\n        super(webRtcConfig, signalChannel, peerAddress.peerId, peerAddress);\n        this._peerAddress = peerAddress;\n\n        // Create offer.\n        const channel = this._rtcConnection.createDataChannel('data-channel');\n        channel.binaryType = 'arraybuffer';\n        channel.onopen = e => this._onDataChannel(e);\n        this._rtcConnection.createOffer()\n            .then(description => this._onDescription(description))\n            .catch(Log.e.tag(OutboundPeerConnector));\n    }\n}\nClass.register(OutboundPeerConnector);\n\nclass InboundPeerConnector extends PeerConnector {\n    constructor(webRtcConfig, signalChannel, peerId, offer) {\n        super(webRtcConfig, signalChannel, peerId, null);\n        this._rtcConnection.ondatachannel = event => {\n            event.channel.onopen = e => this._onDataChannel(e);\n        };\n        this.onSignal(offer);\n    }\n}\nClass.register(InboundPeerConnector);\n","class WebRtcDataChannel extends DataChannel {\n    /**\n     * @param {RTCDataChannel} nativeChannel\n     */\n    constructor(nativeChannel) {\n        super();\n        // We expect WebRtc data channels to be ordered.\n        Assert.that(nativeChannel.ordered, 'WebRtc data channel not ordered');\n        /** @type {RTCDataChannel} */\n        this._channel = nativeChannel;\n\n        this._channel.onmessage = msg => this._onMessage(msg.data || msg);\n        this._channel.onclose = () => this._onClose();\n        this._channel.onerror = e => this.fire('error', e, this);\n    }\n\n    /**\n     * @param {ArrayBuffer} msg\n     * @protected\n     * @override\n     */\n    _onMessage(msg) {\n        // FIXME It seems that Firefox still sometimes receives blobs instead of ArrayBuffers on RTC connections.\n        // FIXME FileReader is async and may RE-ORDER MESSAGES!\n        if (msg instanceof Blob) {\n            const reader = new FileReader();\n            reader.onloadend = () => super._onMessage(reader.result);\n            reader.readAsArrayBuffer(msg);\n        } else {\n            super._onMessage(msg);\n        }\n    }\n    /**\n     * @override\n     */\n    sendChunk(msg) {\n        this._channel.send(msg);\n    }\n\n    /**\n     * @override\n     */\n    close() {\n        this._channel.close();\n    }\n\n    /**\n     * @override\n     */\n    get readyState() {\n        return DataChannel.ReadyState.fromString(this._channel.readyState);\n    }\n}\n\nClass.register(WebRtcDataChannel);\n","class WebRtcUtils {\n    static candidateToNetAddress(candidate) {\n        // TODO XXX Ad-hoc parsing of candidates - Improve!\n        const parts = candidate.candidate.split(' ');\n        if (parts.length < 6) {\n            return null;\n        }\n        // XXX The IP obtained from the ice candidate is not really reliable.\n        // But for the time being, we treat it as such as it only affects browser clients,\n        // which cannot obtain a more reliable form of net addresses.\n        return NetAddress.fromIP(parts[4], true);\n    }\n}\nClass.register(WebRtcUtils);\n","class WebSocketConnector extends Observable {\n    /**\n     * @constructor\n     * @param {NetworkConfig} networkConfig\n     * @listens WebSocketServer#connection\n     */\n    constructor(networkConfig) {\n        super();\n        this._networkConfig = networkConfig;\n\n        if (networkConfig.peerAddress.protocol === Protocol.WS) {\n            this._wss = WebSocketFactory.newWebSocketServer(networkConfig);\n            this._wss.on('connection', ws => this._onConnection(ws));\n\n            Log.d(WebSocketConnector, `WebSocketConnector listening on port ${networkConfig.peerAddress.port}`);\n        }\n\n        /** @type {HashMap.<PeerAddress, WebSocket>} */\n        this._sockets = new HashMap();\n\n        /** @type {Timers} */\n        this._timers = new Timers();\n    }\n\n    /**\n     * @fires WebSocketConnector#connection\n     * @fires WebSocketConnector#error\n     * @param {PeerAddress} peerAddress\n     * @returns {boolean}\n     */\n    connect(peerAddress) {\n        if (peerAddress.protocol !== Protocol.WS) throw 'Malformed peerAddress';\n\n        const timeoutKey = `connect_${peerAddress}`;\n        if (this._timers.timeoutExists(timeoutKey)) {\n            Log.w(WebSocketConnector, `Already connecting to ${peerAddress}`);\n            return false;\n        }\n\n        const ws = WebSocketFactory.newWebSocket(`wss://${peerAddress.host}:${peerAddress.port}`, {\n            handshakeTimeout: WebSocketConnector.CONNECT_TIMEOUT\n        }, this._networkConfig);\n        ws.binaryType = 'arraybuffer';\n        ws.onopen = () => {\n            this._timers.clearTimeout(timeoutKey);\n            this._sockets.remove(peerAddress);\n\n            // Don't fire error events after the connection has been established.\n            ws.onerror = () => {};\n\n            // There is no way to determine the remote IP in the browser ... thanks for nothing, WebSocket API.\n            const netAddress = (ws._socket && ws._socket.remoteAddress) ? NetAddress.fromIP(ws._socket.remoteAddress, true) : null;\n            const conn = new NetworkConnection(new WebSocketDataChannel(ws), Protocol.WS, netAddress, peerAddress);\n            this.fire('connection', conn);\n        };\n        ws.onerror = e => {\n            this._timers.clearTimeout(timeoutKey);\n            this._sockets.remove(peerAddress);\n\n            /**\n             * Tell listeners that an error has ocurred.\n             * @event WebSocketConnector#error\n             */\n            this.fire('error', peerAddress, e);\n        };\n\n        this._sockets.put(peerAddress, ws);\n\n        this._timers.setTimeout(timeoutKey, () => {\n            this._timers.clearTimeout(timeoutKey);\n            this._sockets.remove(peerAddress);\n\n            // We don't want to fire the error event again if the websocket\n            // connect fails at a later time.\n            ws.onerror = () => {};\n\n            // If the connection succeeds after we have fired the error event,\n            // close it.\n            ws.onopen = () => {\n                Log.d(WebSocketConnector, () => `Connection to ${peerAddress} succeeded after timeout - closing it`);\n                ws.close();\n            };\n\n            /**\n             * Tell listeners that a timeout error has occurred.\n             * @event WebSocketConnector#error\n             */\n            this.fire('error', peerAddress, 'timeout');\n        }, WebSocketConnector.CONNECT_TIMEOUT);\n\n        return true;\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @fires WebSocketConnector#error\n     * @returns {void}\n     */\n    abort(peerAddress) {\n        const ws = this._sockets.get(peerAddress);\n        if (!ws) {\n            return;\n        }\n\n        this._timers.clearTimeout(`connect_${peerAddress}`);\n        this._sockets.remove(peerAddress);\n\n        ws.onerror = () => {};\n        ws.onopen = () => {\n            Log.d(WebSocketConnector, () => `Connection to ${peerAddress} succeeded after aborting - closing it`);\n            ws.close();\n        };\n        ws.close();\n\n        /**\n         * Tell listeners that the connection attempt has been aborted.\n         * @event WebSocketConnector#error\n         */\n        this.fire('error', peerAddress, 'aborted');\n    }\n\n    /**\n     * @fires WebSocketConnector#connection\n     * @param {WebSocket} ws\n     * @returns {void}\n     */\n    _onConnection(ws) {\n        const netAddress = NetAddress.fromIP(ws._socket.remoteAddress, true);\n        const conn = new NetworkConnection(new WebSocketDataChannel(ws), Protocol.WS, netAddress, /*peerAddress*/ null);\n\n        /**\n        * Tell listeners that an initial connection to a peer has been established.\n        * @event WebSocketConnector#connection\n        */\n        this.fire('connection', conn);\n    }\n}\nWebSocketConnector.CONNECT_TIMEOUT = 1000 * 5; // 5 seconds\nClass.register(WebSocketConnector);\n","class WebSocketDataChannel extends DataChannel {\n    /**\n     * @param {WebSocket} ws\n     */\n    constructor(ws) {\n        super();\n        /** @type {WebSocket} */\n        this._ws = ws;\n        this._ws.onmessage = msg => this._onMessage(msg.data || msg);\n        this._ws.onclose = () => this._onClose();\n        this._ws.onerror = e => this.fire('error', e);\n    }\n\n    /**\n     * @override\n     */\n    close() {\n        this._ws.close();\n    }\n\n    /**\n     * @override\n     * @param {Uint8Array} msg\n     */\n    sendChunk(msg) {\n        this._ws.send(msg);\n    }\n\n    /**\n     * @override\n     * @type {DataChannel.ReadyState}\n     */\n    get readyState() {\n        return /** @type {DataChannel.ReadyState} */ this._ws.readyState;\n    }\n}\n\nClass.register(WebSocketDataChannel);\n","class NetAddress {\n    /**\n     * @param {string} ip\n     * @param {boolean} reliable\n     * @return {NetAddress}\n     */\n    static fromIP(ip, reliable = false) {\n        const saneIp = NetUtils.ipToBytes(NetUtils.sanitizeIP(ip));\n        const type = NetUtils.isIPv4Address(saneIp) ? NetAddress.Type.IPv4 : NetAddress.Type.IPv6;\n        return new NetAddress(type, saneIp, reliable);\n    }\n\n    /**\n     * @param {NetAddress.Type} type\n     * @param {Uint8Array} ipArray\n     * @param {boolean} reliable\n     */\n    constructor(type, ipArray = null, reliable = false) {\n        switch (type) {\n            case NetAddress.Type.IPv4:\n                if (!(ipArray instanceof Uint8Array) || ipArray.length !== NetUtils.IPv4_LENGTH) throw new Error('Malformed ip');\n                break;\n            case NetAddress.Type.IPv6:\n                if (!(ipArray instanceof Uint8Array) || ipArray.length !== NetUtils.IPv6_LENGTH) throw new Error('Malformed ip');\n                break;\n            case NetAddress.Type.UNKNOWN:\n            case NetAddress.Type.UNSPECIFIED:\n                ipArray = null;\n                break;\n            default:\n                throw new Error('Malformed type');\n        }\n\n        /** @type {NetAddress.Type} */\n        this._type = type;\n        /** @type {Uint8Array} */\n        this._ip = ipArray;\n        /** @type {boolean} */\n        this._reliable = reliable;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {NetAddress}\n     */\n    static unserialize(buf) {\n        const type = /** @type {NetAddress.Type} */ buf.readUint8();\n\n        let ipArray = null;\n        switch (type) {\n            case NetAddress.Type.IPv4:\n                ipArray = buf.read(NetUtils.IPv4_LENGTH);\n                break;\n            case NetAddress.Type.IPv6:\n                ipArray = buf.read(NetUtils.IPv6_LENGTH);\n                break;\n        }\n\n        return new NetAddress(type, ipArray);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._type);\n        if (this._ip) {\n            buf.write(this._ip);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*type*/ 1\n            + (this._ip ? this._ip.length : 0);\n    }\n\n    /**\n     * @param {NetAddress} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof NetAddress\n            && this._type === o._type\n            && BufferUtils.equals(this._ip, o.ip);\n    }\n\n    hashCode() {\n        return this.toString();\n    }\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        if (this._type === NetAddress.Type.UNKNOWN) return '<unknown>';\n        if (this._type === NetAddress.Type.UNSPECIFIED) return '';\n        return NetUtils.bytesToIp(this._ip);\n    }\n\n    /** @type {Uint8Array} */\n    get ip() {\n        return this._ip;\n    }\n\n    /** @type {NetAddress.Type} */\n    get type() {\n        return this._type;\n    }\n\n    /** @type {boolean} */\n    get reliable() {\n        return this._reliable;\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isPseudo() {\n        return !this._ip;\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isPrivate() {\n        return this.isPseudo() || NetUtils.isPrivateIP(this._ip);\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isIPv6() {\n        return this._ip && NetUtils.isIPv6Address(this._ip);\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isIPv4() {\n        return this._ip && NetUtils.isIPv4Address(this._ip);\n    }\n\n    /**\n     * @param {number} bitCount\n     * @return {NetAddress}\n     */\n    subnet(bitCount) {\n        const ip = this._ip ? NetUtils.ipToSubnet(this._ip, bitCount) : null;\n        return new NetAddress(this._type, ip, this._reliable);\n    }\n}\n/** @enum {number} */\nNetAddress.Type = {\n    IPv4: 0,\n    IPv6: 1,\n    UNSPECIFIED: 2,\n    UNKNOWN: 3\n};\nNetAddress.UNSPECIFIED = new NetAddress(NetAddress.Type.UNSPECIFIED);\nNetAddress.UNKNOWN = new NetAddress(NetAddress.Type.UNKNOWN);\nClass.register(NetAddress);\n","class PeerId extends Serializable {\n    /**\n     * @param {PeerId} o\n     * @returns {PeerId}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const obj = new Uint8Array(o._obj);\n        return new PeerId(obj);\n    }\n\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== PeerId.SERIALIZED_SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * Create Address object from binary form.\n     * @param {SerialBuffer} buf Buffer to read from.\n     * @return {PeerId} Newly created Account object.\n     */\n    static unserialize(buf) {\n        return new PeerId(buf.read(PeerId.SERIALIZED_SIZE));\n    }\n\n    /**\n     * Serialize this Address object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    subarray(begin, end) {\n        return this._obj.subarray(begin, end);\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        return PeerId.SERIALIZED_SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PeerId\n            && super.equals(o);\n    }\n\n    /**\n     * @returns {string}\n     * @override\n     */\n    toString() {\n        return this.toHex();\n    }\n\n    /**\n     * @param {string} base64\n     * @return {PeerId}\n     */\n    static fromBase64(base64) {\n        return new PeerId(BufferUtils.fromBase64(base64));\n    }\n\n    /**\n     * @param {string} hex\n     * @return {PeerId}\n     */\n    static fromHex(hex) {\n        return new PeerId(BufferUtils.fromHex(hex));\n    }\n}\n\nPeerId.SERIALIZED_SIZE = 16;\nClass.register(PeerId);\n","class PeerAddress {\n    /**\n     * @param {number} protocol\n     * @param {number} services\n     * @param {number} timestamp\n     * @param {NetAddress} netAddress\n     * @param {PublicKey} publicKey\n     * @param {number} distance\n     * @param {Signature} [signature]\n     */\n    constructor(protocol, services, timestamp, netAddress, publicKey, distance, signature) {\n        if (!NumberUtils.isUint8(distance)) throw new Error('Malformed distance');\n        if (publicKey !== null && !(publicKey instanceof PublicKey)) throw new Error('Malformed publicKey');\n\n        /** @type {number} */\n        this._protocol = protocol;\n        /** @type {number} */\n        this._services = services;\n        /** @type {number} */\n        this._timestamp = timestamp;\n        /** @type {NetAddress} */\n        this._netAddress = netAddress || NetAddress.UNSPECIFIED;\n        /** @type {PublicKey} */\n        this._publicKey = publicKey;\n        /** @type {number} */\n        this._distance = distance;\n        /** @type {?Signature} */\n        this._signature = signature;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {PeerAddress}\n     */\n    static unserialize(buf) {\n        const protocol = buf.readUint8();\n        switch (protocol) {\n            case Protocol.WS:\n                return WsPeerAddress.unserialize(buf);\n\n            case Protocol.RTC:\n                return RtcPeerAddress.unserialize(buf);\n\n            case Protocol.DUMB:\n                return DumbPeerAddress.unserialize(buf);\n\n            default:\n                throw `Malformed PeerAddress protocol ${protocol}`;\n        }\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        if (!this._publicKey) throw new Error('PeerAddress without publicKey may not be serialized.');\n        if (!this._signature) throw new Error('PeerAddress without signature may not be serialized.');\n\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._protocol);\n        buf.writeUint32(this._services);\n        buf.writeUint64(this._timestamp);\n\n        // Never serialize private netAddresses.\n        if (this._netAddress.isPrivate()) {\n            NetAddress.UNSPECIFIED.serialize(buf);\n        } else {\n            this._netAddress.serialize(buf);\n        }\n\n        this._publicKey.serialize(buf);\n        buf.writeUint8(this._distance);\n        this._signature.serialize(buf);\n\n        return buf;\n    }\n\n    serializeContent(buf) {\n        buf = buf || new SerialBuffer(this.serializedContentSize);\n\n        buf.writeUint8(this._protocol);\n        buf.writeUint32(this._services);\n        buf.writeUint64(this._timestamp);\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*protocol*/ 1\n            + /*services*/ 4\n            + /*timestamp*/ 8\n            + this._netAddress.serializedSize\n            + this._publicKey.serializedSize\n            + /*distance*/ 1\n            + this._signature.serializedSize;\n    }\n\n    /** @type {number} */\n    get serializedContentSize() {\n        return /*protocol*/ 1\n            + /*services*/ 4\n            + /*timestamp*/ 8;\n    }\n\n    /**\n     * @param {PeerAddress|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        // We consider peer addresses to be equal if the public key or peer id is not known on one of them:\n        // Peers from the network always contain a peer id and public key, peers without peer id or public key\n        // are always set by the user.\n        return o instanceof PeerAddress\n            && this.protocol === o.protocol\n            && (!this.publicKey || !o.publicKey || this.publicKey.equals(o.publicKey))\n            && (!this.peerId || !o.peerId || this.peerId.equals(o.peerId))\n            /* services is ignored */\n            /* timestamp is ignored */\n            /* netAddress is ignored */\n            /* distance is ignored */;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    verifySignature() {\n        if (this._signatureVerified === undefined) {\n            this._signatureVerified = this.signature.verify(this.publicKey, this.serializeContent());\n        }\n        return this._signatureVerified;\n    }\n\n    /** @type {number} */\n    get protocol() {\n        return this._protocol;\n    }\n\n    /** @type {number} */\n    get services() {\n        return this._services;\n    }\n\n    /** @type {number} */\n    get timestamp() {\n        return this._timestamp;\n    }\n\n    /** @type {NetAddress} */\n    get netAddress() {\n        return this._netAddress.isPseudo() ? null : this._netAddress;\n    }\n\n    /** @type {NetAddress} */\n    set netAddress(value) {\n        this._netAddress = value || NetAddress.UNSPECIFIED;\n    }\n\n    /** @type {PublicKey} */\n    get publicKey() {\n        return this._publicKey;\n    }\n\n    /** @type {PeerId} */\n    get peerId() {\n        return this._publicKey ? this._publicKey.toPeerId() : null;\n    }\n\n    /** @type {number} */\n    get distance() {\n        return this._distance;\n    }\n\n    /** @type {Signature} */\n    get signature() {\n        return this._signature;\n    }\n\n    /** @type {Signature} */\n    set signature(signature) {\n        // Never change the signature of a remote address.\n        if (this._distance !== 0) {\n            return;\n        }\n\n        this._signature = signature;\n        this._signatureVerified = undefined;\n    }\n\n    // Changed when passed on to other peers.\n    /** @type {number} */\n    set distance(value) {\n        this._distance = value;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isSeed() {\n        return this._timestamp === 0;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    exceedsAge() {\n        // Seed addresses are never too old.\n        if (this.isSeed()) {\n            return false;\n        }\n\n        const age = Date.now() - this.timestamp;\n        switch (this.protocol) {\n            case Protocol.WS:\n                return age > PeerAddressBook.MAX_AGE_WEBSOCKET;\n\n            case Protocol.RTC:\n                return age > PeerAddressBook.MAX_AGE_WEBRTC;\n\n            case Protocol.DUMB:\n                return age > PeerAddressBook.MAX_AGE_DUMB;\n        }\n        return false;\n    }\n\n}\n\nClass.register(PeerAddress);\n\nclass WsPeerAddress extends PeerAddress {\n    /**\n     * @param {string} host\n     * @param {number} port\n     * @param {string} [publicKeyHex]\n     * @returns {WsPeerAddress}\n     */\n    static seed(host, port, publicKeyHex) {\n        const publicKey = publicKeyHex ? new PublicKey(BufferUtils.fromHex(publicKeyHex)) : null;\n        return new WsPeerAddress(Services.FULL, /*timestamp*/ 0, NetAddress.UNSPECIFIED, publicKey, 0, host, port);\n    }\n\n    /**\n     * @param {number} services\n     * @param {number} timestamp\n     * @param {NetAddress} netAddress\n     * @param {PublicKey} publicKey\n     * @param {number} distance\n     * @param {string} host\n     * @param {number} port\n     * @param {Signature} [signature]\n     */\n    constructor(services, timestamp, netAddress, publicKey, distance, host, port, signature) {\n        super(Protocol.WS, services, timestamp, netAddress, publicKey, distance, signature);\n        if (!host) throw new Error('Malformed host');\n        if (!NumberUtils.isUint16(port)) throw new Error('Malformed port');\n        this._host = host;\n        this._port = port;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {WsPeerAddress}\n     */\n    static unserialize(buf) {\n        const services = buf.readUint32();\n        const timestamp = buf.readUint64();\n        const netAddress = NetAddress.unserialize(buf);\n        const publicKey = PublicKey.unserialize(buf);\n        const distance = buf.readUint8();\n        const signature = Signature.unserialize(buf);\n        const host = buf.readVarLengthString();\n        const port = buf.readUint16();\n        return new WsPeerAddress(services, timestamp, netAddress, publicKey, distance, host, port, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeVarLengthString(this._host);\n        buf.writeUint16(this._port);\n        return buf;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serializeContent(buf) {\n        buf = buf || new SerialBuffer(this.serializedContentSize);\n        super.serializeContent(buf);\n        buf.writeVarLengthString(this._host);\n        buf.writeUint16(this._port);\n        return buf;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    globallyReachable() {\n        return NetUtils.hostGloballyReachable(this.host);\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + SerialBuffer.varLengthStringSize(this._host)\n            + /*port*/ 2;\n    }\n\n    /** @type {number} */\n    get serializedContentSize() {\n        return super.serializedContentSize\n            + SerialBuffer.varLengthStringSize(this._host)\n            + /*port*/ 2;\n    }\n\n    /**\n     * @override\n     * @param {PeerAddress|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return super.equals(o)\n            && o instanceof WsPeerAddress\n            && ((!!this.peerId && !!o.peerId) || (this._host === o.host && this._port === o.port));\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this.peerId\n            ? `wss:///${this.peerId}`\n            : `wss://${this._host}:${this._port}/`;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `wss://${this._host}:${this._port}/${this.peerId ? this.peerId : ''}`;\n    }\n\n    /**\n     * @returns {WsPeerAddress}\n     */\n    withoutId() {\n        return new WsPeerAddress(this.services, this.timestamp, this.netAddress, null, this.distance, this.host, this.port);\n    }\n\n    /** @type {string} */\n    get host() {\n        return this._host;\n    }\n\n    /** @type {number} */\n    get port() {\n        return this._port;\n    }\n}\n\nClass.register(WsPeerAddress);\n\nclass RtcPeerAddress extends PeerAddress {\n    /**\n     * @param {number} services\n     * @param {number} timestamp\n     * @param {NetAddress} netAddress\n     * @param {PublicKey} publicKey\n     * @param {number} distance\n     * @param {Signature} [signature]\n     */\n    constructor(services, timestamp, netAddress, publicKey, distance, signature) {\n        super(Protocol.RTC, services, timestamp, netAddress, publicKey, distance, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {RtcPeerAddress}\n     */\n    static unserialize(buf) {\n        const services = buf.readUint32();\n        const timestamp = buf.readUint64();\n        const netAddress = NetAddress.unserialize(buf);\n        const publicKey = PublicKey.unserialize(buf);\n        const distance = buf.readUint8();\n        const signature = Signature.unserialize(buf);\n        return new RtcPeerAddress(services, timestamp, netAddress, publicKey, distance, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize;\n    }\n\n    /**\n     * @override\n     * @param {PeerAddress|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return super.equals(o)\n            && o instanceof RtcPeerAddress;\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this.toString();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `rtc:///${this.peerId}`;\n    }\n}\n\nClass.register(RtcPeerAddress);\n\nclass DumbPeerAddress extends PeerAddress {\n    /**\n     * @param {number} services\n     * @param {number} timestamp\n     * @param {NetAddress} netAddress\n     * @param {PublicKey} publicKey\n     * @param {number} distance\n     * @param {Signature} [signature]\n     */\n    constructor(services, timestamp, netAddress, publicKey, distance, signature) {\n        super(Protocol.DUMB, services, timestamp, netAddress, publicKey, distance, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {DumbPeerAddress}\n     */\n    static unserialize(buf) {\n        const services = buf.readUint32();\n        const timestamp = buf.readUint64();\n        const netAddress = NetAddress.unserialize(buf);\n        const publicKey = PublicKey.unserialize(buf);\n        const distance = buf.readUint8();\n        const signature = Signature.unserialize(buf);\n        return new DumbPeerAddress(services, timestamp, netAddress, publicKey, distance, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize;\n    }\n\n    /**\n     * @override\n     * @param {PeerAddress} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return super.equals(o)\n            && o instanceof DumbPeerAddress;\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this.toString();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `dumb:///${this.peerId}`;\n    }\n}\n\nClass.register(DumbPeerAddress);\n","class PeerAddressState {\n    /**\n     * @param {PeerAddress} peerAddress\n     */\n    constructor(peerAddress) {\n        /** @type {PeerAddress} */\n        this.peerAddress = peerAddress;\n\n        /** @type {number} */\n        this.state = PeerAddressState.NEW;\n        /** @type {number} */\n        this.lastConnected = -1;\n        /** @type {number} */\n        this.bannedUntil = -1;\n        /** @type {number} */\n        this.banBackoff = PeerAddressBook.INITIAL_FAILED_BACKOFF;\n\n        /** @type {SignalRouter} */\n        this._signalRouter = new SignalRouter(peerAddress);\n\n        /** @type {number} */\n        this._failedAttempts = 0;\n\n        /**\n         * Map from closeType to number of occurrences\n         * @type {Map.<number,number>}\n         * @private\n         */\n        this._closeTypes = new Map();\n\n        /**\n         * @type {HashSet.<NetAddress>}\n         * @private\n         */\n        this._addedBy = new HashSet();\n    }\n\n    /** @type {SignalRouter} */\n    get signalRouter() {\n        return this._signalRouter;\n    }\n\n    /** @type {number} */\n    get maxFailedAttempts() {\n        switch (this.peerAddress.protocol) {\n            case Protocol.RTC:\n                return PeerAddressBook.MAX_FAILED_ATTEMPTS_RTC;\n            case Protocol.WS:\n                return PeerAddressBook.MAX_FAILED_ATTEMPTS_WS;\n            default:\n                return 0;\n        }\n    }\n\n    /** @type {number} */\n    get failedAttempts() {\n        if (this._signalRouter.bestRoute) {\n            return this._signalRouter.bestRoute.failedAttempts;\n        } else {\n            return this._failedAttempts;\n        }\n    }\n\n    /** @type {number} */\n    set failedAttempts(value) {\n        if (this._signalRouter.bestRoute) {\n            this._signalRouter.bestRoute.failedAttempts = value;\n            this._signalRouter.updateBestRoute(); // scores may have changed\n        } else {\n            this._failedAttempts = value;\n        }\n    }\n\n    /**\n     * @param {number} type\n     */\n    close(type) {\n        if (!type) return;\n\n        if (this._closeTypes.has(type)) {\n            this._closeTypes.set(type, this._closeTypes.get(type) + 1);\n        } else {\n            this._closeTypes.set(type, 1);\n        }\n\n        if (this.state === PeerAddressState.BANNED) {\n            return;\n        }\n\n        if (CloseType.isBanningType(type)) {\n            this.state = PeerAddressState.BANNED;\n        } else if (CloseType.isFailingType(type)) {\n            this.state = PeerAddressState.FAILED;\n        } else {\n            this.state = PeerAddressState.TRIED;\n        }\n    }\n\n    /**\n     * @param {PeerAddressState|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof PeerAddressState\n            && this.peerAddress.equals(o.peerAddress);\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this.peerAddress.hashCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `PeerAddressState{peerAddress=${this.peerAddress}, state=${this.state}, `\n            + `lastConnected=${this.lastConnected}, failedAttempts=${this.failedAttempts}, `\n            + `bannedUntil=${this.bannedUntil}}`;\n    }\n\n    /** @type {HashSet.<NetAddress>} */\n    get addedBy() {\n        return this._addedBy;\n    }\n}\nPeerAddressState.NEW = 1;\nPeerAddressState.ESTABLISHED = 2;\nPeerAddressState.TRIED = 3;\nPeerAddressState.FAILED = 4;\nPeerAddressState.BANNED = 5;\nClass.register(PeerAddressState);\n\nclass SignalRouter {\n    /**\n     * @constructor\n     * @param {PeerAddress} peerAddress\n     */\n    constructor(peerAddress) {\n        /** @type {PeerAddress} */\n        this.peerAddress = peerAddress;\n\n        /** @type {SignalRoute} */\n        this._bestRoute = null;\n        /** @type {HashSet.<SignalRoute>} */\n        this._routes = new HashSet();\n    }\n\n    /** @type {SignalRoute} */\n    get bestRoute() {\n        return this._bestRoute;\n    }\n\n    /**\n     * @param {PeerChannel} signalChannel\n     * @param {number} distance\n     * @param {number} timestamp\n     * @returns {boolean} whether we have a new best route\n     */\n    addRoute(signalChannel, distance, timestamp) {\n        const oldRoute = this._routes.get(signalChannel);\n        const newRoute = new SignalRoute(signalChannel, distance, timestamp);\n\n        if (oldRoute) {\n            // Do not reset failed attempts.\n            newRoute.failedAttempts = oldRoute.failedAttempts;\n        }\n        this._routes.add(newRoute);\n\n        if (!this._bestRoute || newRoute.score > this._bestRoute.score\n            || (newRoute.score === this._bestRoute.score && timestamp > this._bestRoute.timestamp)) {\n\n            this._bestRoute = newRoute;\n            this.peerAddress.distance = this._bestRoute.distance;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @returns {void}\n     */\n    deleteBestRoute() {\n        if (this._bestRoute) {\n            this.deleteRoute(this._bestRoute.signalChannel);\n        }\n    }\n\n    /**\n     * @param {PeerChannel} signalChannel\n     * @returns {void}\n     */\n    deleteRoute(signalChannel) {\n        this._routes.remove(signalChannel); // maps to same hashCode\n        if (this._bestRoute && this._bestRoute.signalChannel.equals(signalChannel)) {\n            this.updateBestRoute();\n        }\n    }\n\n    /**\n     * @returns {void}\n     */\n    deleteAllRoutes() {\n        this._bestRoute = null;\n        this._routes = new HashSet();\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    hasRoute() {\n        return this._routes.length > 0;\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    updateBestRoute() {\n        let bestRoute = null;\n        // Choose the route with minimal distance and maximal timestamp.\n        for (const route of this._routes.values()) {\n            if (bestRoute === null || route.score > bestRoute.score\n                || (route.score === bestRoute.score && route.timestamp > bestRoute.timestamp)) {\n\n                bestRoute = route;\n            }\n        }\n        this._bestRoute = bestRoute;\n        if (this._bestRoute) {\n            this.peerAddress.distance = this._bestRoute.distance;\n        } else {\n            this.peerAddress.distance = PeerAddressBook.MAX_DISTANCE + 1;\n        }\n    }\n\n    /**\n     * @param {PeerAddressState|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof PeerAddressState\n            && this.peerAddress.equals(o.peerAddress);\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this.peerAddress.hashCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `PeerAddressState{peerAddress=${this.peerAddress}, state=${this.state}, `\n            + `lastConnected=${this.lastConnected}, failedAttempts=${this.failedAttempts}, `\n            + `bannedUntil=${this.bannedUntil}}`;\n    }\n}\nClass.register(SignalRouter);\n\nclass SignalRoute {\n    /**\n     * @param {PeerChannel} signalChannel\n     * @param {number} distance\n     * @param {number} timestamp\n     */\n    constructor(signalChannel, distance, timestamp) {\n        this.failedAttempts = 0;\n        this.timestamp = timestamp;\n        this._signalChannel = signalChannel;\n        this._distance = distance;\n    }\n\n    /** @type {PeerChannel} */\n    get signalChannel() {\n        return this._signalChannel;\n    }\n\n    /** @type {number} */\n    get distance() {\n        return this._distance;\n    }\n\n    /** @type {number} */\n    get score() {\n        return ((PeerAddressBook.MAX_DISTANCE - this._distance) / 2) * (1 - (this.failedAttempts / PeerAddressBook.MAX_FAILED_ATTEMPTS_RTC));\n    }\n\n    /**\n     * @param {SignalRoute} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof SignalRoute\n            && this._signalChannel.equals(o._signalChannel);\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this._signalChannel.hashCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `SignalRoute{signalChannel=${this._signalChannel}, distance=${this._distance}, timestamp=${this.timestamp}, failedAttempts=${this.failedAttempts}}`;\n    }\n}\nClass.register(SignalRoute);\n","class PeerAddressBook extends Observable {\n    /**\n     * @constructor\n     * @param {NetworkConfig} netconfig\n     */\n    constructor(netconfig) {\n        super();\n\n        /**\n         * @type {NetworkConfig}\n         * @private\n         */\n        this._networkConfig = netconfig;\n\n        /**\n         * Set of PeerAddressStates of all peerAddresses we know.\n         * @type {HashSet.<PeerAddressState>}\n         * @private\n         */\n        this._store = new HashSet();\n\n        /**\n         * Map from peerIds to RTC peerAddresses.\n         * @type {HashMap.<PeerId,PeerAddressState>}\n         * @private\n         */\n        this._stateByPeerId = new HashMap();\n\n        /**\n         * @type {HashMap.<NetAddress,Set.<PeerAddressState>>}\n         * @private\n         */\n        this._statesByNetAddress = new HashMap();\n\n        // Init seed peers.\n        this.add(/*channel*/ null, GenesisConfig.SEED_PEERS);\n\n        // Setup housekeeping interval.\n        setInterval(() => this._housekeeping(), PeerAddressBook.HOUSEKEEPING_INTERVAL);\n    }\n\n    /**\n     * @returns {Array.<PeerAddressState>}\n     */\n    values() {\n        return this._store.values();\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {?PeerAddressState}\n     * @private\n     */\n    _get(peerAddress) {\n        if (peerAddress instanceof WsPeerAddress) {\n            const localPeerAddress = this._store.get(peerAddress.withoutId());\n            if (localPeerAddress) return localPeerAddress;\n        }\n        return this._store.get(peerAddress);\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {?PeerAddressState}\n     */\n    getState(peerAddress) {\n        return this._get(peerAddress);\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {PeerAddress|null}\n     */\n    get(peerAddress) {\n        /** @type {PeerAddressState} */\n        const peerAddressState = this._get(peerAddress);\n        return peerAddressState ? peerAddressState.peerAddress : null;\n    }\n\n    /**\n     * @param {PeerId} peerId\n     * @returns {PeerAddress|null}\n     */\n    getByPeerId(peerId) {\n        /** @type {PeerAddressState} */\n        const peerAddressState = this._stateByPeerId.get(peerId);\n        return peerAddressState ? peerAddressState.peerAddress : null;\n    }\n\n    /**\n     * @param {PeerId} peerId\n     * @returns {PeerChannel}\n     */\n    getChannelByPeerId(peerId) {\n        const peerAddressState = this._stateByPeerId.get(peerId);\n        if (peerAddressState && peerAddressState.signalRouter.bestRoute) {\n            return peerAddressState.signalRouter.bestRoute.signalChannel;\n        }\n        return null;\n    }\n\n    /**\n     * @param {number} protocolMask\n     * @param {number} serviceMask\n     * @param {number} maxAddresses\n     * @returns {Array.<PeerAddress>}\n     */\n    query(protocolMask, serviceMask, maxAddresses = 1000) {\n        const addressStates = this._store.values();\n        const numAddresses = addressStates.length;\n\n        // Pick a random start index.\n        const index = Math.floor(Math.random() * numAddresses);\n\n        // XXX inefficient linear scan\n        const now = Date.now();\n        const addresses = [];\n        for (let i = 0; i < numAddresses; i++) {\n            const idx = (index + i) % numAddresses;\n            const peerAddressState = addressStates[idx];\n\n            // Never return banned or failed addresses.\n            if (peerAddressState.state === PeerAddressState.BANNED\n                    || peerAddressState.state === PeerAddressState.FAILED) {\n                continue;\n            }\n\n            // Never return seed peers.\n            const address = peerAddressState.peerAddress;\n            if (address.isSeed()) {\n                continue;\n            }\n\n            // Only return addresses matching the protocol mask.\n            if ((address.protocol & protocolMask) === 0) {\n                continue;\n            }\n\n            // Only return addresses matching the service mask.\n            if ((address.services & serviceMask) === 0) {\n                continue;\n            }\n\n            // Update timestamp for connected peers.\n            if (peerAddressState.state === PeerAddressState.ESTABLISHED) {\n                // Also update timestamp for RTC connections\n                if (peerAddressState.signalRouter.bestRoute) {\n                    peerAddressState.signalRouter.bestRoute.timestamp = now;\n                }\n            }\n\n            // Never return addresses that are too old.\n            if (address.exceedsAge()) {\n                continue;\n            }\n\n            // Return this address.\n            addresses.push(address);\n\n            // Stop if we have collected maxAddresses.\n            if (addresses.length >= maxAddresses) {\n                break;\n            }\n        }\n        return addresses;\n    }\n\n    /**\n     * @param {PeerChannel} channel\n     * @param {PeerAddress|Array.<PeerAddress>} arg\n     * @fires PeerAddressBook#added\n     */\n    add(channel, arg) {\n        const peerAddresses = Array.isArray(arg) ? arg : [arg];\n        const newAddresses = [];\n\n        for (const addr of peerAddresses) {\n            if (this._add(channel, addr)) {\n                newAddresses.push(addr);\n            }\n        }\n\n        // Tell listeners that we learned new addresses.\n        if (newAddresses.length) {\n            this.fire('added', newAddresses, this);\n        }\n    }\n\n    /**\n     * @param {PeerChannel} channel\n     * @param {PeerAddress|RtcPeerAddress} peerAddress\n     * @returns {boolean}\n     * @private\n     */\n    _add(channel, peerAddress) {\n        // Max book size reached\n        if (this._store.length >= PeerAddressBook.MAX_SIZE) {\n            return false;\n        }\n\n        // Ignore our own address.\n        if (this._networkConfig.peerAddress.equals(peerAddress)) {\n            return false;\n        }\n\n        // Ignore address if it is too old.\n        // Special case: allow seed addresses (timestamp == 0) via null channel.\n        if (channel && peerAddress.exceedsAge()) {\n            Log.d(PeerAddressBook, `Ignoring address ${peerAddress} - too old (${new Date(peerAddress.timestamp)})`);\n            return false;\n        }\n\n        // Ignore address if its timestamp is too far in the future.\n        if (peerAddress.timestamp > Date.now() + PeerAddressBook.MAX_TIMESTAMP_DRIFT) {\n            Log.d(PeerAddressBook, `Ignoring addresses ${peerAddress} - timestamp in the future`);\n            return false;\n        }\n\n        // Increment distance values of RTC addresses.\n        if (peerAddress.protocol === Protocol.RTC) {\n            peerAddress.distance++;\n\n            // Ignore address if it exceeds max distance.\n            if (peerAddress.distance > PeerAddressBook.MAX_DISTANCE) {\n                Log.d(PeerAddressBook, `Ignoring address ${peerAddress} - max distance exceeded`);\n                // Drop any route to this peer over the current channel. This may prevent loops.\n                const peerAddressState = this._get(peerAddress);\n                if (peerAddressState) {\n                    peerAddressState.signalRouter.deleteRoute(channel);\n                }\n                return false;\n            }\n        }\n\n        // Get the (reliable) netAddress of the peer that sent us this address.\n        const netAddress = channel && channel.netAddress && channel.netAddress.reliable ? channel.netAddress : null;\n\n        // Check if we already know this address.\n        let peerAddressState = this._get(peerAddress);\n        let knownAddress = null;\n        let changed = false;\n        if (peerAddressState) {\n            knownAddress = peerAddressState.peerAddress;\n\n            // Ignore address if it is banned.\n            if (peerAddressState.state === PeerAddressState.BANNED) {\n                return false;\n            }\n\n            // Never update seed peers.\n            if (knownAddress.isSeed()) {\n                return false;\n            }\n\n            // Never erase NetAddresses and never overwrite reliable addresses.\n            if (knownAddress.netAddress && (!peerAddress.netAddress || knownAddress.netAddress.reliable)) {\n                peerAddress.netAddress = knownAddress.netAddress;\n            }\n        } else {\n            // If we know the IP address of the sender, check that we don't exceed the maximum number of addresses per IP.\n            if (netAddress) {\n                const states = this._statesByNetAddress.get(netAddress);\n                if (states && states.size >= PeerAddressBook.MAX_SIZE_PER_IP) {\n                    Log.d(PeerAddressBook, `Ignoring address ${peerAddress} - max count per IP ${netAddress} reached`);\n                    return false;\n                }\n            }\n\n            // Add new peerAddressState.\n            peerAddressState = new PeerAddressState(peerAddress);\n            this._store.add(peerAddressState);\n            if (peerAddress.peerId) {\n                // Index by peerId.\n                this._stateByPeerId.put(peerAddress.peerId, peerAddressState);\n            }\n            changed = true;\n        }\n\n        // Update address if we do not know this address or it has a more recent timestamp.\n        if (!knownAddress || knownAddress.timestamp < peerAddress.timestamp) {\n            peerAddressState.peerAddress = peerAddress;\n            changed = true;\n        }\n\n        // Add route.\n        if (peerAddress.protocol === Protocol.RTC) {\n            changed = peerAddressState.signalRouter.addRoute(channel, peerAddress.distance, peerAddress.timestamp) || changed;\n        }\n\n        // Track which IP address send us this address.\n        if (netAddress) {\n            peerAddressState.addedBy.add(channel.netAddress);\n\n            let states = this._statesByNetAddress.get(channel.netAddress);\n            if (!states) {\n                states = new Set();\n                this._statesByNetAddress.put(channel.netAddress, states);\n            }\n            states.add(peerAddressState);\n        }\n\n        return changed;\n    }\n\n    /**\n     * Called when a connection to this peerAddress has been established.\n     * The connection might have been initiated by the other peer, so address\n     * may not be known previously.\n     * If it is already known, it has been updated by a previous version message.\n     * @param {PeerChannel} channel\n     * @param {PeerAddress|RtcPeerAddress} peerAddress\n     * @returns {void}\n     */\n    established(channel, peerAddress) {\n        let peerAddressState = this._get(peerAddress);\n        \n        if (!peerAddressState) {\n            peerAddressState = new PeerAddressState(peerAddress);\n\n            this._store.add(peerAddressState);\n        }\n\n        if (peerAddress.peerId) {\n            this._stateByPeerId.put(peerAddress.peerId, peerAddressState);\n        }\n\n        peerAddressState.state = PeerAddressState.ESTABLISHED;\n        peerAddressState.lastConnected = Date.now();\n        peerAddressState.failedAttempts = 0;\n        peerAddressState.bannedUntil = -1;\n        peerAddressState.banBackoff = PeerAddressBook.INITIAL_FAILED_BACKOFF;\n\n        if (!peerAddressState.peerAddress.isSeed()) {\n            peerAddressState.peerAddress = peerAddress;\n        }\n\n        // Add route.\n        if (peerAddress.protocol === Protocol.RTC) {\n            peerAddressState.signalRouter.addRoute(channel, peerAddress.distance, peerAddress.timestamp);\n        }\n    }\n\n    /**\n     * Called when a connection to this peerAddress is closed.\n     * @param {PeerChannel} channel\n     * @param {PeerAddress} peerAddress\n     * @param {number|null} type\n     * @returns {void}\n     */\n    close(channel, peerAddress, type = null) {\n        const peerAddressState = this._get(peerAddress);\n        if (!peerAddressState) {\n            return;\n        }\n\n        // register the type of disconnection\n        peerAddressState.close(type);\n\n        // Delete all addresses that were signalable over the disconnected peer.\n        if (channel) {\n            this._removeBySignalChannel(channel);\n        }\n\n        if (CloseType.isBanningType(type)){\n            this._ban(peerAddress);\n        }\n        else if (CloseType.isFailingType(type)) {\n            peerAddressState.failedAttempts++;\n\n            if (peerAddressState.failedAttempts >= peerAddressState.maxFailedAttempts) {\n                // Remove address only if we have tried the maximum number of backoffs.\n                if (peerAddressState.banBackoff >= PeerAddressBook.MAX_FAILED_BACKOFF) {\n                    this._remove(peerAddress);\n                } else {\n                    peerAddressState.bannedUntil = Date.now() + peerAddressState.banBackoff;\n                    peerAddressState.banBackoff = Math.min(PeerAddressBook.MAX_FAILED_BACKOFF, peerAddressState.banBackoff * 2);\n                }\n            }\n        }\n\n        // Immediately delete dumb addresses, since we cannot connect to those anyway.\n        if (peerAddress.protocol === Protocol.DUMB) {\n            this._remove(peerAddress);\n        }\n    }\n\n    /**\n     * Called when a message has been returned as unroutable.\n     * @param {PeerChannel} channel\n     * @param {PeerAddress} peerAddress\n     * @returns {void}\n     */\n    unroutable(channel, peerAddress) {\n        if (!peerAddress) {\n            return;\n        }\n\n        const peerAddressState = this._get(peerAddress);\n        if (!peerAddressState) {\n            return;\n        }\n\n        if (!peerAddressState.signalRouter.bestRoute || !peerAddressState.signalRouter.bestRoute.signalChannel.equals(channel)) {\n            Log.w(PeerAddressBook, `Got unroutable for ${peerAddress} on a channel other than the best route.`);\n            return;\n        }\n\n        peerAddressState.signalRouter.deleteBestRoute();\n        if (!peerAddressState.signalRouter.hasRoute()) {\n            this._remove(peerAddressState.peerAddress);\n        }\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @param {number} [duration] in milliseconds\n     * @returns {void}\n     * @private\n     */\n    _ban(peerAddress, duration = PeerAddressBook.DEFAULT_BAN_TIME) {\n        let peerAddressState = this._get(peerAddress);\n        if (!peerAddressState) {\n            peerAddressState = new PeerAddressState(peerAddress);\n            this._store.add(peerAddressState);\n        }\n\n        peerAddressState.state = PeerAddressState.BANNED;\n        peerAddressState.bannedUntil = Date.now() + duration;\n\n        // Drop all routes to this peer.\n        peerAddressState.signalRouter.deleteAllRoutes();\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {boolean}\n     */\n    isBanned(peerAddress) {\n        const peerAddressState = this._get(peerAddress);\n        return peerAddressState\n            && peerAddressState.state === PeerAddressState.BANNED\n            // XXX Never consider seed peers to be banned. This allows us to use\n            // the banning mechanism to prevent seed peers from being picked when\n            // they are down, but still allows recovering seed peers' inbound\n            // connections to succeed.\n            && !peerAddressState.peerAddress.isSeed();\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {void}\n     * @private\n     */\n    _remove(peerAddress) {\n        const peerAddressState = this._get(peerAddress);\n        if (!peerAddressState) {\n            return;\n        }\n\n        // Never delete seed addresses, ban them instead for a couple of minutes.\n        if (peerAddressState.peerAddress.isSeed()) {\n            this._ban(peerAddress, peerAddressState.banBackoff);\n            return;\n        }\n\n        // Delete from peerId index.\n        if (peerAddress.peerId) {\n            this._stateByPeerId.remove(peerAddress.peerId);\n        }\n\n        // Delete from netAddress index.\n        for (const netAddress of peerAddressState.addedBy) {\n            const states = this._statesByNetAddress.get(netAddress);\n            if (states) {\n                states.delete(peerAddressState);\n                if (states.size === 0) {\n                    this._statesByNetAddress.remove(netAddress);\n                }\n            }\n        }\n\n        // Don't delete bans.\n        if (peerAddressState.state === PeerAddressState.BANNED) {\n            return;\n        }\n\n        // Delete the address.\n        this._store.remove(peerAddress);\n    }\n\n    /**\n     * Delete all RTC-only routes that are signalable over the given peer.\n     * @param {PeerChannel} channel\n     * @returns {void}\n     * @private\n     */\n    _removeBySignalChannel(channel) {\n        // XXX inefficient linear scan\n        for (const peerAddressState of this._store.values()) {\n            if (peerAddressState.peerAddress.protocol === Protocol.RTC) {\n                peerAddressState.signalRouter.deleteRoute(channel);\n                if (!peerAddressState.signalRouter.hasRoute()) {\n                    this._remove(peerAddressState.peerAddress);\n                }\n            }\n        }\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _housekeeping() {\n        const now = Date.now();\n        const unbannedAddresses = [];\n\n        for (/** @type {PeerAddressState} */ const peerAddressState of this._store.values()) {\n            const addr = peerAddressState.peerAddress;\n\n            switch (peerAddressState.state) {\n                case PeerAddressState.NEW:\n                case PeerAddressState.TRIED:\n                case PeerAddressState.FAILED:\n                    // Delete all new peer addresses that are older than MAX_AGE.\n                    if (addr.exceedsAge()) {\n                        this._remove(addr);\n                        continue;\n                    }\n\n                    // Reset failed attempts after bannedUntil has expired.\n                    if (peerAddressState.state === PeerAddressState.FAILED\n                        && peerAddressState.failedAttempts >= peerAddressState.maxFailedAttempts\n                        && peerAddressState.bannedUntil > 0 && peerAddressState.bannedUntil <= now) {\n\n                        peerAddressState.bannedUntil = -1;\n                        peerAddressState.failedAttempts = 0;\n                        unbannedAddresses.push(addr);\n                    }\n\n                    break;\n\n                case PeerAddressState.BANNED:\n                    if (peerAddressState.bannedUntil <= now) {\n                        // Don't remove seed addresses, unban them.\n                        if (addr.isSeed()) {\n                            // Restore banned seed addresses to the NEW state.\n                            peerAddressState.state = PeerAddressState.NEW;\n                            peerAddressState.failedAttempts = 0;\n                            peerAddressState.bannedUntil = -1;\n                            unbannedAddresses.push(addr);\n                        } else {\n                            // Delete expires bans.\n                            this._store.remove(addr);\n                        }\n                    }\n                    break;\n\n                case PeerAddressState.ESTABLISHED:\n                    // Also update timestamp for RTC connections\n                    if (peerAddressState.signalRouter.bestRoute) {\n                        peerAddressState.signalRouter.bestRoute.timestamp = now;\n                    }\n                    break;\n\n                default:\n                    // TODO What about peers who are stuck connecting? Can this happen?\n                    // Do nothing for CONNECTING peers.\n            }\n        }\n\n        if (unbannedAddresses.length) {\n            this.fire('added', unbannedAddresses, this);\n        }\n    }\n\n    /** @type {number} */\n    get knownAddressesCount() {\n        return this._store.length;\n    }\n}\nPeerAddressBook.MAX_AGE_WEBSOCKET = 1000 * 60 * 30; // 30 minutes\nPeerAddressBook.MAX_AGE_WEBRTC = 1000 * 60 * 10; // 10 minutes\nPeerAddressBook.MAX_AGE_DUMB = 1000 * 60; // 1 minute\nPeerAddressBook.MAX_DISTANCE = 4;\nPeerAddressBook.MAX_FAILED_ATTEMPTS_WS = 3;\nPeerAddressBook.MAX_FAILED_ATTEMPTS_RTC = 2;\nPeerAddressBook.MAX_TIMESTAMP_DRIFT = 1000 * 60 * 10; // 10 minutes\nPeerAddressBook.HOUSEKEEPING_INTERVAL = 1000 * 60; // 1 minute\nPeerAddressBook.DEFAULT_BAN_TIME = 1000 * 60 * 10; // 10 minutes\nPeerAddressBook.INITIAL_FAILED_BACKOFF = 1000 * 30; // 30 seconds\nPeerAddressBook.MAX_FAILED_BACKOFF = 1000 * 60 * 10; // 10 minutes\nPeerAddressBook.MAX_SIZE = PlatformUtils.isBrowser() ? 15000 : 100000;\nPeerAddressBook.MAX_SIZE_PER_IP = 250;\nClass.register(PeerAddressBook);\n","class GenesisConfig {\n    static dev() {\n        GenesisConfig.init(GenesisConfig.CONFIGS['dev']);\n    }\n\n    static bounty() {\n        GenesisConfig.init(GenesisConfig.CONFIGS['bounty']);\n    }\n\n    /**\n     * @param {{NETWORK_ID:number,NETWORK_NAME:string,GENESIS_BLOCK:Block,GENESIS_ACCOUNTS:string,SEED_PEERS:Array.<PeerAddress>}} config\n     */\n    static init(config) {\n        if (GenesisConfig._config) throw new Error('GenesisConfig already initialized');\n        if (!config.NETWORK_ID) throw new Error('Config is missing network id');\n        if (!config.NETWORK_NAME) throw new Error('Config is missing database prefix');\n        if (!config.GENESIS_BLOCK) throw new Error('Config is missing genesis block');\n        if (!config.GENESIS_ACCOUNTS) throw new Error('Config is missing genesis accounts');\n        if (!config.SEED_PEERS) throw new Error('Config is missing seed peers');\n\n        GenesisConfig._config = config;\n    }\n\n    /**\n     * @type {number}\n     */\n    static get NETWORK_ID() {\n        if (!GenesisConfig._config) throw new Error('GenesisConfig not initialized');\n        return GenesisConfig._config.NETWORK_ID;\n    }\n\n    /**\n     * @type {string}\n     */\n    static get NETWORK_NAME() {\n        if (!GenesisConfig._config) throw new Error('GenesisConfig not initialized');\n        return GenesisConfig._config.NETWORK_NAME;\n    }\n\n    /**\n     * @type {Block}\n     */\n    static get GENESIS_BLOCK() {\n        if (!GenesisConfig._config) throw new Error('GenesisConfig not initialized');\n        return GenesisConfig._config.GENESIS_BLOCK;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    static get GENESIS_HASH() {\n        if (!GenesisConfig._config) throw new Error('GenesisConfig not initialized');\n        if (!GenesisConfig._config.GENESIS_HASH) {\n            GenesisConfig._config.GENESIS_HASH = GenesisConfig._config.GENESIS_BLOCK.hash();\n        }\n        return GenesisConfig._config.GENESIS_HASH;\n    }\n\n    /**\n     * @type {string}\n     */\n    static get GENESIS_ACCOUNTS() {\n        if (!GenesisConfig._config) throw new Error('GenesisConfig not initialized');\n        return GenesisConfig._config.GENESIS_ACCOUNTS;\n    }\n\n    /**\n     * @type {Array.<PeerAddress>}\n     */\n    static get SEED_PEERS() {\n        if (!GenesisConfig._config) throw new Error('GenesisConfig not initialized');\n        return GenesisConfig._config.SEED_PEERS;\n    }\n}\nClass.register(GenesisConfig);\n\nGenesisConfig.CONFIGS = {\n    // TODO 'main': { }\n    // TODO 'test': { }\n\n    'dev': {\n        NETWORK_ID: 2,\n        NETWORK_NAME: 'dev',\n        SEED_PEERS: [\n            WsPeerAddress.seed('dev.nimiq-network.com', 8080, 'e65e39616662f2c16d62dc08915e5a1d104619db8c2b9cf9b389f96c8dce9837')\n        ],\n        GENESIS_BLOCK: new Block(\n            new BlockHeader(\n                new Hash(null),\n                new Hash(null),\n                Hash.fromBase64('JvMr9c9l2m8HWNdFAGTEastKH+aDZvln9EopXelhVIg='),\n                Hash.fromBase64('1t/Zm91tN0p178+ePcxyR5bPxvC6jFLskqiidFFO3wY='),\n                BlockUtils.difficultyToCompact(1),\n                1,\n                1522338300,\n                12432,\n                BlockHeader.Version.V1),\n            new BlockInterlink([], new Hash(null)),\n            new BlockBody(Address.fromBase64('AAAAAAAAAAAAAAAAAAAAAAAAAAA='), [], BufferUtils.fromBase64('RGV2TmV0'))\n        ),\n        GENESIS_ACCOUNTS:\n            'AGTHyaGKKYtMW9zm81Nw2UYCIWr2bQAAAAOO9hgWyh/5Ezv+1Ldw9Oid2zwaY+LjRXAjAQAAAdpxepGo' +\n            'TVTy25Dj9WOZXg1SAyoCtCmEkgYAAAABAAAWgAAAAdpxepGoAAAB2nF6kagxFAXrnWawCibXmNIocpEN' +\n            'bY2M4QAAAACPgR32bdaFsm6G5Bg4H96UDFtJMFclfA8rAQAAA+Z8YTcn7eJ7xhfBV9k79a2bDLpb0SWE' +\n            'gSIAAAABAAALQAAAAKZqEDPcAAAD5nxhNyfiENwK3NNQGB6fxKS62kvoApoe4gEAAAKLbf59cM8P40JX' +\n            'yIKzSkr749mOqp5n1/ruAAAAAQAAC0AAAABsklUU6AAAAott/n1wZs9N9eWbNeUSLDy5qbhe6CW7Q94B' +\n            'AAADLsSIL0WLcA6Nt5Ji+Pu2j2p4wJgN8lpIVwAAAAEAABaAAAADLsSIL0UAAAMuxIgvRXGosRRWBkji' +\n            'IyWOFAzp3WZYGhQvAAAAAN+ByO6LKclRKAD8iueyAPGY/ZnTIbM5CbUBAAAAMXEUVZ+h9Kb5BH+lzQTK' +\n            'HdVMiFfmRsJBWAAAAAEAAAtAAAAACD2DY5sAAAAxcRRVn+hB476I0A6qQDjCSzzvumwsQHf9AQAAA03B' +\n            '6LO6vHPfpZtbnDWtPlN7WlO0l+aw1KIAAAABAAALQAAAAIz1psifAAADTcHos7qSQrji3cQRvdhZEyJa' +\n            'a9OF/pUTGwEAAAEJawwO04GTmnyPT2hcnepKTWwqUe3rBlVwAAAAAQAAC0AAAAAsPIICeQAAAQlrDA7T' +\n            'Kd6Wv+nDz7vTAMDCu39sALbKiawBAAABJAr6aFtkUf/rcih9aUVHVigY+8UIy2/+QQAAAAEAAAtAAAAA' +\n            'MKx/EWUAAAEkCvpoW4oaIYhRvV3BULo9azzYYyKeeCxrAQAAA03cDnJSDjUiPbhnHIY/7aooMW/Y0Epe' +\n            'T58AAAABAAAWgAAAA03cDnJSAAADTdwOclKFF7HkvjRHt0g5nwPzP59X9Uge9wEAAAGGEgl7kg2aSBjn' +\n            '4A5Od5+0Lh5sBpm6dar7AAAAAQAAFoAAAAGGEgl7kgAAAYYSCXuSk87IwlS6e4YT+koCY6/lL28D3sYB' +\n            'AAACjIEYqGyFuGHIpbQDcibbuM8kkiHguhEKAwAAAAEAABaAAAACjIEYqGwAAAKMgRiobCUh+XSo0plb' +\n            '6NrVoCXHLwt7XzNZAAAAA1fLvw67icCbQBBXoglPtPMRkeln1StoiSYAAAACFc2B9ywrb3evyXkRn2lI' +\n            'r99+cUgwAipdwwEAAAPxDMrFsmKBEu04Bg6LEqHvrJj2ewKnZ3qmAAAAAQAAFoAAAAPxDMrFsgAAA/EM' +\n            'ysWyc3iG9qZDzL/uCLJEdhmwKaAHgIMBAAACPUMNm/Uu1vSoi1gBseNjIp1mp154Sw79UAAAAAEAABaA' +\n            'AAACPUMNm/UAAAI9Qw2b9YcCc88Iyrx0NUbMZOK3rJdc/ggmAQAAAnsptOZZhrhJa+5Z89rK+wkxjzUt' +\n            'hAHVfDoAAAABAAAWgAAAAnsptOZZAAACeym05lkhopvGoZgAsJ38XeT+KI6VFZ6HVQEAAAKZNR0cZ3N/' +\n            'V/VlAJ1g1vBkidPGJBfIBQZcAAAAAQAAC0AAAABu3i+EvAAAApk1HRxnwWGEqi7rwr6bZ9df8Uhr5cG3' +\n            'nAUAAAAB+ett5xJRyHYmu80aIhgssCKeD9KYKNlI+gEAAAHcmaAZJKAMxD+5u1O+u5ALn65VT4HGDIxw' +\n            'AAAAAQAAC0AAAABPbvAEMQAAAdyZoBkkTOyyimPzT9JghHBHVSBRqHTY6qMBAAABMiMv3v3Fqy0Rq/yO' +\n            'BHu3RlPy/l121QrKAwAAAAEAABaAAAABMiMv3v0AAAEyIy/e/TyTgfm1ATlfv11vqgZ2mGgLp5I3AAAA' +\n            'BB6+ivcGqPmcXVPR6jFzANQ/oHcfYAbWLCAAAAACEUzY24RQtw7fskPYnAuOCrVYvYWjy/Sq2QEAAAA1' +\n            'ejIu8T103OAjQ6dOO7R1qdl9voiJTyMzAAAAAQAAC0AAAAAI6bMH0wAAADV6Mi7xMF78LO+AmQt47Q2F' +\n            '8lJOtFmP+8sBAAADIrN3lvTLTPW10LenULSqINB8dhRMCjZoqgAAAAEAAAtAAAAAhciT7n4AAAMis3eW' +\n            '9PfpWIeCkAqinftTYf+jyT/iAxE2AAAAACtXQrrG1ENyC6MF0IZJhxjw1atz1xqHhPwBAAAAvi3c14rV' +\n            'Vkylvnz2LXDSnAd0Ap9o6EcHkwAAAAEAAAtAAAAAH7JPeUIAAAC+LdzXityvfksBfLlWNu3IzdEXOAKK' +\n            'juLqAAAAAWKGyagmDA2tPlgh/4bnCAHEUTy6X43XlxYAAAABpZApuaLoMq3LP2zjV1NWvIyyZ9WXhbjK' +\n            'rgAAAAOSnw31GpWdLCHuiuqqRiU+c6/7QpNNu415AQAAA/PO43ur9pEsqZCx+ctQ0uLZPiPcQtZ4AtoA' +\n            'AAABAAALQAAAAKiiez9IAAAD887je6ty7kyqfDlYpexa6zO61+OPc7PemgEAAAFVhN0jTzdIVM9Xza9g' +\n            'EHJEU/NTXLDe1iXFAAAAAQAAC0AAAAA463owjgAAAVWE3SNP895JOb/wZK4ieF/UWFZvxGiH5yMAAAAB' +\n            'WtMtyhV1iFBda1GZC0OkOSwt9AADUTkavAEAAAGLTWokGsi+QGXG5VciJh0XKhgY2Ffw3nFhAAAAAQAA' +\n            'C0AAAABB4jxbWgAAAYtNaiQaxyj4UkPRXmdB4RUJOmY0/+DGi2sAAAABmtptM00N3PW8TiZSDGq75w65' +\n            'ENAqIvV17gEAAAPVauIkr0eeRNW8s9uvLImxBON8OZc+nrJLAAAAAQAAC0AAAACjkdBbcwAAA9Vq4iSv' +\n            'LMTqFpsInyV7LXX07AVlLB4LwK8AAAACVOJQdF94lWhUD0pOtwPsSpOcOfVM4c3lYAEAAAJZhQlPED5v' +\n            'd70C9VJcR9E0/6kVRjND3chpAAAAAQAAC0AAAABkQNbigwAAAlmFCU8Q5+bT5k92M+EdyU87fjVCIOHg' +\n            'JvQBAAABLAh445G4HY/gCBp8Ww86DjZzqu2656S1WwAAAAEAABaAAAABLAh445EAAAEsCHjjkfGu/x1G' +\n            'ALyflu5s6H/RjA0uF2FJAQAAAfUQ1yISxqLt9R+tekR4gPOI6gjm8GCCewkAAAABAAAWgAAAAfUQ1yIS' +\n            'AAAB9RDXIhLmoPJPmFOfClWZtRtz8SIHZV+RYgEAAAGb6NZw6ik9LhWvYkCsjo753C4xml4yhuLkAAAA' +\n            'AQAAFoAAAAGb6NZw6gAAAZvo1nDq0lWfSarsXeQhGik+Wy00hFQPYNIBAAAC4wlfg1nMx6ncdUeIXQp/' +\n            'MHyEH0Q1GZoNiAAAAAEAAAtAAAAAeyw6leUAAALjCV+DWRJzvcMi6fQ+RMgH4p3thxoZkT3KAQAAAplo' +\n            'xifaQHmEokpWgPZUy2JkLz0fIsjxIz4AAAABAAALQAAAAG7my7FPAAACmWjGJ9ojMPo7C9y8Ib/ncXPh' +\n            'wUC60bh5vwAAAACNnQv2v4inBpnu2xVZInd7VAlMXKKdYgukAQAAApBN6CyLt+TdIz09e58DxUKFW4PK' +\n            '6+lckmcAAAABAAALQAAAAG1iUVzCAAACkE3oLIs/W2vCON/csGZ+BrXXzOfPf3+nwgAAAABdcEFzteZa' +\n            'aSm87wyRZwS2rvearhLJb0wSAQAAA5l3BvfWMZXszk+sOGOzYCH6Scso0530ACEAAAABAAAWgAAAA5l3' +\n            'BvfWAAADmXcG99Yn1+CSxVm0b9VEmdXSPU9MLZ6euQEAAACc7CZPBZWabWnc3dRvBQIYMyDgLCyx2AtM' +\n            'AAAAAQAAC0AAAAAaJ1u31wAAAJzsJk8FMsv+RNrEAeMhkxQQ7swlQm/MWcsBAAAEFqz9ZzfxBC8ZD/h5' +\n            'XbP5/TW158EyNFjtDwAAAAEAAAtAAAAArnIqO98AAAQWrP1nN9WW44AbwcH3rC9B0LDZEGH/6LGWAAAA' +\n            'A0/mTvNyq+e4MxN7UI6LWMDrHl4bIjVbRqkBAAAADwRE4OfGbkb1M4LvJTsug5Guwv4UipUglQAAAAEA' +\n            'AAtAAAAAAoC2JXwAAAAPBETg5xXn4XxmjRL8H7qyrMKtPOQ68d9gAQAAA+kpJjZRO8ds5r5Z15bsaAvU' +\n            'z1Hi+igym+wAAAABAAALQAAAAKbcMQkOAAAD6SkmNlFtNRkkOze3mxqbEGn8LmugDYG9AAEAAAIeKgo/' +\n            '6Q3VK9Fh4+5mvtU/qnCGKcL5eZe6AAAAAQAAC0AAAABaXFcKpwAAAh4qCj/pVkOr82XeobTRYSqMwBit' +\n            '+DK26L0AAAADExdE1KGweTGwMNtOUr0mkTMuJZPdUx/lFgEAAAIYnmRDO5Us7NZLbPKbfSqFz9Qcz12x' +\n            'p7EIAAAAAQAAC0AAAABZb7tgigAAAhieZEM7QJBbpsW5TySU3AOaRq0w6StqDbkBAAAAQYtUtY+neTkG' +\n            'p0FX3yBWlI9VfXL9rY2T0AAAAAEAABaAAAAAQYtUtY8AAABBi1S1j6CfjxyppAST/5j+yNsnpZ4mb+LM' +\n            'AQAAAwd7a4MeZabvmCauqJUxc/dnJt9Qdbu0C+sAAAABAAALQAAAAIE/PJXbAAADB3trgx6XwCRFCATy' +\n            '6PT5xzl/tTynPq+pVwEAAAP3RVI223cMsae0V7OPJkgsuqVbHiDuSfwpAAAAAQAAFoAAAAP3RVI22wAA' +\n            'A/dFUjbbqciNZ2beiMn+kVcprmWvCo0qNNYAAAAAp/x8AiuP0gOSmGXc+PyW+ma3l4h07YsKpAEAAAKh' +\n            'uMUSlEiZItBpeLfj6hIFvBR6t0/1Zyh2AAAAAQAAFoAAAAKhuMUSlAAAAqG4xRKUMbR0l40dlxXJiTEF' +\n            'uHD29zmRDB8BAAAC0qDOUYnujJP0QRa7dQ2AJ0h1cIE0IkEehgAAAAEAABaAAAAC0qDOUYkAAALSoM5R' +\n            'iepA5phgkMYQo9vghvEMs6W2EXiXAQAAAsKfyTSX6ZAOU+orXNxOz0wdBuAqVHbOiV0AAAABAAAWgAAA' +\n            'AsKfyTSXAAACwp/JNJcBVoZ5gIarGpvmG5G4a1OXW3821QEAAANETmvLWBcBCeyCAd6ZLaV8GnQ8Da54' +\n            'gAyrAAAAAQAAFoAAAANETmvLWAAAA0ROa8tY+JrQTn9k06PB7If9N0CfYchk/C0BAAACrhSVuS2ezk3S' +\n            'ZrOTLlI6dWuGTC76mwagfAAAAAEAAAtAAAAAcljDnt0AAAKuFJW5LYlQAlhiQPsfkWnHfepiRbygaVcw' +\n            'AQAAAbh/Gb8NJqE45Cy7l+FzX6ekgF3R/5Mtr+4AAAABAAAWgAAAAbh/Gb8NAAABuH8Zvw0P094GHr/6' +\n            'AsV1AwxF7c61Qq2RSAAAAAJQwqsff2pLw8MLHSdj/TYI/vua9S1qFloyAQAAAZMy1gvR0p1S/3oRAOZ8' +\n            'nDanLv73M3Fv150AAAABAAAWgAAAAZMy1gvRAAABkzLWC9F4DlJe82PbL79kI4++HW6Glhr8OAEAAAAc' +\n            'Kk11+SFNxI4R9S/ebQHQO2V5jHpCMS1hAAAAAQAAC0AAAAAEsbeTqgAAABwqTXX5sSvBMuNoUTbS19Um' +\n            'etiaDp8t/vsBAAABkaKnSL2M6hWXx8/DUkVUtGxAV3Xd9gtcfAAAAAEAABaAAAABkaKnSL0AAAGRoqdI' +\n            'vTi9K8WL24O90wK1LIuwvNvkRR9iAQAAAQ5MDkLw77e4PHxSapULV3EHaCWnRV0ELfQAAAABAAAWgAAA' +\n            'AQ5MDkLwAAABDkwOQvB45gZiCw5zStBMXeShepM6iLltkgAAAAHfl0LN8u7wC1h8uhyRIY5s1I1gZPfF' +\n            '1qn+AAAAA8xCKTupigAMUEItvNB1XfJi5d20TA4oijkBAAABheDAya/Vr7/+aeXTjjrLIAY/8G9+ps7j' +\n            'DAAAAAEAAAtAAAAAQPrKzEgAAAGF4MDJrySGgRI77yf0Ksrs7U5YU1v43lFrAAAAAkrmY2OrF77xscYd' +\n            'oQqK/Kr8Sc5nR/w91goBAAADoIlPx03C0gM7wMgvzaUglns4BJzvq8fWUQAAAAEAABaAAAADoIlPx00A' +\n            'AAOgiU/HTR059QJNJ6egySnjQ5ssU/g987fwAQAAAOSjwgS4txd+4xsScIOZ2jJ8gm6PFGb4IPcAAAAB' +\n            'AAALQAAAACYbSwDKAAAA5KPCBLgEEiPQ5L80JKvaQkZUqVTQVFocRQEAAAAgrZivoOKiOJFwOp94dsp2' +\n            'dceiRnJRp2BDAAAAAQAAC0AAAAAFckQdRgAAACCtmK+gCouuvquET79GQpJvlDjxodZmWlIBAAADdflm' +\n            'IVtOxwzhUy9DP2U/1dg443ziW+44fAAAAAEAAAtAAAAAk6mRBZAAAAN1+WYhW7W78iEqRWPDm9L0+nV1' +\n            'sgxvC7aAAAAAAnjT5GbwylWQC2KwtxExw7D10y49vKcooJ0AAAADf6VG1QRSW6oEqsV40bK3bkmqzoXd' +\n            'ot6i4gEAAAEy6r22pwWExn95sjo6xoCdI0e/eYKD/GftAAAAAQAAFoAAAAEy6r22pwAAATLqvbanD5Iv' +\n            '+2lMo8wGu38cLQnhQWGpZEoBAAAB3Wk4Pnb/keSDfMbiKmBGXEB/R75Sm81yZQAAAAEAABaAAAAB3Wk4' +\n            'PnYAAAHdaTg+dlD3NG/nQX9YueouG07G0GevJx2cAQAAASDQ25ZqoHTmauLeC1uxbbJc9puYK7ibUGQA' +\n            'AAABAAAWgAAAASDQ25ZqAAABINDblmrDxe/R9ACThqXry6xBd28gwzmBbAAAAAA3JtwFy7gOad2nnAuf' +\n            '4c9a2JDr8h65bBqxAQAAApIfgNiYaB9nad26DD093xiYPxcQq2fLUB0AAAABAAALQAAAAG2v6s7EAAAC' +\n            'kh+A2JhP0wpVAIQo7aaYGJz1q+BQ/JvaAQEAAAELaF0K71KfkeqRPM7T8QipPJ8FVXyve5YUAAAAAQAA' +\n            'FoAAAAELaF0K7wAAAQtoXQrvJ/jj56GUsaHxN9mDMXP5RsX08l8AAAADE1QMtlVNL/Tr3lfTfZGZ4SRd' +\n            '7Ko1EbsleAEAAAKN3l0bwt3bQiKYf+QXt0o8YjRC4DeZwDgRAAAAAQAAC0AAAABs+mTZ9gAAAo3eXRvC' +\n            'VJEHZ0qy+F1pvTVulg0P1CdMCToAAAACfGL6o0cNbRO/RL5C/tljM1b4X9GibgKJhgEAAAPEPtTYFS70' +\n            'hIR9vGG5Bss2KK0fyL/Q7ZfwAAAAAQAAFoAAAAPEPtTYFQAAA8Q+1NgVjxMxbNwbSqmxFnDEgA2J2Io6' +\n            'Q14AAAAB0Fl8OgAV2mEYfjb3jRucPYtRg9szNOY5LAEAAADjj9fBEDJIdjKxmX0e1aiPEla5rtes80Lh' +\n            'AAAAAQAAC0AAAAAl7U6gLgAAAOOP18EQBkYuU4gvkHTrVpgVrymqlmeIV3cBAAAA2NjC3v910c484H8c' +\n            'iZmr9lYIo66SCeFyQwAAAAEAAAtAAAAAJCQgeoAAAADY2MLe/1PF67K3QcuQJ+m4P7tOiIrVmdFhAQAA' +\n            'AukCHDJUZrnHmLoVULR6r8HDBaygNH/gNE8AAAABAAAWgAAAAukCHDJUAAAC6QIcMlS4diPveIAR8ciq' +\n            'f6WfLVCvxGQ1MQAAAAJlQHbfixmoGC8hAefMDjnblFS989zLCxhKAQAAA+519/AhViOdiXDAAdtc5/ue' +\n            'TM0syon8VYoAAAABAAAWgAAAA+519/AhAAAD7nX38CH0clyiOijE/jV+sOwm6ZB5i5GvYQEAAAGy/GNM' +\n            'TQyzah076TeqMT+jyMJhGgese8vbAAAAAQAAC0AAAABIf2XiDQAAAbL8Y0xNr/JNzMvTszgQcqMcDBEz' +\n            'tfKONfgAAAARpIlShW0='\n    },\n\n    'bounty': {\n        NETWORK_ID: 3,\n        NETWORK_NAME: 'bounty',\n        SEED_PEERS: [\n            WsPeerAddress.seed('bug-bounty1.nimiq-network.com', 8080, '7e825872ee12a71bda50cba9f230c760c84ee50eef0a3e435467e8d5307c0b4e'),\n            WsPeerAddress.seed('bug-bounty2.nimiq-network.com', 8080, 'ea876175c8b693c0db38b7c17d66e9c510020fceb4634f04e281af30438f8787'),\n            WsPeerAddress.seed('bug-bounty3.nimiq-network.com', 8080, '5c0d5d801e85ebd42f25a45b2cb7f3b39b9ce14002d4662f5ed0cd79ce25165a')\n        ],\n        GENESIS_BLOCK: new Block(\n            new BlockHeader(\n                new Hash(null),\n                new Hash(null),\n                Hash.fromBase64('nPcJa/7i0KYsiPQ8FPOgvLYgpP3m05UMwPfIPJAdAvI='),\n                Hash.fromBase64('sXZsIZDV40vD7NDdrnSk2tOsPMKKit/vH0xvz1RXmQo='),\n                BlockUtils.difficultyToCompact(1),\n                1,\n                1522338300,\n                67058,\n                BlockHeader.Version.V1),\n            new BlockInterlink([], new Hash(null)),\n            new BlockBody(Address.fromBase64('AAAAAAAAAAAAAAAAAAAAAAAAAAA='), [], BufferUtils.fromBase64('Qm91bnR5TmV0'))\n        ),\n        GENESIS_ACCOUNTS:\n            'AGROsO8mYpEUdwzEGQ0O6vnlpVKChwEAAAPgjSSR4LB4qqj8ygd5C6xKRfXafhN7T5fmAAAAAQAAC0AA' +\n            'AAClbNttpgAAA+CNJJHgvj7dWIwWkgYczXTXDMe9WDwe7PIAAAABuvV0Xzr7uF1SMm0j0okevxuwhMCF' +\n            'RbOerwEAAAAzj75naNS5u7vg6bLNCTc+tc++nDMzSMxcAAAAAQAAFoAAAAAzj75naAAAADOPvmdoLCur' +\n            'wI3RXio3O082uOONNCaOL5EAAAAArvAV+ORfFg1aBKGWGk19uDxpWkV+fiIkWwEAAAJR5PbT4MvZdtuH' +\n            'jLiimcdnhbNI6TKH2m4GAAAAAQAAC0AAAABi+354pgAAAlHk9tPgpgOUfVePZWnuO69XlvZf8BzHjTsA' +\n            'AAACuA/6/UZ+myPLTv0rQR48yVjdYBj+xnx0gQEAAAH38jLPmHhUCPYh7IdSdeq5grLJ7N3/9k7oAAAA' +\n            'AQAAC0AAAABT/bMimgAAAffyMs+YTpbsTx+qRTynShhe/OncI3F8UJUBAAACY7QNrF0kaFoknkqcBjWI' +\n            'NhgkiICcLaGFqQAAAAEAABaAAAACY7QNrF0AAAJjtA2sXYy5yceBWd2UZHzOlLJ8bJT3XnkiAQAAAet+' +\n            'mSFo/V6xEWOKhdqqy8rbsGtb0IpSTjsAAAABAAAWgAAAAet+mSFoAAAB636ZIWisTPQqBlMhdavdoB1d' +\n            'Jg4hNeIzSQAAAAM9NgN2R9lbltBpK4dHZ0tyJFuWFqFXycS6AQAAABDdCzYOg7v1ZL/YGtYz6n/pqZ7k' +\n            'BscS9EAAAAABAAALQAAAAALPgd5YAAAAEN0LNg4jeClst35OziQr18E8ongjqdUwkAAAAACSi46KoSGZ' +\n            'ZZgRFEG1UmNVvuGnXlr/p8tLAAAAAo2Y+VdN6KsTS3g0BfG/5A2WO23wvPTR1wQBAAAABjp3o4OXWcPN' +\n            'eS7zgUtJ1ZtdWMlPrUCjQQAAAAEAABaAAAAABjp3o4MAAAAGOnejg0HbqTyPwzbBbmZKac+AJldb1K8S' +\n            'AQAAA2xCJZEUiCvMiRHOWl0TPvfiopaGoWuy/1MAAAABAAAWgAAAA2xCJZEUAAADbEIlkRSW5uOyFaGB' +\n            'eE9iLFclv4dkn0b8hAEAAAAaof6tJK4CoBvPyIm5zYNslaFa0I0DAXdNAAAAAQAAC0AAAAAEcFUc3AAA' +\n            'ABqh/q0k7md7N7SMnce8u1qZ7zza/iG1Tn4AAAAC2fbY76DyEhIrSQASeAudDPtSCBr5cZuxUwEAAADk' +\n            '0kARBJH5qFOo09UHXzNlMp6yjMHoBVicAAAAAQAAFoAAAADk0kARBAAAAOTSQBEEBGm9ERoB+XwvUDmC' +\n            'og0GIMYSA/0BAAACzQJNz/Z6A5yDJeNdyNSW1L+irfZN+NpYRQAAAAEAABaAAAACzQJNz/YAAALNAk3P' +\n            '9grte35IRZZFznMf1gpDH0fsbgh6AAAAANIlCqNKBUnIybVhKsuJHiMrgaeH+72CipcAAAAArp3v7lub' +\n            'ymFcF+x8X6sQer1ayMp1jrlWiwEAAAQQfjLXJ7IS3Zq3na6MsYcufha2Tm5gvr2xAAAAAQAAFoAAAAQQ' +\n            'fjLXJwAABBB+Mtcn5XPFpovekv8bgRGTV2LSeiZleJUAAAACXoxQT4M7+VL2b5FDeiL8Y1dHlO1boy19' +\n            '6AEAAAOcBs1QJwsPNgV1uujn9YRrWXf23JR0QKsvAAAAAQAAC0AAAACaASI4BwAAA5wGzVAnhdNFqitT' +\n            '85qR1j+u1sme41jJRfkAAAAC6ttvlJrkUQTtZt4IVpXGMPPbiOARbrgajgAAAAHVpCh2w6PvV+HiS5PL' +\n            '5s4wdjHd6qKO6i8PAAAAA2qxFnjjJl5FHtoCQxEJfO0uyXaCj9MG+OkBAAADFiD2hCtcPDqv69GPrUF7' +\n            'J1ufmM68/Ru99gAAAAEAAAtAAAAAg7ApFggAAAMWIPaEK5BnIwlb6NRmmDQzimYNOTKOVNPjAAAAAY1F' +\n            'x02zSd3uF8Vj4S/TaoBuM///DSp0gSwAAAADZ5wnyoHktQhKTfw0OpLTgiwg53rMarO+LQEAAAJflxqP' +\n            'fHUakyXzvQFuqMGCr6xa8pbx1MG2AAAAAQAAFoAAAAJflxqPfAAAAl+XGo98TtdEztipo0zyipnMocYl' +\n            'e2VSHzsAAAAB8OIqY4ZJ40Xz0UiBI4UHWjeUanUuMMH5qwEAAAIKm7AwSvDbPaXscFKMfNoshmPOuji4' +\n            'FyTgAAAAAQAAFoAAAAIKm7AwSgAAAgqbsDBKluoH0jINLWuByiQ+CAG3gMo+8JgAAAAA1uRP/GEF1BOx' +\n            '7I2paX5fa/wEkQDcMJcCTQEAAAH5Z+cQz7kBi6Rgajd3MHk58AA3NwBGMyJiAAAAAQAAC0AAAABUO/vY' +\n            'IwAAAfln5xDP/3+ug/4aXTjAo5YwpNMt+nZ+lB0AAAAC4xiGzk8p0EDsMgk7BZ2Lp/Ipqs/8QkvT6wEA' +\n            'AAGe+TeyjXZtAVYZPw0/Wm+gH1sTuonDC+zdAAAAAQAAFoAAAAGe+TeyjQAAAZ75N7KNxcAvQyI0dTnE' +\n            'OU4b5XGOOLIXrOYBAAADvPpJRzblSEO08l6xF6oGQvBQPB7VBBg0cwAAAAEAAAtAAAAAn38MNokAAAO8' +\n            '+klHNocR7UAAXunjaoZ8raL1kqQqMhaBAQAAA8avedwClf/LVcuz9RkrElWM+SyAjp8k+1sAAAABAAAL' +\n            'QAAAAKEdPvoBAAADxq953ALOttlrLzsnbOrQj8LjeGNjY8MCmAEAAAEeregRRXA2d50cqQgJcXF4rsQ1' +\n            'Iy0wCdkPAAAAAQAAC0AAAAAvx6atjAAAAR6t6BFF5pw0DA0RHO6/7cAqKwohgusbMJ4BAAABnR1KdPep' +\n            'yuvGAvBWqAB0Mij3qHXgmM3pQgAAAAEAABaAAAABnR1KdPcAAAGdHUp092IPe5Uo8L6bEBfIcBszCCaU' +\n            '3ZCFAQAAAlApip6i7sSV9Xf/cZOWcSnR3lvQ6qnjYiEAAAABAAALQAAAAGKxlxpxAAACUCmKnqLHZ87+' +\n            '742b7VCY+mdcXgUivnErUQEAAAJc6SBPCXsPV1cyJmrWJbyix0y0MGvNdAxnAAAAAQAAC0AAAABk0YVi' +\n            'ggAAAlzpIE8JJhdSTzJWBddPXWISNCnXKQbdSOEAAAAAshscJDuUrLmff96PmMXSHjv6iLnuakcuEQEA' +\n            'AAF3oHpkI8BjHIpOQcNWshd7j/h9mICI5myBAAAAAQAAC0AAAAA+mr8QsQAAAXegemQjbgkIzm9ttUga' +\n            'Xm481y+qKRjSeqwBAAAB7DzablqAf2gbs+/9SYhcADbIRJbS7G3c+QAAAAEAABaAAAAB7DzabloAAAHs' +\n            'PNpuWtJEhwUaSZ9Tg+yvkFZ242oTVaxrAQAAA8zovmmlJrUqvQ9XKD75Ql3t/wHtYw/hqi4AAAABAAAL' +\n            'QAAAAKImymbxAAADzOi+aaUscN6LWAC41YIiEiyUFT4nl8DbwwEAAAJrqfvqURra+7HArgPHeoZuZGfB' +\n            'nZxo4oZcAAAAAQAAC0AAAABnRv9RuQAAAmup++pRZ77cbnKDpVQw4BL39bEWeOSwHw0AAAACC47Ibf40' +\n            'xdAvwpS6spKJEDfGUOP0dfLvNgEAAADExu0Of/wIe/ktutHQJVsqBotvETusEBk8AAAAAQAAFoAAAADE' +\n            'xu0OfwAAAMTG7Q5/npgGH2YQ5O69Zb8InpcJ+3Xb3hMAAAABGivkj2P3t+w3wcJlDbqHHLeZjaGprCzm' +\n            'FwAAAAFfg6V+9IxjkTpCkTZ2heqwjjcQb3GjCEZTAQAAAZIMcUVqJ0k1ifmmNQt79Rs1dX0L2Mq+MloA' +\n            'AAABAAAWgAAAAZIMcUVqAAABkgxxRWp9VLAV2l/GjEWTAZzpxeDaUsxNkgEAAAN2uVrw4g9W2DDeukSz' +\n            'TyLxYqm5KFcw72fJAAAAAQAAFoAAAAN2uVrw4gAAA3a5WvDii7RScEJSU1x6ZmCL5M3F50xRHfQAAAAC' +\n            '+CK5BiiMrHZJ7TrhEFQ8n0YRfoLMUczX2QAAAAJNvBcYruLQJ2TltxpinmOSf13f+cXn3J3jAAAAA5w4' +\n            'C/BjVTkfE0Phx+Rb2fsm3J8RI3wFwTsBAAAAC+MMUH8dzPNaHQGQKnjqTKs7aWbbdH7dEwAAAAEAAAtA' +\n            'AAAAAfssuBYAAAAL4wxQf4FwpwRoMuHItz9YGBRc6x1o3amtAQAAACwQMTvDUlbrOHxQG5guU3iG0q9/' +\n            '+CrDFXMAAAABAAALQAAAAAdYCDShAAAALBAxO8MhD4gQOrLQfWJGyCsI5ZUmVdh8pQAAAADdRRBrv3G4' +\n            'F2Tq3ImF+xUVZz2gqjVpGdAaAQAAAZYf2OJvN1smnhwcM8c/aZznmfFtvxDRU9gAAAABAAAWgAAAAZYf' +\n            '2OJvAAABlh/Y4m8eR91nBeBI9qdg1mlPf8ZIzFLPmQEAAAI3vx7Pa5ty9e+2jB6gL+lO95IuG4TdDN1v' +\n            'AAAAAQAAFoAAAAI3vx7PawAAAje/Hs9rgCRUm9RKMk+J4Mqy1pCGgnExdFcAAAAAUWefBW7kQ4xPetD+' +\n            '/je2JzS83YLr60juHAEAAAGA5ARRy0KuCQ/K40H+qr7fyuDRlNACqSihAAAAAQAAC0AAAABAJgC4TQAA' +\n            'AYDkBFHLlRXf6DznkAPPYQG5bSgjCxCB6WIBAAAB0PAwzsvj1VjB3iefUVXm0uENgye1iH8GWgAAAAEA' +\n            'ABaAAAAB0PAwzssAAAHQ8DDOy2SmQ0XvARmN17wy1azFVYOFl8LmAAAAAuymvWJbap1uaBnvqo22bGoC' +\n            'cg9XRK1olasAAAAA/lMYYTxyjHLVR/Pxkp4el+dp5sGYw2CyNwAAAANzjeaeP6Vn5Qo6zPTuJbEby9W8' +\n            'yGOUlpj0AAAAAGJvsBrGU9LXiImw0pNsAfYsGPpChDfzxqUAAAACnha01XkWHT3K98ZVf4qFZ+eVZk69' +\n            'HXgTZAAAAADG+hJMiXbLXYotByvgurHAZkCIfeoD4j/GAQAAAnwS195BXMR4RF6S2HEut98KOu46WyAn' +\n            'MgUAAAABAAAWgAAAAnwS195BAAACfBLX3kGB7YYZXaVHVYpvlS5pPB0rTmAdhgEAAAOw7V2WAkTXOeZB' +\n            'hAQ3gO4hKDzaPoI/obIIAAAAAQAAFoAAAAOw7V2WAgAAA7DtXZYCexCLXdJmUo3et6zTrM4JHLAHvHcB' +\n            'AAAAo52G7qeniYMBQPn2IGmF4SyZvtqO5T3j8QAAAAEAAAtAAAAAG0Tr0nIAAACjnYbup/82u4K2pI3Z' +\n            'h8SrLR0y1SaJZ5l2AQAAAM0wkaKTtJYt5lBGk9KdUOfTPfmHPMJYvIwAAAABAAAWgAAAAM0wkaKTAAAA' +\n            'zTCRopP8K2cAplRi+V/cwUxuZsSR4QZlJQEAAAFrnAUfbjFv4oFVJrnxAqoTAfT+ir0cddG8AAAAAQAA' +\n            'C0AAAAA8mgDakwAAAWucBR9uS6QEmO4u5Y4uSMXTZDH8ysKkgeUAAAABJql00I3a+i/3sQxVGNO8jvSH' +\n            'NvKIDDwpCAAAAAG5PG0zfZL63kNtVx8yC/1rU/YJ+beMCq/MAQAAAfyrrlYeV08n7pDCSKBTHhoQtuof' +\n            'LbLc5vIAAAABAAAWgAAAAfyrrlYeAAAB/KuuVh6t32k0jFALkuXmJTd3CVbsSVqr9gAAAAJGVwd4qfoE' +\n            '4hQZ0AIEtzoGqvhfroylPD7hAAAAATCkdqWwldyF7Ow6kOLADIO7fufoY/2MCtwBAAADn+uup3jSsj0K' +\n            '3MSzvXONYK4E0E+ydYu0MQAAAAEAABaAAAADn+uup3gAAAOf666neJlIQtZB2w+EQBPHLR9hU4c7Pc8p' +\n            'AQAAAHrMSxVGaFi1A/Bg67LMchAQLHHATlbxJ1oAAAABAAALQAAAABR3YdjhAAAAesxLFUaL9KQCAqp4' +\n            'Q5SOagEaGjf7lDpynQAAAABBumWs5OROJv8K/JWHN97QVURIoPj96+bXAQAAAzOvVCYV6OmPb3ZVZhDT' +\n            'huOTXPAGcUPCMUAAAAABAAAWgAAAAzOvVCYVAAADM69UJhWOjYkDOqh2GLtyhACzalkqt6i5GAAAAABk' +\n            'HOEzHn2NueFUN/i1nufAJm5Ac7Whv/IvAQAAAnaJFcF5fLjdbjLqfgEZqSxvEzn1UcW6XekAAAABAAAL' +\n            'QAAAAGkW2PWVAAACdokVwXmQSClXUuSIAuzoqKB4jFwZAJuMdgEAAAHsD0/gGtLI0Rhf68pXNo8w6tke' +\n            'Dbl7/leEAAAAAQAAFoAAAAHsD0/gGgAAAewPT+AaCOUy0dRimkU3sK1J9IqLyEwVekoBAAAD1asYkCaI' +\n            'LiY2H+HviJLKv8bvJpZp3yEU5AAAAAEAAAtAAAAAo5yEGAcAAAPVqxiQJviZYUNe7PwjCxRRwmdn2qbL' +\n            'ShqZAQAAAj7b2zm/blSYRSUbnvVCJTGqqdqvIGdeXlIAAAABAAAWgAAAAj7b2zm/AAACPtvbOb9X+fT7' +\n            '4TMZImyXLXIuIgWFUyD5uAEAAAIPegL2Y5UScwJ9ZTWVekf09n4XUKQhwkvjAAAAAQAAC0AAAABX6asp' +\n            'EQAAAg96AvZjv7BLmwd9zQiXxIRalCtzU+r8G3wBAAAEBj9a7W52WYLujJxZpIibUJZrq7ka4SDDEQAA' +\n            'AAEAABaAAAAEBj9a7W4AAAQGP1rtbvPLOoPC9Vea1GXBedP3t7MHPoMsAQAAAgBURMd+ePmpTRjQCgCi' +\n            '5pVFGkD2qs/bOPIAAAABAAAWgAAAAgBURMd+AAACAFREx35sf7kDiNf4hPKBPARdgY4/AAtsaAEAAAEI' +\n            'I2jMolR1W14pluv9x/6myqzxn3ZUEenzAAAAAQAAFoAAAAEII2jMogAAAQgjaMyiEIZJWfKO8Y1GoDU9' +\n            'rEsVumVGFgEAAAABDnO2+5f7Yo9xYe4kL5omlRWQaOFVp1fkRwEAAABQ82mtvY9XMFguE8guQcqN7PcZ' +\n            'aP59u73nAAAAAQAAFoAAAABQ82mtvQAAAFDzaa29HbkxrjlvrxypwVCKBXGLscWZxBsBAAACbbcPl4DZ' +\n            'q3f07ciGYXAPXG+EQbptqwEXgAAAAAEAAAtAAAAAZ56CmUAAAAJttw+XgKh3+qgc1B4nsn6iKBWKH8/1' +\n            'k3DaAQAAAygH/3wfau3GDF2ltpK1zQVT/YbUHG1O6BUAAAABAAAWgAAAAygH/3wfAAADKAf/fB8SWgnh' +\n            'KY7eEBq1dn7EdblSHhwwiAEAAAMiqJ4ySyyTQbUeHOhqhls8J6pSa9FOTdORAAAAAQAAC0AAAACFxsUI' +\n            'YgAAAyKonjJL13wA6mHCW2/OQD28IMlARXIpkYABAAAiUPS1kYdh8z8IT9HgqMC1auELaAZIShQtEgAA' +\n            'AAEAAAtAAAAFuCjI7ZcAACJQ9LWRhw=='\n    }\n};\n","class CloseType {\n    /**\n     * @param {number} closeType\n     * @return {boolean}\n     */\n    static isBanningType(closeType){\n        return closeType >= 100 && closeType < 200;\n    }\n\n    /**\n     * @param {number} closeType\n     * @return {boolean}\n     */\n    static isFailingType(closeType){\n        return closeType >= 200;\n    }\n}\n\n// Regular Close Types\n\nCloseType.GET_BLOCKS_TIMEOUT = 1;\nCloseType.GET_CHAIN_PROOF_TIMEOUT = 2;\nCloseType.GET_ACCOUNTS_TREE_CHUNK_TIMEOUT = 3;\nCloseType.GET_HEADER_TIMEOUT = 4;\nCloseType.INVALID_ACCOUNTS_TREE_CHUNK = 5;\nCloseType.ACCOUNTS_TREE_CHUNCK_ROOT_HASH_MISMATCH = 6;\nCloseType.INVALID_CHAIN_PROOF = 7;\nCloseType.RECEIVED_WRONG_HEADER = 8;\nCloseType.DID_NOT_GET_REQUESTED_HEADER = 9;\n\nCloseType.GET_ACCOUNTS_PROOF_TIMEOUT = 11;\nCloseType.GET_TRANSACTIONS_PROOF_TIMEOUT = 12;\nCloseType.GET_TRANSACTION_RECEIPTS_TIMEOUT = 13;\nCloseType.INVALID_ACCOUNTS_PROOF = 14;\nCloseType.ACCOUNTS_PROOF_ROOT_HASH_MISMATCH = 15;\nCloseType.INCOMPLETE_ACCOUNTS_PROOF = 16;\nCloseType.INVALID_BLOCK = 17;\nCloseType.INVALID_CHAIN_PROOF = 18;\nCloseType.INVALID_TRANSACTION_PROOF = 19;\nCloseType.INVALID_BLOCK_PROOF = 20;\n\nCloseType.SENDING_PING_MESSAGE_FAILED = 22;\nCloseType.SENDING_OF_VERSION_MESSAGE_FAILED = 23;\n\nCloseType.SIMULTANEOUS_CONNECTION = 29;\nCloseType.DUPLICATE_CONNECTION = 30;\nCloseType.PEER_IS_BANNED = 31;\nCloseType.MANUAL_NETWORK_DISCONNECT = 33;\nCloseType.MANUAL_WEBSOCKET_DISCONNECT = 34;\nCloseType.MAX_PEER_COUNT_REACHED = 35;\n\nCloseType.PEER_CONNECTION_RECYCLED = 36;\nCloseType.PEER_CONNECTION_RECYCLED_INBOUND_EXCHANGE = 37;\nCloseType.INBOUND_CONNECTIONS_BLOCKED = 38;\n\nCloseType.MANUAL_PEER_DISCONNECT = 90;\n\n// Ban Close Types\n\nCloseType.RECEIVED_INVALID_BLOCK = 100;\nCloseType.BLOCKCHAIN_SYNC_FAILED = 101;\nCloseType.RECEIVED_INVALID_HEADER = 102;\nCloseType.RECEIVED_TRANSACTION_NOT_MATCHING_OUR_SUBSCRIPTION = 103;\nCloseType.ADDR_MESSAGE_TOO_LARGE = 104;\nCloseType.INVALID_ADDR = 105;\nCloseType.ADDR_NOT_GLOBALLY_REACHABLE = 106;\nCloseType.INVALID_SIGNAL_TTL = 107;\nCloseType.INVALID_SIGNATURE = 108;\nCloseType.RECEIVED_BLOCK_NOT_MATCHING_OUR_SUBSCRIPTION = 109;\n\nCloseType.INCOMPATIBLE_VERSION = 110;\nCloseType.DIFFERENT_GENESIS_BLOCK = 111;\nCloseType.INVALID_PEER_ADDRESS_IN_VERSION_MESSAGE = 112;\nCloseType.UNEXPECTED_PEER_ADDRESS_IN_VERSION_MESSAGE = 113;\nCloseType.INVALID_PUBLIC_KEY_IN_VERACK_MESSAGE = 114;\nCloseType.INVALID_SIGNATURE_IN_VERACK_MESSAGE = 115;\nCloseType.BANNED_IP = 116;\n\nCloseType.RATE_LIMIT_EXCEEDED = 120;\n\nCloseType.MANUAL_PEER_BAN = 190;\n\n// Fail Close Types\n\nCloseType.CLOSED_BY_REMOTE = 200;\nCloseType.PING_TIMEOUT = 201;\nCloseType.CONNECTION_FAILED = 202;\nCloseType.NETWORK_ERROR = 203;\nCloseType.VERSION_TIMEOUT = 204;\nCloseType.VERACK_TIMEOUT = 205;\nCloseType.ABORTED_SYNC = 206;\nCloseType.FAILED_TO_PARSE_MESSAGE_TYPE = 207;\nCloseType.CONNECTION_LIMIT_PER_IP = 208;\nCloseType.CHANNEL_CLOSING = 209;\n\nCloseType.MANUAL_PEER_FAIL = 290;\n\nClass.register(CloseType);\n","class NetworkConnection extends Observable {\n    /**\n     * @param {DataChannel} channel\n     * @param {number} protocol\n     * @param {NetAddress} netAddress\n     * @param {PeerAddress} peerAddress\n     */\n    constructor(channel, protocol, netAddress, peerAddress) {\n        super();\n        /** @type {DataChannel} */\n        this._channel = channel;\n\n        /** @type {number} */\n        this._protocol = protocol;\n        /** @type {NetAddress} */\n        this._netAddress = netAddress;\n        /** @type {PeerAddress} */\n        this._peerAddress = peerAddress;\n\n        /** @type {number} */\n        this._bytesSent = 0;\n        /** @type {number} */\n        this._bytesReceived = 0;\n\n        /** @type {boolean} */\n        this._inbound = !peerAddress;\n\n        /** @type {boolean} */\n        this._closed = false;\n\n        /** @type {*} */\n        this._lastError = null;\n\n        // Unique id for this connection.\n        /** @type {number} */\n        this._id = NetworkConnection._instanceCount++;\n\n        this._channel.on('message', msg => this._onMessage(msg));\n        this._channel.on('close', () => this._onClose(CloseType.CLOSED_BY_REMOTE, 'Closed by remote'));\n        this._channel.on('error', e => this._onError(e));\n    }\n\n    /**\n     * @param {Uint8Array} msg\n     * @private\n     */\n    _onMessage(msg) {\n        // Don't emit messages if this channel is closed.\n        if (this._closed) {\n            return;\n        }\n\n        this._bytesReceived += msg.byteLength || msg.length;\n        this.fire('message', msg, this);\n    }\n\n    /**\n     * @param {*} e\n     * @private\n     */\n    _onError(e) {\n        this._lastError = e;\n        this.fire('error', e, this);\n    }\n\n    /**\n     * @param {number} [type]\n     * @param {string} [reason]\n     * @private\n     */\n    _onClose(type, reason) {\n        // Don't fire close event again when already closed.\n        if (this._closed) {\n            return;\n        }\n\n        // Mark this connection as closed.\n        this._closed = true;\n\n        // Propagate last network error.\n        if (type === CloseType.CLOSED_BY_REMOTE && this._lastError) {\n            type = CloseType.NETWORK_ERROR;\n            reason = this._lastError;\n        }\n\n        // Tell listeners that this connection has closed.\n        this.fire('close', type, reason, this);\n    }\n\n    /**\n     * @param {number} [type]\n     * @param {string} [reason]\n     * @private\n     */\n    _close(type, reason) {\n        // Don't wait for the native close event to fire.\n        this._onClose(type, reason);\n\n        // Close the native channel.\n        this._channel.close();\n    }\n\n    /**\n     * @return {boolean}\n     * @private\n     */\n    _isChannelOpen() {\n        return this._channel.readyState === DataChannel.ReadyState.OPEN;\n    }\n\n    /**\n     * @return {boolean}\n     * @private\n     */\n    _isChannelClosing() {\n        return this._channel.readyState === DataChannel.ReadyState.CLOSING;\n    }\n\n    /**\n     * @return {boolean}\n     * @private\n     */\n    _isChannelClosed() {\n        return this._channel.readyState === DataChannel.ReadyState.CLOSED;\n    }\n\n    /**\n     * @param {Uint8Array} msg\n     * @return {boolean}\n     */\n    send(msg) {\n        const logAddress = this._peerAddress || this._netAddress;\n        if (this._closed) {\n            return false;\n        }\n\n        // Fire close event (early) if channel is closing/closed.\n        if (this._isChannelClosing() || this._isChannelClosed()) {\n            Log.w(NetworkConnection, `Not sending data to ${logAddress} - channel closing/closed (${this._channel.readyState})`);\n            this._onClose(CloseType.CHANNEL_CLOSING, 'channel closing');\n            return false;\n        }\n\n        // Don't attempt to send if channel is not (yet) open.\n        if (!this._isChannelOpen()) {\n            Log.w(NetworkConnection, `Not sending data to ${logAddress} - channel not open (${this._channel.readyState})`);\n            return false;\n        }\n\n        try {\n            this._channel.send(msg);\n            this._bytesSent += msg.byteLength || msg.length;\n            return true;\n        } catch (e) {\n            Log.e(NetworkConnection, `Failed to send data to ${logAddress}: ${e.message || e}`);\n            return false;\n        }\n    }\n\n    /**\n     * @param {Message.Type|Array.<Message.Type>} types\n     * @param {function()} timeoutCallback\n     * @param {number} [msgTimeout]\n     * @param {number} [chunkTimeout]\n     */\n    expectMessage(types, timeoutCallback, msgTimeout, chunkTimeout) {\n        this._channel.expectMessage(types, timeoutCallback, msgTimeout, chunkTimeout);\n    }\n\n    /**\n     * @param {Message.Type} type\n     * @returns {boolean}\n     */\n    isExpectingMessage(type) {\n        return this._channel.isExpectingMessage(type);\n    }\n\n    /**\n     * @param {Message.Type} type\n     * @param {boolean} success\n     */\n    confirmExpectedMessage(type, success) {\n        this._channel.confirmExpectedMessage(type, success);\n    }\n\n    /**\n     * @param {number} [type]\n     * @param {string} [reason]\n     */\n    close(type, reason) {\n        if (!this._closed) {\n            const connType = this._inbound ? 'inbound' : 'outbound';\n            Log.d(NetworkConnection, `Closing ${connType} connection #${this._id} ${this._peerAddress || this._netAddress}` + (reason ? ` - ${reason}` : '') + ` (${type})`);\n        }\n        this._close(type, reason);\n    }\n\n    /**\n     * @param {NetworkConnection} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof NetworkConnection\n            && this._id === o.id;\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this._id.toString();\n    }\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return `NetworkConnection{id=${this._id}, protocol=${this._protocol}, peerAddress=${this._peerAddress}, netAddress=${this._netAddress}}`;\n    }\n\n    /** @type {number} */\n    get id() {\n        return this._id;\n    }\n\n    /** @type {number} */\n    get protocol() {\n        return this._protocol;\n    }\n\n    /** @type {PeerAddress} */\n    get peerAddress() {\n        return this._peerAddress;\n    }\n\n    /** @type {PeerAddress} */\n    set peerAddress(value) {\n        this._peerAddress = value;\n    }\n\n    /** @type {NetAddress} */\n    get netAddress() {\n        return this._netAddress;\n    }\n\n    /** @type {NetAddress} */\n    set netAddress(value) {\n        this._netAddress = value;\n    }\n\n    /** @type {number} */\n    get bytesSent() {\n        return this._bytesSent;\n    }\n\n    /** @type {number} */\n    get bytesReceived() {\n        return this._bytesReceived;\n    }\n\n    /** @type {boolean} */\n    get inbound() {\n        return this._inbound;\n    }\n\n    /** @type {boolean} */\n    get outbound() {\n        return !this._inbound;\n    }\n\n    /** @type {boolean} */\n    get closed() {\n        return this._closed;\n    }\n}\n// Used to generate unique NetworkConnection ids.\nNetworkConnection._instanceCount = 0;\nClass.register(NetworkConnection);\n","class PeerChannel extends Observable {\n    /**\n     * @listens NetworkConnection#message\n     * @param {NetworkConnection} connection\n     */\n    constructor(connection) {\n        super();\n        this._conn = connection;\n        this._conn.on('message', msg => this._onMessage(msg));\n\n        // Forward specified events on the connection to listeners of this Observable.\n        this.bubble(this._conn, 'close', 'error');\n    }\n\n    /**\n     * @param {Uint8Array} rawMsg\n     * @private\n     */\n    _onMessage(rawMsg) {\n        let msg = null, type = null;\n\n        try {\n            const buf = new SerialBuffer(rawMsg);\n            type = MessageFactory.peekType(buf);\n            msg = MessageFactory.parse(buf);\n        } catch(e) {\n            Log.w(PeerChannel, `Failed to parse '${PeerChannel.Event[type]}' message from ${this.peerAddress || this.netAddress}`, e.message || e);\n\n            // Confirm that message arrived but could not be parsed successfully.\n            this._conn.confirmExpectedMessage(type, false);\n\n            // From the Bitcoin Reference:\n            //  \"Be careful of reject message feedback loops where two peers\n            //   each dont understand each others reject messages and so keep\n            //   sending them back and forth forever.\"\n\n            // If the message does not make sense at a whole or we fear to get into a reject loop,\n            // we ban the peer instead.\n            if (type === null || type === Message.Type.REJECT) {\n                this.close(CloseType.FAILED_TO_PARSE_MESSAGE_TYPE, 'Failed to parse message type');\n                return;\n            }\n\n            // Otherwise inform other node and ignore message.\n            this.reject(type, RejectMessage.Code.REJECT_MALFORMED, e.message || e);\n            return;\n        }\n\n        if (!msg) return;\n\n        // Confirm that message was successfully parsed.\n        this._conn.confirmExpectedMessage(type, true);\n\n        try {\n            this.fire(PeerChannel.Event[msg.type], msg, this);\n            this.fire('message-log', msg, this);\n        } catch (e) {\n            Log.w(PeerChannel, `Error while processing '${PeerChannel.Event[msg.type]}' message from ${this.peerAddress || this.netAddress}: ${e}`);\n        }\n    }\n\n    /**\n     * @param {Message.Type|Array.<Message.Type>} types\n     * @param {function()} timeoutCallback\n     * @param {number} [msgTimeout]\n     * @param {number} [chunkTimeout]\n     */\n    expectMessage(types, timeoutCallback, msgTimeout, chunkTimeout) {\n        this._conn.expectMessage(types, timeoutCallback, msgTimeout, chunkTimeout);\n    }\n\n    /**\n     * @param {Message.Type} type\n     * @returns {boolean}\n     */\n    isExpectingMessage(type) {\n        return this._conn.isExpectingMessage(type);\n    }\n\n    /**\n     * @param {Message} msg\n     * @return {boolean}\n     * @private\n     */\n    _send(msg) {\n        return this._conn.send(msg.serialize());\n    }\n\n    /**\n     * @param {number} [type]\n     * @param {string} [reason]\n     */\n    close(type, reason) {\n        this._conn.close(type, reason);\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @param {Hash} headHash\n     * @param {Uint8Array} challengeNonce\n     * @return {boolean}\n     */\n    version(peerAddress, headHash, challengeNonce) {\n        return this._send(new VersionMessage(Version.CODE, peerAddress, GenesisConfig.GENESIS_HASH, headHash, challengeNonce));\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Signature} signature\n     * @returns {boolean}\n     */\n    verack(publicKey, signature) {\n        return this._send(new VerAckMessage(publicKey, signature));\n    }\n\n    /**\n     * @param {Array.<InvVector>} vectors\n     * @return {boolean}\n     */\n    inv(vectors) {\n        return this._send(new InvMessage(vectors));\n    }\n\n    /**\n     * @param {Array.<InvVector>} vectors\n     * @return {boolean}\n     */\n    notFound(vectors) {\n        return this._send(new NotFoundMessage(vectors));\n    }\n\n    /**\n     * @param {Array.<InvVector>} vectors\n     * @return {boolean}\n     */\n    getData(vectors) {\n        return this._send(new GetDataMessage(vectors));\n    }\n\n    /**\n     * @param {Array.<InvVector>} vectors\n     * @return {boolean}\n     */\n    getHeader(vectors) {\n        return this._send(new GetHeaderMessage(vectors));\n    }\n\n    /**\n     * @param {Block} block\n     * @return {boolean}\n     */\n    block(block) {\n        return this._send(new BlockMessage(block));\n    }\n\n    /**\n     * @param {BlockHeader} header\n     * @return {boolean}\n     */\n    header(header) {\n        return this._send(new HeaderMessage(header));\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {?AccountsProof} [accountsProof]\n     * @return {boolean}\n     */\n    tx(transaction, accountsProof) {\n        return this._send(new TxMessage(transaction, accountsProof));\n    }\n\n    /**\n     * @param {Array.<Hash>} locators\n     * @param {number} maxInvSize\n     * @param {boolean} [ascending]\n     * @return {boolean}\n     */\n    getBlocks(locators, maxInvSize=BaseInventoryMessage.VECTORS_MAX_COUNT, ascending=true) {\n        return this._send(new GetBlocksMessage(locators, maxInvSize, ascending ? GetBlocksMessage.Direction.FORWARD : GetBlocksMessage.Direction.BACKWARD));\n    }\n\n    /**\n     * @return {boolean}\n     */\n    mempool() {\n        return this._send(new MempoolMessage());\n    }\n\n    /**\n     * @param {Message.Type} messageType\n     * @param {RejectMessage.Code} code\n     * @param {string} reason\n     * @param {Uint8Array} [extraData]\n     * @return {boolean}\n     */\n    reject(messageType, code, reason, extraData) {\n        return this._send(new RejectMessage(messageType, code, reason, extraData));\n    }\n\n    /**\n     * @param {Subscription} subscription\n     * @returns {boolean}\n     */\n    subscribe(subscription) {\n        return this._send(new SubscribeMessage(subscription));\n    }\n\n    /**\n     * @param {Array.<PeerAddress>} addresses\n     * @return {boolean}\n     */\n    addr(addresses) {\n        return this._send(new AddrMessage(addresses));\n    }\n\n    /**\n     * @param {number} protocolMask\n     * @param {number} serviceMask\n     * @return {boolean}\n     */\n    getAddr(protocolMask, serviceMask) {\n        return this._send(new GetAddrMessage(protocolMask, serviceMask));\n    }\n\n    /**\n     * @param {number} nonce\n     * @return {boolean}\n     */\n    ping(nonce) {\n        return this._send(new PingMessage(nonce));\n    }\n\n    /**\n     * @param {number} nonce\n     * @return {boolean}\n     */\n    pong(nonce) {\n        return this._send(new PongMessage(nonce));\n    }\n\n    /**\n     * @param {PeerId} senderId\n     * @param {PeerId} recipientId\n     * @param {number} nonce\n     * @param {number} ttl\n     * @param {SignalMessage.Flags|number} flags\n     * @param {Uint8Array} [payload]\n     * @param {PublicKey} [senderPubKey]\n     * @param {Signature} [signature]\n     * @return {boolean}\n     */\n    signal(senderId, recipientId, nonce, ttl, flags, payload, senderPubKey, signature) {\n        return this._send(new SignalMessage(senderId, recipientId, nonce, ttl, flags, payload, senderPubKey, signature));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @return {boolean}\n     */\n    getAccountsProof(blockHash, addresses) {\n        return this._send(new GetAccountsProofMessage(blockHash, addresses));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {AccountsProof} [proof]\n     * @return {boolean}\n     */\n    accountsProof(blockHash, proof) {\n        return this._send(new AccountsProofMessage(blockHash, proof));\n    }\n\n    /**\n     * @return {boolean}\n     */\n    getChainProof() {\n        return this._send(new GetChainProofMessage());\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @return {boolean}\n     */\n    chainProof(proof) {\n        return this._send(new ChainProofMessage(proof));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {string} startPrefix\n     * @return {boolean}\n     */\n    getAccountsTreeChunk(blockHash, startPrefix) {\n        return this._send(new GetAccountsTreeChunkMessage(blockHash, startPrefix));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {AccountsTreeChunk} [chunk]\n     * @return {boolean}\n     */\n    accountsTreeChunk(blockHash, chunk) {\n        return this._send(new AccountsTreeChunkMessage(blockHash, chunk));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @return {boolean}\n     */\n    getTransactionsProof(blockHash, addresses) {\n        return this._send(new GetTransactionsProofMessage(blockHash, addresses));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {TransactionsProof} [proof]\n     * @return {boolean}\n     */\n    transactionsProof(blockHash, proof) {\n        return this._send(new TransactionsProofMessage(blockHash, proof));\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {boolean}\n     */\n    getTransactionReceipts(address) {\n        return this._send(new GetTransactionReceiptsMessage(address));\n    }\n\n    /**\n     * @param {Array.<TransactionReceipt>} transactionReceipts\n     * @returns {boolean}\n     */\n    transactionReceipts(transactionReceipts) {\n        return this._send(new TransactionReceiptsMessage(transactionReceipts));\n    }\n\n    /**\n     * @param {Hash} blockHashToProve\n     * @param {Hash} knownBlockHash\n     * @returns {boolean}\n     */\n    getBlockProof(blockHashToProve, knownBlockHash) {\n        return this._send(new GetBlockProofMessage(blockHashToProve, knownBlockHash));\n    }\n\n    /**\n     * @param {BlockChain} [proof]\n     * @returns {boolean}\n     */\n    blockProof(proof) {\n        return this._send(new BlockProofMessage(proof));\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    getHead() {\n        return this._send(new GetHeadMessage());\n    }\n\n    /**\n     * @param {BlockHeader} header\n     * @returns {boolean}\n     */\n    head(header) {\n        return this._send(new HeadMessage(header));\n    }\n\n    /**\n     * @param {PeerChannel} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PeerChannel\n            && this._conn.equals(o.connection);\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this._conn.hashCode();\n    }\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return `PeerChannel{conn=${this._conn}}`;\n    }\n\n    /** @type {NetworkConnection} */\n    get connection() {\n        return this._conn;\n    }\n\n    /** @type {number} */\n    get id() {\n        return this._conn.id;\n    }\n\n    /** @type {number} */\n    get protocol() {\n        return this._conn.protocol;\n    }\n\n    /** @type {PeerAddress} */\n    get peerAddress() {\n        return this._conn.peerAddress;\n    }\n\n    /** @type {PeerAddress} */\n    set peerAddress(value) {\n        this._conn.peerAddress = value;\n    }\n\n    /** @type {NetAddress} */\n    get netAddress() {\n        return this._conn.netAddress;\n    }\n\n    /** @type {NetAddress} */\n    set netAddress(value) {\n        this._conn.netAddress = value;\n    }\n\n    /** @type {boolean} */\n    get closed() {\n        return this._conn.closed;\n    }\n}\nClass.register(PeerChannel);\n\nPeerChannel.Event = {};\nPeerChannel.Event[Message.Type.VERSION] = 'version';\nPeerChannel.Event[Message.Type.INV] = 'inv';\nPeerChannel.Event[Message.Type.GET_DATA] = 'get-data';\nPeerChannel.Event[Message.Type.GET_HEADER] = 'get-header';\nPeerChannel.Event[Message.Type.NOT_FOUND] = 'not-found';\nPeerChannel.Event[Message.Type.GET_BLOCKS] = 'get-blocks';\nPeerChannel.Event[Message.Type.BLOCK] = 'block';\nPeerChannel.Event[Message.Type.HEADER] = 'header';\nPeerChannel.Event[Message.Type.TX] = 'tx';\nPeerChannel.Event[Message.Type.MEMPOOL] = 'mempool';\nPeerChannel.Event[Message.Type.REJECT] = 'reject';\nPeerChannel.Event[Message.Type.SUBSCRIBE] = 'subscribe';\nPeerChannel.Event[Message.Type.ADDR] = 'addr';\nPeerChannel.Event[Message.Type.GET_ADDR] = 'get-addr';\nPeerChannel.Event[Message.Type.PING] = 'ping';\nPeerChannel.Event[Message.Type.PONG] = 'pong';\nPeerChannel.Event[Message.Type.SIGNAL] = 'signal';\nPeerChannel.Event[Message.Type.GET_CHAIN_PROOF] = 'get-chain-proof';\nPeerChannel.Event[Message.Type.CHAIN_PROOF] = 'chain-proof';\nPeerChannel.Event[Message.Type.GET_ACCOUNTS_PROOF] = 'get-accounts-proof';\nPeerChannel.Event[Message.Type.ACCOUNTS_PROOF] = 'accounts-proof';\nPeerChannel.Event[Message.Type.GET_ACCOUNTS_TREE_CHUNK] = 'get-accounts-tree-chunk';\nPeerChannel.Event[Message.Type.ACCOUNTS_TREE_CHUNK] = 'accounts-tree-chunk';\nPeerChannel.Event[Message.Type.GET_TRANSACTIONS_PROOF] = 'get-transactions-proof';\nPeerChannel.Event[Message.Type.TRANSACTIONS_PROOF] = 'transactions-proof';\nPeerChannel.Event[Message.Type.GET_TRANSACTION_RECEIPTS] = 'get-transaction-receipts';\nPeerChannel.Event[Message.Type.TRANSACTION_RECEIPTS] = 'transaction-receipts';\nPeerChannel.Event[Message.Type.GET_BLOCK_PROOF] = 'get-block-proof';\nPeerChannel.Event[Message.Type.BLOCK_PROOF] = 'block-proof';\nPeerChannel.Event[Message.Type.GET_HEAD] = 'get-head';\nPeerChannel.Event[Message.Type.HEAD] = 'head';\nPeerChannel.Event[Message.Type.VERACK] = 'verack';\n","class NetworkAgent extends Observable {\n    /**\n     * @param {IBlockchain} blockchain\n     * @param {PeerAddressBook} addresses\n     * @param {NetworkConfig} networkConfig\n     * @param {PeerChannel} channel\n     *\n     * @listens PeerChannel#version\n     * @listens PeerChannel#verack\n     * @listens PeerChannel#addr\n     * @listens PeerChannel#getAddr\n     * @listens PeerChannel#ping\n     * @listens PeerChannel#pong\n     * @listens PeerChannel#close\n     */\n    constructor(blockchain, addresses, networkConfig, channel) {\n        super();\n        /** @type {IBlockchain} */\n        this._blockchain = blockchain;\n        /** @type {PeerAddressBook} */\n        this._addresses = addresses;\n        /** @type {NetworkConfig} */\n        this._networkConfig = networkConfig;\n        /** @type {PeerChannel} */\n        this._channel = channel;\n\n        /**\n         * The peer object we create after the handshake completes.\n         * @type {Peer}\n         * @private\n         */\n        this._peer = null;\n\n        /**\n         * All peerAddresses that we think the remote peer knows.\n         * @type {HashSet.<PeerAddress>}\n         * @private\n         */\n        this._knownAddresses = new HashSet();\n\n        /**\n         * Helper object to keep track of timeouts & intervals.\n         * @type {Timers}\n         * @private\n         */\n        this._timers = new Timers();\n\n        /**\n         * True if we have received the peer's version message.\n         * @type {boolean}\n         * @private\n         */\n        this._versionReceived = false;\n\n        /**\n         * True if we have received the peer's verack message.\n         * @type {boolean}\n         * @private\n         */\n        this._verackReceived = false;\n\n        /**\n         * True if we have successfully sent our version message.\n         * @type {boolean}\n         * @private\n         */\n        this._versionSent = false;\n\n        /**\n         * True if we have successfully sent our verack message.\n         * @type {boolean}\n         * @private\n         */\n        this._verackSent = false;\n\n        /**\n         * Number of times we have tried to send out the version message.\n         * @type {number}\n         * @private\n         */\n        this._versionAttempts = 0;\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._peerAddressVerified = false;\n\n        /**\n         * @type {Uint8Array}\n         * @private\n         */\n        this._peerChallengeNonce = null;\n\n        /**\n         * @type {Map.<number, number>}\n         * @private\n         */\n        this._pingTimes = new Map();\n\n        /** @type {Uint8Array} */\n        this._challengeNonce = new Uint8Array(VersionMessage.CHALLENGE_SIZE);\n        CryptoWorker.lib.getRandomValues(this._challengeNonce);\n\n        /** @type {ThrottledQueue} */\n        this._addrQueue = new ThrottledQueue(\n            NetworkAgent.MAX_ADDR_RELAY_PER_MESSAGE,\n            NetworkAgent.MAX_ADDR_RELAY_PER_MESSAGE,\n            NetworkAgent.ADDR_QUEUE_INTERVAL,\n            NetworkAgent.ADDR_RATE_LIMIT,\n            () => this._relayNow());\n\n        this._addrLimit = new RateLimit(NetworkAgent.ADDR_RATE_LIMIT);\n\n        // Listen to network/control messages from the peer.\n        channel.on('version', msg => this._onVersion(msg));\n        channel.on('verack', msg => this._onVerAck(msg));\n        channel.on('addr', msg => this._onAddr(msg));\n        channel.on('get-addr', msg => this._onGetAddr(msg));\n        channel.on('ping', msg => this._onPing(msg));\n        channel.on('pong', msg => this._onPong(msg));\n\n        // Clean up when the peer disconnects.\n        channel.on('close', () => this._onClose());\n    }\n\n    /**\n     * @param {Array.<PeerAddress|RtcPeerAddress>} addresses\n     */\n    relayAddresses(addresses) {\n        // Don't relay if the handshake hasn't finished yet.\n        if (!this._verackReceived || !this._versionSent) {\n            return;\n        }\n\n        for (const address of addresses) {\n            this._addrQueue.enqueue(address);\n        }\n    }\n\n    _relayNow() {\n        const addresses = this._addrQueue.dequeueMulti(NetworkAgent.MAX_ADDR_RELAY_PER_MESSAGE);\n        if (addresses.length === 0) return;\n\n        // Only relay addresses that the peer doesn't know yet or that have improved.\n        // If the address the peer knows is older than RELAY_THROTTLE, relay the address again.\n        const filteredAddresses = addresses.filter(addr => {\n            // Exclude RTC addresses that are already at MAX_DISTANCE.\n            if (addr.protocol === Protocol.RTC && addr.distance >= PeerAddressBook.MAX_DISTANCE) {\n                return false;\n            }\n\n            // Exclude DumbPeerAddresses.\n            if (addr.protocol === Protocol.DUMB) {\n                return false;\n            }\n\n            const knownAddress = this._knownAddresses.get(addr);\n            return !addr.isSeed() // Never relay seed addresses.\n                && (!knownAddress // New address.\n                    || (addr.protocol === Protocol.RTC && knownAddress.distance > addr.distance) // Better distance.\n                    || knownAddress.timestamp < Date.now() - NetworkAgent.RELAY_THROTTLE); // Relay throttle.\n        });\n\n        if (filteredAddresses.length) {\n            this._channel.addr(filteredAddresses);\n\n            // We assume that the peer knows these addresses now.\n            for (const address of filteredAddresses) {\n                this._knownAddresses.add(address);\n            }\n        }\n    }\n\n\n    /* Handshake */\n\n    handshake() {\n        if (this._versionSent) {\n            // Version already sent, no need to handshake again.\n            return;\n        }\n\n        // Kick off the handshake by telling the peer our version, network address & blockchain head hash.\n        // Firefox sends the data-channel-open event too early, so sending the version message might fail.\n        // Try again in this case.\n        if (!this._channel.version(this._networkConfig.peerAddress, this._blockchain.headHash, this._challengeNonce)) {\n            this._versionAttempts++;\n            if (this._versionAttempts >= NetworkAgent.VERSION_ATTEMPTS_MAX || this._channel.closed) {\n                this._channel.close(CloseType.SENDING_OF_VERSION_MESSAGE_FAILED, 'sending of version message failed');\n                return;\n            }\n\n            setTimeout(this.handshake.bind(this), NetworkAgent.VERSION_RETRY_DELAY);\n            return;\n        }\n\n        this._versionSent = true;\n\n        // Drop the peer if it doesn't send us a version message.\n        // Only do this if we haven't received the peer's version message already.\n        if (!this._versionReceived) {\n            // TODO Should we ban instead?\n            this._timers.setTimeout('version', () => {\n                this._timers.clearTimeout('version');\n                this._channel.close(CloseType.VERSION_TIMEOUT, 'version timeout');\n            }, NetworkAgent.HANDSHAKE_TIMEOUT);\n        } else if (this._peerAddressVerified) {\n            this._sendVerAck();\n        }\n\n        this._timers.setTimeout('verack', () => {\n            this._timers.clearTimeout('verack');\n            this._channel.close(CloseType.VERACK_TIMEOUT, 'verack timeout');\n        }, NetworkAgent.HANDSHAKE_TIMEOUT * 2);\n    }\n\n    /**\n     * @param {VersionMessage} msg\n     * @private\n     */\n    _onVersion(msg) {\n        Log.d(NetworkAgent, () => `[VERSION] ${msg.peerAddress} ${msg.headHash.toBase64()}`);\n\n        const now = Date.now();\n\n        // Make sure this is a valid message in our current state.\n        if (!this._canAcceptMessage(msg)) {\n            return;\n        }\n\n        // Ignore duplicate version messages.\n        if (this._versionReceived) {\n            Log.d(NetworkAgent, () => `Ignoring duplicate version message from ${this._channel.peerAddress}`);\n            return;\n        }\n\n        // Clear the version timeout.\n        this._timers.clearTimeout('version');\n\n        // Check if the peer is running a compatible version.\n        if (!Version.isCompatible(msg.version)) {\n            this._channel.reject(Message.Type.VERSION, RejectMessage.Code.REJECT_OBSOLETE, `incompatible version (ours=${Version.CODE}, theirs=${msg.version})`);\n            this._channel.close(CloseType.INCOMPATIBLE_VERSION, `incompatible version (ours=${Version.CODE}, theirs=${msg.version})`);\n            return;\n        }\n\n        // Check if the peer is working on the same genesis block.\n        if (!GenesisConfig.GENESIS_HASH.equals(msg.genesisHash)) {\n            this._channel.close(CloseType.DIFFERENT_GENESIS_BLOCK, `different genesis block (${msg.genesisHash})`);\n            return;\n        }\n\n        // Check that the given peerAddress is correctly signed.\n        if (!msg.peerAddress.verifySignature()) {\n            this._channel.close(CloseType.INVALID_PEER_ADDRESS_IN_VERSION_MESSAGE, 'invalid peerAddress in version message');\n            return;\n        }\n\n        // TODO check services?\n\n        // Check that the given peerAddress matches the one we expect.\n        // In case of inbound WebSocket connections, this is the first time we\n        // see the remote peer's peerAddress.\n        const peerAddress = msg.peerAddress;\n        if (this._channel.peerAddress) {\n            if (!this._channel.peerAddress.equals(peerAddress)) {\n                this._channel.close(CloseType.UNEXPECTED_PEER_ADDRESS_IN_VERSION_MESSAGE, 'unexpected peerAddress in version message');\n                return;\n            }\n            this._peerAddressVerified = true;\n        }\n\n        // The client might not send its netAddress. Set it from our address database if we have it.\n        if (!peerAddress.netAddress) {\n            /** @type {PeerAddress} */\n            const storedAddress = this._addresses.get(peerAddress);\n            if (storedAddress && storedAddress.netAddress) {\n                peerAddress.netAddress = storedAddress.netAddress;\n            }\n        }\n\n        // Set/update the channel's peer address.\n        this._channel.peerAddress = peerAddress;\n\n        // Create peer object. Since the initial version message received from the\n        // peer contains their local timestamp, we can use it to calculate their\n        // offset to our local timestamp and store it for later (last argument).\n        this._peer = new Peer(\n            this._channel,\n            msg.version,\n            msg.headHash,\n            peerAddress.timestamp - now\n        );\n\n        this._peerChallengeNonce = msg.challengeNonce;\n        this._versionReceived = true;\n\n        // Tell listeners that we received this peer's version information.\n        // Listeners registered to this event might close the connection to this peer.\n        this.fire('version', this._peer, this);\n\n        // Abort handshake if the connection was closed.\n        if (this._channel.closed) {\n            return;\n        }\n\n        if (!this._versionSent) {\n            this.handshake();\n            return;\n        }\n\n        if (this._peerAddressVerified) {\n            this._sendVerAck();\n        }\n\n        if (this._verackReceived) {\n            this._finishHandshake();\n        }\n    }\n\n    _sendVerAck() {\n        Assert.that(this._peerAddressVerified);\n\n        const data = BufferUtils.concatTypedArrays(this._channel.peerAddress.peerId.serialize(), this._peerChallengeNonce);\n        const signature = Signature.create(this._networkConfig.keyPair.privateKey, this._networkConfig.keyPair.publicKey, data);\n        this._channel.verack(this._networkConfig.keyPair.publicKey, signature);\n\n        this._verackSent = true;\n    }\n\n    /**\n     * @param {VerAckMessage} msg\n     * @private\n     */\n    _onVerAck(msg) {\n        Log.d(NetworkAgent, () => `[VERACK] from ${this._channel.peerAddress}`);\n\n        // Make sure this is a valid message in our current state.\n        if (!this._canAcceptMessage(msg)) {\n            return;\n        }\n\n        // Ignore duplicate verack messages.\n        if (this._verackReceived) {\n            Log.d(NetworkAgent, () => `Ignoring duplicate verack message from ${this._channel.peerAddress}`);\n            return;\n        }\n\n        // Clear the verack timeout.\n        this._timers.clearTimeout('verack');\n\n        // Verify public key\n        if (!msg.publicKey.toPeerId().equals(this._channel.peerAddress.peerId)) {\n            this._channel.close(CloseType.INVALID_PUBLIC_KEY_IN_VERACK_MESSAGE, 'Invalid public key in verack message');\n            return;\n        }\n\n        // Verify signature\n        const data = BufferUtils.concatTypedArrays(this._networkConfig.peerAddress.peerId.serialize(), this._challengeNonce);\n        if (!msg.signature.verify(msg.publicKey, data)) {\n            this._channel.close(CloseType.INVALID_SIGNATURE_IN_VERACK_MESSAGE, 'Invalid signature in verack message');\n            return;\n        }\n\n        if (!this._peerAddressVerified) {\n            this._peerAddressVerified = true;\n            this._sendVerAck();\n        }\n\n        // Remember that the peer has sent us this address.\n        this._knownAddresses.add(this._channel.peerAddress);\n\n        this._verackReceived = true;\n\n        if (this._verackSent) {\n            this._finishHandshake();\n        }\n    }\n\n    _finishHandshake() {\n        // Setup regular connectivity check.\n        // TODO randomize interval?\n        this._timers.setInterval('connectivity',\n            () => this._checkConnectivity(),\n            NetworkAgent.CONNECTIVITY_CHECK_INTERVAL);\n\n        // Regularly announce our address.\n        this._timers.setInterval('announce-addr',\n            () => this._channel.addr([this._networkConfig.peerAddress]),\n            NetworkAgent.ANNOUNCE_ADDR_INTERVAL);\n\n        // Tell listeners that the handshake with this peer succeeded.\n        this.fire('handshake', this._peer, this);\n\n        // Request new network addresses from the peer.\n        this._requestAddresses();\n    }\n\n\n    /* Addresses */\n\n    _requestAddresses() {\n        // Request addresses from peer.\n        this._channel.getAddr(this._networkConfig.protocolMask, this._networkConfig.services.accepted);\n\n        // We don't use a timeout here. The peer will not respond with an addr message if\n        // it doesn't have any new addresses.\n    }\n\n    /**\n     * @param {AddrMessage} msg\n     * @private\n     */\n    async _onAddr(msg) {\n        // Make sure this is a valid message in our current state.\n        if (!this._canAcceptMessage(msg)) {\n            return;\n        }\n\n        // Reject messages that contain more than 1000 addresses, ban peer (bitcoin).\n        if (msg.addresses.length > NetworkAgent.MAX_ADDR_PER_MESSAGE) {\n            Log.w(NetworkAgent, 'Rejecting addr message - too many addresses');\n            this._channel.close(CloseType.ADDR_MESSAGE_TOO_LARGE, 'addr message too large');\n            return;\n        }\n\n        if (!this._addrLimit.note(msg.addresses.length)) {\n            Log.w(NetworkAgent, 'Rejecting addr message - rate-limit exceeded');\n            this._channel.close(CloseType.RATE_LIMIT_EXCEEDED, 'rate-limit exceeded');\n            return;\n        }\n\n        // Check the addresses the peer send us.\n        for (const addr of msg.addresses) {\n            if (!addr.verifySignature()) {\n                this._channel.close(CloseType.INVALID_ADDR, 'invalid addr');\n                return;\n            }\n\n            if (addr.protocol === Protocol.WS && !addr.globallyReachable()) {\n                this._channel.close(CloseType.ADDR_NOT_GLOBALLY_REACHABLE, 'addr not globally reachable');\n                return;\n            }\n\n            this._knownAddresses.add(addr);\n        }\n\n        // Put the new addresses in the address pool.\n        this._addresses.add(this._channel, msg.addresses);\n\n        // Tell listeners that we have received new addresses.\n        this.fire('addr', msg.addresses, this);\n    }\n\n    /**\n     * @private\n     * @param {GetAddrMessage} msg\n     * @return {void}\n     */\n    _onGetAddr(msg) {\n        // Make sure this is a valid message in our current state.\n        if (!this._canAcceptMessage(msg)) {\n            return;\n        }\n\n        // Find addresses that match the given serviceMask.\n        const addresses = this._addresses.query(msg.protocolMask, msg.serviceMask, NetworkAgent.MAX_ADDR_PER_MESSAGE);\n\n        const filteredAddresses = addresses.filter(addr => {\n            // Exclude RTC addresses that are already at MAX_DISTANCE.\n            if (addr.protocol === Protocol.RTC && addr.distance >= PeerAddressBook.MAX_DISTANCE) {\n                return false;\n            }\n\n            // Exclude known addresses from the response unless they are older than RELAY_THROTTLE.\n            const knownAddress = this._knownAddresses.get(addr);\n            return !knownAddress || knownAddress.timestamp < Date.now() - NetworkAgent.RELAY_THROTTLE;\n        });\n\n        // Send the addresses back to the peer.\n        // If we don't have any new addresses, don't send the message at all.\n        if (filteredAddresses.length) {\n            this._channel.addr(filteredAddresses);\n        }\n    }\n\n    /* Connectivity Check */\n\n    _checkConnectivity() {\n        // Generate random nonce.\n        const nonce = NumberUtils.randomUint32();\n\n        // Send ping message to peer.\n        // If sending the ping message fails, assume the connection has died.\n        if (!this._channel.ping(nonce)) {\n            this._channel.close(CloseType.SENDING_PING_MESSAGE_FAILED, 'sending ping message failed');\n            return;\n        }\n\n        // Save ping timestamp to detect the speed of the connection\n        this._pingTimes.set(nonce, Date.now());\n\n        // Drop peer if it doesn't answer with a matching pong message within the timeout.\n        this._timers.setTimeout(`ping_${nonce}`, () => {\n            this._timers.clearTimeout(`ping_${nonce}`);\n            this._channel.close(CloseType.PING_TIMEOUT, 'ping timeout');\n            this._pingTimes.delete(nonce);\n        }, NetworkAgent.PING_TIMEOUT);\n    }\n\n    /**\n     * @param {PingMessage} msg\n     * @private\n     */\n    _onPing(msg) {\n        // Make sure this is a valid message in our current state.\n        if (!this._canAcceptMessage(msg)) {\n            return;\n        }\n\n        // Respond with a pong message\n        this._channel.pong(msg.nonce);\n    }\n\n    /**\n     * @param {PongMessage} msg\n     * @fires NetworkAgent#ping-pong\n     * @private\n     */\n    _onPong(msg) {\n        // Clear the ping timeout for this nonce.\n        this._timers.clearTimeout(`ping_${msg.nonce}`);\n\n        /** @type {number} */\n        const startTime = this._pingTimes.get(msg.nonce);\n        if (startTime) {\n            const delta = Date.now() - startTime;\n            if (delta > 0) {\n                this.fire('ping-pong', delta);\n            }\n            this._pingTimes.delete(msg.nonce);\n        }\n    }\n\n    /**\n     * @private\n     */\n    _onClose() {\n        // Clear all timers and intervals when the peer disconnects.\n        this._timers.clearAll();\n        this._addrQueue.stop();\n    }\n\n    /**\n     * @param {Message} msg\n     * @return {boolean}\n     * @private\n     */\n    _canAcceptMessage(msg) {\n        // The first message must be the version message.\n        if (!this._versionReceived && msg.type !== Message.Type.VERSION) {\n            Log.w(NetworkAgent, `Discarding '${PeerChannel.Event[msg.type] || msg.type}' message from ${this._channel}`\n                + ' - no version message received previously');\n            return false;\n        }\n        if (this._versionReceived && !this._verackReceived && msg.type !== Message.Type.VERACK) {\n            Log.w(NetworkAgent, `Discarding '${PeerChannel.Event[msg.type] || msg.type}' message from ${this._channel}`\n                + ' - no verack message received previously');\n            return false;\n        }\n        return true;\n    }\n\n    /** @type {PeerChannel} */\n    get channel() {\n        return this._channel;\n    }\n\n    /** @type {Peer} */\n    get peer() {\n        return this._peer;\n    }\n}\n\nNetworkAgent.HANDSHAKE_TIMEOUT = 1000 * 4; // 4 seconds\nNetworkAgent.PING_TIMEOUT = 1000 * 10; // 10 seconds\nNetworkAgent.CONNECTIVITY_CHECK_INTERVAL = 1000 * 60; // 1 minute\nNetworkAgent.ANNOUNCE_ADDR_INTERVAL = 1000 * 60 * 5; // 5 minutes\nNetworkAgent.RELAY_THROTTLE = 1000 * 60 * 2; // 2 minutes\nNetworkAgent.VERSION_ATTEMPTS_MAX = 10;\nNetworkAgent.VERSION_RETRY_DELAY = 500; // 500 ms\nNetworkAgent.ADDR_RATE_LIMIT = 2000;\nNetworkAgent.ADDR_QUEUE_INTERVAL = 5000;\nNetworkAgent.MAX_ADDR_PER_MESSAGE = 1000;\nNetworkAgent.MAX_ADDR_RELAY_PER_MESSAGE = 10;\nClass.register(NetworkAgent);\n","class PeerConnectionStatistics {\n    /**\n     * @constructor\n     */\n    constructor() {\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        this._latencies = [];\n\n        /**\n         * @type {HashMap<number, number>}\n         * @private\n         */\n        this._messages = new HashMap();\n    }\n\n    /**\n     * @returns {void}\n     */\n    reset() {\n        this._latencies = [];\n        this._messages = new HashMap();\n    }\n\n    /**\n     * @param {number} latency\n     * @returns {void}\n     */\n    addLatency(latency) {\n        this._latencies.push(latency);\n    }\n\n    /**\n     * @param {Message} msg\n     * @returns {void}\n     */\n    addMessage(msg) {\n        this._messages.put(msg.type, this._messages.contains(msg.type) ? this._messages.get(msg.type) + 1 : 1);\n    }\n\n    /**\n     * @param {number} msgType\n     * @returns {number}\n     */\n    getMessageCount(msgType) {\n        return this._messages.contains(msgType) ? this._messages.get(msgType) : 0;\n    }\n\n    /** @type {number} */\n    get latencyMedian() {\n        const length = this._latencies.length;\n\n        if (length === 0) {\n            return 0;\n        }\n\n        this._latencies.sort((a, b) => a - b);\n        let median;\n        if ((length % 2) === 0) {\n            median = Math.round((this._latencies[(length / 2) - 1] + this._latencies[length / 2]) / 2);\n        } else {\n            median = this._latencies[(length - 1) / 2];\n        }\n        return median;\n    }\n\n}\nClass.register(PeerConnectionStatistics);\n","class PeerConnection {\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {PeerConnection}\n     */\n    static getOutbound(peerAddress) {\n        const peerConnection = new PeerConnection();\n        peerConnection._peerAddress = peerAddress;\n        peerConnection._state = PeerConnectionState.CONNECTING;\n        return peerConnection;\n    }\n\n    /**\n     * @param {NetworkConnection} networkConnection\n     * @returns {PeerConnection}\n     */\n    static getInbound(networkConnection) {\n        const peerConnection = new PeerConnection();\n        peerConnection._networkConnection = networkConnection;\n        return peerConnection;\n    }\n\n    /**\n     * @constructor\n     */\n    constructor() {\n        // Unique id for this connection.\n        /** @type {number} */\n        this._id = PeerConnection._instanceCount++;\n\n        /**\n         * @type {PeerAddress}\n         * @private\n         */\n        this._peerAddress = null;\n\n        // Helper Objects are added during lifecycle\n        /**\n         * @type {NetworkConnection}\n         * @private\n         */\n        this._networkConnection = null;\n \n        /**\n         * @type {PeerChannel}\n         * @private\n         */\n        this._peerChannel = null;\n\n        /**\n         * @type {NetworkAgent}\n         * @private\n         */\n        this._networkAgent = null;\n\n        /**\n         * @type {Peer}\n         * @private\n         */\n        this._peer = null;\n\n        /**\n         * Lifecycle state of connection\n         * @type {number}\n         * @private\n         */\n        this._state = PeerConnectionState.NEW;\n\n        /**\n         * Latest score given, computed by PeerScorer\n         * @type {number}\n         * @private\n         */\n        this._score = null;\n\n        /**\n         * @type {number}\n         * @private\n         */\n        this._establishedSince = null;\n\n        /**\n         * @type {PeerConnectionStatistics}\n         * @private\n         */\n        this._statistics = new PeerConnectionStatistics();\n    }\n\n    /** @type {number} */\n    get id() {\n        return this._id;\n    }\n\n    /** @type {number} */\n    get state() {\n        return this._state;\n    }\n\n    /** @type {PeerAddress} */\n    get peerAddress() {\n        return this._peerAddress;\n    }\n\n    /** @param {PeerAddress} value */\n    set peerAddress(value) {\n        this._peerAddress = value;\n    }\n\n    /** @type {NetworkConnection} */\n    get networkConnection() {\n        return this._networkConnection;\n    }\n\n    /** @param {NetworkConnection} value */\n    set networkConnection(value) {\n        this._networkConnection = value;\n        this._state = PeerConnectionState.CONNECTED;\n    }\n\n    /** @type {PeerChannel} */\n    get peerChannel() {\n        return this._peerChannel;\n    }\n\n    /** @param {PeerChannel} value */\n    set peerChannel(value) {\n        this._peerChannel = value;\n    }\n\n    /** @type {NetworkAgent} */\n    get networkAgent() {\n        return this._networkAgent;\n    }\n\n    /** @param {NetworkAgent} value */\n    set networkAgent(value) {\n        this._networkAgent = value;\n    }\n\n    /**\n     * @returns {void}\n     */\n    negotiating() {\n        Assert.that(this._state === PeerConnectionState.CONNECTED);\n        this._state = PeerConnectionState.NEGOTIATING;\n    }\n\n    /** @type {Peer} */\n    get peer() {\n        return this._peer;\n    }\n\n    /** @param {Peer} value */\n    set peer(value) {\n        this._peer = value;\n        this._state = PeerConnectionState.ESTABLISHED;\n        this._establishedSince = Date.now();\n\n        // start statistics\n        this._networkAgent.on('ping-pong', (latency) => this._statistics.addLatency(latency));\n        this._peerChannel.on('message-log', (msg) => this._statistics.addMessage(msg));\n    }\n\n    /** @type {number} */\n    get score() {\n        return this._score;\n    }\n\n    /** @param {number} value */\n    set score(value) {\n        this._score = value;\n    }\n\n    /** @type {number} */\n    get establishedSince() {\n        return this._establishedSince;\n    }\n\n    /** @type {number} */\n    get ageEstablished() {\n        return Date.now() - this.establishedSince;\n    }\n\n    /** @type {PeerConnectionStatistics} */\n    get statistics() {\n        return this._statistics;\n    }\n\n    /**\n     * @returns {void}\n     */\n    close() {\n        this._state = PeerConnectionState.CLOSED;\n        this._networkConnection = null;\n        this._networkAgent = null;\n        this._peerChannel = null;\n        this._peer = null;\n    }\n}\n// Used to generate unique PeerConnection ids.\nPeerConnection._instanceCount = 0;\nClass.register(PeerConnection);\n\nclass PeerConnectionState {\n}\nPeerConnectionState.NEW = 1;\nPeerConnectionState.CONNECTING = 2;\nPeerConnectionState.CONNECTED = 3;\nPeerConnectionState.NEGOTIATING = 4;\nPeerConnectionState.ESTABLISHED = 5;\nPeerConnectionState.CLOSED = 6;\nClass.register(PeerConnectionState);\n","class SignalProcessor {\n    /**\n     * @constructor\n     * @param {PeerAddressBook} peerAddresses\n     * @param {NetworkConfig} networkConfig\n     * @param {WebRtcConnector} rtcConnector\n     */\n    constructor(peerAddresses, networkConfig, rtcConnector) {\n        /**\n         * @type {PeerAddressBook}\n         * @private\n         */\n        this._addresses = peerAddresses;\n\n        /**\n         * @type {NetworkConfig}\n         * @private\n         */\n        this._networkConfig = networkConfig;\n\n        /**\n         * @type {WebRtcConnector}\n         * @private\n         */\n        this._rtcConnector = rtcConnector;\n\n        /**\n         * @type {SignalStore}\n         * @private\n         */\n        this._forwards = new SignalStore();\n    }\n\n    /**\n     * @param {PeerChannel} channel\n     * @param {SignalMessage} msg\n     * @returns {void}\n     */\n    onSignal(channel, msg) {\n        // Discard signals with invalid TTL.\n        if (msg.ttl > Network.SIGNAL_TTL_INITIAL) {\n            channel.close(CloseType.INVALID_SIGNAL_TTL, 'invalid signal ttl');\n            return;\n        }\n\n        // Discard signals that have a payload, which is not properly signed.\n        if (msg.hasPayload() && !msg.verifySignature()) {\n            channel.close(CloseType.INVALID_SIGNATURE, 'invalid signature');\n            return;\n        }\n\n        // Can be undefined for non-rtc nodes.\n        const myPeerId = this._networkConfig.peerAddress.peerId;\n\n        // Discard signals from myself.\n        if (msg.senderId.equals(myPeerId)) {\n            Log.w(SignalProcessor, `Received signal from myself to ${msg.recipientId} from ${channel.peerAddress} (myId: ${myPeerId})`);\n            return;\n        }\n\n        // If the signal has the unroutable flag set and we previously forwarded a matching signal,\n        // mark the route as unusable.\n        if (msg.isUnroutable() && this._forwards.signalForwarded(/*senderId*/ msg.recipientId, /*recipientId*/ msg.senderId, /*nonce*/ msg.nonce)) {\n            const senderAddr = this._addresses.getByPeerId(msg.senderId);\n            this._addresses.unroutable(channel, senderAddr);\n        }\n\n        // If the signal is intended for us, pass it on to our WebRTC connector.\n        if (msg.recipientId.equals(myPeerId)) {\n            // If we sent out a signal that did not reach the recipient because of TTL\n            // or it was unroutable, delete this route.\n            if (this._rtcConnector.isValidSignal(msg) && (msg.isUnroutable() || msg.isTtlExceeded())) {\n                const senderAddr = this._addresses.getByPeerId(msg.senderId);\n                this._addresses.unroutable(channel, senderAddr);\n            }\n            this._rtcConnector.onSignal(channel, msg);\n            return;\n        }\n\n        // Discard signals that have reached their TTL.\n        if (msg.ttl <= 0) {\n            Log.d(SignalProcessor, `Discarding signal from ${msg.senderId} to ${msg.recipientId} - TTL reached`);\n            // Send signal containing TTL_EXCEEDED flag back in reverse direction.\n            if (msg.flags === 0) {\n                channel.signal(/*senderId*/ msg.recipientId, /*recipientId*/ msg.senderId, msg.nonce, Network.SIGNAL_TTL_INITIAL, SignalMessage.Flag.TTL_EXCEEDED);\n            }\n            return;\n        }\n\n        // Otherwise, try to forward the signal to the intended recipient.\n        const signalChannel = this._addresses.getChannelByPeerId(msg.recipientId);\n        if (!signalChannel) {\n            Log.d(SignalProcessor, `Failed to forward signal from ${msg.senderId} to ${msg.recipientId} - no route found`);\n            // If we don't know a route to the intended recipient, return signal to sender with unroutable flag set and payload removed.\n            // Only do this if the signal is not already a unroutable response.\n            if (msg.flags === 0) {\n                channel.signal(/*senderId*/ msg.recipientId, /*recipientId*/ msg.senderId, msg.nonce, Network.SIGNAL_TTL_INITIAL, SignalMessage.Flag.UNROUTABLE);\n            }\n            return;\n        }\n\n        // Discard signal if our shortest route to the target is via the sending peer.\n        // XXX Why does this happen?\n        if (signalChannel.peerAddress.equals(channel.peerAddress)) {\n            Log.w(SignalProcessor, `Discarding signal from ${msg.senderId} to ${msg.recipientId} - shortest route via sending peer`);\n            // If our best route is via the sending peer, return signal to sender with unroutable flag set and payload removed.\n            // Only do this if the signal is not already a unroutable response.\n            if (msg.flags === 0) {\n                channel.signal(/*senderId*/ msg.recipientId, /*recipientId*/ msg.senderId, msg.nonce, Network.SIGNAL_TTL_INITIAL, SignalMessage.Flag.UNROUTABLE);\n            }\n            return;\n        }\n\n        // Decrement ttl and forward signal.\n        signalChannel.signal(msg.senderId, msg.recipientId, msg.nonce, msg.ttl - 1, msg.flags, msg.payload, msg.senderPubKey, msg.signature);\n\n        // We store forwarded messages if there are no special flags set.\n        if (msg.flags === 0) {\n            this._forwards.add(msg.senderId, msg.recipientId, msg.nonce);\n        }\n\n        // XXX This is very spammy!!!\n        // Log.v(Network, `Forwarding signal (ttl=${msg.ttl}) from ${msg.senderId} `\n        //     + `(received from ${channel.peerAddress}) to ${msg.recipientId} `\n        //     + `(via ${signalChannel.peerAddress})`);\n    }\n}\nClass.register(SignalProcessor);\n\nclass SignalStore {\n    /**\n     * @param {number} maxSize maximum number of entries\n     */\n    constructor(maxSize = 1000) {\n        /** @type {number} */\n        this._maxSize = maxSize;\n        /** @type {Queue.<ForwardedSignal>} */\n        this._queue = new Queue();\n        /** @type {HashMap.<ForwardedSignal, number>} */\n        this._store = new HashMap();\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._queue.length;\n    }\n\n    /**\n     * @param {PeerId} senderId\n     * @param {PeerId} recipientId\n     * @param {number} nonce\n     */\n    add(senderId, recipientId, nonce) {\n        // If we already forwarded such a message, just update timestamp.\n        if (this.contains(senderId, recipientId, nonce)) {\n            const signal = new ForwardedSignal(senderId, recipientId, nonce);\n            this._store.put(signal, Date.now());\n            this._queue.remove(signal);\n            this._queue.enqueue(signal);\n            return;\n        }\n\n        // Delete oldest if needed.\n        if (this.length >= this._maxSize) {\n            const oldest = this._queue.dequeue();\n            this._store.remove(oldest);\n        }\n        const signal = new ForwardedSignal(senderId, recipientId, nonce);\n        this._queue.enqueue(signal);\n        this._store.put(signal, Date.now());\n    }\n\n    /**\n     * @param {PeerId} senderId\n     * @param {PeerId} recipientId\n     * @param {number} nonce\n     * @return {boolean}\n     */\n    contains(senderId, recipientId, nonce) {\n        const signal = new ForwardedSignal(senderId, recipientId, nonce);\n        return this._store.contains(signal);\n    }\n\n    /**\n     * @param {PeerId} senderId\n     * @param {PeerId} recipientId\n     * @param {number} nonce\n     * @return {boolean}\n     */\n    signalForwarded(senderId, recipientId, nonce) {\n        const signal = new ForwardedSignal(senderId, recipientId, nonce);\n        const lastSeen = this._store.get(signal);\n        if (!lastSeen) {\n            return false;\n        }\n        const valid = lastSeen + ForwardedSignal.SIGNAL_MAX_AGE > Date.now();\n        if (!valid) {\n            // Because of the ordering, we know that everything after that is invalid too.\n            const toDelete = this._queue.dequeueUntil(signal);\n            for (const dSignal of toDelete) {\n                this._store.remove(dSignal);\n            }\n        }\n        return valid;\n    }\n}\nSignalStore.SIGNAL_MAX_AGE = 10 /* seconds */;\nClass.register(SignalStore);\n\nclass ForwardedSignal {\n    /**\n     * @param {PeerId} senderId\n     * @param {PeerId} recipientId\n     * @param {number} nonce\n     */\n    constructor(senderId, recipientId, nonce) {\n        /** @type {PeerId} */\n        this._senderId = senderId;\n        /** @type {PeerId} */\n        this._recipientId = recipientId;\n        /** @type {number} */\n        this._nonce = nonce;\n    }\n\n    /**\n     * @param {ForwardedSignal} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof ForwardedSignal\n            && this._senderId.equals(o._senderId)\n            && this._recipientId.equals(o._recipientId)\n            && this._nonce === o._nonce;\n    }\n\n    hashCode() {\n        return this.toString();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `ForwardedSignal{senderId=${this._senderId}, recipientId=${this._recipientId}, nonce=${this._nonce}}`;\n    }\n}\nClass.register(ForwardedSignal);\n","class ConnectionPool extends Observable {\n    /**\n     * @constructor\n     * @param {PeerAddressBook} peerAddresses\n     * @param {NetworkConfig} networkConfig\n     * @param {IBlockchain} blockchain\n     * @param {Time} time\n     * @listens WebSocketConnector#connection\n     * @listens WebSocketConnector#error\n     * @listens WebRtcConnector#connection\n     * @listens WebRtcConnector#error\n     */\n    constructor(peerAddresses, networkConfig, blockchain, time) {\n        super();\n\n        /**\n         * @type {PeerAddressBook}\n         * @private\n         */\n        this._addresses = peerAddresses;\n\n        /**\n         * @type {NetworkConfig}\n         * @private\n         */\n        this._networkConfig = networkConfig;\n\n        /**\n         * @type {IBlockchain}\n         * @private\n         */\n        this._blockchain = blockchain;\n\n        /**\n         * @type {Time}\n         * @private\n         */\n        this._time = time;\n\n        /**\n         * HashMap from peerAddresses to connections.\n         * @type {HashMap.<PeerAddress, PeerConnection>}\n         * @private\n         */\n        this._connectionsByPeerAddress = new HashMap();\n        \n        /**\n         * HashMap from netAddresses to connections.\n         * @type {HashMap.<NetAddress, Array.<PeerConnection>>}\n         * @private\n         */\n        this._connectionsByNetAddress = new HashMap();\n\n        /**\n         * HashMap from subnet addresses to connections.\n         * @type {HashMap.<NetAddress, Array.<PeerConnection>>}\n         * @private\n         */\n        this._connectionsBySubnet = new HashMap();\n\n        // Total bytes sent/received on past connections.\n        /** @type {number} */\n        this._bytesSent = 0;\n        /** @type {number} */\n        this._bytesReceived = 0;\n\n        /** @type {WebSocketConnector} */\n        this._wsConnector = new WebSocketConnector(this._networkConfig);\n        this._wsConnector.on('connection', conn => this._onConnection(conn));\n        this._wsConnector.on('error', (peerAddr, e) => this._onConnectError(peerAddr, e));\n\n        /** @type {WebRtcConnector} */\n        this._rtcConnector = new WebRtcConnector(this._networkConfig);\n        this._rtcConnector.on('connection', conn => this._onConnection(conn));\n        this._rtcConnector.on('error', (peerAddr, reason) => this._onConnectError(peerAddr, reason));\n\n        // Various counters for established connections.\n        /** @type {number} */\n        this._peerCountWs = 0;\n        /** @type {number} */\n        this._peerCountRtc = 0;\n        /** @type {number} */\n        this._peerCountDumb = 0;\n        /** @type {number} */\n        this._peerCountFull = 0;\n        /** @type {number} */\n        this._peerCountLight = 0;\n        /** @type {number} */\n        this._peerCountNano = 0;\n        /** @type {number} */\n        this._peerCountOutbound = 0;\n        /** @type {number} */\n        this._peerCountFullWsOutbound = 0;\n\n        /**\n         * Number of ongoing outbound connection attempts.\n         * @type {number}\n         * @private\n         */\n        this._connectingCount = 0;\n\n        /**\n         * Number of not established inbound connections.\n         * @type {number}\n         * @private\n         */\n        this._inboundCount = 0;\n\n        /** @type {SignalProcessor} */\n        this._signalProcessor = new SignalProcessor(peerAddresses, networkConfig, this._rtcConnector);\n\n        // When true, send a signal to network to close an established connection for a incoming one\n        /** @type {boolean} */\n        this._allowInboundExchange = false;\n\n        // Whether we allow inbound connections. Does not apply to WebRTC connections.\n        /** @type {boolean} */\n        this._allowInboundConnections = false;\n\n        /** @type {HashMap.<NetAddress, number>} */\n        this._bannedIPv4IPs = new HashMap();\n\n        /** @type {HashMap.<Uint8Array, number>} */\n        this._bannedIPv6IPs = new HashMap();\n\n        setInterval(() => this._checkUnbanIps(), ConnectionPool.UNBAN_IPS_INTERVAL);\n    }\n\n    /**\n     * @returns {Array.<PeerConnection>}\n     */\n    values() {\n        return Array.from(this._connectionsByPeerAddress.values());\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {PeerConnection|null}\n     */\n    getConnectionByPeerAddress(peerAddress) {\n        return this._connectionsByPeerAddress.get(peerAddress);\n    }\n\n    /**\n     * @param {NetAddress} netAddress\n     * @returns {Array.<PeerConnection>}\n     */\n    getConnectionsByNetAddress(netAddress) {\n        return this._connectionsByNetAddress.get(netAddress) || [];\n    }\n\n    /**\n     * @param {NetAddress} netAddress\n     * @returns {Array.<PeerConnection>}\n     */\n    getConnectionsBySubnet(netAddress) {\n        return this._connectionsBySubnet.get(this._getSubnetAddress(netAddress)) || [];\n    }\n\n    /**\n     * @param {NetAddress} netAddress\n     * @returns {Array.<PeerConnection>}\n     */\n    getOutboundConnectionsBySubnet(netAddress) {\n        return (this._connectionsBySubnet.get(this._getSubnetAddress(netAddress)) || [])\n            .filter(/** @type {PeerConnection} */ peerConnection => peerConnection.networkConnection.outbound);\n    }\n\n    /**\n     * @param {NetAddress} netAddress\n     * @returns {NetAddress}\n     */\n    _getSubnetAddress(netAddress) {\n        return netAddress.subnet(netAddress.isIPv4() ? Network.IPV4_SUBNET_MASK : Network.IPV6_SUBNET_MASK);\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @returns {void}\n     * @private\n     */\n    _add(peerConnection) {\n        if (peerConnection.peerAddress) {\n            this._connectionsByPeerAddress.put(peerConnection.peerAddress, peerConnection);\n        }\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @returns {void}\n     * @private\n     */\n    _remove(peerConnection) {\n        if (peerConnection.peerAddress) {\n            this._connectionsByPeerAddress.remove(peerConnection.peerAddress);\n        }\n\n        if (peerConnection.networkConnection && peerConnection.networkConnection.netAddress) {\n            this._removeNetAddress(peerConnection, peerConnection.networkConnection.netAddress);\n        }\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @param {NetAddress} netAddress\n     * @returns {void}\n     * @private\n     */\n    _addNetAddress(peerConnection, netAddress) {\n        // Only add reliable netAddresses.\n        if (netAddress.isPseudo() || !netAddress.reliable) {\n            return;\n        }\n\n        if (this._connectionsByNetAddress.contains(netAddress)) {\n            this._connectionsByNetAddress.get(netAddress).push(peerConnection);\n        } else {\n            this._connectionsByNetAddress.put(netAddress, [peerConnection]);\n        }\n\n        const subnetAddress = this._getSubnetAddress(netAddress);\n        if (this._connectionsBySubnet.contains(subnetAddress)) {\n            this._connectionsBySubnet.get(subnetAddress).push(peerConnection);\n        } else {\n            this._connectionsBySubnet.put(subnetAddress, [peerConnection]);\n        }\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @param {NetAddress} netAddress\n     * @returns {void}\n     * @private\n     */\n    _removeNetAddress(peerConnection, netAddress) {\n        if (netAddress.isPseudo() || !netAddress.reliable) {\n            return;\n        }\n\n        if (this._connectionsByNetAddress.contains(netAddress)) {\n            const peerConnections = this._connectionsByNetAddress.get(netAddress);\n\n            const index = peerConnections.indexOf(peerConnection);\n            if (index >= 0) {\n                peerConnections.splice(index, 1);\n            }\n\n            if (peerConnections.length === 0) {\n                this._connectionsByNetAddress.remove(netAddress);\n            }\n        }\n\n        const subnetAddress = this._getSubnetAddress(netAddress);\n        if (this._connectionsBySubnet.contains(subnetAddress)) {\n            const peerConnections = this._connectionsBySubnet.get(subnetAddress);\n\n            const index = peerConnections.indexOf(peerConnection);\n            if (index >= 0) {\n                peerConnections.splice(index, 1);\n            }\n\n            if (peerConnections.length === 0) {\n                this._connectionsBySubnet.remove(subnetAddress);\n            }\n        }\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {boolean}\n     */\n    _checkOutboundConnectionRequest(peerAddress) {\n        if (peerAddress === null) {\n            return false;\n        }\n\n        if (peerAddress.protocol !== Protocol.WS && peerAddress.protocol !== Protocol.RTC) {\n            Log.e(ConnectionPool, `Cannot connect to ${peerAddress} - unsupported protocol`);\n            return false;\n        }\n\n        if (this._addresses.isBanned(peerAddress)){\n            Log.e(ConnectionPool, `Connecting to banned address ${peerAddress}`);\n            return false;\n        }\n\n        const peerConnection = this.getConnectionByPeerAddress(peerAddress);\n        if (peerConnection) {\n            Log.e(ConnectionPool, `Duplicate connection to ${peerAddress}`);\n            return false;\n        }\n\n        // Forbid connection if we have too many connections to the peer's IP address.\n        if (peerAddress.netAddress && peerAddress.netAddress.reliable) {\n            if (this.getConnectionsByNetAddress(peerAddress.netAddress).length >= Network.PEER_COUNT_PER_IP_MAX) {\n                Log.e(ConnectionPool, `connection limit per ip (${Network.PEER_COUNT_PER_IP_MAX}) reached`);\n                return false;\n            }\n\n            if (this.getOutboundConnectionsBySubnet(peerAddress.netAddress).length >= Network.OUTBOUND_PEER_COUNT_PER_SUBNET_MAX) {\n                Log.e(ConnectionPool, `connection limit per ip (${Network.OUTBOUND_PEER_COUNT_PER_SUBNET_MAX}) reached`);\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {boolean}\n     */\n    connectOutbound(peerAddress) {\n        // all checks in one step\n        if (!this._checkOutboundConnectionRequest(peerAddress)) {\n            return false;\n        }\n\n        // Connection request accepted.\n\n        // create fresh PeerConnection instance\n        const peerConnection = PeerConnection.getOutbound(peerAddress);\n        this._add(peerConnection);\n\n        // choose connector type and call\n        let connecting = false;\n        if (peerAddress.protocol === Protocol.WS) {\n            connecting = this._wsConnector.connect(peerAddress);\n        } else {\n            const signalChannel = this._addresses.getChannelByPeerId(peerAddress.peerId);\n            connecting = this._rtcConnector.connect(peerAddress, signalChannel);\n        }\n\n        if (connecting) {\n            this._connectingCount++;\n        } else {\n            this._remove(peerConnection);\n            Log.d(Network, `Outbound attempt not connecting: ${peerAddress}`);\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @returns {boolean}\n     * @private\n     */\n    _checkConnection(peerConnection) {\n        /** @type {NetworkConnection} */\n        const conn = peerConnection.networkConnection;\n\n        // Close connection if we currently do not allow inbound connections. WebRTC connections are exempt.\n        if (conn.inbound && !this._allowInboundConnections && conn.protocol !== Protocol.RTC) {\n            conn.close(CloseType.INBOUND_CONNECTIONS_BLOCKED, 'inbound connections are blocked temporarily');\n            return false;\n        }\n\n        if (conn.netAddress && !conn.netAddress.isPseudo() && conn.netAddress.reliable) {\n            // Close connection if peer's IP is banned.\n            if (this._isIpBanned(conn.netAddress)) {\n                conn.close(CloseType.BANNED_IP, `connection with banned IP ${conn.netAddress}`);\n                return false;\n            }\n\n            // Close connection if we have too many connections to the peer's IP address.\n            if (this.getConnectionsByNetAddress(conn.netAddress).length >= Network.PEER_COUNT_PER_IP_MAX) {\n                conn.close(CloseType.CONNECTION_LIMIT_PER_IP, `connection limit per IP (${Network.PEER_COUNT_PER_IP_MAX}) reached`);\n                return false;\n            }\n\n            // Close connection if we have too many connections to the peer's subnet.\n            if (this.getConnectionsBySubnet(conn.netAddress).length >= Network.INBOUND_PEER_COUNT_PER_SUBNET_MAX) {\n                conn.close(CloseType.CONNECTION_LIMIT_PER_IP, `connection limit per subnet (${Network.INBOUND_PEER_COUNT_PER_SUBNET_MAX}) reached`);\n                return false;\n            }\n        }\n\n        // Reject peer if we have reached max peer count.\n        if (this.peerCount >= Network.PEER_COUNT_MAX\n            && !conn.outbound\n            && !(conn.inbound && this._allowInboundExchange)) {\n\n            conn.close(CloseType.MAX_PEER_COUNT_REACHED, `max peer count reached (${Network.PEER_COUNT_MAX})`);\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @listens PeerChannel#signal\n     * @listens NetworkAgent#handshake\n     * @listens NetworkAgent#close\n     * @fires ConnectionPool#connection\n     * @param {NetworkConnection} conn\n     * @returns {void}\n     * @private\n     */\n    _onConnection(conn) {\n        /** @type {PeerConnection} */\n        let peerConnection;\n        if (conn.outbound) {\n            this._connectingCount--;\n            Assert.that(this._connectingCount >= 0, 'connectingCount < 0');\n\n            peerConnection = this.getConnectionByPeerAddress(conn.peerAddress);\n\n            Assert.that(!!peerConnection, `PeerAddress not stored ${conn.peerAddress}`);\n            Assert.that(peerConnection.state === PeerConnectionState.CONNECTING,\n                `PeerConnection state not CONNECTING, but ${peerConnection.state} (${conn.peerAddress})`);\n        } else {\n            peerConnection = PeerConnection.getInbound(conn);\n            this._inboundCount++;\n        }\n\n        // Set peerConnection to CONNECTED state.\n        peerConnection.networkConnection = conn;\n\n        // Register close listener early to clean up correctly in case _checkConnection() closes the connection.\n        conn.on('close', (type, reason) => this._onClose(peerConnection, type, reason));\n\n        if (!this._checkConnection(peerConnection)) {\n            return;\n        }\n\n        // Connection accepted.\n\n        if (conn.netAddress && !conn.netAddress.isPseudo()) {\n            this._addNetAddress(peerConnection, conn.netAddress);\n        }\n\n        const connType = conn.inbound ? 'inbound' : 'outbound';\n        Log.d(ConnectionPool, `Connection established (${connType}) #${conn.id} ${conn.netAddress || conn.peerAddress || '<pending>'}`);\n\n        // Let listeners know about this connection.\n        this.fire('connection', conn);\n\n        // Create peer channel.\n        const channel = new PeerChannel(conn);\n        channel.on('signal', msg => this._signalProcessor.onSignal(channel, msg));\n \n        peerConnection.peerChannel = channel;\n\n        // Create network agent.\n        const agent = new NetworkAgent(this._blockchain, this._addresses, this._networkConfig, channel);\n        agent.on('version', peer => this._checkHandshake(peerConnection, peer));\n        agent.on('handshake', peer => this._onHandshake(peerConnection, peer));\n\n        peerConnection.networkAgent = agent;\n\n        // Initiate handshake with the peer.\n        agent.handshake();\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @param {Peer} peer\n     * @returns {boolean}\n     * @private\n     */\n    _checkHandshake(peerConnection, peer) {\n        // Close connection if peer's address is banned.\n        if (this._addresses.isBanned(peer.peerAddress)) {\n            peerConnection.peerChannel.close(CloseType.PEER_IS_BANNED,\n                `connection with banned address ${peer.peerAddress} (post version)`);\n            return false;\n        }\n\n        // Duplicate/simultaneous connection check (post version):\n        const storedConnection = this.getConnectionByPeerAddress(peer.peerAddress);\n        if (storedConnection && storedConnection.id !== peerConnection.id) {\n            // If we already have an established connection to this peer, close this connection.\n            if (storedConnection.state === PeerConnectionState.ESTABLISHED) {\n                peerConnection.peerChannel.close(CloseType.DUPLICATE_CONNECTION,\n                    'duplicate connection (post version)');\n                return false;\n            }\n        }\n\n        // Set peerConnection to NEGOTIATING state.\n        peerConnection.negotiating();\n\n        return true;\n    }\n\n    /**\n     * Handshake with this peer was successful.\n     * @fires ConnectionPool#peer-joined\n     * @fires ConnectionPool#peers-changed\n     * @fires ConnectionPool#recyling-request\n     * @param {PeerConnection} peerConnection\n     * @param {Peer} peer\n     * @returns {void}\n     * @private\n     */\n    _onHandshake(peerConnection, peer) {\n        if (peerConnection.networkConnection.inbound) {\n            // Re-check allowInboundExchange as it might have changed.\n            if (this.peerCount >= Network.PEER_COUNT_MAX && !this._allowInboundExchange) {\n                peerConnection.peerChannel.close(CloseType.MAX_PEER_COUNT_REACHED,\n                    `max peer count reached (${Network.PEER_COUNT_MAX})`);\n                return;\n            }\n\n            // Duplicate/simultaneous connection check (post handshake):\n            const storedConnection = this.getConnectionByPeerAddress(peer.peerAddress);\n            if (storedConnection && storedConnection.id !== peerConnection.id) {\n                switch (storedConnection.state) {\n                    case PeerConnectionState.CONNECTING:\n                        // Abort the stored connection attempt and accept this connection.\n                        Assert.that(peer.peerAddress.protocol === Protocol.WS, 'Duplicate connection to non-WS node');\n                        Log.d(ConnectionPool, `Aborting connection attempt to ${peer.peerAddress}, simultaneous inbound connection succeeded`);\n                        this._wsConnector.abort(peer.peerAddress);\n                        Assert.that(!this.getConnectionByPeerAddress(peer.peerAddress), 'PeerConnection not removed');\n                        break;\n\n                    case PeerConnectionState.ESTABLISHED:\n                        // If we have another established connection to this peer, close this connection.\n                        peerConnection.peerChannel.close(CloseType.DUPLICATE_CONNECTION,\n                            'duplicate connection (post handshake)');\n                        return;\n\n                    case PeerConnectionState.NEGOTIATING:\n                        // The peer with the lower peerId accepts this connection and closes his stored connection.\n                        if (this._networkConfig.peerAddress.peerId.compare(peer.peerAddress.peerId) < 0) {\n                            storedConnection.peerChannel.close(CloseType.SIMULTANEOUS_CONNECTION,\n                                'simultaneous connection (post handshake) - lower peerId');\n                            Assert.that(!this.getConnectionByPeerAddress(peer.peerAddress), 'PeerConnection not removed');\n                        }\n                        // The peer with the higher peerId closes this connection and keeps his stored connection.\n                        else {\n                            peerConnection.peerChannel.close(CloseType.SIMULTANEOUS_CONNECTION,\n                                'simultaneous connection (post handshake) - higher peerId');\n                            return;\n                        }\n                        break;\n\n                    default:\n                        // Accept this connection and close the stored connection.\n                        storedConnection.peerChannel.close(CloseType.SIMULTANEOUS_CONNECTION,\n                            `simultaneous connection (post handshake) - state ${storedConnection.state}`);\n                        Assert.that(!this.getConnectionByPeerAddress(peer.peerAddress), 'PeerConnection not removed');\n                }\n            }\n\n            Assert.that(!this.getConnectionByPeerAddress(peer.peerAddress), `PeerConnection ${peer.peerAddress} already exists`);\n            peerConnection.peerAddress = peer.peerAddress;\n            this._add(peerConnection);\n\n            this._inboundCount--;\n            Assert.that(this._inboundCount >= 0, 'inboundCount < 0');\n        }\n\n        // Handshake accepted.\n\n        // Check if we need to recycle a connection.\n        if (this.peerCount >= Network.PEER_COUNT_MAX) {\n            this.fire('recycling-request');\n        }\n\n        // Set peerConnection to ESTABLISHED state.\n        peerConnection.peer = peer;\n\n        if (peer.netAddress && !peer.netAddress.isPseudo() && this.getConnectionsByNetAddress(peer.netAddress).indexOf(peerConnection) < 0) {\n            this._addNetAddress(peerConnection, peer.netAddress);\n        }\n \n        this._updateConnectedPeerCount(peerConnection, 1);\n\n        this._addresses.established(peer.channel, peer.peerAddress);\n\n        // Let listeners know about this peer.\n        this.fire('peer-joined', peer);\n\n        // Let listeners know that the peers changed.\n        this.fire('peers-changed');\n\n        Log.d(ConnectionPool, () => `[PEER-JOINED] ${peer.peerAddress} ${peer.netAddress} (version=${peer.version}, services=${peer.peerAddress.services}, headHash=${peer.headHash.toBase64()})`);\n    }\n\n    /**\n     * This peer channel was closed.\n     * @param {PeerConnection} peerConnection\n     * @param {number} type\n     * @param {string} reason\n     * @fires ConnectionPool#peer-left\n     * @fires ConnectionPool#peers-changed\n     * @fires ConnectionPool#close\n     * @returns {void}\n     * @private\n     */\n    _onClose(peerConnection, type, reason) {\n        // Update total bytes sent/received.\n        this._bytesSent += peerConnection.networkConnection.bytesSent;\n        this._bytesReceived += peerConnection.networkConnection.bytesReceived;\n\n        // Only propagate the close type (i.e. track fails/bans) if the peerAddress is set.\n        // This is true for\n        // - all outbound connections\n        // - inbound connections post handshake (peerAddress is verified)\n        if (peerConnection.peerAddress) {\n            this._addresses.close(peerConnection.peerChannel, peerConnection.peerAddress, type);\n        }\n\n        this._remove(peerConnection);\n\n        // Check if the handshake with this peer has completed.\n        if (peerConnection.state === PeerConnectionState.ESTABLISHED) {\n            // If closing is due to a ban, also ban the IP\n            if (CloseType.isBanningType(type) && peerConnection.peer.netAddress){\n                this._banIp(peerConnection.peer.netAddress);\n            }\n\n            this._updateConnectedPeerCount(peerConnection, -1);\n\n            // Tell listeners that this peer has gone away.\n            this.fire('peer-left', peerConnection.peer);\n\n            // Let listeners know that the peers changed.\n            this.fire('peers-changed');\n\n            const kbTransferred = ((peerConnection.networkConnection.bytesSent\n                + peerConnection.networkConnection.bytesReceived) / 1000).toFixed(2);\n            Log.d(ConnectionPool, `[PEER-LEFT] ${peerConnection.peerAddress} ${peerConnection.peer.netAddress} `\n                + `(version=${peerConnection.peer.version}, transferred=${kbTransferred} kB, closeType=${type} ${reason})`);\n        } else {\n            if (peerConnection.networkConnection.inbound) {\n                this._inboundCount--;\n                Log.w(ConnectionPool, `Inbound connection #${peerConnection.networkConnection.id} closed pre-handshake: ${reason} (${type})`);\n            } else {\n                Log.w(ConnectionPool, `Connection #${peerConnection.networkConnection.id} to ${peerConnection.peerAddress} closed pre-handshake: ${reason} (${type})`);\n                this.fire('connect-error', peerConnection.peerAddress, `${reason} (${type})`);\n            }\n        }\n\n        // Let listeners know about this closing.\n        this.fire('close', peerConnection, type, reason);\n\n        // Set the peer connection to closed state.\n        peerConnection.close();\n    }\n\n    /**\n     * @param {NetAddress} netAddress\n     * @returns {void}\n     * @private\n     */\n    _banIp(netAddress) {\n        if (!netAddress.isPseudo() && netAddress.reliable) {\n            Log.w(ConnectionPool, `Banning IP ${netAddress}`);\n            if (netAddress.isIPv4()) {\n                this._bannedIPv4IPs.put(netAddress, Date.now() + ConnectionPool.DEFAULT_BAN_TIME);\n            } else if (netAddress.isIPv6()) {\n                // Ban IPv6 IPs prefix based\n                this._bannedIPv6IPs.put(netAddress.ip.subarray(0,8), Date.now() + ConnectionPool.DEFAULT_BAN_TIME);\n            }\n        }\n    }\n\n    /**\n     * @param {NetAddress} netAddress\n     * @returns {boolean}\n     * @private\n     */\n    _isIpBanned(netAddress) {\n        if (netAddress.isPseudo()) return false;\n        if (netAddress.isIPv4()) {\n            return this._bannedIPv4IPs.contains(netAddress);\n        } else if (netAddress.isIPv6()) {\n            const prefix = netAddress.ip.subarray(0, 8);\n            return this._bannedIPv6IPs.contains(prefix);\n        }\n        return false;\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _checkUnbanIps() {\n        const now = Date.now();\n        for (const netAddress of this._bannedIPv4IPs.keys()) {\n            if (this._bannedIPv4IPs.get(netAddress) < now) {\n                this._bannedIPv4IPs.remove(netAddress);\n            }\n        }\n        for (const prefix of this._bannedIPv6IPs.keys()) {\n            if (this._bannedIPv6IPs.get(prefix) < now) {\n                this._bannedIPv6IPs.remove(prefix);\n            }\n        }\n    }\n\n    /**\n     * Connection to this peer address failed.\n     * @param {PeerAddress} peerAddress\n     * @param {string|*} [reason]\n     * @fires ConnectionPool#connect-error\n     * @returns {void}\n     * @private\n     */\n    _onConnectError(peerAddress, reason) {\n        Log.w(ConnectionPool, `Connection to ${peerAddress} failed` + (typeof reason === 'string' ? ` - ${reason}` : ''));\n\n        const peerConnection = this.getConnectionByPeerAddress(peerAddress);\n        Assert.that(!!peerConnection, `PeerAddress not stored ${peerAddress}`);\n        Assert.that(peerConnection.state === PeerConnectionState.CONNECTING,\n            `PeerConnection state not CONNECTING, but ${peerConnection.state} (${peerAddress})`);\n        this._remove(peerConnection);\n\n        this._connectingCount--;\n        Assert.that(this._connectingCount >= 0, 'connectingCount < 0');\n\n        this._addresses.close(null, peerAddress, CloseType.CONNECTION_FAILED);\n\n        this.fire('connect-error', peerAddress, reason);\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @param {number} delta\n     * @returns {void}\n     * @private\n     */\n    _updateConnectedPeerCount(peerConnection, delta) {\n        const peerAddress = peerConnection.peerAddress;\n        switch (peerAddress.protocol) {\n            case Protocol.WS:\n                this._peerCountWs += delta;\n                Assert.that(this._peerCountWs >= 0, 'peerCountWs < 0');\n                break;\n            case Protocol.RTC:\n                this._peerCountRtc += delta;\n                Assert.that(this._peerCountRtc >= 0, 'peerCountRtc < 0');\n                break;\n            case Protocol.DUMB:\n                this._peerCountDumb += delta;\n                Assert.that(this._peerCountDumb >= 0, 'peerCountDumb < 0');\n                break;\n            default:\n                Log.w(PeerAddressBook, `Unknown protocol ${peerAddress.protocol}`);\n        }\n\n        if (Services.isFullNode(peerAddress.services)) {\n            this._peerCountFull += delta;\n            Assert.that(this._peerCountFull >= 0, 'peerCountFull < 0');\n        } else if (Services.isLightNode(peerAddress.services)) {\n            this._peerCountLight += delta;\n            Assert.that(this._peerCountLight >= 0, 'peerCountLight < 0');\n        } else {\n            this._peerCountNano += delta;\n            Assert.that(this._peerCountNano >= 0, 'peerCountNano < 0');\n        }\n\n        if (peerConnection.networkConnection.outbound) {\n            this._peerCountOutbound += delta;\n            if (Services.isFullNode(peerAddress.services) && peerAddress.protocol === Protocol.WS) {\n                this._peerCountFullWsOutbound += delta;\n            }\n        }\n    }\n\n\n    /**\n     * @param {string|*} reason\n     * @returns {void}\n     */\n    disconnect(reason) {\n        // Close all active connections.\n        for (const connection of this.values()) {\n            if (connection.peerChannel) {\n                connection.peerChannel.close(CloseType.MANUAL_NETWORK_DISCONNECT, reason || 'manual network disconnect');\n            }\n        }\n    }\n\n    // XXX For testing\n    disconnectWebSocket() {\n        // Close all websocket connections.\n        for (const connection of this.values()) {\n            if (connection.peerChannel && connection.peerAddress && connection.peerAddress.protocol === Protocol.WS) {\n                connection.channel.close(CloseType.MANUAL_WEBSOCKET_DISCONNECT, 'manual websocket disconnect');\n            }\n        }\n    }\n\n    /** @type {number} */\n    get peerCountWs() {\n        return this._peerCountWs;\n    }\n\n    /** @type {number} */\n    get peerCountRtc() {\n        return this._peerCountRtc;\n    }\n\n    /** @type {number} */\n    get peerCountDumb() {\n        return this._peerCountDumb;\n    }\n\n    /** @type {number} */\n    get peerCount() {\n        return this._peerCountWs + this._peerCountRtc + this._peerCountDumb;\n    }\n\n    /** @type {number} */\n    get peerCountFull() {\n        return this._peerCountFull;\n    }\n\n    /** @type {number} */\n    get peerCountLight() {\n        return this._peerCountLight;\n    }\n\n    /** @type {number} */\n    get peerCountNano() {\n        return this._peerCountNano;\n    }\n\n    /** @type {number} */\n    get peerCountOutbound() {\n        return this._peerCountOutbound;\n    }\n\n    /** @type {number} */\n    get peerCountFullWsOutbound() {\n        return this._peerCountFullWsOutbound;\n    }\n\n    /** @type {number} */\n    get connectingCount() {\n        return this._connectingCount;\n    }\n\n    /** @type {number} */\n    get count() {\n        return this._connectionsByPeerAddress.length + this._inboundCount;\n    }\n\n    /** @type {number} */\n    get bytesSent() {\n        return this._bytesSent\n            + this.values().reduce((n, peerConnection) => n + (peerConnection.networkConnection ? peerConnection.networkConnection.bytesSent : 0), 0);\n    }\n\n    /** @type {number} */\n    get bytesReceived() {\n        return this._bytesReceived\n            + this.values().reduce((n, peerConnection) => n + (peerConnection.networkConnection ? peerConnection.networkConnection.bytesReceived : 0), 0);\n    }\n\n    /** @param {boolean} value */\n    set allowInboundExchange(value) {\n        this._allowInboundExchange = value;\n    }\n\n    /** @type {boolean} */\n    get allowInboundConnections() {\n        return this._allowInboundConnections;\n    }\n\n    /** @param {boolean} value */\n    set allowInboundConnections(value) {\n        this._allowInboundConnections = value;\n    }\n\n}\nConnectionPool.DEFAULT_BAN_TIME = 1000 * 60 * 10; // 10 minutes\nConnectionPool.UNBAN_IPS_INTERVAL = 1000 * 60; // 1 minute\n\nClass.register(ConnectionPool);\n","class PeerScorer {\n    /**\n     * @constructor\n     * @param {NetworkConfig} networkConfig\n     * @param {PeerAddressBook} addresses\n     * @param {ConnectionPool} connections\n     */\n    constructor(networkConfig, addresses, connections) {\n        /**\n         * @type {NetworkConfig}\n         * @private\n         */\n        this._networkConfig = networkConfig;\n\n        /**\n         * @type {PeerAddressBook}\n         * @private\n         */\n        this._addresses = addresses;\n\n        /**\n         * @type {ConnectionPool}\n         * @private\n         */\n        this._connections = connections;\n\n        /**\n         * @type {Array.<PeerConnection>}\n         * @private\n         */\n        this._connectionScores = null;\n    }\n\n    /**\n     * @returns {?PeerAddress}\n     */\n    pickAddress() {\n        const findCandidates = (addressStates, numCandidates, allowBadPeers = false) => {\n            const numAddresses = addressStates.length;\n\n            // Pick a random start index.\n            const index = Math.floor(Math.random() * numAddresses);\n\n            // Compute address scores until we have found at 1000 candidates with score >= 0.\n            const minCandidates = Math.min(numAddresses, numCandidates);\n            const candidates = [];\n            for (let i = 0; i < numAddresses; i++) {\n                const idx = (index + i) % numAddresses;\n                const addressState = addressStates[idx];\n                const score = this._scoreAddress(addressState, allowBadPeers);\n                if (score >= 0) {\n                    candidates.push({score, addressState});\n                    if (candidates.length >= minCandidates) {\n                        break;\n                    }\n                }\n            }\n\n            return candidates;\n        };\n\n        const addressStates = this._addresses.values();\n        let candidates = findCandidates(addressStates, 1000);\n        if (candidates.length === 0 && this.needsGoodPeers()) {\n            candidates = findCandidates(addressStates, 1000, true);\n        }\n\n        if (candidates.length === 0) {\n            return null;\n        }\n\n        // Return a random candidate with a high score.\n        const scores = candidates.sort((a, b) => b.score - a.score);\n        const goodCandidates = scores.slice(0, PeerScorer.PICK_SELECTION_SIZE);\n        const winner = ArrayUtils.randomElement(goodCandidates);\n        return winner.addressState.peerAddress;\n    }\n\n    /**\n     * @param {PeerAddressState} peerAddressState\n     * @param {boolean} [allowBadPeers]\n     * @returns {number}\n     * @private\n     */\n    _scoreAddress(peerAddressState, allowBadPeers = false) {\n        const peerAddress = peerAddressState.peerAddress;\n\n        // Filter addresses that we cannot connect to.\n        if (!this._networkConfig.canConnect(peerAddress.protocol)) {\n            return -1;\n        }\n\n        // Filter addresses not matching our accepted services.\n        if ((peerAddress.services & this._networkConfig.services.accepted) === 0) {\n            return -1;\n        }\n\n        // Filter addresses that are too old.\n        if (peerAddress.exceedsAge()) {\n            return -1;\n        }\n\n        // A channel to that peer address is CONNECTING, CONNECTED, NEGOTIATING OR ESTABLISHED\n        if (this._connections.getConnectionByPeerAddress(peerAddress)) {\n            return -1;\n        }\n\n        // If we need more good peers, only allow good peers unless allowBadPeers is true.\n        if (this.needsGoodPeers() && !this.isGoodPeer(peerAddress) && !allowBadPeers) {\n            return -1;\n        }\n\n        // Give all peers the same base score. Penalize peers with failed connection attempts.\n        const score = 1;\n        switch (peerAddressState.state) {\n            case PeerAddressState.BANNED:\n                return -1;\n\n            case PeerAddressState.NEW:\n            case PeerAddressState.TRIED:\n                return score;\n\n            case PeerAddressState.FAILED:\n                // Don't pick failed addresses when they have failed the maximum number of times.\n                return (1 - ((peerAddressState.failedAttempts + 1) / peerAddressState.maxFailedAttempts)) * score;\n\n            default:\n                return -1;\n        }\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isGoodPeerSet() {\n        return !this.needsGoodPeers() && !this.needsMorePeers();\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    needsGoodPeers() {\n        return this._connections.peerCountFullWsOutbound < PeerScorer.PEER_COUNT_MIN_FULL_WS_OUTBOUND;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    needsMorePeers() {\n        return this._connections.peerCountOutbound < PeerScorer.PEER_COUNT_MIN_OUTBOUND;\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {boolean}\n     */\n    isGoodPeer(peerAddress) {\n        return Services.isFullNode(peerAddress.services) && peerAddress.protocol === Protocol.WS;\n    }\n\n    /**\n     * @returns {void}\n     */\n    scoreConnections() {\n        const candidates = [];\n\n        for (const peerConnection of this._connections.values()) {\n            if (peerConnection.state === PeerConnectionState.ESTABLISHED) {\n                // Grant new connections a grace period from recycling.\n                if (peerConnection.ageEstablished > PeerScorer._getMinAge(peerConnection.peerAddress)) {\n                    peerConnection.score = this._scoreConnection(peerConnection);\n                    candidates.push(peerConnection);\n                }\n\n                peerConnection.statistics.reset();\n            }\n        }\n\n        // sort by score\n        this._connectionScores = candidates.sort((a, b) => b.score - a.score);\n    }\n\n    /**\n     * @param {number} count\n     * @param {number} type\n     * @param {string} reason\n     * @returns {void}\n     */\n    recycleConnections(count, type, reason) {\n        if (!this._connectionScores) {\n            return;\n        }\n\n        while (count > 0 && this._connectionScores.length > 0) {\n            const peerConnection = this._connectionScores.pop();\n            if (peerConnection.state === PeerConnectionState.ESTABLISHED) {\n                peerConnection.peerChannel.close(type, `${reason}`);\n                count--;\n            }\n        }\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @returns {number}\n     * @private\n     */\n    _scoreConnection(peerConnection) {\n        // Connection age\n        const scoreAge = this._scoreConnectionAge(peerConnection);\n\n        // Connection type (inbound/outbound)\n        const scoreOutbound = peerConnection.networkConnection.inbound ? 0 : 1;\n\n        // Node type (full/light/nano)\n        const peerAddress = peerConnection.peerAddress;\n        const scoreType = Services.isFullNode(peerAddress.services)\n            ? 1\n            : Services.isLightNode(peerAddress.services) ? 0.5 : 0;\n\n        // Protocol: Prefer WebSocket when low on WebSocket connections.\n        let scoreProtocol = 0;\n        if (peerAddress.protocol === Protocol.WS) {\n            const distribution = this._connections.peerCountWs / this._connections.peerCount;\n            if (distribution < PeerScorer.BEST_PROTOCOL_WS_DISTRIBUTION || this._connections.peerCountFullWsOutbound <= PeerScorer.PEER_COUNT_MIN_FULL_WS_OUTBOUND) {\n                scoreProtocol = 1;\n            }\n        }\n\n        // Connection speed, based on ping-pong latency median\n        const medianLatency = peerConnection.statistics.latencyMedian;\n        let scoreSpeed = 0;\n        if (medianLatency > 0 && medianLatency < NetworkAgent.PING_TIMEOUT) {\n            scoreSpeed = 1 - medianLatency / NetworkAgent.PING_TIMEOUT;\n        }\n\n        return 0.15 * scoreAge + 0.25 * scoreOutbound + 0.2 * scoreType + 0.2 * scoreProtocol + 0.2 * scoreSpeed;\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @returns {number}\n     * @private\n     */\n    _scoreConnectionAge(peerConnection) {\n        const score = (age, bestAge, maxAge) => Math.max(Math.min(1 - (age - bestAge) / maxAge, 1), 0);\n\n        const age = peerConnection.ageEstablished;\n        const services = peerConnection.peerAddress.services;\n        if (Services.isFullNode(services)) {\n            return age / (2 * PeerScorer.BEST_AGE_FULL) + 0.5;\n        } else if (Services.isLightNode(services)) {\n            return score(age, PeerScorer.BEST_AGE_LIGHT, PeerScorer.MAX_AGE_LIGHT);\n        } else {\n            return score(age, PeerScorer.BEST_AGE_NANO, PeerScorer.MAX_AGE_NANO);\n        }\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {number}\n     * @private\n     */\n    static _getMinAge(peerAddress) {\n        if (Services.isFullNode(peerAddress.services)) {\n            return PeerScorer.MIN_AGE_FULL;\n        } else if (Services.isLightNode(peerAddress.services)) {\n            return PeerScorer.MIN_AGE_LIGHT;\n        } else {\n            return PeerScorer.MIN_AGE_NANO;\n        }\n    }\n\n    /** @type {Number} */\n    get lowestConnectionScore() {\n        if (!this._connectionScores) {\n            return null;\n        }\n\n        // Remove all closed connections from the end of connectionScores.\n        while (this._connectionScores.length > 0\n            && this._connectionScores[this._connectionScores.length - 1].state !== PeerConnectionState.ESTABLISHED) {\n\n            this._connectionScores.pop();\n        }\n\n        return this._connectionScores.length > 0\n            ? this._connectionScores[this._connectionScores.length - 1].score\n            : null;\n    }\n}\n/**\n * @type {number}\n * @constant\n */\nPeerScorer.PEER_COUNT_MIN_FULL_WS_OUTBOUND = PlatformUtils.isNodeJs() ? 12 : 3;\n/**\n * @type {number}\n * @constant\n */\nPeerScorer.PEER_COUNT_MIN_OUTBOUND = PlatformUtils.isNodeJs() ? 12 : 6;\n/**\n * @type {number}\n * @constant\n */\nPeerScorer.PICK_SELECTION_SIZE = 100;\n\nPeerScorer.MIN_AGE_FULL = 5 * 60 * 1000; // 5 minutes\nPeerScorer.BEST_AGE_FULL = 24 * 60 * 60 * 1000; // 24 hours\n\nPeerScorer.MIN_AGE_LIGHT = 2 * 60 * 1000; // 2 minutes\nPeerScorer.BEST_AGE_LIGHT = 15 * 60 * 1000; // 15 minutes\nPeerScorer.MAX_AGE_LIGHT = 6 * 60 * 60 * 1000; // 6 hours\n\nPeerScorer.MIN_AGE_NANO = 60 * 1000; // 1 minute\nPeerScorer.BEST_AGE_NANO = 5 * 60 * 1000; // 5 minutes\nPeerScorer.MAX_AGE_NANO = 30 * 60 * 1000; // 30 minutes\n\nPeerScorer.BEST_PROTOCOL_WS_DISTRIBUTION = 0.15; // 15%\n\nClass.register(PeerScorer);\n","class NetworkConfig {\n    /**\n     * @returns {NetworkConfig}\n     */\n    static getDefault() {\n        return PlatformUtils.supportsWebRTC()\n            ? new RtcNetworkConfig()\n            : new DumbNetworkConfig();\n    }\n\n    /**\n     * @constructor\n     * @param {number} protocolMask\n     */\n    constructor(protocolMask) {\n        /** @type {number} */\n        this._protocolMask = protocolMask;\n\n        /**\n         * @type {KeyPair}\n         * @protected\n         */\n        this._keyPair = null;\n\n        /**\n         * @type {PeerId}\n         * @protected\n         */\n        this._peerId = null;\n\n        /**\n         * @type {Services}\n         * @protected\n         */\n        this._services = null;\n    }\n\n    /**\n     * @returns {void}\n     */\n    async initPersistent() {\n        const db = await PeerKeyStore.getPersistent();\n        await this._init(db);\n    }\n\n    /**\n     * @returns {void}\n     */\n    async initVolatile() {\n        const db = PeerKeyStore.createVolatile();\n        await this._init(db);\n    }\n\n    /**\n     * @private\n     * @param {PeerKeyStore} db\n     * @returns {void}\n     */\n    async _init(db) {\n        if (this._keyPair) {\n            return;\n        }\n\n        /** @type {KeyPair} */\n        let keys = await db.get('keys');\n        if (!keys) {\n            keys = KeyPair.generate();\n            await db.put('keys', keys);\n        }\n\n        this._keyPair = keys;\n        this._peerId = keys.publicKey.toPeerId();\n    }\n\n    /**\n     * Used for filtering peer addresses by protocols.\n     * @type {number}\n     */\n    get protocolMask() {\n        return this._protocolMask;\n    }\n\n    /**\n     * @type {KeyPair}\n     */\n    get keyPair() {\n        return this._keyPair;\n    }\n\n    /**\n     * @type {PublicKey}\n     */\n    get publicKey() {\n        return this._keyPair.publicKey;\n    }\n\n    /**\n     * @type {PeerId}\n     */\n    get peerId() {\n        return this._peerId;\n    }\n\n    /**\n     * @type {Services}\n     */\n    get services() {\n        return this._services;\n    }\n\n    /**\n     * @param {Services} services\n     */\n    set services(services) {\n        this._services = services;\n    }\n\n    /**\n     * @type {PeerAddress}\n     */\n    get peerAddress() {\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * @param {number} protocol\n     * @returns {boolean}\n     */\n    canConnect(protocol) {\n        return (protocol & this._protocolMask) !== 0;\n    }\n}\n\nClass.register(NetworkConfig);\n\nclass WsNetworkConfig extends NetworkConfig {\n    /**\n     * @constructor\n     * @param {string} host\n     * @param {number} port\n     * @param {string} key\n     * @param {string} cert\n     */\n    constructor(host, port, key, cert) {\n        super(Protocol.WS);\n        this._host = host;\n        this._port = port;\n        this._key = key;\n        this._cert = cert;\n\n        /* @type {{key: string, cert: string}} */\n        this._sslConfig = {\n            key: this._key,\n            cert: this._cert\n        };\n    }\n\n    /**\n     * @type {{key: string, cert: string}}\n     */\n    get sslConfig() {\n        return this._sslConfig;\n    }\n\n    /**\n     * @type {WsPeerAddress}\n     * @override\n     */\n    get peerAddress() {\n        if (!this._services || !this._keyPair) {\n            throw 'PeerAddress is not configured.';\n        }\n\n        const peerAddress = new WsPeerAddress(\n            this._services.provided, Date.now(), NetAddress.UNSPECIFIED,\n            this.publicKey, /*distance*/ 0,\n            this._host, this._port);\n\n        if (!peerAddress.globallyReachable()) {\n            throw 'PeerAddress not globally reachable.';\n        }\n        peerAddress.signature = Signature.create(this._keyPair.privateKey, this.publicKey, peerAddress.serializeContent());\n        return peerAddress;\n    }\n}\n\nClass.register(WsNetworkConfig);\n\nclass RtcNetworkConfig extends NetworkConfig {\n    /**\n     * @constructor\n     */\n    constructor() {\n        super(Protocol.WS | Protocol.RTC);\n        this._rtcConfig = {\n            iceServers: [\n                {urls: 'stun:stun.l.google.com:19302'},\n                {urls: 'stun:stun.nimiq-network.com:19302'}\n            ]\n        };\n    }\n\n    /**\n     * @returns {?RTCConfiguration}\n     */\n    get rtcConfig() {\n        return this._rtcConfig;\n    }\n\n    /**\n     * @type {RtcPeerAddress}\n     * @override\n     */\n    get peerAddress() {\n        if (!this._services || !this._keyPair) {\n            throw 'PeerAddress is not configured.';\n        }\n\n        const peerAddress = new RtcPeerAddress(\n            this._services.provided, Date.now(), NetAddress.UNSPECIFIED,\n            this.publicKey, /*distance*/ 0);\n        peerAddress.signature = Signature.create(this._keyPair.privateKey, this.publicKey, peerAddress.serializeContent());\n        return peerAddress;\n    }\n}\n\nClass.register(RtcNetworkConfig);\n\nclass DumbNetworkConfig extends NetworkConfig {\n    /**\n     * @constructor\n     */\n    constructor() {\n        super(Protocol.WS);\n    }\n\n    /**\n     * @type {DumbPeerAddress}\n     * @override\n     */\n    get peerAddress() {\n        if (!this._services || !this._keyPair) {\n            throw 'PeerAddress is not configured.';\n        }\n\n        const peerAddress = new DumbPeerAddress(\n            this._services.provided, Date.now(), NetAddress.UNSPECIFIED,\n            this.publicKey, /*distance*/ 0);\n        peerAddress.signature = Signature.create(this._keyPair.privateKey, this.publicKey, peerAddress.serializeContent());\n        return peerAddress;\n    }\n}\n\nClass.register(DumbNetworkConfig);\n","class Network extends Observable {\n    /**\n     * @constructor\n     * @param {IBlockchain} blockchain\n     * @param {NetworkConfig} networkConfig\n     * @param {Time} time\n     * @listens PeerAddressBook#added\n     * @listens ConnectionPool#peer-joined\n     * @listens ConnectionPool#peer-left\n     * @listens ConnectionPool#peers-changed\n     * @listens ConnectionPool#recycling-request\n     * @listens ConnectionPool#connect-error\n     */\n    constructor(blockchain, networkConfig, time) {\n        super();\n\n        /**\n         * @type {IBlockchain}\n         * @private\n         */\n        this._blockchain = blockchain;\n\n        /**\n         * @type {NetworkConfig}\n         * @private\n         */\n        this._networkConfig = networkConfig;\n\n        /**\n         * @type {Time}\n         * @private\n         */\n        this._time = time;\n\n        /**\n         * Flag indicating whether we should actively connect to other peers\n         * if our peer count is below PEER_COUNT_DESIRED.\n         * @type {boolean}\n         * @private\n         */\n        this._autoConnect = false;\n\n        /**\n         * Backoff for peer count check in seconds.\n         * @type {number}\n         * @private\n         */\n        this._backoff = Network.CONNECT_BACKOFF_INITIAL;\n\n        /**\n         * Flag indicating whether we already triggered a backoff.\n         * @type {boolean}\n         * @private\n         */\n        this._backedOff = false;\n\n        /**\n         * The network's addressbook\n         * @type {PeerAddressBook}\n         * @private\n         */\n        this._addresses = new PeerAddressBook(this._networkConfig);\n\n        // Relay new addresses to peers.\n        this._addresses.on('added', addresses => {\n            this._relayAddresses(addresses);\n            this._checkPeerCount();\n        });\n       \n        /**\n         * Peer connections database & operator\n         * @type {ConnectionPool}\n         * @private\n         */\n        this._connections = new ConnectionPool(this._addresses, networkConfig, blockchain, time);\n\n        this._connections.on('peer-joined', peer => this._onPeerJoined(peer));\n        this._connections.on('peer-left', peer => this._onPeerLeft(peer));\n        this._connections.on('peers-changed', () => this._onPeersChanged());\n        this._connections.on('recycling-request', () => this._onRecyclingRequest());\n        this._connections.on('connect-error', () => setTimeout(this._checkPeerCount.bind(this), Network.CONNECT_THROTTLE));\n\n        /**\n         * Helper object to pick addresses from PeerAddressBook.\n         * @type {PeerScorer}\n         * @private\n         */\n        this._scorer = new PeerScorer(this._networkConfig, this._addresses, this._connections);\n\n        /**\n         * @type {number|null}\n         * @private\n         */\n        this._houseKeepingIntervalId = null;\n\n        /**\n         * @type {Timers}\n         */\n        this._timers = new Timers();\n    }\n\n    /**\n     * @returns {void}\n     */\n    connect() {\n        this._autoConnect = true;\n\n        // Setup housekeeping interval.\n        this._houseKeepingIntervalId = setInterval(() => this._housekeeping(), Network.HOUSEKEEPING_INTERVAL);\n\n        // Start connecting to peers.\n        this._checkPeerCount();\n    }\n\n    /**\n     * @param {string|*} reason\n     * @returns {void}\n     */\n    disconnect(reason) {\n        this._autoConnect = false;\n\n        // Clear housekeeping interval.\n        clearInterval(this._houseKeepingIntervalId);\n\n        this._connections.disconnect(reason);\n        this._connections.allowInboundConnections = false;\n    }\n\n    // XXX For testing\n    disconnectWebSocket() {\n        this._autoConnect = false;\n\n        this._connections.disconnectWebSocket();\n    }\n\n    /**\n     * @param {Peer} peer\n     * @returns {void}\n     * @fires Network#peer-joined\n     * @private\n     */\n    _onPeerJoined(peer) {\n        // Recalculate the network adjusted offset\n        this._updateTimeOffset();\n\n        // Tell others about the address that we just connected to.\n        this._relayAddresses([peer.peerAddress]);\n\n        this.fire('peer-joined', peer);\n    }\n\n    /**\n     * @param {Peer} peer\n     * @returns {void}\n     * @fires Network#peer-left\n     * @private\n     */\n    _onPeerLeft(peer) {\n        // Recalculate the network adjusted offset\n        this._updateTimeOffset();\n\n        this.fire('peer-left', peer);\n    }\n\n    /**\n     * @returns {void}\n     * @fires Network#peers-changed\n     * @private\n     */\n    _onPeersChanged() {\n        setTimeout(this._checkPeerCount.bind(this), Network.CONNECT_THROTTLE);\n\n        this.fire('peers-changed');\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _onRecyclingRequest() {\n        this._scorer.recycleConnections(1, CloseType.PEER_CONNECTION_RECYCLED_INBOUND_EXCHANGE, 'Peer connection recycled inbound exchange');\n\n        // set ability to exchange for new inbound connections\n        this._connections.allowInboundExchange = this._scorer.lowestConnectionScore !== null\n            ? this._scorer.lowestConnectionScore < Network.SCORE_INBOUND_EXCHANGE\n            : false;\n    }\n\n    /**\n     * @param {Array.<PeerAddress>} addresses\n     * @returns {void}\n     * @private\n     */\n    _relayAddresses(addresses) {\n        // Pick PEER_COUNT_RELAY random peers and relay addresses to them if:\n        // - number of addresses <= 10\n        // TODO more restrictions, see Bitcoin\n        if (addresses.length > 10) {\n            return;\n        }\n\n        // XXX We don't protect against picking the same peer more than once.\n        // The NetworkAgent will take care of not sending the addresses twice.\n        // In that case, the address will simply be relayed to less peers. Also,\n        // the peer that we pick might already know the address.\n        const peerConnections = this._connections.values();\n        for (let i = 0; i < Network.PEER_COUNT_RELAY; ++i) {\n            const peerConnection = ArrayUtils.randomElement(peerConnections);\n            if (peerConnection && peerConnection.state === PeerConnectionState.ESTABLISHED && peerConnection.networkAgent) {\n                peerConnection.networkAgent.relayAddresses(addresses);\n            }\n        }\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _checkPeerCount() {\n        if (this._autoConnect\n            && !this._scorer.isGoodPeerSet()\n            && this._connections.connectingCount < Network.CONNECTING_COUNT_MAX) {\n\n            // Pick a peer address that we are not connected to yet.\n            const peerAddress = this._scorer.pickAddress();\n\n            // We can't connect if we don't know any more addresses or only want connections to good peers.\n            const onlyGoodPeers = this._scorer.needsGoodPeers() && !this._scorer.needsMorePeers();\n            if (!peerAddress || onlyGoodPeers && !this._scorer.isGoodPeer(peerAddress)) {\n                // If no backoff has been triggered, trigger one.\n                // This helps us to check back whether we need more connections.\n                if (!this._backedOff) {\n                    this._backedOff = true;\n                    const oldBackoff = this._backoff;\n                    this._backoff = Math.min(Network.CONNECT_BACKOFF_MAX, oldBackoff * 2);\n                    setTimeout(() => {\n                        this._backedOff = false;\n                        this._checkPeerCount();\n                    }, oldBackoff);\n\n                    if (this._connections.count === 0) {\n                        // We are not connected to any peers (anymore) and don't know any more addresses to connect to.\n\n                        // Tell listeners that we are disconnected. This is primarily useful for tests.\n                        this.fire('disconnected');\n\n                        // Allow inbound connections. This is important for the first seed node on the network which\n                        // will never establish a consensus and needs to accept incoming connections eventually.\n                        this._connections.allowInboundConnections = true;\n                    }\n                }\n\n                return;\n            }\n\n            // Connect to this address.\n            if (!this._connections.connectOutbound(peerAddress)) {\n                this._addresses.close(null, peerAddress, CloseType.CONNECTION_FAILED);\n                setTimeout(() => this._checkPeerCount(), Network.CONNECT_THROTTLE);\n            }\n        }\n        this._backoff = Network.CONNECT_BACKOFF_INITIAL;\n    }\n\n    /**\n     * Updates the network time offset by calculating the median offset\n     * from all our peers.\n     * @returns {void}\n     * @private\n     */\n    _updateTimeOffset() {\n        const peerConnections = this._connections.values();\n\n        const offsets = [0]; // Add our own offset.\n        peerConnections.forEach(peerConnection => {\n            if (peerConnection.state === PeerConnectionState.ESTABLISHED) {\n                offsets.push(peerConnection.networkAgent.peer.timeOffset);\n            }\n        });\n\n        const offsetsLength = offsets.length;\n        offsets.sort((a, b) => a - b);\n\n        let timeOffset;\n        if ((offsetsLength % 2) === 0) {\n            timeOffset = Math.round((offsets[(offsetsLength / 2) - 1] + offsets[offsetsLength / 2]) / 2);\n        } else {\n            timeOffset = offsets[(offsetsLength - 1) / 2];\n        }\n\n        this._time.offset = Math.max(Math.min(timeOffset, Network.TIME_OFFSET_MAX), -Network.TIME_OFFSET_MAX);\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _housekeeping() {\n        this._scorer.scoreConnections();\n\n        // recycle\n        if (this.peerCount > Network.PEER_COUNT_RECYCLING_ACTIVE) {\n            // recycle 1% at PEER_COUNT_RECYCLING_ACTIVE, 20% at PEER_COUNT_MAX\n            const percentageToRecycle = (this.peerCount - Network.PEER_COUNT_RECYCLING_ACTIVE) * 0.19 / (Network.PEER_COUNT_MAX - Network.PEER_COUNT_RECYCLING_ACTIVE) + 0.01;\n            const connectionsToRecycle = Math.ceil(this.peerCount * percentageToRecycle);\n            this._scorer.recycleConnections(connectionsToRecycle, CloseType.PEER_CONNECTION_RECYCLED, 'Peer connection recycled');\n        }\n\n        // set ability to exchange for new inbound connections\n        this._connections.allowInboundExchange = this._scorer.lowestConnectionScore !== null\n            ? this._scorer.lowestConnectionScore < Network.SCORE_INBOUND_EXCHANGE\n            : false;\n    }\n\n    /** @type {Time} */\n    get time() {\n        return this._time;\n    }\n\n    /** @type {number} */\n    get peerCount() {\n        return this._connections.peerCount;\n    }\n\n    /** @type {number} */\n    get peerCountWebSocket() {\n        return this._connections.peerCountWs;\n    }\n\n    /** @type {number} */\n    get peerCountWebRtc() {\n        return this._connections.peerCountRtc;\n    }\n\n    /** @type {number} */\n    get peerCountDumb() {\n        return this._connections.peerCountDumb;\n    }\n\n    /** @type {number} */\n    get peerCountConnecting() {\n        return this._connections.connectingCount;\n    }\n\n    /** @type {number} */\n    get knownAddressesCount() {\n        return this._addresses.knownAddressesCount;\n    }\n\n    /** @type {number} */\n    get bytesSent() {\n        return this._connections.bytesSent;\n    }\n\n    /** @type {number} */\n    get bytesReceived() {\n        return this._connections.bytesReceived;\n    }\n\n    /** @type {boolean} */\n    get allowInboundConnections() {\n        return this._connections.allowInboundConnections;\n    }\n\n    /** @param {boolean} allowInboundConnections */\n    set allowInboundConnections(allowInboundConnections) {\n        this._connections.allowInboundConnections = allowInboundConnections;\n    }\n\n    /** @type {PeerAddressBook} */\n    get addresses() {\n        return this._addresses;\n    }\n\n    /** @type {ConnectionPool} */\n    get connections() {\n        return this._connections;\n    }\n}\n/**\n * @type {number}\n * @constant\n */\nNetwork.PEER_COUNT_MAX = PlatformUtils.isBrowser() ? 15 : 50000;\n/**\n * @type {number}\n * @constant\n */\nNetwork.INBOUND_PEER_COUNT_PER_SUBNET_MAX = PlatformUtils.isBrowser() ? 2 : 100;\n/**\n * @type {number}\n * @constant\n */\nNetwork.OUTBOUND_PEER_COUNT_PER_SUBNET_MAX = 2;\n/**\n * @type {number}\n * @constant\n */\nNetwork.PEER_COUNT_PER_IP_MAX = PlatformUtils.isBrowser() ? 1 : 20;\n/**\n * @type {number}\n * @constant\n */\nNetwork.IPV4_SUBNET_MASK = 24;\n/**\n * @type {number}\n * @constant\n */\nNetwork.IPV6_SUBNET_MASK = 96;\n/**\n * @type {number}\n * @constant\n */\nNetwork.PEER_COUNT_RECYCLING_ACTIVE = PlatformUtils.isBrowser() ? 5 : 1000;\n/**\n * @type {number}\n * @constant\n */\nNetwork.PEER_COUNT_RELAY = 4;\n/**\n * @type {number}\n * @constant\n */\nNetwork.CONNECTING_COUNT_MAX = 2;\n/**\n * @type {number}\n * @constant\n */\nNetwork.SIGNAL_TTL_INITIAL = 3;\n/**\n * @type {number}\n * @constant\n */\nNetwork.CONNECT_BACKOFF_INITIAL = 1000; // 1 second\n/**\n * @type {number}\n * @constant\n */\nNetwork.CONNECT_BACKOFF_MAX = 5 * 60 * 1000; // 5 minutes\n/**\n * @type {number}\n * @constant\n */\nNetwork.TIME_OFFSET_MAX = 15 * 60 * 1000; // 15 minutes\n/**\n * @type {number}\n * @constant\n */\nNetwork.HOUSEKEEPING_INTERVAL = 5 * 60 * 1000; // 5 minutes\n/**\n * @type {number}\n * @constant\n */\nNetwork.SCORE_INBOUND_EXCHANGE = 0.5;\n/**\n * @type {number}\n * @constant\n */\nNetwork.CONNECT_THROTTLE = 300; // 300 ms\n\nClass.register(Network);\n","class NetUtils {\n    /**\n     * @param {string|Uint8Array} ip\n     * @return {boolean}\n     */\n    static isPrivateIP(ip) {\n        if (!(ip instanceof Uint8Array)) {\n            ip = NetUtils.ipToBytes(ip);\n        }\n\n        if (NetUtils.isLocalIP(ip)) {\n            return true;\n        }\n\n        if (NetUtils.isIPv4Address(ip)) {\n            for (const subnet of NetUtils.IPv4_PRIVATE_NETWORK) {\n                if (NetUtils.isIPv4inSubnet(ip, subnet)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        if (NetUtils.isIPv6Address(ip)) {\n            // Private subnet is fc00::/7.\n            // So, we only check the first 7 bits of the address to be equal fc00.\n            if ((ip[0] & 0xfe) === 0xfc) {\n                return true;\n            }\n\n            // Link-local addresses are fe80::/10.\n            if (ip[0] === 0xfe && (ip[1] & 0xc0) === 0x80) {\n                return true;\n            }\n\n            // Does not seem to be a private IP.\n            return false;\n        }\n\n        throw `Malformed IP address ${ip}`;\n    }\n\n    /**\n     * @param {string|Uint8Array} ip\n     * @returns {boolean}\n     */\n    static isLocalIP(ip) {\n        if (!(ip instanceof Uint8Array)) {\n            ip = NetUtils.ipToBytes(ip);\n        }\n\n        if (ip.length === NetUtils.IPv4_LENGTH) {\n            return ip[0] === 127 && ip[1] === 0 && ip[2] === 0 && ip[3] === 1;\n        }\n        if (ip.length === NetUtils.IPv6_LENGTH) {\n            for (let i = 0; i < NetUtils.IPv6_LENGTH - 1; i++) {\n                if (ip[i] !== 0) return false;\n            }\n            return ip[NetUtils.IPv6_LENGTH - 1] === 1;\n        }\n\n        return false;\n    }\n\n    /**\n     * @param {string|Uint8Array} ip\n     * @param {string} subnet\n     * @return {boolean}\n     */\n    static isIPv4inSubnet(ip, subnet) {\n        if (!(ip instanceof Uint8Array)) {\n            ip = NetUtils.ipToBytes(ip);\n        }\n\n        let [subIp, mask] = subnet.split('/');\n        mask = -1<<(32-parseInt(mask));\n        return (NetUtils._IPv4toLong(ip) & mask) === NetUtils._IPv4toLong(subIp);\n    }\n\n    /**\n     * @param {string|Uint8Array} ip\n     * @return {boolean}\n     */\n    static isIPv4Address(ip) {\n        if (ip instanceof Uint8Array) return ip.length === NetUtils.IPv4_LENGTH;\n        const match = ip.match(/^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/);\n        return !!match && parseInt(match[1]) <= 255 && parseInt(match[2]) <= 255\n            && parseInt(match[3]) <= 255 && parseInt(match[4]) <= 255;\n    }\n\n    /**\n     * @param {string|Uint8Array} ip\n     * @return {boolean}\n     */\n    static isIPv6Address(ip) {\n        if (ip instanceof Uint8Array) return ip.length === NetUtils.IPv6_LENGTH;\n\n        const parts = ip.toLowerCase().split(':');\n        // An IPv6 address consists of at most 8 parts and at least 3.\n        if (parts.length > 8 || parts.length < 3) {\n            return false;\n        }\n\n        const isEmbeddedIPv4 = NetUtils.isIPv4Address(parts[parts.length - 1]);\n\n        let innerEmpty = false;\n        for (let i = 0; i < parts.length; ++i) {\n            // Check whether each part is valid.\n            // Note: the last part may be a IPv4 address!\n            // They can be embedded in the last part. Remember that they take 32bit.\n            if (!(/^[a-f0-9]{0,4}$/.test(parts[i])\n                    || (i === parts.length - 1\n                        && isEmbeddedIPv4\n                        && parts.length < 8))) {\n                return false;\n            }\n            // Inside the parts, there has to be at most one empty part.\n            if (parts[i].length === 0 && i > 0 && i < parts.length - 1) {\n                if (innerEmpty) {\n                    return false; // at least two empty parts\n                }\n                innerEmpty = true;\n            }\n        }\n\n        // In the special case of embedded IPv4 addresses, everything but the last 48 bit must be 0.\n        if (isEmbeddedIPv4) {\n            // Exclude the last two parts.\n            for (let i=0; i<parts.length-2; ++i) {\n                if (!/^0{0,4}$/.test(parts[i])) {\n                    return false;\n                }\n            }\n        }\n\n        // If the first part is empty, the second has to be empty as well (e.g., ::1).\n        if (parts[0].length === 0) {\n            return parts[1].length === 0;\n        }\n\n        // If the last part is empty, the second last has to be empty as well (e.g., 1::).\n        if (parts[parts.length - 1].length === 0) {\n            return parts[parts.length - 2].length === 0;\n        }\n\n        // If the length is less than 7 and an IPv4 address is embedded, there has to be an empty part.\n        if (isEmbeddedIPv4 && parts.length < 7) {\n            return innerEmpty;\n        }\n\n        // Otherwise if the length is less than 8, there has to be an empty part.\n        if (parts.length < 8) {\n            return innerEmpty;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {string} ip\n     * @return {string}\n     */\n    static sanitizeIP(ip) {\n        const saneIp = NetUtils._normalizeIP(ip);\n        // FIXME\n        if (NetUtils.IP_BLACKLIST.indexOf(saneIp) >= 0) {\n            throw `Malformed IP address ${ip}`;\n        }\n        // TODO reject IPv6 broadcast addresses\n        return saneIp;\n    }\n\n    /**\n     * @param {string} host\n     * @returns {boolean}\n     */\n    static hostGloballyReachable(host) {\n        // IP addresses can't have a proper certificate\n        if (NetUtils.isIPv4Address(host) || NetUtils.isIPv6Address(host)) {\n            return false;\n        }\n        // \"the use of dotless domains is prohibited [in new gTLDs]\" [ https://www.icann.org/resources/board-material/resolutions-new-gtld-2013-08-13-en#1 ]. Old gTLDs rarely use them.\n        if (!host.match(/.+\\..+$/)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @param {string} ip\n     * @return {string}\n     */\n    static _normalizeIP(ip) {\n        if (NetUtils.isIPv4Address(ip)) {\n            // Re-create IPv4 address to strip possible leading zeros.\n            // Embed into IPv6 format.\n            const match = ip.match(/^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/);\n            return `${parseInt(match[1])}.${parseInt(match[2])}.${parseInt(match[3])}.${parseInt(match[4])}`;\n        }\n\n        if (NetUtils.isIPv6Address(ip)) {\n            // Shorten IPv6 address according to RFC 5952.\n\n            // Only use lower-case letters.\n            ip = ip.toLowerCase();\n\n            // Split into parts.\n            let parts = ip.split(':');\n\n            // Return normalized IPv4 address if embedded.\n            if (NetUtils.isIPv4Address(parts[parts.length - 1])) {\n                return NetUtils._normalizeIP(parts[parts.length - 1]);\n            }\n\n            // If it is already shortened at one point, blow it up again.\n            parts = NetUtils._extendIPv6(parts);\n\n            let maxZeroSeqStart = -1;\n            let maxZeroSeqLength = 0;\n            let curZeroSeqStart = -1;\n            let curZeroSeqLength = 1;\n            for (let i = 0; i < parts.length; ++i) {\n                // Remove leading zeros from each part, but keep at least one number.\n                parts[i] = parts[i].replace(/^0+([a-f0-9])/, '$1');\n\n                // We look for the longest, leftmost consecutive sequence of zero parts.\n                if (parts[i] === '0') {\n                    // Freshly started sequence.\n                    if (curZeroSeqStart < 0) {\n                        curZeroSeqStart = i;\n                    } else {\n                        // Known sequence, so increment length.\n                        curZeroSeqLength++;\n                    }\n                } else {\n                    // A sequence just ended, check if it is of better length.\n                    if (curZeroSeqStart >= 0 && curZeroSeqLength > maxZeroSeqLength) {\n                        maxZeroSeqStart = curZeroSeqStart;\n                        maxZeroSeqLength = curZeroSeqLength;\n                        curZeroSeqStart = -1;\n                        curZeroSeqLength = 1;\n                    }\n                }\n            }\n\n            if (curZeroSeqStart >= 0 && curZeroSeqLength > maxZeroSeqLength) {\n                maxZeroSeqStart = curZeroSeqStart;\n                maxZeroSeqLength = curZeroSeqLength;\n            }\n\n            // Remove consecutive zeros.\n            if (maxZeroSeqStart >= 0 && maxZeroSeqLength > 1) {\n                if (maxZeroSeqLength === parts.length) {\n                    return '::';\n                } else if (maxZeroSeqStart === 0 || maxZeroSeqStart + maxZeroSeqLength === parts.length) {\n                    parts.splice(maxZeroSeqStart, maxZeroSeqLength, ':');\n                } else {\n                    parts.splice(maxZeroSeqStart, maxZeroSeqLength, '');\n                }\n            }\n\n            return parts.join(':');\n        }\n\n        throw `Malformed IP address ${ip}`;\n    }\n\n    /**\n     * @param {string|Uint8Array} ip\n     * @return {number}\n     */\n    static _IPv4toLong(ip) {\n        if (!(ip instanceof Uint8Array)) {\n            ip = NetUtils.ipToBytes(ip);\n        }\n        return (ip[0]<<24) + (ip[1]<<16) + (ip[2]<<8) + ip[3];\n    }\n\n    /**\n     * @param {string} ip\n     * @returns {string}\n     * @private\n     */\n    static _IPv4toIPv6(ip) {\n        let parts = ip.split('.');\n        parts = parts.map(x => parseInt(x));\n        const mask = [];\n        for(let i = 0; i < 4; i++) {\n            mask.push(('00' + parts[i].toString(16)).slice(-2));\n        }\n        return `${mask[0]}${mask[1]}:${mask[2]}${mask[3]}`;\n    }\n\n    /**\n     * @param {string} ip\n     * @returns {Uint8Array}\n     */\n    static ipToBytes(ip) {\n        if (NetUtils.isIPv4Address(ip)) {\n            const parts = ip.split('.');\n            return new Uint8Array(parts.map(x => parseInt(x)));\n        }\n\n        if (NetUtils.isIPv6Address(ip)) {\n            let parts = ip.toLowerCase().split(':');\n\n            // Handle embedded IPv4 addresses.\n            if (NetUtils.isIPv4Address(parts[parts.length - 1])) {\n                return NetUtils.ipToBytes(parts[parts.length - 1]);\n            }\n\n            // IPv6\n            parts = NetUtils._extendIPv6(parts);\n            parts = parts.map(x => parseInt(x, 16));\n            const bytes = [];\n            for(let i = 0; i < 8; i++) {\n                bytes.push(parts[i] >> 8);\n                bytes.push(parts[i] & 0xff);\n            }\n            return new Uint8Array(bytes);\n        }\n\n        throw `Malformed IP address ${ip}`;\n    }\n\n    /**\n     * @param {Uint8Array} ip\n     * @returns {string}\n     */\n    static bytesToIp(ip) {\n        if (NetUtils.isIPv4Address(ip)) {\n            return ip.join('.');\n        }\n\n        if (NetUtils.isIPv6Address(ip)) {\n            const hexIp = Array.from(ip, x => ('00' + x.toString(16)).slice(-2));\n            const ipv6 = [];\n            for (let i = 0; i < 8; i++) {\n                ipv6.push(hexIp[i*2] + hexIp[i*2+1]);\n            }\n            return NetUtils.sanitizeIP(ipv6.join(':'));\n        }\n\n        throw `Malformed IP address ${ip}`;\n    }\n\n    /**\n     * @param {Array.<string>} parts\n     * @returns {Array.<string>}\n     * @private\n     */\n    static _extendIPv6(parts) {\n        // Handle embedded IPv4 addresses.\n        if (NetUtils.isIPv4Address(parts[parts.length - 1])) {\n            const ipv4 = parts[parts.length - 1];\n            const ipv6 = NetUtils._IPv4toIPv6(ipv4);\n            ip = ip.replace(ipv4, ipv6);\n            parts = ip.toLowerCase().split(':');\n        }\n\n        let emptyPart = parts.indexOf('');\n        // If there is an empty part, fill it up.\n        if (emptyPart >= 0) {\n            parts[emptyPart] = '0';\n            for (let i = parts.length; i < 8; i++) {\n                parts.splice(emptyPart, 0, '0');\n            }\n        }\n        // Fill remaining empty fields with 0 as well.\n        emptyPart = parts.indexOf('');\n        while (emptyPart >= 0) {\n            parts[emptyPart] = '0';\n            emptyPart = parts.indexOf('');\n        }\n\n        return parts;\n    }\n\n    /**\n     * @param {string|Uint8Array} ip\n     * @param {number} bitCount\n     * @return {string|Uint8Array}\n     */\n    static ipToSubnet(ip, bitCount) {\n        let stringResult = false;\n        if (!(ip instanceof Uint8Array)) {\n            ip = NetUtils.ipToBytes(ip);\n            stringResult = true;\n        }\n\n        const mask = [];\n        for(let i = 0; i < ip.byteLength; i++) {\n            const n = Math.min(bitCount, 8);\n            mask.push(ip[i] & (256 - Math.pow(2, 8 - n)));\n            bitCount -= n;\n        }\n        const result = new Uint8Array(mask);\n        return stringResult ? NetUtils.bytesToIp(result) : result;\n    }\n}\nNetUtils.IPv4_LENGTH = 4;\nNetUtils.IPv6_LENGTH = 16;\nNetUtils.IP_BLACKLIST = [\n    '0.0.0.0',\n    '255.255.255.255',\n    '::',\n];\nNetUtils.IPv4_PRIVATE_NETWORK = [\n    '10.0.0.0/8',\n    '172.16.0.0/12',\n    '192.168.0.0/16',\n    '100.64.0.0/10', // link-local\n\n    // Actually, the following one is only an approximation,\n    // the first and the last /24 subnets in the range should be excluded.\n    '169.254.0.0/16'\n];\nClass.register(NetUtils);\n","class PeerKeyStore {\n    /**\n     * @returns {Promise.<PeerKeyStore>}\n     */\n    static async getPersistent() {\n        if (!PeerKeyStore._instance) {\n            const jdb = new JDB.JungleDB('peer-key', PeerKeyStore.VERSION, { maxDbSize: PeerKeyStore.INITIAL_DB_SIZE });\n\n            // Initialize object stores.\n            jdb.createObjectStore(PeerKeyStore.KEY_DATABASE, { codec: new PeerKeyStoreCodec() });\n\n            // Establish connection to database.\n            await jdb.connect();\n\n            PeerKeyStore._instance = new PeerKeyStore(jdb.getObjectStore(PeerKeyStore.KEY_DATABASE));\n        }\n        return PeerKeyStore._instance;\n    }\n\n    /**\n     * @returns {PeerKeyStore}\n     */\n    static createVolatile() {\n        const store = JDB.JungleDB.createVolatileObjectStore();\n        return new PeerKeyStore(store);\n    }\n\n    /**\n     * @param {IObjectStore} store\n     */\n    constructor(store) {\n        this._store = store;\n    }\n\n    /**\n     * @param {string} key\n     * @returns {Promise.<KeyPair>}\n     */\n    get(key) {\n        return this._store.get(key);\n    }\n\n    /**\n     * @param {string} key\n     * @param {KeyPair} keyPair\n     * @returns {Promise}\n     */\n    put(key, keyPair) {\n        return this._store.put(key, keyPair);\n    }\n}\nPeerKeyStore._instance = null;\nPeerKeyStore.VERSION = 2;\nPeerKeyStore.KEY_DATABASE = 'keys';\nPeerKeyStore.INITIAL_DB_SIZE = 1024*1024*10; // 10 MB\nClass.register(PeerKeyStore);\n\n/**\n * @implements {ICodec}\n */\nclass PeerKeyStoreCodec {\n    /**\n     * @param {*} obj The object to encode before storing it.\n     * @returns {*} Encoded object.\n     */\n    encode(obj) {\n        return obj.serialize();\n    }\n\n    /**\n     * @param {*} buf The object to decode.\n     * @param {string} key The object's primary key.\n     * @returns {*} Decoded object.\n     */\n    decode(buf, key) {\n        return KeyPair.unserialize(new SerialBuffer(buf));\n    }\n\n    /**\n     * @type {string}\n     */\n    get leveldbValueEncoding() {\n        return 'binary';\n    }\n\n    /**\n     * @type {object}\n     */\n    get lmdbValueEncoding() {\n        return JDB.JungleDB.BINARY_ENCODING;\n    }\n}\n","class Peer {\n    /**\n     * @param {PeerChannel} channel\n     * @param {number} version\n     * @param {Hash} headHash\n     * @param {number} timeOffset\n     */\n    constructor(channel, version, headHash, timeOffset) {\n        /** @type {PeerChannel} */\n        this._channel = channel;\n        /** @type {number} */\n        this._version = version;\n        /** @type {Hash} */\n        this._headHash = headHash;\n        /** @type {BlockHeader} */\n        this._head = null;\n        /**\n         * Offset between the peer's time and our local time.\n         * @type {number}\n         */\n        this._timeOffset = timeOffset;\n\n        this._setNetAddress();\n    }\n\n    /**\n     * @private\n     * @returns {void}\n     */\n    _setNetAddress() {\n        // If the connector was able the determine the peer's netAddress, update the peer's advertised netAddress.\n        if (this.channel.netAddress) {\n            /*\n             * TODO What to do if it doesn't match the currently advertised one?\n             * This might happen if multiple IPs are assigned to a host.\n             */\n            if (this.peerAddress.netAddress && !this.peerAddress.netAddress.equals(this.channel.netAddress)) {\n                Log.w(Peer, `Got different netAddress ${this.channel.netAddress} for ${this.peerAddress} `\n                    + `- advertised was ${this.peerAddress.netAddress}`);\n            }\n\n            // Only set the advertised netAddress if we have the public IP of the peer.\n            // WebRTC connectors might return local IP addresses for peers on the same LAN.\n            if (!this.channel.netAddress.isPrivate()) {\n                this.peerAddress.netAddress = this.channel.netAddress;\n            }\n        }\n        // Otherwise, use the netAddress advertised for this peer if available.\n        else if (this.channel.peerAddress.netAddress) {\n            this.channel.netAddress = this.channel.peerAddress.netAddress;\n        }\n        // Otherwise, we don't know the netAddress of this peer. Use a pseudo netAddress.\n        else {\n            this.channel.netAddress = NetAddress.UNKNOWN;\n        }\n    }\n\n    /** @type {PeerChannel} */\n    get channel() {\n        return this._channel;\n    }\n\n    /** @type {number} */\n    get version() {\n        return this._version;\n    }\n\n    /** @type {Hash} */\n    get headHash() {\n        return this._headHash;\n    }\n\n    /** @type {BlockHeader} */\n    get head() {\n        return this._head;\n    }\n\n    /** @param {BlockHeader} head */\n    set head(head) {\n        this._head = head;\n        this._headHash = head.hash();\n    }\n\n    /** @type {number} */\n    get timeOffset() {\n        return this._timeOffset;\n    }\n\n    /** @type {number} */\n    get id() {\n        return this._channel.id;\n    }\n\n    /** @type {PeerAddress} */\n    get peerAddress() {\n        return this._channel.peerAddress;\n    }\n\n    /** @type {NetAddress} */\n    get netAddress() {\n        return this._channel.netAddress;\n    }\n\n    /**\n     * @param {Peer} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof Peer\n            && this._channel.equals(o.channel);\n    }\n\n    hashCode() {\n        return this._channel.hashCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `Peer{version=${this._version}, headHash=${this._headHash}, `\n            + `peerAddress=${this.peerAddress}, netAddress=${this.netAddress}}`;\n    }\n}\nClass.register(Peer);\n","class Miner extends Observable {\n    /**\n     * @param {IBlockchain} blockchain\n     * @param {Accounts} accounts\n     * @param {Mempool} mempool\n     * @param {Time} time\n     * @param {Address} minerAddress\n     * @param {Uint8Array} [extraData=new Uint8Array(0)]\n     *\n     * @listens Mempool#transaction-added\n     * @listens Mempool#transaction-ready\n     */\n    constructor(blockchain, accounts, mempool, time, minerAddress, extraData = new Uint8Array(0)) {\n        super();\n        /** @type {IBlockchain} */\n        this._blockchain = blockchain;\n        /** @type {Accounts} */\n        this._accounts = accounts;\n        /** @type {Mempool} */\n        this._mempool = mempool;\n        /** @type {Time} */\n        this._time = time;\n        /** @type {Address} */\n        this._address = minerAddress;\n        /** @type {Uint8Array} */\n        this._extraData = extraData;\n\n        /**\n         * Number of hashes computed since the last hashrate update.\n         * @type {number}\n         * @private\n         */\n        this._hashCount = 0;\n\n        /**\n         * Timestamp of the last hashrate update.\n         * @type {number}\n         * @private\n         */\n        this._lastHashrate = 0;\n\n        /**\n         * Hashrate computation interval handle.\n         * @private\n         */\n        this._hashrateWorker = null;\n\n        /**\n         * The current hashrate of this miner.\n         * @type {number}\n         * @private\n         */\n        this._hashrate = 0;\n\n        /**\n         * The last hash counts used in the moving average.\n         * @type {Array.<number>}\n         * @private\n         */\n        this._lastHashCounts = [];\n\n        /**\n         * The total hashCount used in the current moving average.\n         * @type {number}\n         * @private\n         */\n        this._totalHashCount = 0;\n\n        /**\n         * The time elapsed for the last measurements used in the moving average.\n         * @type {Array.<number>}\n         * @private\n         */\n        this._lastElapsed = [];\n\n        /**\n         * The total time elapsed used in the current moving average.\n         * @type {number}\n         * @private\n         */\n        this._totalElapsed = 0;\n\n        /** @type {MinerWorkerPool} */\n        this._workerPool = new MinerWorkerPool();\n\n        if (typeof navigator === 'object' && navigator.hardwareConcurrency) {\n            this.threads = Math.ceil(navigator.hardwareConcurrency / 2);\n        } else if (PlatformUtils.isNodeJs()) {\n            const cores = require('os').cpus().length;\n            this.threads = Math.ceil(cores / 2);\n            if (cores === 1) this.throttleAfter = 2;\n        } else {\n            this.threads = 1;\n        }\n        this._workerPool.on('share', (obj) => this._onWorkerShare(obj));\n        this._workerPool.on('no-share', (obj) => this._onWorkerShare(obj));\n\n        /**\n         * Flag indicating that the mempool has changed since we started mining the current block.\n         * @type {boolean}\n         * @private\n         */\n        this._mempoolChanged = false;\n\n        /** @type {boolean} */\n        this._restarting = false;\n\n        /** @type {number} */\n        this._lastRestart = 0;\n\n        /** @type {boolean} */\n        this._submittingBlock = false;\n\n        // Listen to changes in the mempool which evicts invalid transactions\n        // after every blockchain head change and then fires 'transactions-ready'\n        // when the eviction process finishes. Restart work on the next block\n        // with fresh transactions when this fires.\n        this._mempool.on('transactions-ready', () => this._startWork());\n\n        // Immediately start processing transactions when they come in.\n        this._mempool.on('transaction-added', () => this._mempoolChanged = true);\n    }\n\n    startWork() {\n        if (this.working) {\n            return;\n        }\n\n        // Initialize hashrate computation.\n        this._hashCount = 0;\n        this._lastElapsed = [];\n        this._lastHashCounts = [];\n        this._totalHashCount = 0;\n        this._totalElapsed = 0;\n        this._lastHashrate = Date.now();\n        this._hashrateWorker = setInterval(() => this._updateHashrate(), 1000);\n        this._retry = 0;\n\n        // Tell listeners that we've started working.\n        this.fire('start', this);\n\n        // Kick off the mining process.\n        this._startWork().catch(Log.w.tag(Miner));\n    }\n\n    async _startWork() {\n        // XXX Needed as long as we cannot unregister from transactions-ready events.\n        if (!this.working || this._restarting) {\n            return;\n        }\n        try {\n            this._lastRestart = Date.now();\n            this._restarting = true;\n            this._mempoolChanged = false;\n\n            // Construct next block.\n            this._retry = 0;\n            const block = await this.getNextBlock();\n\n            Log.i(Miner, `Starting work on ${block.header}, transactionCount=${block.transactionCount}, hashrate=${this._hashrate} H/s`);\n\n            this._workerPool.startMiningOnBlock(block).catch(Log.w.tag(Miner));\n        } catch (e) {\n            Log.w(Miner, 'Failed to start work, retrying in 100ms');\n            this.stopWork();\n            setTimeout(() => this.startWork(), 100);\n        } finally {\n            this._restarting = false;\n        }\n    }\n\n    /**\n     * @param {{hash: Hash, nonce: number, block: Block}} obj\n     * @private\n     */\n    async _onWorkerShare(obj) {\n        this._hashCount += this._workerPool.noncesPerRun;\n        if (obj.block && obj.block.prevHash.equals(this._blockchain.headHash)) {\n            Log.d(Miner, () => `Received share: ${obj.nonce} / ${obj.hash.toHex()}`);\n            if (BlockUtils.isProofOfWork(obj.hash, obj.block.target) && !this._submittingBlock) {\n                obj.block.header.nonce = obj.nonce;\n                this._submittingBlock = true;\n                if (await obj.block.header.verifyProofOfWork()) {\n                    // Tell listeners that we've mined a block.\n                    this.fire('block-mined', obj.block, this);\n\n                    // Push block into blockchain.\n                    if ((await this._blockchain.pushBlock(obj.block)) < 0) {\n                        this._submittingBlock = false;\n                        this._startWork().catch(Log.w.tag(Miner));\n                        return;\n                    } else {\n                        this._submittingBlock = false;\n                    }\n                } else {\n                    Log.d(Miner, `Ignoring invalid share: ${await obj.block.header.pow()}`);\n                }\n            }\n        }\n        if (this._mempoolChanged && this._lastRestart + Miner.MIN_TIME_ON_BLOCK < Date.now()) {\n            this._startWork().catch(Log.w.tag(Miner));\n        }\n    }\n\n    /**\n     * @return {Promise.<Block>}\n     * @private\n     */\n    async getNextBlock() {\n        this._retry++;\n        try {\n            const nextTarget = await this._blockchain.getNextTarget();\n            const interlink = await this._getNextInterlink(nextTarget);\n            const body = await this._getNextBody(interlink.serializedSize);\n            const header = await this._getNextHeader(nextTarget, interlink, body);\n            if ((await this._blockchain.getNextTarget()) !== nextTarget) return this.getNextBlock();\n            return new Block(header, interlink, body);\n        } catch (e) {\n            // Retry up to three times.\n            if (this._retry <= 3) return this.getNextBlock();\n            throw e;\n        }\n    }\n\n    /**\n     * @param {number} nextTarget\n     * @param {BlockInterlink} interlink\n     * @param {BlockBody} body\n     * @return {Promise.<BlockHeader>}\n     * @private\n     */\n    async _getNextHeader(nextTarget, interlink, body) {\n        const prevHash = this._blockchain.headHash;\n        const interlinkHash = interlink.hash();\n        const height = this._blockchain.height + 1;\n\n        // Compute next accountsHash.\n        const accounts = await this._accounts.transaction();\n        let accountsHash;\n        try {\n            await accounts.commitBlockBody(body, height, this._blockchain.transactionCache);\n            accountsHash = await accounts.hash();\n            await accounts.abort();\n        } catch (e) {\n            await accounts.abort();\n            throw new Error(`Invalid block body: ${e.message}`);\n        }\n\n        const bodyHash = body.hash();\n        const timestamp = this._getNextTimestamp();\n        const nBits = BlockUtils.targetToCompact(nextTarget);\n        const nonce = 0;\n        return new BlockHeader(prevHash, interlinkHash, bodyHash, accountsHash, nBits, height, timestamp, nonce);\n    }\n\n    /**\n     * @param {number} nextTarget\n     * @returns {Promise.<BlockInterlink>}\n     * @private\n     */\n    _getNextInterlink(nextTarget) {\n        return this._blockchain.head.getNextInterlink(nextTarget);\n    }\n\n    /**\n     * @param {number} interlinkSize\n     * @return {BlockBody}\n     * @private\n     */\n    async _getNextBody(interlinkSize) {\n        const maxSize = Policy.BLOCK_SIZE_MAX\n            - BlockHeader.SERIALIZED_SIZE\n            - interlinkSize\n            - BlockBody.getMetadataSize(this._extraData);\n        const transactions = await this._mempool.getTransactionsForBlock(maxSize);\n        const prunedAccounts = await this._accounts.gatherToBePrunedAccounts(transactions, this._blockchain.height + 1, this._blockchain.transactionCache);\n        return new BlockBody(this._address, transactions, this._extraData, prunedAccounts);\n    }\n\n    /**\n     * @return {number}\n     * @private\n     */\n    _getNextTimestamp() {\n        const now = Math.floor(this._time.now() / 1000);\n        return Math.max(now, this._blockchain.head.timestamp + 1);\n    }\n\n    /**\n     * @fires Miner#stop\n     */\n    stopWork() {\n        // TODO unregister from blockchain head-changed events.\n        if (!this.working) {\n            return;\n        }\n\n        clearInterval(this._hashrateWorker);\n        this._hashrateWorker = null;\n        this._hashrate = 0;\n        this._lastElapsed = [];\n        this._lastHashCounts = [];\n        this._totalHashCount = 0;\n        this._totalElapsed = 0;\n\n        // Tell listeners that we've stopped working.\n        this._workerPool.stop();\n        this.fire('stop', this);\n\n        Log.i(Miner, 'Stopped work');\n    }\n\n    /**\n     * @fires Miner#hashrate-changed\n     * @private\n     */\n    _updateHashrate() {\n        const elapsed = (Date.now() - this._lastHashrate) / 1000;\n        const hashCount = this._hashCount;\n        // Enable next measurement.\n        this._hashCount = 0;\n        this._lastHashrate = Date.now();\n\n        // Update stored information on moving average.\n        this._lastElapsed.push(elapsed);\n        this._lastHashCounts.push(hashCount);\n        this._totalElapsed += elapsed;\n        this._totalHashCount += hashCount;\n\n        if (this._lastElapsed.length > Miner.MOVING_AVERAGE_MAX_SIZE) {\n            const oldestElapsed = this._lastElapsed.shift();\n            const oldestHashCount = this._lastHashCounts.shift();\n            this._totalElapsed -= oldestElapsed;\n            this._totalHashCount -= oldestHashCount;\n        }\n\n        this._hashrate = Math.round(this._totalHashCount / this._totalElapsed);\n\n        // Tell listeners about our new hashrate.\n        this.fire('hashrate-changed', this._hashrate, this);\n    }\n\n    /** @type {Address} */\n    get address() {\n        return this._address;\n    }\n\n    /** @type {boolean} */\n    get working() {\n        return !!this._hashrateWorker;\n    }\n\n    /** @type {number} */\n    get hashrate() {\n        return this._hashrate;\n    }\n\n    /** @type {number} */\n    get threads() {\n        return this._workerPool.poolSize;\n    }\n\n    /**\n     * @param {number} threads\n     */\n    set threads(threads) {\n        this._workerPool.poolSize = threads;\n    }\n\n    /** @type {number} */\n    get throttleWait() {\n        return this._workerPool.cycleWait;\n    }\n\n    /**\n     * @param {number} throttleWait\n     */\n    set throttleWait(throttleWait) {\n        this._workerPool.cycleWait = throttleWait;\n    }\n\n    /** @type {number} */\n    get throttleAfter() {\n        return this._workerPool.runsPerCycle;\n    }\n\n    /**\n     * @param {number} throttleAfter\n     */\n    set throttleAfter(throttleAfter) {\n        this._workerPool.runsPerCycle = throttleAfter;\n    }\n}\n\nMiner.MIN_TIME_ON_BLOCK = 10000;\nMiner.MOVING_AVERAGE_MAX_SIZE = 10;\nClass.register(Miner);\n","class Wallet {\n    /**\n     * Create a new Wallet.\n     * @returns {Promise.<Wallet>} Newly created Wallet.\n     */\n    static async generate() {\n        return new Wallet(KeyPair.generate());\n    }\n\n    /**\n     * @param {Uint8Array|string} buf\n     * @return {Wallet}\n     */\n    static loadPlain(buf) {\n        if (typeof buf === 'string') buf = BufferUtils.fromHex(buf);\n        if (!buf || buf.byteLength === 0) {\n            throw new Error('Invalid wallet seed');\n        }\n        return new Wallet(KeyPair.unserialize(new SerialBuffer(buf)));\n    }\n\n    /**\n     * @param {Uint8Array|string} buf\n     * @param {Uint8Array|string} key\n     * @return {Promise.<Wallet>}\n     */\n    static async loadEncrypted(buf, key) {\n        if (typeof buf === 'string') buf = BufferUtils.fromHex(buf);\n        if (typeof key === 'string') key = BufferUtils.fromAscii(key);\n        return new Wallet(await KeyPair.fromEncrypted(new SerialBuffer(buf), key));\n    }\n\n    /**\n     * Create a new Wallet object.\n     * @param {KeyPair} keyPair KeyPair owning this Wallet.\n     * @returns {Wallet} A newly generated Wallet.\n     */\n    constructor(keyPair) {\n        /** @type {KeyPair} */\n        this._keyPair = keyPair;\n        /** @type {Address} */\n        this._address = this._keyPair.publicKey.toAddress();\n    }\n\n    /**\n     * Create a Transaction that is signed by the owner of this Wallet.\n     * @param {Address} recipient Address of the transaction receiver\n     * @param {number} value Number of Satoshis to send.\n     * @param {number} fee Number of Satoshis to donate to the Miner.\n     * @param {number} validityStartHeight The validityStartHeight for the transaction.\n     * @returns {Transaction} A prepared and signed Transaction object. This still has to be sent to the network.\n     */\n    createTransaction(recipient, value, fee, validityStartHeight) {\n        const transaction = new BasicTransaction(this._keyPair.publicKey, recipient, value, fee, validityStartHeight);\n        transaction.signature = Signature.create(this._keyPair.privateKey, this._keyPair.publicKey, transaction.serializeContent());\n        return transaction;\n    }\n\n    /**\n     * Sign a transaction by the owner of this Wallet.\n     * @param {Transaction} transaction The transaction to sign.\n     * @returns {SignatureProof} A signature proof for this transaction.\n     */\n    signTransaction(transaction) {\n        const signature = Signature.create(this._keyPair.privateKey, this._keyPair.publicKey, transaction.serializeContent());\n        return SignatureProof.singleSig(this._keyPair.publicKey, signature);\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    exportPlain() {\n        return this._keyPair.serialize();\n    }\n\n    /**\n     * @param {Uint8Array|string} key\n     * @param {Uint8Array|string} [unlockKey]\n     * @return {Promise.<Uint8Array>}\n     */\n    exportEncrypted(key, unlockKey) {\n        if (typeof key === 'string') key = BufferUtils.fromAscii(key);\n        if (typeof unlockKey === 'string') unlockKey = BufferUtils.fromAscii(unlockKey);\n        return this._keyPair.exportEncrypted(key, unlockKey);\n    }\n\n    /** @type {boolean} */\n    get isLocked() {\n        return this.keyPair.isLocked;\n    }\n\n    /**\n     * @param {Uint8Array|string} key\n     * @returns {Promise.<void>}\n     */\n    lock(key) {\n        if (typeof key === 'string') key = BufferUtils.fromAscii(key);\n        return this.keyPair.lock(key);\n    }\n\n    relock() {\n        this.keyPair.relock();\n    }\n\n    /**\n     * @param {Uint8Array|string} key\n     * @returns {Promise.<void>}\n     */\n    unlock(key) {\n        if (typeof key === 'string') key = BufferUtils.fromAscii(key);\n        return this.keyPair.unlock(key);\n    }\n\n    /**\n     * @param {Wallet} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Wallet && this.keyPair.equals(o.keyPair) && this.address.equals(o.address);\n    }\n\n    /**\n     * The address of the Wallet owner.\n     * @type {Address}\n     */\n    get address() {\n        return this._address;\n    }\n\n    /**\n     * The public key of the Wallet owner\n     * @type {PublicKey}\n     */\n    get publicKey() {\n        return this._keyPair.publicKey;\n    }\n\n    /** @type {KeyPair} */\n    get keyPair() {\n        return this._keyPair;\n    }\n}\n\nClass.register(Wallet);\n","class MultiSigWallet extends Wallet {\n    /**\n     * Create a new MultiSigWallet object.\n     * @param {KeyPair} keyPair KeyPair owning this Wallet.\n     * @param {number} minSignatures Number of signatures required.\n     * @param {Array.<PublicKey>} publicKeys A list of all owners' public keys.\n     * @returns {MultiSigWallet} A newly generated MultiSigWallet.\n     */\n    static fromPublicKeys(keyPair, minSignatures, publicKeys) {\n        if (publicKeys.length === 0) throw new Error('publicKeys may not be empty');\n        if (minSignatures <= 0) throw new Error('minSignatures must be greater than 0');\n        if (!publicKeys.some(key => key.equals(keyPair.publicKey))) throw new Error('Own publicKey must be part of publicKeys');\n\n        // Sort public keys so that the order when signing and construction does not matter.\n        publicKeys = publicKeys.slice();\n        publicKeys.sort((a, b) => a.compare(b));\n        const combinations = [...ArrayUtils.k_combinations(publicKeys, minSignatures)];\n        const multiSigKeys = combinations.map(arr => PublicKey.sum(arr));\n        return new MultiSigWallet(keyPair, minSignatures, multiSigKeys);\n    }\n\n    /**\n     * @param {KeyPair} keyPair\n     * @param {SerialBuffer} buf\n     * @returns {MultiSigWallet}\n     * @private\n     */\n    static _loadMultiSig(keyPair, buf) {\n        const minSignatures = buf.readUint8();\n        const numPublicKeys = buf.readUint8();\n        const publicKeys = [];\n        for (let i = 0; i < numPublicKeys; ++i) {\n            publicKeys.push(PublicKey.unserialize(buf));\n        }\n        return new MultiSigWallet(keyPair, minSignatures, publicKeys);\n    }\n\n    /**\n     * @param {Uint8Array|string} buf\n     * @return {MultiSigWallet}\n     */\n    static loadPlain(buf) {\n        if (typeof buf === 'string') buf = BufferUtils.fromHex(buf);\n        if (!buf || buf.byteLength === 0) {\n            throw new Error('Invalid wallet seed');\n        }\n\n        const serialBuf = new SerialBuffer(buf);\n        const keyPair = KeyPair.unserialize(serialBuf);\n        return MultiSigWallet._loadMultiSig(keyPair, serialBuf);\n    }\n\n    /**\n     * @param {Uint8Array|string} buf\n     * @param {Uint8Array|string} key\n     * @return {Promise.<MultiSigWallet>}\n     */\n    static async loadEncrypted(buf, key) {\n        if (typeof buf === 'string') buf = BufferUtils.fromHex(buf);\n        if (typeof key === 'string') key = BufferUtils.fromAscii(key);\n\n        const serialBuf = new SerialBuffer(buf);\n        const keyPair = await KeyPair.fromEncrypted(serialBuf, key);\n        return MultiSigWallet._loadMultiSig(keyPair, serialBuf);\n    }\n\n    /**\n     * Create a new MultiSigWallet object.\n     * @param {KeyPair} keyPair KeyPair owning this Wallet.\n     * @param {number} minSignatures Number of signatures required.\n     * @param {Array.<PublicKey>} publicKeys A list of all aggregated public keys.\n     * @returns {MultiSigWallet} A newly generated MultiSigWallet.\n     */\n    constructor(keyPair, minSignatures, publicKeys) {\n        super(keyPair);\n        /** @type {number} minSignatures */\n        this._minSignatures = minSignatures;\n        /** @type {Array.<PublicKey>} publicKeys */\n        this._publicKeys = publicKeys;\n        this._publicKeys.sort((a, b) => a.compare(b));\n\n        const merkleRoot = MerkleTree.computeRoot(this._publicKeys);\n        /** @type {Address} */\n        this._address = Address.fromHash(merkleRoot);\n    }\n\n    /**\n     * @override\n     * @returns {Uint8Array}\n     */\n    exportPlain() {\n        const buf = new SerialBuffer(this.exportedSize);\n        this._keyPair.serialize(buf);\n        buf.writeUint8(this._minSignatures);\n        buf.writeUint8(this._publicKeys.length);\n        for (const pubKey of this._publicKeys) {\n            pubKey.serialize(buf);\n        }\n        return buf;\n    }\n\n    /**\n     * @override\n     * @param {Uint8Array|string} key\n     * @param {Uint8Array|string} [unlockKey]\n     * @return {Promise.<Uint8Array>}\n     */\n    async exportEncrypted(key, unlockKey) {\n        if (typeof key === 'string') key = BufferUtils.fromAscii(key);\n        if (typeof unlockKey === 'string') unlockKey = BufferUtils.fromAscii(unlockKey);\n        const buf = new SerialBuffer(this.encryptedExportedSize);\n        buf.write(await this._keyPair.exportEncrypted(key, unlockKey));\n        buf.writeUint8(this._minSignatures);\n        buf.writeUint8(this._publicKeys.length);\n        for (const pubKey of this._publicKeys) {\n            pubKey.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get encryptedExportedSize() {\n        return this._keyPair.encryptedSize\n            + /*minSignatures*/ 1\n            + /*count*/ 1\n            + this._publicKeys.reduce((sum, pubKey) => sum + pubKey.serializedSize, 0);\n    }\n\n    /** @type {number} */\n    get exportedSize() {\n        return this._keyPair.serializedSize\n            + /*minSignatures*/ 1\n            + /*count*/ 1\n            + this._publicKeys.reduce((sum, pubKey) => sum + pubKey.serializedSize, 0);\n    }\n\n    /**\n     * Create a Transaction that still needs to be signed.\n     * @param {Address} recipientAddr Address of the transaction receiver\n     * @param {number} value Number of Satoshis to send.\n     * @param {number} fee Number of Satoshis to donate to the Miner.\n     * @param {number} validityStartHeight The validityStartHeight for the transaction.\n     * @returns {Transaction} A prepared Transaction object.\n     * @override\n     */\n    createTransaction(recipientAddr, value, fee, validityStartHeight) {\n        return new ExtendedTransaction(this._address, Account.Type.BASIC,\n            recipientAddr, Account.Type.BASIC, value, fee, validityStartHeight,\n            Transaction.Flag.NONE, new Uint8Array(0));\n    }\n\n    /**\n     * Creates a commitment pair for signing a transaction.\n     * @returns {CommitmentPair} The commitment pair.\n     */\n    createCommitment() {\n        return CommitmentPair.generate();\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {Array.<PublicKey>} publicKeys\n     * @param {Commitment} aggregatedCommitment\n     * @param {RandomSecret} secret\n     * @returns {PartialSignature}\n     */\n    partiallySignTransaction(transaction, publicKeys, aggregatedCommitment, secret) {\n        // Sort public keys to get the right combined public key.\n        publicKeys = publicKeys.slice();\n        publicKeys.sort((a, b) => a.compare(b));\n\n        return PartialSignature.create(this._keyPair.privateKey, this._keyPair.publicKey, publicKeys,\n            secret, aggregatedCommitment, transaction.serializeContent());\n    }\n\n    /**\n     * Sign a transaction by the owner of this Wallet.\n     * @param {Transaction} transaction The transaction to sign.\n     * @param {PublicKey} aggregatedPublicKey\n     * @param {Commitment} aggregatedCommitment\n     * @param {Array.<PartialSignature>} signatures\n     * @returns {SignatureProof} A signature proof for this transaction.\n     */\n    signTransaction(transaction, aggregatedPublicKey, aggregatedCommitment, signatures) {\n        if (signatures.length !== this._minSignatures) {\n            throw 'Not enough signatures to complete this transaction';\n        }\n\n        const signature = Signature.fromPartialSignatures(aggregatedCommitment, signatures);\n        return SignatureProof.multiSig(aggregatedPublicKey, this._publicKeys, signature);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {PublicKey} aggregatedPublicKey\n     * @param {Commitment} aggregatedCommitment\n     * @param {Array.<PartialSignature>} signatures\n     * @returns {Transaction}\n     */\n    completeTransaction(transaction, aggregatedPublicKey, aggregatedCommitment, signatures) {\n        const proof = this.signTransaction(transaction, aggregatedPublicKey, aggregatedCommitment, signatures);\n        transaction.proof = proof.serialize();\n        return transaction;\n    }\n\n    /** @type {number} */\n    get minSignatures() {\n        return this._minSignatures;\n    }\n\n    /** @type {Array.<PublicKey>} */\n    get publicKeys() {\n        return this._publicKeys;\n    }\n}\nClass.register(MultiSigWallet);\n","// TODO: Move outside of Nimiq Core library?\nclass WalletStore {\n    /**\n     * @returns {Promise.<WalletStore>}\n     */\n    constructor(dbName = 'wallet') {\n        this._jdb = new JDB.JungleDB(dbName, WalletStore.VERSION, {\n            maxDbSize: WalletStore.INITIAL_DB_SIZE,\n            autoResize: true,\n            minResize: WalletStore.MIN_RESIZE\n        });\n        /** @type {ObjectStore} */\n        this._walletStore = null;\n        /** @type {ObjectStore} */\n        this._multiSigStore = null;\n\n        return this._init();\n    }\n\n    /**\n     * @returns {Promise.<WalletStore>}\n     */\n    async _init() {\n        // Initialize object stores.\n        this._walletStore = this._jdb.createObjectStore(WalletStore.WALLET_DATABASE, { codec: new WalletStoreCodec() });\n        this._multiSigStore = this._jdb.createObjectStore(WalletStore.MULTISIG_WALLET_DATABASE, { codec: new WalletStoreCodec() });\n\n        // Establish connection to database.\n        await this._jdb.connect();\n\n        return this;\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    async hasDefault(key) {\n        const defaultAddress = await this._walletStore.get('default');\n        return !!defaultAddress;\n    }\n\n    /**\n     * @param {Uint8Array|string} [key]\n     * @returns {Promise.<?Wallet>}\n     */\n    async getDefault(key) {\n        const defaultAddress = await this._walletStore.get('default');\n        if (!defaultAddress) {\n            const defaultWallet = await Wallet.generate();\n            await this.put(defaultWallet);\n            await this.setDefault(defaultWallet.address);\n            return defaultWallet;\n        }\n        const base64Address = new Address(defaultAddress);\n        return this.get(base64Address, key);\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise}\n     */\n    setDefault(address) {\n        const defaultAddress = address.serialize();\n        return this._walletStore.put('default', defaultAddress);\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Uint8Array|string} [key]\n     * @returns {Promise.<?Wallet>}\n     */\n    async get(address, key) {\n        const base64Address = address.toBase64();\n        const buf = await this._walletStore.get(base64Address);\n        if (!buf) return null;\n        if (key) {\n            return Wallet.loadEncrypted(buf, key);\n        }\n        return Wallet.loadPlain(buf);\n    }\n\n    /**\n     * @param {Wallet} wallet\n     * @param {Uint8Array|string} [key]\n     * @param {Uint8Array|string} [unlockKey]\n     * @returns {Promise}\n     */\n    async put(wallet, key, unlockKey) {\n        const base64Address = wallet.address.toBase64();\n        /** @type {Uint8Array} */\n        let buf = null;\n        if (key) {\n            buf = await wallet.exportEncrypted(key, unlockKey);\n        } else {\n            buf = wallet.exportPlain();\n        }\n        return this._walletStore.put(base64Address, buf);\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise}\n     */\n    async remove(address) {\n        const base64Address = address.toBase64();\n        const tx = this._walletStore.transaction();\n        tx.removeSync(base64Address);\n        // Remove default address as well if they coincide.\n        let defaultAddress = await this._walletStore.get('default');\n        if (defaultAddress) {\n            defaultAddress = new Address(defaultAddress);\n            if (address.equals(defaultAddress)) {\n                tx.removeSync('default');\n            }\n        }\n        return tx.commit();\n    }\n\n    /**\n     * @returns {Promise<Array.<Address>>}\n     */\n    async list() {\n        const keys = await this._walletStore.keys();\n        return Array.from(keys).filter(key => key !== 'default').map(key => Address.fromBase64(key));\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Uint8Array|string} [key]\n     * @returns {Promise.<?MultiSigWallet>}\n     */\n    async getMultiSig(address, key) {\n        const base64Address = address.toBase64();\n        const buf = await this._multiSigStore.get(base64Address);\n        if (!buf) return null;\n        if (key) {\n            return MultiSigWallet.loadEncrypted(buf, key);\n        }\n        return MultiSigWallet.loadPlain(buf);\n    }\n\n    /**\n     * @param {MultiSigWallet} wallet\n     * @param {Uint8Array|string} [key]\n     * @param {Uint8Array|string} [unlockKey]\n     * @returns {Promise}\n     */\n    async putMultiSig(wallet, key, unlockKey) {\n        const base64Address = wallet.address.toBase64();\n        /** @type {Uint8Array} */\n        let buf = null;\n        if (key) {\n            buf = await wallet.exportEncrypted(key, unlockKey);\n        } else {\n            buf = wallet.exportPlain();\n        }\n        return this._multiSigStore.put(base64Address, buf);\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise}\n     */\n    removeMultiSig(address) {\n        const base64Address = address.toBase64();\n        return this._multiSigStore.remove(base64Address);\n    }\n\n    /**\n     * @returns {Promise<Array.<Address>>}\n     */\n    async listMultiSig() {\n        const keys = await this._multiSigStore.keys();\n        return Array.from(keys).map(key => Address.fromBase64(key));\n    }\n\n    close() {\n        return this._jdb.close();\n    }\n}\nClass.register(WalletStore);\nWalletStore._instance = null;\nWalletStore.VERSION = 1;\nWalletStore.INITIAL_DB_SIZE = 1024*1024*10; // 10 MB initially\nWalletStore.MIN_RESIZE = 1024*1024*10; // 10 MB\nWalletStore.WALLET_DATABASE = 'wallets';\nWalletStore.MULTISIG_WALLET_DATABASE = 'multisig-wallets';\n\n/**\n * @implements {ICodec}\n */\nclass WalletStoreCodec {\n    /**\n     * @param {*} obj The object to encode before storing it.\n     * @returns {*} Encoded object.\n     */\n    encode(obj) {\n        return obj;\n    }\n\n    /**\n     * @param {*} buf The object to decode.\n     * @param {string} key The object's primary key.\n     * @returns {*} Decoded object.\n     */\n    decode(buf, key) {\n        return new Uint8Array(buf);\n    }\n\n    /**\n     * @type {string}\n     */\n    get leveldbValueEncoding() {\n        return 'binary';\n    }\n\n    /**\n     * @type {object}\n     */\n    get lmdbValueEncoding() {\n        return JDB.JungleDB.BINARY_ENCODING;\n    }\n}\n","/**\n * @interface\n */\nclass MinerWorker {\n    /**\n     * @param blockHeader\n     * @param compact\n     * @param minNonce\n     * @param maxNonce\n     * @returns {Promise.<{hash: Uint8Array, nonce: number}|boolean>}\n     */\n    async multiMine(blockHeader, compact, minNonce, maxNonce) {}\n}\nClass.register(MinerWorker);\n","class MinerWorkerImpl extends IWorker.Stub(MinerWorker) {\n    constructor() {\n        super();\n        // FIXME: This is needed for Babel to work correctly. Can be removed as soon as we updated to Babel v7.\n        this._superInit = super.init;\n    }\n\n    async init(name) {\n        await this._superInit.call(this, name);\n        await WasmHelper.doImportBrowser();\n    }\n\n    async multiMine(input, compact, minNonce, maxNonce) {\n        const hash = new Uint8Array(32);\n        let wasmOut, wasmIn;\n        try {\n            wasmOut = Module._malloc(hash.length);\n            wasmIn = Module._malloc(input.length);\n            Module.HEAPU8.set(input, wasmIn);\n            const nonce = Module._nimiq_argon2_target(wasmOut, wasmIn, input.length, compact, minNonce, maxNonce, 512);\n            if (nonce === maxNonce) return false;\n            hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hash.length));\n            return {hash, nonce};\n        } catch (e) {\n            Log.w(MinerWorkerImpl, e);\n            throw e;\n        } finally {\n            if (wasmOut !== undefined) Module._free(wasmOut);\n            if (wasmIn !== undefined) Module._free(wasmIn);\n        }\n    }\n}\n\nIWorker.prepareForWorkerUse(MinerWorker, new MinerWorkerImpl());\n","/**\n *\n */\nclass MinerWorkerPool extends IWorker.Pool(MinerWorker) {\n    constructor(size = 1) {\n        super((name) => IWorker.startWorkerForProxy(MinerWorker, name), 'miner', size);\n        /** @type {boolean} */\n        this._miningEnabled = false;\n        /** @type {Array.<{minNonce: number, maxNonce: number}>} */\n        this._activeNonces = [];\n        /** @type {Block} */\n        this._block = null;\n        /** @type {number} */\n        this._noncesPerRun = 256;\n        /** @type {Observable} */\n        this._observable = new Observable();\n        /** @type {number} */\n        this._shareCompact = Policy.BLOCK_TARGET_MAX;\n        /** @type {number} */\n        this._runsPerCycle = Infinity;\n        /** @type {number} */\n        this._cycleWait = 100;\n\n        // FIXME: This is needed for Babel to work correctly. Can be removed as soon as we updated to Babel v7.\n        this._superUpdateToSize = super._updateToSize;\n\n        if (PlatformUtils.isNodeJs()) {\n            /**\n             * @param {SerialBuffer} blockHeader\n             * @param {number} compact\n             * @param {number} minNonce\n             * @param {number} maxNonce\n             * @returns {Promise.<{hash: Uint8Array, nonce: number}|boolean>}\n             */\n            this.multiMine = function (blockHeader, compact, minNonce, maxNonce) {\n                return new Promise((resolve, fail) => {\n                    NodeNative.node_argon2_target_async(async (nonce) => {\n                        try {\n                            if (nonce === maxNonce) {\n                                resolve(false);\n                            } else {\n                                blockHeader.writePos -= 4;\n                                blockHeader.writeUint32(nonce);\n                                const hash = await (await CryptoWorker.getInstanceAsync()).computeArgon2d(blockHeader);\n                                resolve({hash, nonce});\n                            }\n                        } catch (e) {\n                            fail(e);\n                        }\n                    }, blockHeader, compact, minNonce, maxNonce, 512);\n                });\n            };\n        }\n    }\n\n    /**\n     * @type {number}\n     */\n    get noncesPerRun() {\n        return this._noncesPerRun;\n    }\n\n    /**\n     * @param {number} nonces\n     */\n    set noncesPerRun(nonces) {\n        this._noncesPerRun = nonces;\n    }\n\n    /**\n     * @type {number}\n     */\n    get runsPerCycle() {\n        return this._runsPerCycle;\n    }\n\n    /**\n     * @param {number} runsPerCycle\n     */\n    set runsPerCycle(runsPerCycle) {\n        this._runsPerCycle = runsPerCycle;\n    }\n\n    /**\n     * @type {number}\n     */\n    get cycleWait() {\n        return this._cycleWait;\n    }\n\n    /**\n     * @param {number} cycleWait\n     */\n    set cycleWait(cycleWait) {\n        this._cycleWait = cycleWait;\n    }\n\n    /**\n     * @param {string} type\n     * @param {Function} callback\n     * @return {number}\n     */\n    on(type, callback) { this._observable.on(type, callback); }\n\n    /**\n     * @param {string} type\n     * @param {number} id\n     */\n    off(type, id) { this._observable.off(type, id); }\n\n    /**\n     * @param {Block} block\n     * @param {number} [shareCompact] target of a share, in compact format.\n     */\n    async startMiningOnBlock(block, shareCompact = block.nBits) {\n        this._block = block;\n        this._shareCompact = shareCompact;\n        if (!this._miningEnabled) {\n            await this._updateToSize();\n            this._activeNonces = [];\n            this._miningEnabled = true;\n            for (let i = 0; i < this.poolSize; ++i) {\n                this._startMiner();\n            }\n        } else {\n            this._activeNonces = [{minNonce:0, maxNonce:0}];\n        }\n    }\n\n    stop() {\n        this._miningEnabled = false;\n    }\n\n    async _updateToSize() {\n        if (!PlatformUtils.isNodeJs()) {\n            await this._superUpdateToSize.call(this);\n        }\n\n        while (this._miningEnabled && this._activeNonces.length < this.poolSize) {\n            this._startMiner();\n        }\n    }\n\n    _startMiner() {\n        const minNonce = this._activeNonces.length === 0 ? 0 : Math.max.apply(null, this._activeNonces.map((a) => a.maxNonce));\n        const maxNonce = minNonce + this._noncesPerRun;\n        const nonceRange = {minNonce, maxNonce};\n        this._activeNonces.push(nonceRange);\n        this._singleMiner(nonceRange).catch((e) => Log.e(MinerWorkerPool, e));\n    }\n\n    /**\n     * @param {{minNonce: number, maxNonce: number}} nonceRange\n     * @return {Promise.<void>}\n     * @private\n     */\n    async _singleMiner(nonceRange) {\n        let i = 0;\n        while (this._miningEnabled && (IWorker.areWorkersAsync || PlatformUtils.isNodeJs() || i === 0) && i < this._runsPerCycle) {\n            i++;\n            const block = this._block;\n            const result = await this.multiMine(block.header.serialize(), this._shareCompact, nonceRange.minNonce, nonceRange.maxNonce);\n            if (result) {\n                const hash = new Hash(result.hash);\n                this._observable.fire('share', {\n                    block,\n                    nonce: result.nonce,\n                    hash\n                });\n            } else {\n                this._observable.fire('no-share', {\n                    nonce: nonceRange.maxNonce\n                });\n            }\n            if (this._activeNonces.length > this.poolSize) {\n                this._activeNonces.splice(this._activeNonces.indexOf(nonceRange), 1);\n                return;\n            } else {\n                const newMin = Math.max.apply(null, this._activeNonces.map((a) => a.maxNonce));\n                const newRange = {minNonce: newMin, maxNonce: newMin + this._noncesPerRun};\n                this._activeNonces.splice(this._activeNonces.indexOf(nonceRange), 1, newRange);\n                nonceRange = newRange;\n            }\n        }\n        if (this._miningEnabled) {\n            setTimeout(() => this._singleMiner(nonceRange), this._cycleWait);\n        }\n    }\n}\n\nClass.register(MinerWorkerPool);\n","// Print stack traces to the console.\nError.prototype.toString = function () {\n    return this.stack;\n};\n\n// Don't exit on uncaught exceptions.\nprocess.on('uncaughtException', (err) => {\n    // Blacklist unsupressable WebSocket errors.\n    const message = err.message;\n    if (message\n        && (\n            message.startsWith('connect E')\n            || message === \"Cannot read property 'aborted' of null\")\n        ) {\n        return;\n    }\n\n    console.error(`Uncaught exception: ${err.message || err}`, err);\n});\n"]}