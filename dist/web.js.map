{"version":3,"sources":["node_modules/@nimiq/jungle-db/dist/loader/browser/prefix.js.template","src/main/platform/browser/index.prefix.js","node_modules/@nimiq/jungle-db/dist/main/platform/browser/Class.js","node_modules/@nimiq/jungle-db/dist/main/platform/browser/utils/LogNative.js","node_modules/@nimiq/jungle-db/dist/main/backend/indexeddb/utils/IDBTools.js","node_modules/@nimiq/jungle-db/dist/main/backend/indexeddb/IDBBackend.js","node_modules/@nimiq/jungle-db/dist/main/backend/indexeddb/JungleDB.js","node_modules/@nimiq/jungle-db/dist/main/backend/indexeddb/PersistentIndex.js","node_modules/@nimiq/jungle-db/dist/main/generic/utils/ArrayUtils.js","node_modules/@nimiq/jungle-db/dist/main/generic/utils/BTree.js","node_modules/@nimiq/jungle-db/dist/main/generic/utils/BufferUtils.js","node_modules/@nimiq/jungle-db/dist/main/generic/utils/ComparisonUtils.js","node_modules/@nimiq/jungle-db/dist/main/generic/utils/JSONUtils.js","node_modules/@nimiq/jungle-db/dist/main/generic/utils/Log.js","node_modules/@nimiq/jungle-db/dist/main/generic/utils/LRUMap.js","node_modules/@nimiq/jungle-db/dist/main/generic/utils/ObjectUtils.js","node_modules/@nimiq/jungle-db/dist/main/generic/utils/SetUtils.js","node_modules/@nimiq/jungle-db/dist/main/generic/utils/SortedList.js","node_modules/@nimiq/jungle-db/dist/main/generic/utils/Synchronizer.js","node_modules/@nimiq/jungle-db/dist/main/generic/utils/EncodedTransaction.js","node_modules/@nimiq/jungle-db/dist/main/generic/utils/GenericValueEncoding.js","node_modules/@nimiq/jungle-db/dist/main/generic/CachedBackend.js","node_modules/@nimiq/jungle-db/dist/main/generic/InMemoryIndex.js","node_modules/@nimiq/jungle-db/dist/main/generic/InMemoryBackend.js","node_modules/@nimiq/jungle-db/dist/main/generic/KeyRange.js","node_modules/@nimiq/jungle-db/dist/main/generic/ObjectStore.js","node_modules/@nimiq/jungle-db/dist/main/generic/Query.js","node_modules/@nimiq/jungle-db/dist/main/generic/TransactionIndex.js","node_modules/@nimiq/jungle-db/dist/main/generic/Transaction.js","node_modules/@nimiq/jungle-db/dist/main/generic/SynchronousTransaction.js","node_modules/@nimiq/jungle-db/dist/main/generic/Snapshot.js","node_modules/@nimiq/jungle-db/dist/main/generic/SnapshotManager.js","node_modules/@nimiq/jungle-db/dist/main/generic/CombinedTransaction.js","node_modules/@nimiq/jungle-db/dist/loader/browser/suffix.js.template","src/main/platform/browser/Class.js","src/main/platform/browser/utils/LogNative.js","src/main/generic/utils/Log.js","src/main/generic/utils/Observable.js","src/main/generic/network/DataChannel.js","src/main/platform/browser/crypto/CryptoLib.js","src/main/platform/browser/network/webrtc/WebRtcFactory.js","src/main/platform/browser/network/websocket/WebSocketFactory.js","src/main/platform/browser/network/DnsUtils.js","src/main/generic/utils/ConstantHelper.js","src/main/generic/utils/Services.js","src/main/generic/utils/Timers.js","src/main/generic/utils/Version.js","src/main/generic/utils/Time.js","src/main/generic/utils/array/ArrayUtils.js","src/main/generic/utils/array/HashMap.js","src/main/generic/utils/array/HashSet.js","src/main/generic/utils/array/LimitIterable.js","src/main/generic/utils/array/Queue.js","src/main/generic/utils/array/UniqueQueue.js","src/main/generic/utils/array/ThrottledQueue.js","src/main/generic/utils/array/SortedList.js","src/main/generic/utils/assert/Assert.js","src/main/generic/utils/buffer/BufferUtils.js","src/main/generic/utils/buffer/SerialBuffer.js","src/main/generic/utils/synchronizer/Synchronizer.js","src/main/generic/utils/synchronizer/MultiSynchronizer.js","src/main/generic/utils/synchronizer/PrioritySynchronizer.js","src/main/generic/utils/RateLimit.js","src/main/generic/utils/IWorker.js","src/main/generic/utils/WasmHelper.js","src/main/generic/utils/crypto/CryptoWorker.js","src/main/generic/utils/crypto/CryptoWorkerImpl.js","src/main/generic/utils/crc/CRC32.js","src/main/generic/utils/number/NumberUtils.js","src/main/generic/utils/merkle/MerkleTree.js","src/main/generic/utils/merkle/MerklePath.js","src/main/generic/utils/merkle/MerkleProof.js","src/main/generic/utils/platform/PlatformUtils.js","src/main/generic/utils/string/StringUtils.js","src/main/generic/consensus/Policy.js","src/main/generic/consensus/base/primitive/Serializable.js","src/main/generic/consensus/base/primitive/Hash.js","src/main/generic/consensus/base/primitive/PrivateKey.js","src/main/generic/consensus/base/primitive/PublicKey.js","src/main/generic/consensus/base/primitive/KeyPair.js","src/main/generic/consensus/base/primitive/RandomSecret.js","src/main/generic/consensus/base/primitive/Signature.js","src/main/generic/consensus/base/primitive/Commitment.js","src/main/generic/consensus/base/primitive/CommitmentPair.js","src/main/generic/consensus/base/primitive/PartialSignature.js","src/main/generic/consensus/base/account/Address.js","src/main/generic/consensus/base/account/Account.js","src/main/generic/consensus/base/account/PrunedAccount.js","src/main/generic/consensus/base/account/BasicAccount.js","src/main/generic/consensus/base/account/Contract.js","src/main/generic/consensus/base/account/HashedTimeLockedContract.js","src/main/generic/consensus/base/account/VestingContract.js","src/main/generic/consensus/base/account/tree/AccountsTreeNode.js","src/main/generic/consensus/base/account/tree/AccountsTreeStore.js","src/main/generic/consensus/base/account/tree/SynchronousAccountsTreeStore.js","src/main/generic/consensus/base/account/tree/AccountsProof.js","src/main/generic/consensus/base/account/tree/AccountsTreeChunk.js","src/main/generic/consensus/base/account/tree/AccountsTree.js","src/main/generic/consensus/base/account/tree/SynchronousAccountsTree.js","src/main/generic/consensus/base/account/tree/PartialAccountsTree.js","src/main/generic/consensus/base/account/Accounts.js","src/main/generic/consensus/base/block/BlockHeader.js","src/main/generic/consensus/base/block/BlockInterlink.js","src/main/generic/consensus/base/block/BlockBody.js","src/main/generic/consensus/base/block/BlockUtils.js","src/main/generic/consensus/base/subscription/Subscription.js","src/main/generic/consensus/base/transaction/Transaction.js","src/main/generic/consensus/base/transaction/SignatureProof.js","src/main/generic/consensus/base/transaction/BasicTransaction.js","src/main/generic/consensus/base/transaction/ExtendedTransaction.js","src/main/generic/consensus/base/transaction/TransactionsProof.js","src/main/generic/consensus/base/transaction/TransactionCache.js","src/main/generic/consensus/base/transaction/index/TransactionStoreEntry.js","src/main/generic/consensus/base/transaction/index/TransactionStore.js","src/main/generic/consensus/base/transaction/index/TransactionReceipt.js","src/main/generic/consensus/base/block/Block.js","src/main/generic/consensus/base/blockchain/IBlockchain.js","src/main/generic/consensus/base/blockchain/BaseChain.js","src/main/generic/consensus/base/blockchain/BlockChain.js","src/main/generic/consensus/base/blockchain/HeaderChain.js","src/main/generic/consensus/base/blockchain/ChainProof.js","src/main/generic/consensus/base/blockchain/ChainData.js","src/main/generic/consensus/base/blockchain/ChainDataStore.js","src/main/generic/consensus/base/mempool/MempoolTransactionSet.js","src/main/generic/consensus/base/mempool/Mempool.js","src/main/generic/consensus/InvRequestManager.js","src/main/generic/consensus/BaseConsensusAgent.js","src/main/generic/consensus/BaseConsensus.js","src/main/generic/consensus/full/FullChain.js","src/main/generic/consensus/full/FullConsensusAgent.js","src/main/generic/consensus/full/FullConsensus.js","src/main/generic/consensus/light/LightChain.js","src/main/generic/consensus/light/LightConsensusAgent.js","src/main/generic/consensus/light/LightConsensus.js","src/main/generic/consensus/light/PartialLightChain.js","src/main/generic/consensus/nano/NanoChain.js","src/main/generic/consensus/nano/NanoConsensusAgent.js","src/main/generic/consensus/nano/NanoConsensus.js","src/main/generic/consensus/nano/NanoMempool.js","src/main/generic/consensus/ConsensusDB.js","src/main/generic/consensus/Consensus.js","src/main/generic/network/Protocol.js","src/main/generic/network/message/Message.js","src/main/generic/network/message/AddrMessage.js","src/main/generic/network/message/BlockMessage.js","src/main/generic/network/message/RawBlockMessage.js","src/main/generic/network/message/GetAddrMessage.js","src/main/generic/network/message/GetBlocksMessage.js","src/main/generic/network/message/HeaderMessage.js","src/main/generic/network/message/InventoryMessage.js","src/main/generic/network/message/MempoolMessage.js","src/main/generic/network/message/PingMessage.js","src/main/generic/network/message/PongMessage.js","src/main/generic/network/message/RejectMessage.js","src/main/generic/network/message/SignalMessage.js","src/main/generic/network/message/SubscribeMessage.js","src/main/generic/network/message/TxMessage.js","src/main/generic/network/message/VersionMessage.js","src/main/generic/network/message/VerAckMessage.js","src/main/generic/network/message/AccountsProofMessage.js","src/main/generic/network/message/GetAccountsProofMessage.js","src/main/generic/network/message/ChainProofMessage.js","src/main/generic/network/message/GetChainProofMessage.js","src/main/generic/network/message/AccountsTreeChunkMessage.js","src/main/generic/network/message/GetAccountsTreeChunkMessage.js","src/main/generic/network/message/TransactionsProofMessage.js","src/main/generic/network/message/GetTransactionsProofMessage.js","src/main/generic/network/message/GetTransactionReceiptsMessage.js","src/main/generic/network/message/TransactionReceiptsMessage.js","src/main/generic/network/message/GetBlockProofMessage.js","src/main/generic/network/message/BlockProofMessage.js","src/main/generic/network/message/GetHeadMessage.js","src/main/generic/network/message/HeadMessage.js","src/main/generic/network/message/MessageFactory.js","src/main/generic/network/webrtc/WebRtcConnector.js","src/main/generic/network/webrtc/WebRtcDataChannel.js","src/main/generic/network/webrtc/WebRtcUtils.js","src/main/generic/network/websocket/WebSocketConnector.js","src/main/generic/network/websocket/WebSocketDataChannel.js","src/main/generic/network/address/NetAddress.js","src/main/generic/network/address/PeerId.js","src/main/generic/network/address/PeerAddress.js","src/main/generic/network/address/PeerAddressState.js","src/main/generic/network/address/PeerAddressBook.js","src/main/generic/consensus/GenesisConfig.js","src/main/generic/network/connection/CloseType.js","src/main/generic/network/connection/NetworkConnection.js","src/main/generic/network/connection/PeerChannel.js","src/main/generic/network/connection/NetworkAgent.js","src/main/generic/network/connection/PeerConnectionStatistics.js","src/main/generic/network/connection/PeerConnection.js","src/main/generic/network/connection/SignalProcessor.js","src/main/generic/network/connection/ConnectionPool.js","src/main/generic/network/PeerScorer.js","src/main/generic/network/NetworkConfig.js","src/main/generic/network/Network.js","src/main/generic/network/NetUtils.js","src/main/generic/network/PeerKeyStore.js","src/main/generic/network/Peer.js","src/main/generic/miner/Miner.js","src/main/generic/wallet/Wallet.js","src/main/generic/wallet/MultiSigWallet.js","src/main/generic/wallet/WalletStore.js","src/main/generic/miner/MinerWorker.js","src/main/generic/miner/MinerWorkerImpl.js","src/main/generic/miner/MinerWorkerPool.js","src/main/platform/browser/index.suffix.js"],"names":["JDB","Proxy","exports","Class","[object Object]","cls","name","register","LogNative","this","_global_level","Log","TRACE","_tag_levels","window","localStorage","c","getItem","JSON","parse","e","console","warn","tag","level","setItem","stringify","args","isLoggable","unshift","Level","toStringTag","Date","toTimeString","substr","error","ERROR","apply","WARNING","info","INFO","debug","DEBUG","trace","log","IDBTools","keyRange","KeyRange","exactMatch","IDBKeyRange","only","lower","undefined","upper","lowerBound","lowerOpen","upperBound","upperOpen","bound","IDBBackend","db","tableName","codec","_db","_tableName","_indices","Map","_indicesToCreate","_indicesToDelete","_codec","connected","_backend","Error","backend","indices","objectStore","oldVersion","newVersion","indexName","upgradeCondition","indexNames","contains","deleteIndex","index","keyPath","Array","isArray","join","createIndex","unique","multiEntry","clear","value","key","decode","encode","options","Promise","resolve","reject","getTx","transaction","get","onsuccess","event","raw","target","result","onerror","query","limit","Query","values","convertKeyRange","results","openCursorRequest","openCursor","cursor","length","push","primaryKey","continue","keys","Set","store","openKeyCursor","size","add","callback","ascending","request","count","tx","idbTx","objSt","_truncated","_removed","delete","_modified","put","oncomplete","onabort","getRequest","PersistentIndex","set","close","encodedTx","EncodedTransaction","truncate","remove","JungleDB","dbVersion","_databaseDir","_dbVersion","_onUpgradeNeeded","onUpgradeNeeded","_connected","_objectStores","_objectStoreBackends","_objectStoresToDelete","_indexedDB","indexedDB","webkitIndexedDB","mozIndexedDB","OIndexedDB","msIndexedDB","open","that","onupgradeneeded","_initDB","objectStoreNames","deleteObjectStore","IDBobjStore","createObjectStore","init","ObjectStore","InMemoryBackend","persistent","enableLruCache","lruCacheSize","CachedBackend","MAX_CACHE_SIZE","rawLruCacheSize","has","cachedBackend","objStore","req","deleteDatabase","tx1","tx2","txs","CombinedTransaction","functions","encodedTxs","tableNames","infos","all","transactions","map","applyCombined","tmp","innerInfo","truncated","removed","modified","f","then","every","Transaction","commit","JSON_ENCODING","BINARY_ENCODING","STRING_ENCODING","NUMBER_ENCODING","GENERIC_ENCODING","_objectStore","_indexName","_keyPath","_multiEntry","_unique","_index","maxKey","ComparisonUtils","equals","minKey","prototype","iterator","nextIndex","next","hasNext","peek","Node","_keys","LeafNode","records","super","_records","prevLeaf","nextLeaf","near","BTree","NEAR_MODE","GE","i","len","compare","LE","record","insertPos","splice","mov","Math","floor","newKeys","newRecords","pop","newL","frNod","paNod","frKey","pos","nodePointers","InnerNode","_nodePointers","ptrL","ptrR","ceil","newNodePointers","paItm","del","order","_root","_maxkey","_minkyl","_minkyn","_leaf","_item","_key","_record","_length","_eof","_found","currentKey","currentRecord","rec","stack","isLeaf","addKey","pL","pR","split","ky","newN","nod","_del","seek","NONE","cnt","goBottom","skip","goTop","ptr","toN","toI","frN","frI","parKey","parNod","kidKey","kidNod","delKey","parPtr","_fixNodes","sibL","sibR","shift","merge","parItm","curNod","stk","toKey","lvl","mor","success","BufferUtils","u8","TextDecoder","_ISO_8859_15_DECODER","replace","num","_BASE64_LOOKUP","start","end","output","_tripletToBase64","extraBytes","parts","len2","_base64encodeChunk","buffer","Buffer","toString","btoa","_codePointTextDecoder","Uint8Array","_base64fromByteArray","base64","test","from","atob","charCodeAt","toBase64","base64lex","BASE64_TO_BASE64_LEX","BASE64_LEX_TO_BASE64","fromBase64","a","b","viewA","viewB","BASE64_ALPHABET","BASE64_LEX_ALPHABET","=","-","isUint8Array","obj","ArrayBuffer","isView","JSONUtils","jsonifyType","parseType","TYPE_SYMBOL","VALUE_SYMBOL","typedObject","type","instance","_instance","native","_native","setLoggable","l","constructor","msg","message","arguments","slice","call","VERBOSE","ASSERT","d","bind","v","w","t","LRUMap","maxSize","_maxSize","_map","_numAccesses","_accessQueue","entries","thisArg","forEach","access","k","oldest","accesses","evict","Symbol","ObjectUtils","path","component","union","setB","elem","intersection","difference","limitedResults","val","arg","sampleElement","s","SortedList","sortedList","_list","_compare","o","currentIndex","currentElement","round","_insertionIndex","indexOf","Synchronizer","_queue","_working","fn","_doWork","catch","job","working","GenericValueEncoding","binary","dv","DataView","setUint8","Type","INTEGER","setUint32","pow","getUint32","string","STRING","buf","String","fromCharCode","subarray","_encodeString","json","_decodeString","byteLength","BUFFER","data","Number","isInteger","_encodeInteger","_encodeBuffer","_encodeOther","_decodeInteger","_decodeBuffer","_decodeOther","encoding","Encoding","BINARY","cacheSize","rawCacheSize","_cache","_rawCache","valuePromises","_has","_get","isSynchronous","getSync","expectPresence","keyStream","valueStream","maxValue","minValue","_applyLocally","_apply","InMemoryIndex","_tree","byKeyPath","iKey","tree","insert","oldValue","oldIKey","_indexKey","newIKey","_remove","_insert","_retrieveValues","resultSet","goToLowerBound","includes","goToUpperBound","outer","maxKeys","isRange","minKeys","_primaryIndex","truncateSync","originalValues","_indexApply","func","_lower","_upper","_lowerOpen","_upperOpen","_name","_stateStack","_backendInfo","TransactionInfo","_transactions","BACKEND_ID","_snapshotManager","SnapshotManager","_synchronizer","jungleDB","_currentState","_currentStateInfo","_currentStateId","id","err","abort","isCached","_isCommittable","_commitInternal","state","STATE","OPEN","isCommittable","MAX_STACK_SIZE","toStringFull","isFlushable","_flattenState","parent","Snapshot","abortSnapshot","numOpenChildren","_flattenStateInternal","cleanup","flush","statePosition","dependency","isBackend","applyTx","_setAborted","onFlushable","enableWatchdog","synchronousTransaction","SynchronousTransaction","snapshot","createSnapshot","toStringShort","_openTransactions","parentInfo","children","_parentInfo","_open","addChild","removeChild","child","_setParent","filter","isOpen","op","value2","OPERATORS","GT","LT","EQ","BETWEEN","WITHIN","var_args","AND","OR","MAX","MIN","some","it","COMBINED_OPERATORS","_queryType","COMBINED","_queries","_op","RANGE_OPERATORS","RANGE","_keyRange","_parseKeyRange","ADVANCED_OPERATORS","ADVANCED","_execute","resultPromises","_executeCombined","_executeAdvanced","_executeRange","firstResult","TransactionIndex","secondaryKey","promises","backendKeys","maxIKey","tmpQuery","valueTx","iKeyBackend","iKeyTx","minIKey","managingBackend","_id","_instanceCount","_parent","_managingBackend","derive","_state","_nested","_nestedCommitted","_dependency","_startTime","now","_enableWatchdog","_watchdog","setTimeout","WATCHDOG_TIMER","nested","_put","constraints","checkUniqueConstraint","txIt","sort","stopped","currentTxKey","NESTED","COMMITTED","inherit","_checkConstraints","_commitBackend","_abortBackend","_applySync","clearTimeout","commitStart","_performanceCheck","CONFLICTED","startTime","functionName","executionTime","toFixed","ABORTED","abortStart","localOldValue","constraintChecks","_getCached","_snapshots","applications","isConsistent","_flushable","_preprocessing","_jdb","objectStores","preprocessing","preprocessings","commitCombined","r","_loaded","_onload","Nimiq","_currentScript","document","currentScript","scripts","getElementsByTagName","_path","src","substring","lastIndexOf","scope","isNaN","parseInt","toLowerCase","Observable","WILDCARD","_listeners","res","listener","observable","types","fire","on","DataChannel","_buffer","_msgType","_receivingTag","_sendingTag","_expectedMessagesByType","_timers","Timers","_lastChunkReceivedAt","expectedMsg","timeoutCallback","msgTimeout","MESSAGE_TIMEOUT","chunkTimeout","CHUNK_TIMEOUT","ExpectedMessage","resetTimeout","_onTimeout","clearAll","readyState","ReadyState","SerialBuffer","CHUNK_SIZE_MAX","_error","readUint8","effectiveChunkLength","readPos","chunk","read","NumberUtils","UINT8_MAX","chunkBuffer","messageSize","Message","peekLength","MESSAGE_SIZE_MAX","peekType","remainingBytes","writePos","write","Assert","_sendChunked","remaining","writeUint8","sendChunk","lastMessageReceivedAt","CONNECTING","CLOSING","CLOSED","fromString","str","CryptoLib","getRandomValues","crypto","msCrypto","WebRtcFactory","configuration","RTCPeerConnection","rtcSessionDescriptionInit","RTCSessionDescription","rtcIceCandidateInit","RTCIceCandidate","WebSocketFactory","url","WebSocket","DnsUtils","host","NetAddress","UNSPECIFIED","ConstantHelper","_originalValues","constant","clazz","startsWith","toUpperCase","hasOwnProperty","Object","isConstant","_ensureIsConstant","Services","provided","accepted","_provided","_accepted","services","FULL","LIGHT","NANO","_timeouts","_intervals","waitTime","intervalTime","setInterval","clearInterval","Version","code","CODE","Time","offset","_offset","ArrayUtils","arr","random","uintarr","begin","clamp","min","max","byteOffset","list","n","x","reverseRange","found","j","HashMap","fnHash","_hash","_fnHash","hashCode","HashSet","collection","valueIterator","LimitIterable","_iterator","_limit","done","Queue","hash","UniqueQueue","_set","enqueue","enqueueFirst","enqueueUnique","dequeue","dequeueMulti","dequeueUntil","ThrottledQueue","maxAtOnce","POSITIVE_INFINITY","allowanceNum","allowanceInterval","allowanceCallback","_maxAtOnce","_availableNow","isAvailable","available","condition","PlatformUtils","isNodeJs","alphabet","BASE32_ALPHABET","NIMIQ","byte","symbol","carry","base32","charmap","char","hex","HEX_ALPHABET","trim","StringUtils","isHexBytes","match","RFC4648","RFC4648_HEX","bufferOrArrayOrLength","_view","_readPos","_writePos","array","getUint8","getUint16","setUint16","isUint64","readUint16","readUint32","readUint64","writeUint16","writeUint32","writeUint64","getFloat64","setFloat64","bytes","toAscii","isMultibyte","fromAscii","view","padding","isUint8","MultiSynchronizer","_synchronizers","synchonizer","synchronizer","PrioritySynchronizer","numPriorities","_queues","priority","queue","RateLimit","allowedOccurences","timeRange","_allowedEntries","_timeRange","_lastReset","_counter","number","IWorker","worker","workerScript","_workersSupported","createProxy","Worker","URL","createObjectURL","Blob","_workerImplementation","Pool","startWorkerForProxy","command","self","postMessage","status","areWorkersAsync","_insideWebWorker","WorkerGlobalScope","_global","global","baseClazz","impl","onmessage","stubBaseOnMessage","head","script","createElement","ret","onreadystatechange","onload","appendChild","proxyClass","_messageId","_worker","_receive","_waiting","_invoke","cb","WorkerProxy","funcName","getOwnPropertyNames","Stub","finalRes","_result","_onmessage","poolClass","proxyInitializer","_proxyInitializer","_poolSize","_workers","_freeWorkers","_waitingCalls","_updateToSize","poolSize","_size","_step","destroy","workerPromises","createdWorkers","idx","_moduleLoadedCallbacks","WasmHelper","_importStarted","importWasmBrowser","importScriptBrowser","_importFinished","importWasmNodeJs","importScriptNodeJs","wasm","module","_adjustWasmPath","WebAssembly","xhr","XMLHttpRequest","responseType","wasmBinary","response","send","fs","require","readFileSync","u","toUint8Array","asm","_adjustScriptPath","moduleSettings","async","onRuntimeInitialized","importScripts","_loadBrowserScript","__dirname","CryptoWorker","lib","_workerAsync","startWorkerPoolForProxy","input","inputs","salt","iterations","block","transactionValid","timeNow","genesisHash","networkId","CryptoWorkerImpl","_superInit","doImportBrowser","out","Hash","getSize","Algorithm","ARGON2D","NodeNative","node_argon2","stackPtr","Module","stackSave","hashSize","wasmOut","stackAlloc","wasmIn","HEAPU8","_nimiq_argon2","stackRestore","hashes","stackTmp","node_kdf","wasmSalt","_nimiq_kdf","blockSerialized","GenesisConfig","GENESIS_HASH","unserialize","NETWORK_ID","Block","body","_valid","valid","_verify","header","interlinkHash","interlink","bodyHash","serialize","prepareForWorkerUse","CRC32","table","_POLYNOMIAL","_table","_createTable","_hex_chars","crc","UINT16_MAX","UINT32_MAX","UINT64_MAX","MAX_SAFE_INTEGER","MerkleTree","_computeRoot","light","mid","left","right","leftHash","rightHash","concatTypedArrays","MerklePath","nodes","MerklePathNode","_nodes","leafValue","leafHash","_compute","containsLeaf","inner","leftLeaf","rightLeaf","root","node","concat","serializedSize","leftBitsSize","leftBits","_compress","reduce","sum","_left","MerkleProof","operations","isUint16","_operations","leafValues","leafHashes","fnCompare","leaves","leafIndex","valueIndex","comparisonResult","compute","Operation","CONSUME_PROOF","h","CONSUME_INPUT","leftOps","leftPath","rightOps","rightPath","HASH","proofNodes","hashStack","opBitsSize","opBits","opCount","countNodes","isBrowser","process","webkitRTCPeerConnection","navigator","onLine","isHex","str1","str2","Policy","coins","SATOSHIS_PER_COIN","satoshis","blockHeight","startHeight","_supplyCacheInterval","startI","_supplyCacheMax","endI","supply","INITIAL_SUPPLY","_supplyCache","endHeight","_supplyAfter","initialSupply","_blockRewardAt","currentSupply","supplyAfter","TOTAL_SUPPLY","EMISSION_TAIL_START","EMISSION_TAIL_REWARD","EMISSION_SPEED","BLOCK_TIME","BLOCK_SIZE_MAX","BLOCK_TARGET_MAX","DIFFICULTY_BLOCK_WINDOW","DIFFICULTY_MAX_ADJUSTMENT_FACTOR","TRANSACTION_VALIDITY_WINDOW","M","K","DELTA","NUM_BLOCKS_VERIFICATION","NUM_SNAPSHOTS_MAX","Serializable","toHex","_obj","algorithm","BLAKE2B","_algorithm","blake2b","computeBlake2b","argon2d","getInstanceAsync","computeArgon2d","computeSha256","SHA256","sha256","SIZE","fromHex","node_blake2","_nimiq_blake2","node_sha256","_nimiq_sha256","SHA512","NULL","PrivateKey","privateKey","publicKey","publicKeysHash","PublicKey","node_ed25519_derive_delinearized_private_key","wasmInPrivateKey","wasmInPublicKey","wasmInPublicKeysHash","_ed25519_derive_delinearized_private_key","delinearizedPrivateKey","_publicKeyDerive","publicKeys","_delinearizeAndAggregatePublicKeys","Address","fromHash","PeerId","publicKeysObj","_publicKeysHash","_publicKeysDelinearizeAndAggregate","node_ed25519_public_key_derive","pubKeyBuffer","HEAP8","privKeyBuffer","_ed25519_public_key_derive","fill","concatenatedPublicKeys","node_ed25519_hash_public_keys","wasmInPublicKeys","_ed25519_hash_public_keys","hashedPublicKey","node_ed25519_delinearize_public_key","_ed25519_delinearize_public_key","delinearizedPublicKey","node_ed25519_aggregate_delinearized_public_keys","_ed25519_aggregate_delinearized_public_keys","aggregatePublicKey","KeyPair","locked","lockSalt","_locked","_lockedInternally","_lockSalt","_publicKey","_internalPrivateKey","generate","hexBuf","roundsLog","rounds","encryptedKey","EXPORT_SALT_LENGTH","check","EXPORT_CHECKSUM_LENGTH","_otpKdf","keyPair","pubHash","_privateKey","isLocked","_unlockedPrivateKey","unlockKey","wasLocked","unlock","encryptedSize","log2","EXPORT_KDF_ROUNDS","relock","overwrite","_otpPrivateKey","_clearUnlockedPrivateKey","LOCK_KDF_ROUNDS","xor","kdf","RandomSecret","Signature","_signatureCreate","commitment","signatures","_combinePartialSignatures","_signatureVerify","combinedCommitment","partialSignatures","combinedSignature","_aggregatePartialSignatures","sigA","sigB","_scalarsAdd","PartialSignature","node_ed25519_add_scalars","wasmOutSum","wasmInA","wasmInB","_ed25519_add_scalars","node_ed25519_sign","wasmOutSignature","signatureBuffer","wasmInMessage","wasmInPubKey","wasmInPrivKey","_ed25519_sign","signature","node_ed25519_verify","wasmInSignature","_ed25519_verify","Commitment","commitments","_commitmentsAggregate","concatenatedCommitments","node_ed25519_aggregate_commitments","wasmInCommitments","_ed25519_aggregate_commitments","aggCommitments","CommitmentPair","secret","_secret","_commitment","randomness","RANDOMNESS_SIZE","_commitmentCreate","node_ed25519_create_commitment","wasmOutCommitment","wasmOutSecret","_ed25519_create_commitment","SERIALIZED_SIZE","aggregateCommitment","_delinearizedPartialSignatureCreate","node_ed25519_delinearized_partial_sign","wasmInSecret","wasmInCommitment","_ed25519_delinearized_partial_sign","partialSignature","fromUserFriendlyAddress","CCODE","_ibanCheck","fromBase32","withSpaces","toBase32","HEX_SIZE","CONTRACT_CREATION","Account","balance","_type","_balance","TYPE_MAP","transactionsCache","revert","validityStartHeight","withBalance","fee","newBalance","containsTransaction","INITIAL","isInitial","BASIC","VESTING","HTLC","PrunedAccount","address","account","_address","_account","BasicAccount","SignatureProof","verifyTransaction","hasFlag","Flag","recipientType","withIncomingTransaction","create","Contract","recipient","getContractCreationAddress","HashedTimeLockedContract","sender","hashRoot","hashCount","timeout","totalAmount","isUint32","_sender","_recipient","_hashRoot","_hashCount","_timeout","_totalAmount","hashAlgorithm","toUserFriendlyAddress","proof","ProofType","REGULAR_TRANSFER","hashDepth","preImage","verify","serializeContent","EARLY_RESOLVE","TIMEOUT_RESOLVE","verifyIncomingTransaction","minCap","isSignedBy","withOutgoingTransaction","VestingContract","owner","vestingStart","vestingStepBlocks","vestingStepAmount","vestingTotalAmount","_owner","_vestingStart","_vestingStepBlocks","_vestingStepAmount","_vestingTotalAmount","getMinCap","AccountsTreeNode","prefix","TERMINAL","childrenSuffixes","childrenHashes","BRANCH","arg2","_prefix","isBranch","_childrenSuffixes","_childrenHashes","isTerminal","readVarLengthString","isTerminalType","terminalNode","isBranchType","childCount","childSuffix","childHash","childIndex","branchNode","writeVarLengthString","payloadSize","varLengthStringSize","_getChildIndex","suffix","find","getChildren","is","ourChild","otherChild","AccountsTreeStore","jdb","AccountsTreeStoreCodec","getObjectStore","createVolatileObjectStore","_store","startPrefix","relevantKeys","SynchronousAccountsTreeStore","valueEncoding","_syncStore","preload","expectedToBePresent","putSync","removeSync","AccountsProof","isChildOf","getChildHash","getChild","rootNode","_getAccount","commonPrefix","childKey","childNode","AccountsTreeChunk","_proof","lastPrefix","tail","terminalNodes","SIZE_MAX","EMPTY","AccountsTree","getPersistent","_init","createVolatile","getRootNode","rootPath","newChild","newChildHash","newParent","withChild","newParentHash","_updateKeys","_prune","nodeHash","withAccount","childPrefix","withoutChild","hasSingleChild","getFirstChild","hasChildren","addresses","prefixes","_getAccountsProof","includeNode","subPrefixes","getTerminalNodes","lastNode","getAccountsProof","SynchronousAccountsTree","PartialAccountsTree","_preloadAddresses","putBatch","finalizeBatch","getRootNodeSync","_updateHashes","_insertBatch","_updateKeysBatch","_pruneBatch","zeroHash","subHashes","currentHash","newNode","_complete","_lastPrefix","Status","ERR_INCORRECT_PROOF","_putLight","_mergeProof","ERR_UNMERGEABLE","complete","OK_COMPLETE","OK_UNFINISHED","nodeChildren","proofNode","proofChildren","nextChild","getLastChild","insertedNode","proofChild","proofHash","missingPrefix","ERR_HASH_MISMATCH","Accounts","accountsTree","bubble","genesisBlock","encodedAccounts","isEmpty","_commitBlockBody","height","TransactionCache","rootSync","accountsHash","getChunk","transactionCache","preloadAddresses","getAddresses","_processSenderAccounts","_processRecipientAccounts","_processContracts","toBePruned","senderAccount","_getSync","isToBePruned","revertBlockBody","_revertBlockBody","accountType","partialTree","senderType","recipientAccount","reverse","withContractCommand","prunedAccounts","accIdx","findIndex","acc","_rewardMiner","txFees","coinbaseTransaction","ExtendedTransaction","minerAddr","blockRewardAt","BlockHeader","prevHash","copy","_prevHash","_interlinkHash","_bodyHash","_accountsHash","_nBits","_height","_timestamp","_nonce","_version","nBits","timestamp","nonce","version","CURRENT_VERSION","isHash","BlockUtils","isValidCompact","SUPPORTED_VERSIONS","isProofOfWork","prevHeader","_pow","hard","compactToTarget","difficulty","compactToDifficulty","V1","BlockInterlink","_hashes","repeatBits","_repeatBits","compressed","_compressed","repeatBitsSize","lastHash","computeRoot","BlockBody","extraData","_minerAddr","_extraData","_prunedAccounts","extraDataLength","numTransactions","numPrunedAccounts","previousTx","compareBlockOrder","previousAcc","getMerkleLeafs","transactionCount","compact","isFinite","getTargetHeight","targetToCompact","difficultyToTarget","targetToDifficulty","hashToTarget","getTargetDepth","isValidTarget","headBlock","tailBlock","deltaTotalDifficulty","actualTime","adjustment","averageDifficulty","nextTarget","Subscription","ADDRESSES","minFeePerByte","MIN_FEE","_addresses","_minFeePerByte","addAll","additionalSize","ANY","BLOCKS_ONLY","format","flags","_format","_senderType","_recipientType","_value","_fee","_networkId","_validityStartHeight","_flags","_data","FORMAT_MAP","serializedContentSize","verifyOutgoingTransaction","recCompare","senderCompare","feePerByte","flag","Format","EXTENDED","ALL","signerKey","merklePath","_merklePath","_signature","merkleRoot","BasicTransaction","senderPubKey","singleSig","toAddress","_signatureProof","dataSize","proofSize","TransactionsProof","blockOrder","_blockOrder","shiftBlock","removeAll","missingBlocks","blockFromOrder","blocks","TransactionStoreEntry","transactionHash","blockHash","_transactionHash","_blockHeight","_blockHash","senderBuffer","recipientBuffer","transactionHashBuffer","TransactionStore","TransactionStoreCodec","keyEncoding","indexedTransactions","fromBlock","currentId","_currentId","indexedTransaction","_idForHash","toJSON","fromJSON","TransactionReceipt","_header","_interlink","_body","time","isLight","blockVerify","TIMESTAMP_DRIFT_MAX","verifyProofOfWork","_verifyInterlink","isFull","_verifyBody","predecessor","isImmediateSuccessorOf","getNextInterlink","prevPow","targetHeight","blockFound","depth","depthDiff","commonBlock","thisInterlink","prevInterlink","isInterlinkSuccessorOf","nextVersion","thisPowDepth","getHashDepth","nextTargetDepth","numOccurrences","IBlockchain","headHash","BaseChain","includeForks","includeBody","chainData","getChainData","onMainChain","getRawBlock","getBlockAt","getNearestBlockAt","locators","getBlock","step","headData","_mainChain","tailHeight","tailData","getChainDataAt","prevData","totalDifficulty","getNextTarget","_prove","m","delta","BlockChain","superBlockCounts","getCandidateDepth","alpha","_getSuperChain","toLight","_isGoodSuperChain","_getHeaderChain","ChainProof","chain","reference","ChainData","initial","GENESIS_BLOCK","superchain","_hasSuperQuality","_hasMultiLevelQuality","underlyingLength","_isLocallyGood","k1","mu","upperChainLength","MULTILEVEL_STRATEGY","MultilevelStrategy","STRICT","lowerChainLength","MODERATE","RELAXED","superLength","headers","HeaderChain","failOnBadness","suffixTail","prefixHead","chains","getSuperChains","deletedBlockHeights","_superchain","referenceBlock","numBlocksToDelete","candidateBlock","newPrefix","blockToProve","knownBlock","getInterlinkReference","hashToProve","proveTarget","proveDepth","nextBlock","partitions","part","computeArgon2dBatch","pows","proof1","proof2","lca","lowestCommonAncestor","score1","NanoChain","_getProofScore","score2","counts","maxScore","score","chain1","chain2","merged","i1","i2","block1","block2","superChains","_blocks","_chains","isSuccessorOf","denseSuffix","denseSuffixHead","_headers","_suffix","isAnchored","_verifyDifficulty","denseChain","totalDifficulties","headIndex","tailIndex","checkBlock","totalWork","realDifficulty","copyAndAdd","SuperBlockCounts","mainChainSuccessor","_head","_totalDifficulty","_totalWork","_superBlockCounts","_onMainChain","_mainChainSuccessor","hashBase64","successor","copyAndSubtract","_arr","subtract","ChainDataStore","chainStore","ChainDataStoreCodec","CHAINDATA_CACHING_ENABLED","CHAINDATA_CACHE_SIZE","_createIndexes","BlockStoreCodec","BLOCKS_CACHING_ENABLED","BLOCKS_CACHE_SIZE","BLOCKS_RAW_CACHE_SIZE","blockStore","lmdbKeyEncoding","leveldbKeyEncoding","_chainStore","_blockStore","chainTx","blockTx","candidates","eq","maxValues","minValues","startBlockHash","forward","getBlocksForward","getBlocksBackward","chainSnapshot","blockSnapshot","toObj","fromObj","MempoolTransactionSet","sortedTransactions","Mempool","blockchain","accounts","_blockchain","_accounts","_transactionsByFeePerByte","_transactionsByHash","_transactionSetBySender","_transactionSetByRecipient","_evictTransactions","_restoreTransactions","_pushTransaction","ReturnCode","KNOWN","TRANSACTION_RELAY_FEE_MIN","numBelowFeePerByte","FREE_TRANSACTIONS_PER_SENDER_MAX","FEE_TOO_LOW","INVALID","tmpAccount","TRANSACTIONS_PER_SENDER_MAX","_removeTransaction","_popLowFeeTransaction","byRecipient","ACCEPTED","Infinity","txSize","transactionGenerator","getTransactions","gatherToBePrunedAccounts","getTransactionsBySender","maxTransactions","bySender","getTransactionsByRecipient","peekLast","__evictTransactions","InvRequestManager","_vectorsToRequest","agent","vector","syncing","MAX_INV_MANAGED","requestVector","current","peer","channel","closed","_request","waiting","noteVectorNotReceived","MAX_TIME_PER_VECTOR","BaseConsensusAgent","invRequestManager","targetSubscription","_time","_peer","_synced","_knownObjects","InvVector","BLOCK","_blocksToRequest","_txsToRequest","TRANSACTIONS_AT_ONCE","FREE_TRANSACTIONS_AT_ONCE","TRANSACTIONS_PER_SECOND","FREE_TRANSACTIONS_PER_SECOND","REQUEST_TRANSACTIONS_WAITING_MAX","_objectsInFlight","_objectsThatFlew","_objectsProcessing","_remoteSubscription","_localSubscription","_lastSubscriptionChange","_targetSubscription","_waitingInvVectors","_sendWaitingInvVectors","TRANSACTION_RELAY_INTERVAL","_waitingFreeInvVectors","_sendFreeWaitingInvVectors","FREE_TRANSACTION_RELAY_INTERVAL","_blockProofRequest","_transactionsProofRequest","_transactionReceiptsRequest","_invRequestManager","_onInv","_onBlock","_onHeader","_onTx","_onNotFound","_onSubscribe","_onGetData","_onGetHeader","_onBlockProof","_onTransactionsProof","_onTransactionReceipts","_onGetHead","_onHead","_onClose","_requestHead","getHead","HEAD_REQUEST_INTERVAL","onHeadUpdated","subscription","_subscribe","subscribe","matchesBlock","inv","BaseInventoryMessage","VECTORS_MAX_COUNT","invVectors","peerAddress","FREE_TRANSACTION_SIZE_PER_INTERVAL","matchesTransaction","fromTransaction","vectors","unknownBlocks","unknownTxs","_shouldRequestData","_getBlock","_onKnownBlockAnnounced","_onNewBlockAnnounced","TRANSACTION","_getTransaction","_onKnownTransactionAnnounced","_onNewTransactionAnnounced","askToRequestVector","_onNoUnknownObjects","enqueueAllNew","REQUEST_THRESHOLD","_requestData","REQUEST_THROTTLE","vectorsMaxCount","_doRequestData","_noMoreData","REQUEST_TIMEOUT","getData","transactionPromises","_onObjectReceived","_processBlock","_onObjectProcessed","noteVectorReceived","_processHeader","_processTransaction","SUBSCRIPTION_CHANGE_GRACE_PERIOD","CloseType","RECEIVED_TRANSACTION_NOT_MATCHING_OUR_SUBSCRIPTION","_onAllObjectsReceived","_onAllObjectsProcessed","unknownObjects","_getRawBlock","rawBlock","notFound","blockHashToProve","_getBlockProof","getBlockProof","expectMessage","BLOCK_PROOF","BLOCK_PROOF_REQUEST_TIMEOUT","hasProof","INVALID_BLOCK_PROOF","_getTransactionsProof","getTransactionsProof","TRANSACTIONS_PROOF","GET_TRANSACTIONS_PROOF_TIMEOUT","TRANSACTIONS_PROOF_REQUEST_TIMEOUT","INVALID_TRANSACTION_PROOF","_getTransactionReceipts","getTransactionReceipts","TRANSACTION_RECEIPTS","GET_TRANSACTION_RECEIPTS_TIMEOUT","TRANSACTION_RECEIPTS_REQUEST_TIMEOUT","transactionReceipts","stop","synced","REQUEST_BLOCKS_WAITING_MAX","BaseConsensus","mempool","network","_network","_agents","_established","_syncPeer","_subscription","_onPeerJoined","_onPeerLeft","_onHeadChanged","_onTransactionAdded","_newConsensusAgent","_onPeerSynced","_onPeerOutOfSync","_syncBlockchain","SYNC_THROTTLE","numSyncedFullNodes","isFullNode","MIN_FULL_NODES","randomElement","syncBlockchain","allowInboundConnections","relayBlock","relayTransaction","blockHeightToProve","agents","knownBlockHash","knowsBlock","isNanoNode","receipts","_requestTransactionReceipts","blockRequests","lastBlockHash","receipt","_requestBlockProof","transactionRequests","_requestTransactionsProof","flat","established","FullChain","transactionStore","_snapshotOrder","_transactionCache","_transactionStore","_blockKnownCount","_blockInvalidCount","_blockOrphanCount","_blockExtendedCount","_blockRebranchedCount","_blockForkedCount","_headHash","genesis","prependBlocks","putChainDataSync","setHeadSync","initialize","GENESIS_ACCOUNTS","_pushBlock","OK_KNOWN","ERR_INVALID","ERR_ORPHAN","nextChainData","_extend","OK_EXTENDED","_rebranch","OK_REBRANCHED","putChainData","OK_FORKED","accountsTx","commitBlock","storeTx","transactionStoreTx","_saveSnapshot","pushBlock","_shouldExtendChainProof","_extendChainProof","forkChain","forkHashes","curData","curHash","ancestorData","ancestorHash","transactionCacheTx","clone","revertChain","revertBlock","numMissingBlocks","revertedData","forkData","getBlocks","_getChainProof","_getSnapshot","getAccountsTreeChunk","matches","addressesSet","entriesBySender","getBySender","entriesByRecipient","getByRecipient","entry","txStoreEntry","transactionsTx","currentBlock","oldestHash","oldestSnapshot","blockForkedCount","blockRebranchedCount","blockExtendedCount","blockOrphanCount","blockInvalidCount","blockKnownCount","FullConsensusAgent","_mempool","_syncing","_numBlocksExtending","_numBlocksForking","_forkHead","_failedSyncs","_syncTarget","_chainProofLimit","CHAIN_PROOF_RATE_LIMIT","_accountsProofLimit","ACCOUNTS_PROOF_RATE_LIMIT","_accountsTreeChunkLimit","ACCOUNTS_TREE_CHUNK_RATE_LIMIT","_transactionsProofLimit","TRANSACTION_PROOF_RATE_LIMIT","_transactionReceiptsLimit","TRANSACTION_RECEIPTS_RATE_LIMIT","_blockProofLimit","BLOCK_PROOF_RATE_LIMIT","_onGetBlocks","_onGetChainProof","_onGetAccountsProof","_onGetAccountsTreeChunk","_onGetTransactionsProof","_onGetTransactions","_onGetBlockProof","_onMempool","_syncFinished","SYNC_ATTEMPTS_MAX","BLOCKCHAIN_SYNC_FAILED","_requestBlocks","_subscribeTarget","delay","MEMPOOL_DELAY_MIN","MEMPOOL_DELAY_MAX","maxInvSize","isExpectingMessage","INV","GET_BLOCKS_TIMEOUT","getBlockLocators","getTransaction","RECEIVED_INVALID_BLOCK","_onOrphanBlock","timeoutExists","_outOfSync","RESYNC_THROTTLE","pushTransaction","TX","RejectMessage","Code","REJECT_INSUFFICIENT_FEE","REJECT_INVALID","startBlock","locator","GETBLOCKS_VECTORS_MAX","direction","GetBlocksMessage","Direction","FORWARD","note","RATE_LIMIT_EXCEEDED","getChainProof","chainProof","blockProof","accountsProof","transactionsProof","accountsTreeChunk","getTransactionReceiptsByAddress","TRANSACTION_RECEIPTS_LIMIT","TransactionReceiptsMessage","RECEIPTS_MAX_COUNT","getTransactionsByAddresses","MEMPOOL_ENTRIES_MAX","MEMPOOL_THROTTLE","FullConsensus","fromMinFeePerByte","evictBelowMinFeePerByte","LightChain","partialChain","PartialLightChain","mainChain","LightConsensusAgent","_partialChain","_catchup","_orphanedBlocks","_busy","_accountsRequest","_requestedChainProof","_numWeakProofs","_onChainProof","_onAccountsTreeChunk","getHeader","DID_NOT_GET_REQUESTED_HEADER","_initChainProofSync","State","PROVE_CHAIN","_requestChainProof","PROVE_ACCOUNTS_TREE","_requestAccountsTree","PROVE_BLOCKS","_requestProofBlocks","COMPLETE","_applyOrphanedBlocks","ABORTED_SYNC","WEAK_PROOF","WEAK_PROOFS_MAX","CHAIN_PROOF","GET_CHAIN_PROOF_TIMEOUT","CHAINPROOF_REQUEST_TIMEOUT","CHAINPROOF_CHUNK_TIMEOUT","pushProof","INVALID_CHAIN_PROOF","getMissingAccountsPrefix","ACCOUNTS_TREE_CHUNK","GET_ACCOUNTS_TREE_CHUNK_TIMEOUT","ACCOUNTS_TREE_CHUNK_REQUEST_TIMEOUT","hasChunk","INVALID_ACCOUNTS_TREE_CHUNK","rootHash","ACCOUNTS_TREE_CHUNCK_ROOT_HASH_MISMATCH","pushAccountsTreeChunk","_lastChainHeight","proofHeadHeight","numBlocksNeeded","_chain","_headerRequest","HEADER","GET_HEADER_TIMEOUT","NanoConsensusAgent","requestedHash","RECEIVED_WRONG_HEADER","LightConsensus","_partialTree","_accountsTx","_proofHead","_pushProof","toDo","manyPow","suffixBlocks","currentProof","isBetterProof","_acceptProof","tailEnd","_pushLightBlock","partialAccountsTree","setHead","_pushBlockInternal","proofHeadHash","_pushBlockBackwards","_pushHeadBlock","_prepend","needsMoreBlocks","previousChainData","pushChunk","numBlocks","_pushHeader","_onAccountsProof","requestMempool","pushHeader","RECEIVED_INVALID_HEADER","_getAccounts","ACCOUNTS_PROOF","GET_ACCOUNTS_PROOF_TIMEOUT","ACCOUNTSPROOF_REQUEST_TIMEOUT","INVALID_ACCOUNTS_PROOF","ACCOUNTS_PROOF_ROOT_HASH_MISMATCH","getAccount","INCOMPLETE_ACCOUNTS_PROOF","NanoConsensus","fromAddresses","evictExceptAddresses","includedTransactions","changeHead","getAccounts","relayed","NanoMempool","_transactionSetByAddress","maxCount","addressSet","blockHeader","txHash","ConsensusDB","dbPrefix","dbName","VERSION","maxDbSize","INITIAL_DB_SIZE","autoResize","minResize","MIN_RESIZE","initPersistent","connect","Consensus","netconfig","NetworkConfig","getDefault","getFull","NETWORK_NAME","Network","getLight","initVolatile","Protocol","DUMB","WS","RTC","readVarUint","magic","checksum","MAGIC","_writeChecksum","writeVarUint","varUintSize","GET_DATA","GET_HEADER","NOT_FOUND","GET_BLOCKS","MEMPOOL","REJECT","SUBSCRIBE","ADDR","GET_ADDR","PING","PONG","SIGNAL","GET_CHAIN_PROOF","GET_ACCOUNTS_PROOF","GET_ACCOUNTS_TREE_CHUNK","GET_TRANSACTIONS_PROOF","GET_TRANSACTION_RECEIPTS","GET_BLOCK_PROOF","GET_HEAD","HEAD","VERACK","AddrMessage","PeerAddress","addr","_setChecksum","BlockMessage","_block","RawBlockMessage","GetAddrMessage","protocolMask","serviceMask","_protocolMask","_serviceMask","_locators","_maxInvSize","_direction","BACKWARD","HeaderMessage","_vectors","subtype","InvMessage","GetDataMessage","GetHeaderMessage","NotFoundMessage","MempoolMessage","PingMessage","PongMessage","messageType","reason","_messageType","_code","_reason","REJECT_MALFORMED","REJECT_OBSOLETE","REJECT_DOUBLE","REJECT_DUST","SignalMessage","senderId","recipientId","ttl","payload","hasPayload","_senderId","_recipientId","_ttl","_payload","_senderPubKey","toPeerId","UNROUTABLE","TTL_EXCEEDED","SubscribeMessage","TxMessage","_transaction","_accountsProof","hasAccountsProof","VersionMessage","challengeNonce","_peerAddress","_genesisHash","_challengeNonce","CHALLENGE_SIZE","VerAckMessage","AccountsProofMessage","GetAccountsProofMessage","ChainProofMessage","GetChainProofMessage","AccountsTreeChunkMessage","_accountsTreeChunk","GetAccountsTreeChunkMessage","_startPrefix","TransactionsProofMessage","GetTransactionsProofMessage","GetTransactionReceiptsMessage","_transactionReceipts","GetBlockProofMessage","_blockHashToProve","_knownBlockHash","BlockProofMessage","GetHeadMessage","HeadMessage","MessageFactory","CLASSES","WebRtcConnector","networkConfig","_networkConfig","_connectors","signalChannel","protocol","peerId","connector","OutboundPeerConnector","conn","_onConnection","rtcConnection","CONNECT_TIMEOUT","isUnroutable","isTtlExceeded","isValidSignal","InboundPeerConnector","onSignal","PeerConnector","_signalChannel","_peerId","randomUint32","_rtcConnection","newPeerConnection","rtcConfig","onicecandidate","_onIceCandidate","_lastIceCandidate","_iceCandidateQueue","signal","sdp","setRemoteDescription","newSessionDescription","createAnswer","description","_onDescription","_handleCandidateQueue","candidate","_addIceCandidate","newIceCandidate","remoteDescription","addIceCandidate","SIGNAL_TTL_INITIAL","_signal","setLocalDescription","localDescription","WebRtcDataChannel","netAddress","WebRtcUtils","candidateToNetAddress","NetworkConnection","webRtcConfig","createDataChannel","binaryType","onopen","_onDataChannel","createOffer","offer","ondatachannel","nativeChannel","ordered","_channel","_onMessage","onclose","reader","FileReader","onloadend","readAsArrayBuffer","fromIP","WebSocketConnector","_wss","newWebSocketServer","ws","port","_sockets","timeoutKey","newWebSocket","handshakeTimeout","_socket","remoteAddress","WebSocketDataChannel","_ws","ip","reliable","saneIp","NetUtils","ipToBytes","isIPv4Address","IPv4","IPv6","ipArray","IPv4_LENGTH","IPv6_LENGTH","UNKNOWN","_ip","_reliable","bytesToIp","isPseudo","isPrivateIP","isIPv6Address","bitCount","ipToSubnet","distance","_protocol","_services","_netAddress","_distance","WsPeerAddress","RtcPeerAddress","DumbPeerAddress","isPrivate","_signatureVerified","isSeed","age","PeerAddressBook","MAX_AGE_WEBSOCKET","MAX_AGE_WEBRTC","MAX_AGE_DUMB","publicKeyHex","_host","_port","hostGloballyReachable","PeerAddressState","NEW","lastConnected","bannedUntil","banBackoff","INITIAL_FAILED_BACKOFF","_signalRouter","SignalRouter","_failedAttempts","_closeTypes","_addedBy","signalRouter","maxFailedAttempts","MAX_FAILED_ATTEMPTS_RTC","MAX_FAILED_ATTEMPTS_WS","failedAttempts","bestRoute","updateBestRoute","BANNED","isBanningType","isFailingType","FAILED","TRIED","addedBy","ESTABLISHED","_bestRoute","_routes","oldRoute","newRoute","SignalRoute","deleteRoute","route","MAX_DISTANCE","_stateByPeerId","_statesByNetAddress","SEED_PEERS","_housekeeping","HOUSEKEEPING_INTERVAL","localPeerAddress","withoutId","peerAddressState","maxAddresses","addressStates","numAddresses","exceedsAge","peerAddresses","newAddresses","_add","MAX_SIZE","MAX_TIMESTAMP_DRIFT","knownAddress","changed","states","MAX_SIZE_PER_IP","addRoute","_removeBySignalChannel","_ban","MAX_FAILED_BACKOFF","deleteBestRoute","hasRoute","duration","DEFAULT_BAN_TIME","deleteAllRoutes","unbannedAddresses","knownAddressesCount","CONFIGS","config","_config","dev","seed","difficultyToCompact","bounty","closeType","INVALID_BLOCK","SENDING_PING_MESSAGE_FAILED","SENDING_OF_VERSION_MESSAGE_FAILED","SIMULTANEOUS_CONNECTION","DUPLICATE_CONNECTION","PEER_IS_BANNED","MANUAL_NETWORK_DISCONNECT","MANUAL_WEBSOCKET_DISCONNECT","MAX_PEER_COUNT_REACHED","PEER_CONNECTION_RECYCLED","PEER_CONNECTION_RECYCLED_INBOUND_EXCHANGE","INBOUND_CONNECTIONS_BLOCKED","MANUAL_PEER_DISCONNECT","ADDR_MESSAGE_TOO_LARGE","INVALID_ADDR","ADDR_NOT_GLOBALLY_REACHABLE","INVALID_SIGNAL_TTL","INVALID_SIGNATURE","RECEIVED_BLOCK_NOT_MATCHING_OUR_SUBSCRIPTION","INCOMPATIBLE_VERSION","DIFFERENT_GENESIS_BLOCK","INVALID_PEER_ADDRESS_IN_VERSION_MESSAGE","UNEXPECTED_PEER_ADDRESS_IN_VERSION_MESSAGE","INVALID_PUBLIC_KEY_IN_VERACK_MESSAGE","INVALID_SIGNATURE_IN_VERACK_MESSAGE","BANNED_IP","MANUAL_PEER_BAN","CLOSED_BY_REMOTE","PING_TIMEOUT","CONNECTION_FAILED","NETWORK_ERROR","VERSION_TIMEOUT","VERACK_TIMEOUT","FAILED_TO_PARSE_MESSAGE_TYPE","CONNECTION_LIMIT_PER_IP","CHANNEL_CLOSING","MANUAL_PEER_FAIL","_bytesSent","_bytesReceived","_inbound","_closed","_lastError","_onError","logAddress","_isChannelClosing","_isChannelClosed","_isChannelOpen","confirmExpectedMessage","connType","_close","bytesSent","bytesReceived","inbound","outbound","PeerChannel","connection","_conn","rawMsg","Event","_send","NetworkAgent","_knownAddresses","_versionReceived","_verackReceived","_versionSent","_verackSent","_versionAttempts","_peerAddressVerified","_peerChallengeNonce","_pingTimes","_addrQueue","MAX_ADDR_RELAY_PER_MESSAGE","ADDR_QUEUE_INTERVAL","ADDR_RATE_LIMIT","_relayNow","_addrLimit","_onVersion","_onVerAck","_onAddr","_onGetAddr","_onPing","_onPong","filteredAddresses","RELAY_THROTTLE","_sendVerAck","HANDSHAKE_TIMEOUT","VERSION_ATTEMPTS_MAX","handshake","VERSION_RETRY_DELAY","_canAcceptMessage","isCompatible","verifySignature","storedAddress","Peer","_finishHandshake","verack","_checkConnectivity","CONNECTIVITY_CHECK_INTERVAL","ANNOUNCE_ADDR_INTERVAL","_requestAddresses","getAddr","MAX_ADDR_PER_MESSAGE","globallyReachable","ping","pong","PeerConnectionStatistics","_latencies","_messages","latency","msgType","latencyMedian","median","PeerConnection","peerConnection","PeerConnectionState","networkConnection","_networkConnection","_peerChannel","_networkAgent","_score","_establishedSince","_statistics","CONNECTED","peerChannel","networkAgent","NEGOTIATING","addLatency","addMessage","establishedSince","ageEstablished","statistics","SignalProcessor","rtcConnector","_rtcConnector","_forwards","SignalStore","myPeerId","signalForwarded","senderAddr","getByPeerId","unroutable","getChannelByPeerId","ForwardedSignal","lastSeen","SIGNAL_MAX_AGE","toDelete","dSignal","ConnectionPool","_connectionsByPeerAddress","_connectionsByNetAddress","_connectionsBySubnet","_wsConnector","peerAddr","_onConnectError","_peerCountWs","_peerCountRtc","_peerCountDumb","_peerCountFull","_peerCountLight","_peerCountNano","_peerCountOutbound","_peerCountFullWsOutbound","_connectingCount","_inboundCount","_signalProcessor","_allowInboundExchange","_allowInboundConnections","_bannedIPv4IPs","_bannedIPv6IPs","_checkUnbanIps","UNBAN_IPS_INTERVAL","_getSubnetAddress","subnet","isIPv4","IPV4_SUBNET_MASK","IPV6_SUBNET_MASK","_removeNetAddress","subnetAddress","peerConnections","isBanned","getConnectionByPeerAddress","getConnectionsByNetAddress","PEER_COUNT_PER_IP_MAX","getOutboundConnectionsBySubnet","OUTBOUND_PEER_COUNT_PER_SUBNET_MAX","_checkOutboundConnectionRequest","getOutbound","connecting","_isIpBanned","getConnectionsBySubnet","INBOUND_PEER_COUNT_PER_SUBNET_MAX","peerCount","PEER_COUNT_MAX","getInbound","_checkConnection","_addNetAddress","_checkHandshake","_onHandshake","storedConnection","negotiating","_updateConnectedPeerCount","_banIp","kbTransferred","isIPv6","isLightNode","peerCountWs","peerCountRtc","peerCountDumb","peerCountFull","peerCountLight","peerCountNano","peerCountOutbound","peerCountFullWsOutbound","connectingCount","allowInboundExchange","PeerScorer","connections","_connections","_connectionScores","findCandidates","numCandidates","allowBadPeers","minCandidates","addressState","_scoreAddress","needsGoodPeers","goodCandidates","PICK_SELECTION_SIZE","canConnect","isGoodPeer","needsMorePeers","PEER_COUNT_MIN_FULL_WS_OUTBOUND","PEER_COUNT_MIN_OUTBOUND","_getMinAge","_scoreConnection","reset","scoreAge","_scoreConnectionAge","scoreOutbound","scoreType","scoreProtocol","BEST_PROTOCOL_WS_DISTRIBUTION","medianLatency","scoreSpeed","bestAge","maxAge","BEST_AGE_FULL","BEST_AGE_LIGHT","MAX_AGE_LIGHT","BEST_AGE_NANO","MAX_AGE_NANO","MIN_AGE_FULL","MIN_AGE_LIGHT","MIN_AGE_NANO","lowestConnectionScore","supportsWebRTC","RtcNetworkConfig","DumbNetworkConfig","_keyPair","PeerKeyStore","WsNetworkConfig","cert","_cert","_sslConfig","sslConfig","_rtcConfig","iceServers","urls","_autoConnect","_backoff","CONNECT_BACKOFF_INITIAL","_backedOff","_relayAddresses","_checkPeerCount","_onPeersChanged","_onRecyclingRequest","CONNECT_THROTTLE","_scorer","_houseKeepingIntervalId","disconnect","disconnectWebSocket","_updateTimeOffset","recycleConnections","SCORE_INBOUND_EXCHANGE","PEER_COUNT_RELAY","relayAddresses","isGoodPeerSet","CONNECTING_COUNT_MAX","pickAddress","onlyGoodPeers","oldBackoff","CONNECT_BACKOFF_MAX","connectOutbound","offsets","timeOffset","offsetsLength","TIME_OFFSET_MAX","scoreConnections","PEER_COUNT_RECYCLING_ACTIVE","percentageToRecycle","connectionsToRecycle","peerCountWebSocket","peerCountWebRtc","peerCountConnecting","isLocalIP","IPv4_PRIVATE_NETWORK","isIPv4inSubnet","subIp","mask","_IPv4toLong","isEmbeddedIPv4","innerEmpty","_extendIPv6","hexIp","ipv6","ipv4","_IPv4toIPv6","emptyPart","stringResult","KEY_DATABASE","PeerKeyStoreCodec","leveldbValueEncoding","lmdbValueEncoding","_timeOffset","_setNetAddress","Miner","minerAddress","_lastHashrate","_hashrateWorker","_hashrate","_lastHashCounts","_totalHashCount","_lastElapsed","_totalElapsed","_workerPool","MinerWorkerPool","hardwareConcurrency","threads","cores","cpus","throttleAfter","_onWorkerShare","_mempoolChanged","_restarting","_lastRestart","_submittingBlock","_startWork","_updateHashrate","_retry","getNextBlock","startMiningOnBlock","stopWork","startWork","noncesPerRun","MIN_TIME_ON_BLOCK","_getNextInterlink","_getNextBody","_getNextHeader","commitBlockBody","_getNextTimestamp","interlinkSize","getMetadataSize","getTransactionsForBlock","elapsed","MOVING_AVERAGE_MAX_SIZE","oldestElapsed","oldestHashCount","hashrate","throttleWait","cycleWait","runsPerCycle","Wallet","fromEncrypted","exportEncrypted","lock","MultiSigWallet","minSignatures","multiSigKeys","k_combinations","numPublicKeys","serialBuf","_loadMultiSig","_minSignatures","_publicKeys","exportedSize","pubKey","encryptedExportedSize","recipientAddr","aggregatedCommitment","aggregatedPublicKey","fromPartialSignatures","multiSig","signTransaction","WalletStore","_walletStore","_multiSigStore","WALLET_DATABASE","WalletStoreCodec","MULTISIG_WALLET_DATABASE","defaultAddress","defaultWallet","setDefault","base64Address","loadEncrypted","loadPlain","wallet","exportPlain","MinerWorker","minNonce","maxNonce","MinerWorkerImpl","_malloc","_nimiq_argon2_target","_free","_miningEnabled","_activeNonces","_noncesPerRun","_observable","_shareCompact","_runsPerCycle","_cycleWait","_superUpdateToSize","multiMine","fail","node_argon2_target_async","nonces","off","shareCompact","_startMiner","nonceRange","_singleMiner","newMin","newRange"],"mappings":"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","file":"web.js","sourcesContent":["if (typeof JDB === 'undefined') {\n    var JDB = {};\n}\nvar Proxy; // ensure Proxy exists\n(function (exports) {\n    exports = typeof exports !== 'undefined' ? exports : {};\n","if (typeof Nimiq === 'undefined') {\n    var Nimiq = typeof window !== 'undefined' ? window : {};\n}\nvar Proxy; // ensure Proxy exists\n(function (exports) {\n    exports = typeof exports !== 'undefined' ? exports : {};\n    Nimiq = exports;\n    if (!Nimiq._currentScript) {\n        Nimiq._currentScript = document.currentScript;\n    }\n    if (!Nimiq._currentScript) {\n        // Heuristic\n        const scripts = document.getElementsByTagName('script');\n        Nimiq._currentScript = scripts[scripts.length - 1];\n    }\n    if (!Nimiq._path) {\n        if (Nimiq._currentScript && Nimiq._currentScript.src.indexOf('/') !== -1) {\n            Nimiq._path = Nimiq._currentScript.src.substring(0, Nimiq._currentScript.src.lastIndexOf('/') + 1);\n        } else {\n            // Fallback\n            Nimiq._path = './';\n        }\n    }\n","class Class {\n    static register(cls) {\n        if (typeof exports !== 'undefined') exports[cls.name] = cls;\n    }\n}\nClass.register(Class);\n","class LogNative {\n    constructor() {\n        this._global_level = Log.TRACE;\n        this._tag_levels = {};\n        try {\n            if (window.localStorage) {\n                try {\n                    let c = window.localStorage.getItem('log_tag_levels');\n                    if (c && typeof c === 'string') c = JSON.parse(c);\n                    if (c && typeof c === 'object') this._tag_levels = c;\n                } catch (e) {\n                    console.warn('Failed to load log configuration from local storage.');\n                }\n            }\n        } catch (e) {\n            // ignore\n        }\n    }\n\n    isLoggable(tag, level) {\n        if (tag && this._tag_levels[tag]) {\n            return this._tag_levels[tag] <= level;\n        }\n        if (this._tag_levels['*']) {\n            return this._tag_levels['*'] <= level;\n        }\n        return this._global_level <= level;\n    }\n\n    setLoggable(tag, level) {\n        if (tag && tag.name) tag = tag.name;\n        this._tag_levels[tag] = level;\n        if (window.localStorage) {\n            window.localStorage.setItem('log_tag_levels', JSON.stringify(this._tag_levels));\n        }\n    }\n\n    msg(level, tag, args) {\n        if (tag && tag.name) tag = tag.name;\n        if (!this.isLoggable(tag, level)) return;\n        if (tag) args.unshift(tag + ':');\n        args.unshift(`[${Log.Level.toStringTag(level)} ${new Date().toTimeString().substr(0, 8)}]`);\n        if (console.error && level >= Log.ERROR) {\n            console.error.apply(console, args);\n        } else if (console.warn && level >= Log.WARNING) {\n            console.warn.apply(console, args);\n        } else if (console.info && level >= Log.INFO) {\n            console.info.apply(console, args);\n        } else if (console.debug && level >= Log.DEBUG) {\n            console.debug.apply(console, args);\n        } else if (console.trace && level <= Log.TRACE) {\n            console.trace.apply(console, args);\n        } else {\n            console.log.apply(console, args);\n        }\n    }\n}\nClass.register(LogNative);\n","class IDBTools {\n    /**\n     * Converts our KeyRange objects into IDBKeyRange objects.\n     * @param {KeyRange} keyRange A KeyRange object.\n     * @returns {IDBKeyRange} The corresponding IDBKeyRange.\n     */\n    static convertKeyRange(keyRange) {\n        if (!(keyRange instanceof KeyRange)) return keyRange;\n        if (keyRange.exactMatch) {\n            return IDBKeyRange.only(keyRange.lower);\n        }\n        if (keyRange.lower !== undefined && keyRange.upper === undefined) {\n            return IDBKeyRange.lowerBound(keyRange.lower, keyRange.lowerOpen);\n        }\n        if (keyRange.upper !== undefined && keyRange.lower === undefined) {\n            return IDBKeyRange.upperBound(keyRange.upper, keyRange.upperOpen);\n        }\n        return IDBKeyRange.bound(keyRange.lower, keyRange.upper, keyRange.lowerOpen, keyRange.upperOpen);\n    }\n}\nClass.register(IDBTools);\n","/**\n * This class is a wrapper around the IndexedDB.\n * It manages the access to a single table/object store.\n * @implements {IBackend}\n */\nclass IDBBackend {\n    /**\n     * Creates a wrapper given a JungleDB object and table name.\n     * @param {JungleDB} db The JungleDB object managing the connection.\n     * @param {string} tableName THe table name this object store represents.\n     * @param {ICodec} [codec] Optional codec applied before storing/retrieving values in/from the backend (null is the identity codec).\n     */\n    constructor(db, tableName, codec=null) {\n        this._db = db;\n        this._tableName = tableName;\n        /** @type {Map.<string,IIndex>} */\n        this._indices = new Map();\n        this._indicesToCreate = new Map();\n        this._indicesToDelete = [];\n        this._codec = codec;\n    }\n\n    /** @type {boolean} */\n    get connected() {\n        return this._db.connected;\n    }\n\n    /** @type {IDBDatabase} */\n    get _backend() {\n        if (!this.connected) {\n            throw new Error('Requires a connected database');\n        }\n        return this._db.backend;\n    }\n\n    /**\n     * A map of index names to indices.\n     * The index names can be used to access an index.\n     * @type {Map.<string,IIndex>}\n     */\n    get indices() {\n        return this._indices;\n    }\n\n    /**\n     * Internal method called by the JungleDB to create the necessary indices during a version upgrade.\n     * @param {IDBObjectStore} objectStore The IDBObjectStore object obtained during a version upgrade.\n     * @param {number} oldVersion\n     * @param {number} newVersion\n     * @protected\n     */\n    init(objectStore, oldVersion, newVersion) {\n        // Delete indices.\n        for (const { indexName, upgradeCondition } of this._indicesToDelete) {\n            if (objectStore.indexNames.contains(indexName) && (upgradeCondition === null || upgradeCondition === true || (typeof upgradeCondition === 'function' && upgradeCondition(oldVersion, newVersion)))) {\n                objectStore.deleteIndex(indexName);\n            }\n        }\n        this._indicesToDelete = [];\n\n        // Create indices.\n        for (const [indexName, { index, upgradeCondition }] of this._indicesToCreate) {\n            // Only check upgradeCondition if index does not already exist!\n            if (!objectStore.indexNames.contains(indexName)\n                && (upgradeCondition === null || upgradeCondition === true\n                    || (typeof upgradeCondition === 'function' && upgradeCondition(oldVersion, newVersion)))) {\n                const keyPath = Array.isArray(index.keyPath) ? index.keyPath.join('.') : index.keyPath;\n                objectStore.createIndex(indexName, keyPath, { unique: index.unique, multiEntry: index.multiEntry });\n            }\n        }\n        this._indicesToCreate.clear();\n    }\n\n    /**\n     * Method called to decode a single value.\n     * @param {*} value Value to be decoded.\n     * @param {string} key Key corresponding to the value.\n     * @returns {*} The decoded value.\n     */\n    decode(value, key) {\n        if (value === undefined) {\n            return undefined;\n        }\n        if (this._codec !== null && this._codec !== undefined) {\n            return this._codec.decode(value, key);\n        }\n        return value;\n    }\n\n    /**\n     * Method called to encode a single value.\n     * @param {*} value Value to be encoded.\n     * @returns {*} The encoded value.\n     */\n    encode(value) {\n        if (value === undefined) {\n            return undefined;\n        }\n        if (this._codec !== null && this._codec !== undefined) {\n            return this._codec.encode(value);\n        }\n        return value;\n    }\n\n    /**\n     * Returns a promise of the object stored under the given primary key.\n     * Resolves to undefined if the key is not present in the object store.\n     * @param {string} key The primary key to look for.\n     * @param {RetrievalConfig} [options] Advanced retrieval options.\n     * @returns {Promise.<*>} A promise of the object stored under the given key, or undefined if not present.\n     */\n    async get(key, options = {}) {\n        const db = this._backend;\n        return new Promise((resolve, reject) => {\n            const getTx = db.transaction([this._tableName])\n                .objectStore(this._tableName)\n                .get(key);\n            getTx.onsuccess = event => {\n                try {\n                    resolve((options && options.raw) ? event.target.result : this.decode(event.target.result, key));\n                } catch (e) {\n                    reject(e);\n                }\n            };\n            getTx.onerror = reject;\n        });\n    }\n\n    /**\n     * Returns a promise of an array of objects whose primary keys fulfill the given query.\n     * If the optional query is not given, it returns all objects in the object store.\n     * If the query is of type KeyRange, it returns all objects whose primary keys are within this range.\n     * If the query is of type Query, it returns all objects whose primary keys fulfill the query.\n     * @param {Query|KeyRange} [query] Optional query to check keys against.\n     * @param {number} [limit] Limits the number of results if given.\n     * @returns {Promise.<Array.<*>>} A promise of the array of objects relevant to the query.\n     */\n    async values(query = null, limit = null) {\n        if (query !== null && query instanceof Query) {\n            return query.values(this, limit);\n        }\n        query = IDBTools.convertKeyRange(query);\n        const db = this._backend;\n        return new Promise((resolve, reject) => {\n            const results = [];\n            const openCursorRequest = db.transaction([this._tableName], 'readonly')\n                .objectStore(this._tableName)\n                .openCursor(query);\n            openCursorRequest.onsuccess = event => {\n                const cursor = event.target.result;\n                if (cursor) {\n                    // Limit\n                    if (limit !== null && results.length >= limit) {\n                        resolve(results);\n                        return;\n                    }\n\n                    try {\n                        results.push(this.decode(cursor.value, cursor.primaryKey));\n                    } catch (e) {\n                        reject(e);\n                    }\n                    cursor.continue();\n                } else {\n                    resolve(results);\n                }\n            };\n            openCursorRequest.onerror = () => reject(openCursorRequest.error);\n        });\n    }\n\n    /**\n     * Returns a promise of a set of keys fulfilling the given query.\n     * If the optional query is not given, it returns all keys in the object store.\n     * If the query is of type KeyRange, it returns all keys of the object store being within this range.\n     * If the query is of type Query, it returns all keys fulfilling the query.\n     * @param {Query|KeyRange} [query] Optional query to check keys against.\n     * @param {number} [limit] Limits the number of results if given.\n     * @returns {Promise.<Set.<string>>} A promise of the set of keys relevant to the query.\n     */\n    async keys(query = null, limit = null) {\n        if (query !== null && query instanceof Query) {\n            return query.keys(this, limit);\n        }\n        query = IDBTools.convertKeyRange(query);\n        const db = this._backend;\n        return new Promise((resolve, reject) => {\n            const results = new Set();\n            const store = db.transaction([this._tableName], 'readonly').objectStore(this._tableName);\n            const openCursorRequest = store.openKeyCursor ? store.openKeyCursor(query) : store.openCursor(query);\n            openCursorRequest.onsuccess = event => {\n                const cursor = event.target.result;\n                if (cursor) {\n                    // Limit\n                    if (limit !== null && results.size >= limit) {\n                        resolve(results);\n                        return;\n                    }\n\n                    results.add(cursor.primaryKey);\n                    cursor.continue();\n                } else {\n                    resolve(results);\n                }\n            };\n            openCursorRequest.onerror = () => reject(openCursorRequest.error);\n        });\n    }\n\n    /**\n     * Iterates over the keys in a given range and direction.\n     * The callback is called for each primary key fulfilling the query\n     * until it returns false and stops the iteration.\n     * @param {function(key:string):boolean} callback A predicate called for each key until returning false.\n     * @param {boolean} ascending Determines the direction of traversal.\n     * @param {KeyRange} query An optional KeyRange to narrow down the iteration space.\n     * @returns {Promise} The promise resolves after all elements have been streamed.\n     */\n    keyStream(callback, ascending=true, query=null) {\n        query = IDBTools.convertKeyRange(query);\n        const db = this._backend;\n        return new Promise((resolve, reject) => {\n            const store = db.transaction([this._tableName], 'readonly').objectStore(this._tableName);\n            const openCursorRequest = store.openKeyCursor\n                ? store.openKeyCursor(query, ascending ? 'next' : 'prev')\n                : store.openCursor(query, ascending ? 'next' : 'prev');\n            openCursorRequest.onsuccess = event => {\n                const cursor = event.target.result;\n                if (cursor) {\n                    try {\n                        if (callback(cursor.primaryKey)) {\n                            cursor.continue();\n                        } else {\n                            resolve();\n                        }\n                    } catch (e) {\n                        reject(e);\n                    }\n                } else {\n                    resolve();\n                }\n            };\n            openCursorRequest.onerror = () => reject(openCursorRequest.error);\n        });\n    }\n\n    /**\n     * Iterates over the keys and values in a given range and direction.\n     * The callback is called for each value and primary key fulfilling the query\n     * until it returns false and stops the iteration.\n     * @param {function(value:*, key:string):boolean} callback A predicate called for each value and key until returning false.\n     * @param {boolean} ascending Determines the direction of traversal.\n     * @param {KeyRange} query An optional KeyRange to narrow down the iteration space.\n     * @returns {Promise} The promise resolves after all elements have been streamed.\n     */\n    valueStream(callback, ascending=true, query=null) {\n        query = IDBTools.convertKeyRange(query);\n        const db = this._backend;\n        return new Promise((resolve, reject) => {\n            const openCursorRequest = db.transaction([this._tableName], 'readonly')\n                .objectStore(this._tableName)\n                .openCursor(query, ascending ? 'next' : 'prev');\n            openCursorRequest.onsuccess = event => {\n                const cursor = event.target.result;\n                if (cursor) {\n                    try {\n                        if (callback(this.decode(cursor.value, cursor.primaryKey), cursor.primaryKey)) {\n                            cursor.continue();\n                        } else {\n                            resolve();\n                        }\n                    } catch (e) {\n                        reject(e);\n                    }\n                } else {\n                    resolve();\n                }\n            };\n            openCursorRequest.onerror = () => reject(openCursorRequest.error);\n        });\n    }\n\n    /**\n     * Returns a promise of the object whose primary key is maximal for the given range.\n     * If the optional query is not given, it returns the object whose key is maximal.\n     * If the query is of type KeyRange, it returns the object whose primary key is maximal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<*>} A promise of the object relevant to the query.\n     */\n    async maxValue(query=null) {\n        query = IDBTools.convertKeyRange(query);\n        const db = this._backend;\n        return new Promise((resolve, reject) => {\n            const openCursorRequest = db.transaction([this._tableName], 'readonly')\n                .objectStore(this._tableName)\n                .openCursor(query, 'prev');\n            openCursorRequest.onsuccess = event => {\n                try {\n                    const cursor = event.target.result;\n                    resolve(cursor ? this.decode(cursor.value, cursor.primaryKey) : undefined);\n                } catch (e) {\n                    reject(e);\n                }\n            };\n            openCursorRequest.onerror = () => reject(openCursorRequest.error);\n        });\n    }\n\n    /**\n     * Returns a promise of the key being maximal for the given range.\n     * If the optional query is not given, it returns the maximal key.\n     * If the query is of type KeyRange, it returns the key being maximal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<string>} A promise of the key relevant to the query.\n     */\n    async maxKey(query=null) {\n        query = IDBTools.convertKeyRange(query);\n        const db = this._backend;\n        return new Promise((resolve, reject) => {\n            const store = db.transaction([this._tableName], 'readonly').objectStore(this._tableName);\n            const openCursorRequest = store.openKeyCursor ? store.openKeyCursor(query, 'prev') : store.openCursor(query, 'prev');\n            openCursorRequest.onsuccess = () => resolve(openCursorRequest.result ? openCursorRequest.result.primaryKey : undefined);\n            openCursorRequest.onerror = () => reject(openCursorRequest.error);\n        });\n    }\n\n    /**\n     * Returns a promise of the object whose primary key is minimal for the given range.\n     * If the optional query is not given, it returns the object whose key is minimal.\n     * If the query is of type KeyRange, it returns the object whose primary key is minimal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<*>} A promise of the object relevant to the query.\n     */\n    async minValue(query=null) {\n        query = IDBTools.convertKeyRange(query);\n        const db = this._backend;\n        return new Promise((resolve, reject) => {\n            const openCursorRequest = db.transaction([this._tableName], 'readonly')\n                .objectStore(this._tableName)\n                .openCursor(query, 'next');\n            openCursorRequest.onsuccess = event => {\n                try {\n                    const cursor = event.target.result;\n                    resolve(cursor ? this.decode(cursor.value, cursor.primaryKey) : undefined);\n                } catch (e) {\n                    reject(e);\n                }\n            };\n            openCursorRequest.onerror = () => reject(openCursorRequest.error);\n        });\n    }\n\n    /**\n     * Returns a promise of the key being minimal for the given range.\n     * If the optional query is not given, it returns the minimal key.\n     * If the query is of type KeyRange, it returns the key being minimal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<string>} A promise of the key relevant to the query.\n     */\n    async minKey(query=null) {\n        query = IDBTools.convertKeyRange(query);\n        const db = this._backend;\n        return new Promise((resolve, reject) => {\n            const store = db.transaction([this._tableName], 'readonly').objectStore(this._tableName);\n            const openCursorRequest = store.openKeyCursor ? store.openKeyCursor(query, 'next') : store.openCursor(query, 'next');\n            openCursorRequest.onsuccess = () => resolve(openCursorRequest.result ? openCursorRequest.result.primaryKey : undefined);\n            openCursorRequest.onerror = () => reject(openCursorRequest.error);\n        });\n    }\n\n    /**\n     * Returns the count of entries in the given range.\n     * If the optional query is not given, it returns the count of entries in the object store.\n     * If the query is of type KeyRange, it returns the count of entries within the given range.\n     * @param {KeyRange} [query]\n     * @returns {Promise.<number>}\n     */\n    async count(query=null) {\n        query = IDBTools.convertKeyRange(query);\n        const db = this._backend;\n        return new Promise((resolve, reject) => {\n            let request;\n            // Edge compatibility\n            if (query) {\n                request = db.transaction([this._tableName], 'readonly')\n                    .objectStore(this._tableName)\n                    .count(query);\n            } else {\n                request = db.transaction([this._tableName], 'readonly')\n                    .objectStore(this._tableName)\n                    .count();\n            }\n            request.onsuccess = () => resolve(request.result);\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    /**\n     * Returns the index of the given name.\n     * If the index does not exist, it returns undefined.\n     * @param {string} indexName The name of the requested index.\n     * @returns {IIndex} The index associated with the given name.\n     */\n    index(indexName) {\n        return this._indices.get(indexName);\n    }\n\n    /** @type {Promise.<IDBDatabase>} The underlying IDBDatabase. */\n    get backend() {\n        return this._db.backend;\n    }\n\n    /** @type {string} The own table name. */\n    get tableName() {\n        return this._tableName;\n    }\n\n    /**\n     * Internally applies a transaction to the store's state.\n     * This needs to be done in batch (as a db level transaction), i.e., either the full state is updated\n     * or no changes are applied.\n     * @param {Transaction} tx The transaction to apply.\n     * @returns {Promise} The promise resolves after applying the transaction.\n     * @protected\n     */\n    async _apply(tx) {\n        const db = this._backend;\n        return new Promise((resolve, reject) => {\n            const idbTx = db.transaction([this._tableName], 'readwrite');\n            const objSt = idbTx.objectStore(this._tableName);\n\n            if (tx._truncated) {\n                objSt.clear();\n            }\n            for (const key of tx._removed) {\n                objSt.delete(key);\n            }\n            for (const [key, value] of tx._modified) {\n                objSt.put(this.encode(value), key);\n            }\n\n            idbTx.oncomplete = () => resolve(true);\n            idbTx.onerror = reject;\n            idbTx.onabort = reject;\n        });\n    }\n\n    /**\n     * Empties the object store.\n     * @returns {Promise} The promise resolves after emptying the object store.\n     */\n    async truncate() {\n        const db = this._backend;\n        return new Promise((resolve, reject) => {\n            const getRequest = db.transaction([this._tableName], 'readonly')\n                .objectStore(this._tableName)\n                .clear();\n            getRequest.onsuccess = resolve;\n            getRequest.onerror = () => reject(getRequest.error);\n        });\n    }\n\n    /**\n     * Creates a new secondary index on the object store.\n     * Currently, all secondary indices are non-unique.\n     * They are defined by a key within the object or alternatively a path through the object to a specific subkey.\n     * For example, ['a', 'b'] could be used to use 'key' as the key in the following object:\n     * { 'a': { 'b': 'key' } }\n     * Secondary indices may be multiEntry, i.e., if the keyPath resolves to an iterable object, each item within can\n     * be used to find this entry.\n     * If a new object does not possess the key path associated with that index, it is simply ignored.\n     *\n     * This function may only be called before the database is connected.\n     * Moreover, it is only executed on database version updates or on first creation.\n     * @param {string} indexName The name of the index.\n     * @param {string|Array.<string>} [keyPath] The path to the key within the object. May be an array for multiple levels.\n     * @param {IndexConfig} [options] An options object.\n     */\n    createIndex(indexName, keyPath, options = {}) {\n        let { multiEntry = false, upgradeCondition = null, unique = false } = options || {};\n\n        if (this._db.connected) throw new Error('Cannot create index while connected');\n        keyPath = keyPath || indexName;\n        const index = new PersistentIndex(this, indexName, keyPath, multiEntry, unique);\n        this._indices.set(indexName, index);\n        this._indicesToCreate.set(indexName, { index, upgradeCondition });\n    }\n\n    /**\n     * Deletes a secondary index from the object store.\n     * @param indexName\n     * @param {{upgradeCondition:?boolean|?function(oldVersion:number, newVersion:number):boolean}} [options]\n     */\n    deleteIndex(indexName, options={}) {\n        let { upgradeCondition = null } = options || {};\n\n        if (this._db.connected) throw new Error('Cannot delete index while connected');\n        this._indicesToDelete.push({ indexName, upgradeCondition });\n    }\n\n    /**\n     * Closes the object store and potential connections.\n     * @returns {Promise} The promise resolves after closing the object store.\n     */\n    close() {\n        // Nothing to do here, it is all done on the DB level.\n        return this._db.close();\n    }\n\n    /**\n     * Returns the necessary information in order to flush a combined transaction.\n     * @param {Transaction} tx The transaction that should be applied to this backend.\n     * @returns {Promise.<EncodedTransaction>} A special transaction object bundling all necessary information.\n     */\n    async applyCombined(tx) {\n        const encodedTx = new EncodedTransaction(this._tableName);\n\n        if (tx._truncated) {\n            encodedTx.truncate();\n        }\n\n        for (const key of tx._removed) {\n            encodedTx.remove(key);\n        }\n        for (const [key, value] of tx._modified) {\n            encodedTx.put(key, this.encode(value));\n        }\n        return encodedTx;\n    }\n\n    /**\n     * Checks whether an object store implements the ISynchronousObjectStore interface.\n     * @returns {boolean} The transaction object.\n     */\n    isSynchronous() {\n        return false;\n    }\n}\nClass.register(IDBBackend);\n","/**\n * @implements {IJungleDB}\n */\nclass JungleDB {\n    /**\n     * Initiates a new database connection. All changes to the database structure\n     * require an increase in the version number.\n     * Whenever new object stores need to be created, old ones deleted,\n     * or indices created/deleted, the dbVersion number has to be increased.\n     * When the version number increases, the given function onUpgradeNeeded is called\n     * after modifying the database structure.\n     * @param {string} name The name of the database.\n     * @param {number} dbVersion The current version of the database.\n     * @param {{onUpgradeNeeded:?function(oldVersion:number, newVersion:number)}} [options]\n     */\n    constructor(name, dbVersion, options = {}) {\n        if (dbVersion <= 0) throw new Error('The version provided must not be less or equal to 0');\n        this._databaseDir = name;\n        this._dbVersion = dbVersion;\n        this._onUpgradeNeeded = options.onUpgradeNeeded;\n        this._connected = false;\n        this._objectStores = new Map();\n        this._objectStoreBackends = new Map();\n        this._objectStoresToDelete = [];\n    }\n\n    /**\n     * @type {IDBFactory} The browser's IDB factory.\n     * @private\n     */\n    get _indexedDB() {\n        return window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.OIndexedDB || window.msIndexedDB;\n    }\n\n    /**\n     * Connects to the indexedDB.\n     * @returns {Promise.<IDBDatabase>} A promise resolving on successful connection.\n     * The raw IDBDatabase object should not be used.\n     */\n    connect() {\n        if (this._db) return Promise.resolve(this._db);\n\n        const request = this._indexedDB.open(this._databaseDir, this._dbVersion);\n        const that = this;\n\n        return new Promise((resolve, reject) => {\n            request.onsuccess = () => {\n                that._connected = true;\n                that._db = request.result;\n                resolve(request.result);\n            };\n\n            request.onerror = reject;\n            request.onupgradeneeded = event => that._initDB(event, request);\n        });\n    }\n\n    /**\n     * Internal method that is called when a db upgrade is required.\n     * @param {IDBVersionChangeEvent} event The obupgradeneeded event.\n     * @param {IDBRequest} request\n     * @returns {Promise.<void>} A promise that resolves after successful completion.\n     * @private\n     */\n    async _initDB(event, request) {\n        const db = event.target.result;\n\n        // Delete existing ObjectStores.\n        for (const { tableName, upgradeCondition } of this._objectStoresToDelete) {\n            if (db.objectStoreNames.contains(tableName) && (upgradeCondition === null || upgradeCondition === true || (typeof upgradeCondition === 'function' && upgradeCondition(event.oldVersion, event.newVersion)))) {\n                db.deleteObjectStore(tableName);\n            }\n        }\n        this._objectStoresToDelete = [];\n\n        // Create new ObjectStores.\n        for (const [tableName, { backend, upgradeCondition }] of this._objectStoreBackends) {\n            let IDBobjStore;\n            // Only check upgradeCondition if object store does not already exist!\n            if (!db.objectStoreNames.contains(tableName)\n                && (upgradeCondition === null || upgradeCondition === true\n                    || (typeof upgradeCondition === 'function' && upgradeCondition(event.oldVersion, event.newVersion)))) {\n                IDBobjStore = db.createObjectStore(tableName);\n            } else {\n                IDBobjStore = request.transaction.objectStore(tableName);\n            }\n            // Create indices.\n            backend.init(IDBobjStore, event.oldVersion, event.newVersion);\n        }\n        this._objectStoreBackends.clear();\n\n        // Call user defined function if requested.\n        if (this._onUpgradeNeeded) {\n            await this._onUpgradeNeeded(event.oldVersion, event.newVersion);\n        }\n    }\n\n    /** @type {IDBDatabase} The underlying IDBDatabase. */\n    get backend() {\n        return this._db;\n    }\n\n    /** @type {boolean} Whether a connection is established. */\n    get connected() {\n        return this._connected;\n    }\n\n    /**\n     * Returns the ObjectStore object for a given table name.\n     * @param {string} tableName The table name to access.\n     * @returns {ObjectStore} The ObjectStore object.\n     */\n    getObjectStore(tableName) {\n        return this._objectStores.get(tableName);\n    }\n\n    /**\n     * Creates a volatile object store (non-persistent).\n     * @param {{codec:?ICodec}} [options] An options object.\n     * @returns {ObjectStore}\n     */\n    static createVolatileObjectStore(options = {}) {\n        const { codec = null } = options || {};\n        return new ObjectStore(new InMemoryBackend('', codec), null);\n    }\n\n    /**\n     * Creates a new object store (and allows to access it).\n     * This method always has to be called before connecting to the database.\n     * If it is not called, the object store will not be accessible afterwards.\n     * If a call is newly introduced, but the database version did not change,\n     * the table does not exist yet.\n     * @param {string} tableName The name of the object store.\n     * @param {ObjectStoreConfig} [options] An options object.\n     * @returns {IObjectStore}\n     */\n    createObjectStore(tableName, options = {}) {\n        const { codec = null, persistent = true, upgradeCondition = null, enableLruCache = true, lruCacheSize = CachedBackend.MAX_CACHE_SIZE, rawLruCacheSize = 0 } = options || {};\n\n        if (this._connected) throw new Error('Cannot create ObjectStore while connected');\n        if (this._objectStores.has(tableName)) {\n            return this._objectStores.get(tableName);\n        }\n\n        // Create backend\n        let backend = null;\n        if (persistent) {\n            backend = new IDBBackend(this, tableName, codec);\n        } else {\n            backend = new InMemoryBackend(tableName, codec);\n        }\n        // Create cache if enabled\n        let cachedBackend = backend;\n        if (persistent && enableLruCache) {\n            cachedBackend = new CachedBackend(backend, lruCacheSize, rawLruCacheSize);\n        }\n\n        const objStore = new ObjectStore(cachedBackend, this, tableName);\n        this._objectStores.set(tableName, objStore);\n        this._objectStoreBackends.set(tableName, { backend, upgradeCondition });\n        return objStore;\n    }\n\n    /**\n     * Deletes an object store.\n     * This method has to be called before connecting to the database.\n     * @param {string} tableName\n     * @param {{upgradeCondition:?boolean|?function(oldVersion:number, newVersion:number):boolean}, indexNames:Array.<string>} [options]\n     */\n    deleteObjectStore(tableName, options = {}) {\n        let { upgradeCondition = null } = options || {};\n\n        if (this._connected) throw new Error('Cannot delete ObjectStore while connected');\n        this._objectStoresToDelete.push({ tableName, upgradeCondition });\n    }\n\n    /**\n     * Closes the database connection.\n     * @returns {Promise} The promise resolves after closing the database.\n     */\n    async close() {\n        if (this._connected) {\n            this._connected = false;\n            this.backend.close();\n        }\n    }\n\n    /**\n     * Fully deletes the database.\n     * @returns {Promise} The promise resolves after deleting the database.\n     */\n    async destroy() {\n        await this.close();\n        return new Promise((resolve, reject) => {\n            const req = this._indexedDB.deleteDatabase(this._databaseDir);\n            req.onsuccess = resolve;\n            req.onerror = reject;\n        });\n    }\n\n    /**\n     * Is used to commit multiple transactions atomically.\n     * This guarantees that either all transactions are written or none.\n     * The method takes a list of transactions (at least two transactions).\n     * If the commit was successful, the method returns true, and false otherwise.\n     * @param {Transaction|CombinedTransaction} tx1 The first transaction\n     * (a CombinedTransaction object is only used internally).\n     * @param {Transaction} tx2 The second transaction.\n     * @param {...Transaction} txs A list of further transactions to commit together.\n     * @returns {Promise.<boolean>} A promise of the success outcome.\n     */\n    static async commitCombined(tx1, tx2, ...txs) {\n        // If tx1 is a CombinedTransaction, flush it to the database.\n        if (tx1 instanceof CombinedTransaction) {\n            const functions = [];\n            /** @type {Array.<EncodedTransaction>} */\n            const encodedTxs = [];\n            const tableNames = [];\n\n            const infos = await Promise.all(tx1.transactions.map(tx => tx.objectStore._backend.applyCombined(tx)));\n            for (const info of infos) {\n                let tmp = info;\n                if (!Array.isArray(info)) {\n                    tmp = [info];\n                }\n                for (const innerInfo of tmp) {\n                    if (typeof innerInfo === 'function') {\n                        functions.push(innerInfo);\n                    } else {\n                        encodedTxs.push(innerInfo);\n                        tableNames.push(innerInfo.tableName);\n                    }\n                }\n            }\n\n            const db = tx1.backend !== null ? tx1.backend.backend : null;\n            return new Promise((resolve, reject) => {\n                if (tableNames.length > 0) {\n                    const idbTx = db.transaction(tableNames, 'readwrite');\n\n                    for (const encodedTx of encodedTxs) {\n                        const objSt = idbTx.objectStore(encodedTx.tableName);\n\n                        if (encodedTx.truncated) {\n                            objSt.clear();\n                        }\n                        for (const key of encodedTx.removed) {\n                            objSt.delete(key);\n                        }\n                        for (const [key, value] of encodedTx.modified) {\n                            objSt.put(value, key);\n                        }\n                    }\n\n                    idbTx.oncomplete = () => {\n                        Promise.all(functions.map(f => f())).then(() => {\n                            resolve(true);\n                        });\n                    };\n                    idbTx.onerror = reject;\n                    idbTx.onabort = reject;\n                } else {\n                    Promise.all(functions.map(f => f())).then(() => {\n                        resolve(true);\n                    });\n                }\n            });\n        }\n        txs.push(tx1);\n        txs.push(tx2);\n        if (!txs.every(tx => tx instanceof Transaction)) {\n            throw new Error('Invalid arguments supplied');\n        }\n        const ctx = new CombinedTransaction(...txs);\n        return ctx.commit();\n    }\n\n    toString() {\n        return `JungleDB{name=${this._databaseDir}}`;\n    }\n}\n/**\n * Empty encodings.\n */\nJungleDB.JSON_ENCODING = {};\nJungleDB.BINARY_ENCODING = {};\nJungleDB.STRING_ENCODING = {};\nJungleDB.NUMBER_ENCODING = {};\nJungleDB.GENERIC_ENCODING = {};\nClass.register(JungleDB);\n","/**\n * This class represents a wrapper around the IndexedDB indices.\n * @implements {IIndex}\n */\nclass PersistentIndex {\n    /**\n     * @param {IDBBackend} objectStore\n     * @param {string} indexName\n     * @param {string|Array.<string>} keyPath\n     * @param {boolean} [multiEntry]\n     * @param {boolean} [unique]\n     */\n    constructor(objectStore, indexName, keyPath, multiEntry = false, unique = false) {\n        this._objectStore = objectStore;\n        this._indexName = indexName;\n        this._keyPath = keyPath;\n        this._multiEntry = multiEntry;\n        this._unique = unique;\n    }\n\n    /**\n     * Reinitialises the index.\n     * @returns {Promise} The promise resolves after emptying the index.\n     */\n    async truncate() {\n        // Will automatically be truncated.\n    }\n\n    /**\n     * The key path associated with this index.\n     * A key path is defined by a key within the object or alternatively a path through the object to a specific subkey.\n     * For example, ['a', 'b'] could be used to use 'key' as the key in the following object:\n     * { 'a': { 'b': 'key' } }\n     * @type {string|Array.<string>}\n     */\n    get keyPath() {\n        return this._keyPath;\n    }\n\n    /**\n     * This value determines whether the index supports multiple secondary keys per entry.\n     * If so, the value at the key path is considered to be an iterable.\n     * @type {boolean}\n     */\n    get multiEntry() {\n        return this._multiEntry;\n    }\n\n    /**\n     * This value determines whether the index is a unique constraint.\n     * @type {boolean}\n     */\n    get unique() {\n        return this._unique;\n    }\n\n    /**\n     * Internal method to access IDB index.\n     * @param {IDBDatabase} db The indexed DB.\n     * @returns {IDBIndex} The indexedDB's index object.\n     * @private\n     */\n    _index(db) {\n        return db.transaction([this._objectStore.tableName], 'readonly')\n            .objectStore(this._objectStore.tableName)\n            .index(this._indexName);\n    }\n\n    /**\n     * Returns a promise of an array of objects whose secondary keys fulfill the given query.\n     * If the optional query is not given, it returns all objects in the index.\n     * If the query is of type KeyRange, it returns all objects whose secondary keys are within this range.\n     * @param {KeyRange} [query] Optional query to check secondary keys against.\n     * @param {number} [limit] Limits the number of results if given.\n     * @returns {Promise.<Array.<*>>} A promise of the array of objects relevant to the query.\n     */\n    async values(query = null, limit = null) {\n        query = IDBTools.convertKeyRange(query);\n        const db = await this._objectStore.backend;\n        return new Promise((resolve, reject) => {\n            const results = [];\n            const request = this._index(db).openCursor(query);\n            request.onsuccess = event => {\n                const cursor = event.target.result;\n                if (cursor) {\n                    // Limit\n                    if (limit !== null && results.length >= limit) {\n                        resolve(results);\n                        return;\n                    }\n\n                    try {\n                        results.push(this._objectStore.decode(cursor.value, cursor.primaryKey));\n                    } catch (e) {\n                        reject(e);\n                    }\n                    cursor.continue();\n                } else {\n                    resolve(results);\n                }\n            };\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    /**\n     * Returns a promise of a set of primary keys, whose associated objects' secondary keys are in the given range.\n     * If the optional query is not given, it returns all primary keys in the index.\n     * If the query is of type KeyRange, it returns all primary keys for which the secondary key is within this range.\n     * @param {KeyRange} [query] Optional query to check the secondary keys against.\n     * @param {number} [limit] Limits the number of results if given.\n     * @returns {Promise.<Set.<string>>} A promise of the set of primary keys relevant to the query.\n     */\n    async keys(query = null, limit = null) {\n        query = IDBTools.convertKeyRange(query);\n        const db = await this._objectStore.backend;\n        return new Promise((resolve, reject) => {\n            const results = new Set();\n            const index = this._index(db);\n            const openCursorRequest = index.openKeyCursor ? index.openKeyCursor(query) : index.openCursor(query);\n            openCursorRequest.onsuccess = event => {\n                const cursor = event.target.result;\n                if (cursor) {\n                    // Limit\n                    if (limit !== null && results.size >= limit) {\n                        resolve(results);\n                        return;\n                    }\n\n                    results.add(cursor.primaryKey);\n                    cursor.continue();\n                } else {\n                    resolve(results);\n                }\n            };\n            openCursorRequest.onerror = () => reject(openCursorRequest.error);\n        });\n    }\n\n    /**\n     * Returns a promise of an array of objects whose secondary key is maximal for the given range.\n     * If the optional query is not given, it returns the objects whose secondary key is maximal within the index.\n     * If the query is of type KeyRange, it returns the objects whose secondary key is maximal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<Array.<*>>} A promise of array of objects relevant to the query.\n     */\n    async maxValues(query=null) {\n        query = IDBTools.convertKeyRange(query);\n        const db = await this._objectStore.backend;\n        return new Promise((resolve, reject) => {\n            const results = [];\n            let maxKey = null;\n            const request = this._index(db).openCursor(query, 'prev');\n            request.onsuccess = event => {\n                const cursor = event.target.result;\n                if (cursor && maxKey === null) {\n                    maxKey = cursor.key;\n                }\n                // Only iterate until key changes.\n                if (cursor && ComparisonUtils.equals(maxKey, cursor.key)) {\n                    try {\n                        results.push(this._objectStore.decode(cursor.value, cursor.primaryKey));\n                    } catch (e) {\n                        reject(e);\n                    }\n                    cursor.continue();\n                } else {\n                    resolve(results);\n                }\n            };\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    /**\n     * Returns a promise of a set of primary keys, whose associated secondary keys are maximal for the given range.\n     * If the optional query is not given, it returns the set of primary keys, whose associated secondary key is maximal within the index.\n     * If the query is of type KeyRange, it returns the set of primary keys, whose associated secondary key is maximal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<Set.<*>>} A promise of the key relevant to the query.\n     */\n    async maxKeys(query=null) {\n        query = IDBTools.convertKeyRange(query);\n        const db = await this._objectStore.backend;\n        return new Promise((resolve, reject) => {\n            const results = new Set();\n            let maxKey = null;\n            const index = this._index(db);\n            const request = index.openKeyCursor ? index.openKeyCursor(query, 'prev') : index.openCursor(query, 'prev');\n            request.onsuccess = event => {\n                const cursor = event.target.result;\n                if (cursor && maxKey === null) {\n                    maxKey = cursor.key;\n                }\n                // Only iterate until key changes.\n                if (cursor && ComparisonUtils.equals(maxKey, cursor.key)) {\n                    results.add(cursor.primaryKey);\n                    cursor.continue();\n                } else {\n                    resolve(results);\n                }\n            };\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    /**\n     * Returns a promise of an array of objects whose secondary key is minimal for the given range.\n     * If the optional query is not given, it returns the objects whose secondary key is minimal within the index.\n     * If the query is of type KeyRange, it returns the objects whose secondary key is minimal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<Array.<*>>} A promise of array of objects relevant to the query.\n     */\n    async minValues(query=null) {\n        query = IDBTools.convertKeyRange(query);\n        const db = await this._objectStore.backend;\n        return new Promise((resolve, reject) => {\n            const results = [];\n            let minKey = null;\n            const request = this._index(db).openCursor(query, 'next');\n            request.onsuccess = event => {\n                const cursor = event.target.result;\n                if (cursor && minKey === null) {\n                    minKey = cursor.key;\n                }\n                // Only iterate until key changes.\n                if (cursor && ComparisonUtils.equals(minKey, cursor.key)) {\n                    try {\n                        results.push(this._objectStore.decode(cursor.value, cursor.primaryKey));\n                    } catch (e) {\n                        reject(e);\n                    }\n                    cursor.continue();\n                } else {\n                    resolve(results);\n                }\n            };\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    /**\n     * Returns a promise of a set of primary keys, whose associated secondary keys are minimal for the given range.\n     * If the optional query is not given, it returns the set of primary keys, whose associated secondary key is minimal within the index.\n     * If the query is of type KeyRange, it returns the set of primary keys, whose associated secondary key is minimal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<Set.<*>>} A promise of the key relevant to the query.\n     */\n    async minKeys(query=null) {\n        query = IDBTools.convertKeyRange(query);\n        const db = await this._objectStore.backend;\n        return new Promise((resolve, reject) => {\n            const results = new Set();\n            let minKey = null;\n            const index = this._index(db);\n            const request = index.openKeyCursor ? index.openKeyCursor(query, 'next') : index.openCursor(query, 'next');\n            request.onsuccess = event => {\n                const cursor = event.target.result;\n                if (cursor && minKey === null) {\n                    minKey = cursor.key;\n                }\n                // Only iterate until key changes.\n                if (cursor && ComparisonUtils.equals(minKey, cursor.key)) {\n                    results.add(cursor.primaryKey);\n                    cursor.continue();\n                } else {\n                    resolve(results);\n                }\n            };\n            request.onerror = () => reject(request.error);\n        });\n    }\n\n    /**\n     * Iterates over the primary keys in a given range of secondary keys and direction.\n     * The order is determined by the secondary keys first and by the primary keys second.\n     * The callback is called for each primary key fulfilling the query\n     * until it returns false and stops the iteration.\n     * @param {function(key:string):boolean} callback A predicate called for each key until returning false.\n     * @param {boolean} ascending Determines the direction of traversal.\n     * @param {KeyRange} query An optional KeyRange to narrow down the iteration space.\n     * @returns {Promise} The promise resolves after all elements have been streamed.\n     */\n    async keyStream(callback, ascending=true, query=null) {\n        query = IDBTools.convertKeyRange(query);\n        const db = await this._objectStore.backend;\n        return new Promise((resolve, reject) => {\n            const index = this._index(db);\n            const openCursorRequest = index.openKeyCursor\n                ? index.openKeyCursor(query, ascending ? 'next' : 'prev')\n                : index.openCursor(query, ascending ? 'next' : 'prev');\n            openCursorRequest.onsuccess = event => {\n                const cursor = event.target.result;\n                if (cursor) {\n                    try {\n                        if (callback(cursor.primaryKey)) {\n                            cursor.continue();\n                        } else {\n                            resolve();\n                        }\n                    } catch (e) {\n                        reject(e);\n                    }\n                } else {\n                    resolve();\n                }\n            };\n            openCursorRequest.onerror = () => reject(openCursorRequest.error);\n        });\n    }\n\n    /**\n     * Iterates over the values of the store in a given range of secondary keys and direction.\n     * The order is determined by the secondary keys first and by the primary keys second.\n     * The callback is called for each value and primary key fulfilling the query\n     * until it returns false and stops the iteration.\n     * @param {function(value:*, key:string):boolean} callback A predicate called for each value and key until returning false.\n     * @param {boolean} ascending Determines the direction of traversal.\n     * @param {KeyRange} query An optional KeyRange to narrow down the iteration space.\n     * @returns {Promise} The promise resolved after all elements have been streamed.\n     */\n    async valueStream(callback, ascending=true, query=null) {\n        query = IDBTools.convertKeyRange(query);\n        const db = await this._objectStore.backend;\n        return new Promise((resolve, reject) => {\n            const openCursorRequest = this._index(db).openCursor(query, ascending ? 'next' : 'prev');\n            openCursorRequest.onsuccess = event => {\n                const cursor = event.target.result;\n                if (cursor) {\n                    try {\n                        if (callback(this._objectStore.decode(cursor.value, cursor.primaryKey), cursor.primaryKey)) {\n                            cursor.continue();\n                        } else {\n                            resolve();\n                        }\n                    } catch (e) {\n                        reject(e);\n                    }\n                } else {\n                    resolve();\n                }\n            };\n            openCursorRequest.onerror = () => reject(openCursorRequest.error);\n        });\n    }\n\n    /**\n     * Returns the count of entries, whose secondary key is in the given range.\n     * If the optional query is not given, it returns the count of entries in the index.\n     * If the query is of type KeyRange, it returns the count of entries, whose secondary key is within the given range.\n     * @param {KeyRange} [query]\n     * @returns {Promise.<number>}\n     */\n    async count(query=null) {\n        query = IDBTools.convertKeyRange(query);\n        const db = await this._objectStore.backend;\n        return new Promise((resolve, reject) => {\n            let request;\n            // Edge compatibility\n            if (query) {\n                request = this._index(db).count(query);\n            } else {\n                request = this._index(db).count();\n            }\n            request.onsuccess = () => resolve(request.result);\n            request.onerror = () => reject(request.error);\n        });\n    }\n}\nClass.register(PersistentIndex);\n\n","/**\n * Returns an iterator over an array in a specific direction.\n * It does *not* handle or reflect changes of the array while iterating it.\n * @memberOf Array\n * @param {boolean} ascending Whether to traverse the array in ascending direction.\n * @returns {{next:function():*, peek:function():*, hasNext:function():boolean}} An iterator.\n */\nArray.prototype.iterator = function(ascending=true) {\n    let nextIndex = ascending ? 0 : this.length-1;\n\n    return {\n        next: () => {\n            return nextIndex >= 0 && nextIndex < this.length ?\n                this[ascending ? nextIndex++ : nextIndex--] : undefined;\n        },\n        hasNext: () => {\n            return nextIndex >= 0 && nextIndex < this.length;\n        },\n        peek: () => {\n            return nextIndex >= 0 && nextIndex < this.length ?\n                this[nextIndex] : undefined;\n        }\n    };\n};\n","/*\n B+ Tree processing\n Version 2.0.0\n Based on code by Graham O'Neill, April 2013\n Modified by Pascal Berrang, July 2017\n\n ------------------------------------------------------------------------------\n\n Copyright (c) 2017 Graham O'Neill & Pascal Berrang\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n\n ------------------------------------------------------------------------------\n\n */\n\n/**\n * This abstract class describes a general Node within a B+Tree.\n * Each node owns an array of keys and has an id.\n */\nclass Node {\n    /**\n     * Creates a new node.\n     * @param {Array.<*>} [keys] Optional array of keys (default is empty).\n     */\n    constructor(keys = []) {\n        this._keys = keys;\n    }\n\n    /**\n     * @type {Array.<*>} The array of keys.\n     */\n    get keys() {\n        return this._keys;\n    }\n}\nClass.register(Node);\n\n/**\n * A Leaf Node in the B+Tree.\n * @extends Node\n */\nclass LeafNode extends Node {\n    /**\n     * Creates a new leaf node.\n     * Leaf nodes store key value pairs,\n     * hence the keys and records arrays are required to have the same length.\n     * In an index, the keys array usually stores the secondary key,\n     * while the records array stores the corresponding primary key.\n     * The B+Tree ensures that the items in the keys array are ordered ascending.\n     * @param {Array.<*>} [keys] Optional array of keys (default is empty).\n     * @param {Array.<*>} [records] Optional array of records (default is empty).\n     */\n    constructor(keys=[], records=[]) {\n        if (keys.length !== records.length) {\n            throw new Error('Keys and records must have the same length');\n        }\n        super(keys);\n        this._records = records;\n        this.prevLeaf = null;\n        this.nextLeaf = null;\n    }\n\n    /**\n     * @type {Array.<*>} The list of records associated with the keys.\n     */\n    get records() {\n        return this._records;\n    }\n\n    /**\n     * Returns whether this is a leaf node.\n     * @returns {boolean} True, since it is a leaf node.\n     */\n    isLeaf() {\n        return true;\n    }\n\n    /**\n     * Searches the node for a specific key and returns its position if found.\n     * The near parameter allows to find either an exact match or the first key\n     * greater/less or equal than the specified key.\n     *\n     * Since the B+tree limits the number of records per leaf node,\n     * the complexity of this method is in O([order/2, order-1]).\n     * @param {*} key The key to look for.\n     * @param {BTree.NEAR_MODE} near\n     * @returns {number} The index of the match if found, -1 otherwise.\n     */\n    getItem(key, near) {\n        const keys = this._keys;\n        // Find item matching the query.\n        if (near === BTree.NEAR_MODE.GE) {\n            for (let i=0, len=keys.length; i<len; ++i) {\n                if (ComparisonUtils.compare(key, keys[i]) <= 0) return i;\n            }\n        } else if (near === BTree.NEAR_MODE.LE) {\n            for (let i=keys.length - 1; i>=0; --i) {\n                if (ComparisonUtils.compare(key, keys[i]) >= 0) return i;\n            }\n        } else {\n            for (let i=0, len=keys.length; i<len; ++i) {\n                if (ComparisonUtils.equals(key, keys[i])) return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Adds a key, record pair to this leaf node.\n     * By definition, the key is inserted into the keys of this leaf node,\n     * such that the ascending order of the keys is maintained.\n     * @param {*} key The key to insert.\n     * @param {*} record The corresponding record to insert.\n     * @returns {number} The position it was inserted at.\n     */\n    addKey(key, record) {\n        let insertPos = this._keys.length;\n        // Find position to insert.\n        for (let i=0, len=insertPos; i<len; ++i) {\n            // Key already exists.\n            if (ComparisonUtils.equals(key, this._keys[i])) {\n                return -1;\n            }\n            // Update potential position.\n            if (ComparisonUtils.compare(key, this._keys[i]) <= 0) {\n                insertPos = i;\n                break;\n            }\n        }\n        // Insert key/record.\n        this._keys.splice(insertPos, 0, key);\n        this._records.splice(insertPos, 0, record);\n        return insertPos;\n    }\n\n    /**\n     * Splits the leaf node into two nodes (this + one new node).\n     * The resulting nodes should have almost equal sizes.\n     * The new node will return the upper half of the previous entries.\n     * @returns {LeafNode} The new leaf node containing the upper half of entries.\n     */\n    split() {\n        const mov = Math.floor(this._keys.length/2);\n        const newKeys = [], newRecords = [];\n        for (let i = 0; i < mov; ++i) {\n            newKeys.unshift(this._keys.pop());\n            newRecords.unshift(this._records.pop());\n        }\n        const newL = new LeafNode(newKeys, newRecords);\n        newL.prevLeaf = this;\n        newL.nextLeaf = this.nextLeaf;\n        if (this.nextLeaf !== null) this.nextLeaf.prevLeaf = newL;\n        this.nextLeaf = newL;\n        return newL;\n    }\n\n    /**\n     * Merges two leaf nodes together (this + frNod).\n     * The given node frNod is no longer connected afterwards.\n     * @param {LeafNode} frNod The node to merge with.\n     * @param {InnerNode} paNod The parent node that needs to be updated.\n     * @param {*} frKey The key of the old leaf in the parent.\n     */\n    merge(frNod, paNod, frKey) {\n        // Append keys/records.\n        for (let i=0, len=frNod.keys.length; i<len; ++i) {\n            this._keys.push(frNod.keys[i]);\n            this._records.push(frNod.records[i]);\n        }\n        // Update leaf pointers.\n        this.nextLeaf = frNod.nextLeaf;\n        if (frNod.nextLeaf !== null) frNod.nextLeaf.prevLeaf = this;\n        frNod.prevLeaf = null;\n        frNod.nextLeaf = null;\n        // Update parent: find position of old leaf.\n        let pos = paNod.keys.length-1;\n        for (let i=pos; i>=0; --i) {\n            if (ComparisonUtils.equals(paNod.keys[i], frKey)) {\n                pos = i;\n                break;\n            }\n        }\n        // Delete old key from parent.\n        paNod.keys.splice(pos, 1);\n        paNod.nodePointers.splice(pos+1, 1);\n    }\n\n}\nClass.register(LeafNode);\n\n/**\n * An Inner Node in the B+Tree.\n * @extends Node\n */\nclass InnerNode extends Node {\n    /**\n     * Creates a new inner node.\n     * The only key values that appear in the internal nodes are the first key values from each leaf,\n     * with the exception of the key from the very first leaf which isn't included.\n     * Each key value that appears in the internal nodes only appears once.\n     * @param {Array.<*>} [keys] The first key of each child node (except for the first one).\n     * @param {Array.<Node>} [nodePointers] The pointers to the child nodes.\n     */\n    constructor(keys=[], nodePointers=[]) {\n        super(keys);\n        this._nodePointers = nodePointers;\n    }\n\n    /**\n     * Returns whether this is a leaf node.\n     * @returns {boolean} False, since it is an inner node.\n     */\n    isLeaf() {\n        return false;\n    }\n\n    /**\n     * @type {Array.<Node>} The pointers to the children.\n     */\n    get nodePointers() {\n        return this._nodePointers;\n    }\n\n    /**\n     * Searches the node for a specific key and returns the matching child's position.\n     *\n     * Since the B+tree limits the number of records per leaf node,\n     * the complexity of this method is in O([(order-1)/2, order-1]).\n     * @param {*} key The key to look for.\n     * @returns {number} The index of the match.\n     */\n    getItem(key) {\n        const len = this._keys.length;\n        for (let i=0; i<len; ++i) {\n            if (key < this._keys[i]) return i;\n        }\n        return this._keys.length;\n    }\n\n    /**\n     * Adds a key corresponding to a new child node to this inner node.\n     * By definition, the key is inserted into the keys of this leaf node,\n     * such that the ascending order of the keys is maintained.\n     * @param {*} key The key to insert.\n     * @param {Node} ptrL The pointer to the corresponding child node.\n     * @param {Node} ptrR The pointer to the node right of the child node.\n     * @returns {number} The position it was inserted at.\n     */\n    addKey(key, ptrL, ptrR) {\n        const len = this._keys.length;\n        let insertPos = len;\n        // Find position to insert.\n        for (let i=0; i<len; ++i) {\n            if (ComparisonUtils.compare(key, this._keys[i]) <= 0) {\n                insertPos = i;\n                break;\n            }\n        }\n        // Update keys and pointers.\n        this._keys.splice(insertPos, 0, key);\n        this._nodePointers.splice(insertPos, 0, ptrL);\n        this._nodePointers[insertPos+1] = ptrR;\n    }\n\n    /**\n     * Splits the node into two nodes (this + one new node).\n     * The resulting nodes should have almost equal sizes.\n     * The new node will return the upper half of the previous entries.\n     * @returns {InnerNode} The new inner node containing the upper half of entries.\n     */\n    split() {\n        const mov = Math.ceil(this._keys.length/2) - 1;\n        const newNodePointers = [this._nodePointers.pop()];\n        const newKeys = [];\n        for (let i=mov-1; i>=0; --i) {\n            newKeys.unshift(this._keys.pop());\n            newNodePointers.unshift(this._nodePointers.pop());\n        }\n        return new InnerNode(newKeys, newNodePointers);\n    }\n\n    /**\n     * Merges two inner nodes together (this + frNod).\n     * The given node frNod is no longer connected afterwards.\n     * @param {InnerNode} frNod The node to merge with.\n     * @param {InnerNode} paNod The parent node that needs to be updated.\n     * @param {number} paItm The position in the parent.\n     */\n    merge(frNod, paNod, paItm) {\n        const del = paNod.keys[paItm];\n        // Add key from parent.\n        this._keys.push(del);\n        // Add keys and nodePointers from merged node.\n        for (let i=0, len=frNod.keys.length; i<len; ++i) {\n            this._keys.push(frNod.keys[i]);\n            this._nodePointers.push(frNod.nodePointers[i]);\n        }\n        // Add last nodePointer as well.\n        this._nodePointers.push(frNod.nodePointers[frNod.nodePointers.length-1]);\n        paNod.keys.splice(paItm, 1); // Delete old key from parent.\n        paNod.nodePointers.splice(paItm+1, 1); // Delete old pointer from parent.\n        return del;\n    }\n}\nClass.register(InnerNode);\n\n/**\n * The actual BTree implementation.\n * @implements {IBTree}\n */\nclass BTree {\n    /**\n     * Creates a new BTree of a given order.\n     * The order specifies how many entries a single node can contain.\n     * A leaf node generally contains [order/2, order-1] entries,\n     * while an inner node contains [(order-1)/2, order-1] entries.\n     * @param {number} order The order of the tree.\n     */\n    constructor(order=7) {\n        this._root = new LeafNode();\n        this._maxkey = order-1;\n        this._minkyl = Math.floor(order/2);\n        this._minkyn = Math.floor(this._maxkey/2);\n        this._leaf = null;\n        this._item = -1;\n\n        this._key = null;\n        this._record = null;\n        this._length = 0;\n        this._eof = true;\n        this._found = false;\n    }\n\n    /**\n     * The total number of records.\n     * Note that if the record is a list/set of records, these are not counted.\n     * @type {number}\n     */\n    get length() {\n        return this._length;\n    }\n\n    /**\n     * The current key as returned by any operation.\n     * It is null if there is no matching record.\n     * @type {*}\n     */\n    get currentKey() {\n        return this._key;\n    }\n\n    /**\n     * The current record as returned by any operation.\n     * It is null if there is no matching record.\n     * @type {*}\n     */\n    get currentRecord() {\n        return this._record;\n    }\n\n    /**\n     * Inserts a new key-record pair into the BTree, if there is no entry for that key.\n     * The current record and current key are set to the new entry in case of success\n     * or the existing entry if present.\n     * @param {*} key The unique key for the record.\n     * @param {*} rec The record associated with the key.\n     * @returns {boolean} True if the record was inserted, false if there was already a record with that key.\n     */\n    insert(key, rec) {\n        const stack = [];\n        this._leaf = this._root;\n        while (!this._leaf.isLeaf()) {\n            stack.push(this._leaf);\n            this._item = this._leaf.getItem(key);\n            this._leaf = this._leaf.nodePointers[this._item];\n        }\n        this._item = this._leaf.addKey(key, rec);\n        this._key = key;\n        this._eof = false;\n        if (this._item === -1) {\n            this._found = true;\n            this._item = this._leaf.getItem(key, false);\n            this._record = this._leaf.records[this._item];\n        } else {\n            this._found = false;\n            this._record = rec;\n            this._length++;\n            if (this._leaf.keys.length > this._maxkey) {\n                let pL = this._leaf;\n                let pR = this._leaf.split();\n                let ky = pR.keys[0];\n                this._item = this._leaf.getItem(key, false);\n                if (this._item === -1) {\n                    this._leaf = this._leaf.nextLeaf;\n                    this._item = this._leaf.getItem(key, false);\n                }\n                while (true) { // eslint-disable-line no-constant-condition\n                    if (stack.length === 0) {\n                        const newN = new InnerNode();\n                        newN.keys[0] = ky;\n                        newN.nodePointers[0] = pL;\n                        newN.nodePointers[1] = pR;\n                        this._root = newN;\n                        break;\n                    }\n                    const nod = stack.pop();\n                    nod.addKey(ky, pL, pR);\n                    if (nod.keys.length <= this._maxkey) break;\n                    pL = nod;\n                    pR = nod.split();\n                    ky = nod.keys.pop();\n                }\n            }\n        }\n        return (!this._found);\n    }\n\n    /**\n     * Removes a key-record pair from the BTree.\n     * In case of successful deletion, the current record and key will be set to the next entry greater or equal.\n     * If no record was found, they will be reset to null.\n     * @param {*} key The unique key for the record.\n     * @returns {boolean} True if the record was deleted, false if there is no such record.\n     */\n    remove(key) {\n        if (typeof key === 'undefined') {\n            if (this._item === -1) {\n                this._eof = true;\n                this._found = false;\n                return false;\n            }\n            key = this._leaf.keys[this._item];\n        }\n        this._del(key);\n        if (!this._found) {\n            this._item = -1;\n            this._eof = true;\n            this._key = null;\n            this._record = null;\n        } else {\n            this.seek(key, BTree.NEAR_MODE.GE);\n            this._found = true;\n        }\n        return (this._found);\n    }\n\n    /**\n     * Searches the tree for a specific key and advances the current key/record pointers if found.\n     * By default only an exact key match is found, but the near parameter also allows to advance to the next entry\n     * greater/less or equal than the specified key.\n     * @param {*} key The key to look for.\n     * @param {BTree.NEAR_MODE} [near] Optional parameter, specifies to look for a key k' =// key.\n     * @returns {boolean} True if such a key was found, false otherwise.\n     */\n    seek(key, near=BTree.NEAR_MODE.NONE) {\n        this._leaf = this._root;\n        while (!this._leaf.isLeaf()) {\n            this._item = this._leaf.getItem(key);\n            this._leaf = this._leaf.nodePointers[this._item];\n        }\n        this._item = this._leaf.getItem(key, near);\n        if (near === BTree.NEAR_MODE.GE && this._item === -1 && this._leaf.nextLeaf !== null) {\n            this._leaf = this._leaf.nextLeaf;\n            this._item = 0;\n        }\n        if (near === BTree.NEAR_MODE.LE && this._item === -1 && this._leaf.prevLeaf !== null) {\n            this._leaf = this._leaf.prevLeaf;\n            this._item = this._leaf.records.length - 1;\n        }\n        if (this._item === -1) {\n            this._eof = true;\n            this._key = null;\n            this._found = false;\n            this._record = null;\n        } else {\n            this._eof = false;\n            this._found = (this._leaf.keys[this._item] === key);\n            this._key = this._leaf.keys[this._item];\n            this._record = this._leaf.records[this._item];\n        }\n        return (!this._eof);\n    }\n\n    /**\n     * Advances the current key/record pointers by a given number of steps.\n     * Default is advancing by 1, which means the next record (the new key will thus be the next larger key).\n     * -1 means the previous record (the new key will thus be the next smaller key).\n     * @param {number} [cnt] The number of records to advance (may be negative).\n     * @returns {boolean} True if there is a record to advance to, false otherwise.\n     */\n    skip(cnt = 1) {\n        if (typeof cnt !== 'number') cnt = 1;\n        if (this._item === -1 || this._leaf === null) this._eof = true;\n        if (cnt > 0) {\n            while (!this._eof && this._leaf.keys.length - this._item - 1 < cnt) {\n                cnt = cnt - this._leaf.keys.length + this._item;\n                this._leaf = this._leaf.nextLeaf;\n                if (this._leaf === null) {\n                    this._eof = true;\n                } else {\n                    this._item = 0;\n                }\n            }\n            if (!this._eof) this._item = this._item + cnt;\n        } else {\n            cnt = -cnt;\n            while (!this._eof && this._item < cnt) {\n                cnt = cnt - this._item - 1;\n                this._leaf = this._leaf.prevLeaf;\n                if (this._leaf === null) {\n                    this._eof = true;\n                } else {\n                    this._item = this._leaf.keys.length-1;\n                }\n            }\n            if (!this._eof) {\n                this._item = this._item - cnt;\n            }\n        }\n        if (this._eof) {\n            this._item = -1;\n            this._found = false;\n            this._key = null;\n            this._record = null;\n        } else {\n            this._found = true;\n            this._key = this._leaf.keys[this._item];\n            this._record = this._leaf.records[this._item];\n        }\n        return (this._found);\n    }\n\n    /**\n     * Jumps to the cnt entry starting from the smallest key (i.e., leftmost leaf, first entry) if cnt > 0.\n     * If cnt < 0, it jumps to the cnt entry starting from the largest key (i.e., rightmost leaf, last entry).\n     * @param {number} [cnt] The record to jump to (may be negative).\n     * @returns {boolean} True if there is a record to jump to, false otherwise.\n     */\n    goto(cnt) {\n        if (cnt < 0) {\n            this.goBottom();\n            if (!this._eof) this.skip(cnt+1);\n        } else {\n            this.goTop();\n            if (!this._eof) this.skip(cnt-1);\n        }\n        return (this._found);\n    }\n\n    /**\n     * Returns the index of the current entry (key/record) in a sorted list of all entries.\n     * For the B+ Tree, this is done by traversing the leafs from the leftmost leaf, first entry\n     * until the respective key is found.\n     * @returns {number} The entry position.\n     */\n    keynum() {\n        if (this._leaf === null || this._item === -1) return -1;\n        let cnt = this._item + 1;\n        let ptr = this._leaf;\n        while (ptr.prevLeaf !== null) {\n            ptr = ptr.prevLeaf;\n            cnt += ptr.keys.length;\n        }\n        return cnt;\n    }\n\n    /**\n     * Jumps to the smallest key's entry (i.e., leftmost leaf, first entry).\n     * False will only be returned if the tree is completely empty.\n     * @returns {boolean} True if there is such an entry, false otherwise.\n     */\n    goTop() {\n        this._leaf = this._root;\n        while (!this._leaf.isLeaf()) {\n            this._leaf = this._leaf.nodePointers[0];\n        }\n        if (this._leaf.keys.length === 0) {\n            this._item = -1;\n            this._eof = true;\n            this._found = false;\n            this._key = null;\n            this._record = null;\n        } else {\n            this._item = 0;\n            this._eof = false;\n            this._found = true;\n            this._key = this._leaf.keys[0];\n            this._record = this._leaf.records[0];\n        }\n        return (this._found);\n    }\n\n    /**\n     * Jumps to the largest key's entry (i.e., rightmost leaf, last entry).\n     * False will only be returned if the tree is completely empty.\n     * @returns {boolean} True if there is such an entry, false otherwise.\n     */\n    goBottom() {\n        this._leaf = this._root;\n        while (!this._leaf.isLeaf()) {\n            this._leaf = this._leaf.nodePointers[this._leaf.nodePointers.length-1];\n        }\n        if (this._leaf.keys.length === 0) {\n            this._item = -1;\n            this._eof = true;\n            this._found = false;\n            this._key = null;\n            this._record = null;\n        } else {\n            this._item = this._leaf.keys.length-1;\n            this._eof = false;\n            this._found = true;\n            this._key = this._leaf.keys[this._item];\n            this._record = this._leaf.records[this._item];\n        }\n        return (this._found);\n    }\n\n    /**\n     * Rebuilds/balances the whole tree.\n     * Inserting and deleting keys into a tree will result\n     * in some leaves and nodes having the minimum number of keys allowed.\n     * This routine will ensure that each leaf and node has as many keys as possible,\n     * resulting in a denser, flatter tree.\n     * False is only returned if the tree is completely empty.\n     * @returns {boolean} True if the tree is not completely empty.\n     */\n    pack() {\n        let len;\n        let i;\n        this.goTop(0);\n        if (this._leaf === this._root) return false;\n\n        // Pack leaves\n        let toN = new LeafNode();\n        let toI = 0;\n        let frN = this._leaf;\n        let frI = 0;\n        let parKey = [];\n        let parNod = [];\n        while (true) { // eslint-disable-line no-constant-condition\n            toN.keys[toI] = frN.keys[frI];\n            toN.records[toI] = frN.records[frI];\n            if (toI === 0) parNod.push(toN);\n            if (frI === frN.keys.length-1) {\n                if (frN.nextLeaf === null) break;\n                frN = frN.nextLeaf;\n                frI = 0;\n            } else {\n                frI++;\n            }\n            if (toI === this._maxkey-1) {\n                const tmp = new LeafNode();\n                toN.nextLeaf = tmp;\n                tmp.prevLeaf = toN;\n                toN = tmp;\n                toI = 0;\n            } else {\n                toI++;\n            }\n        }\n        let mov = this._minkyl - toN.keys.length;\n        frN = toN.prevLeaf;\n        if (mov > 0 && frN !== null) {\n            // Insert new keys/records.\n            for (i = mov-1; i>=0; --i) {\n                toN.keys.unshift(frN.keys.pop());\n                toN.records.unshift(frN.records.pop());\n            }\n        }\n        for (i=1, len=parNod.length; i<len; ++i) {\n            parKey.push(parNod[i].keys[0]);\n        }\n        parKey[parKey.length] = null;\n\n        // Rebuild nodes\n        let kidKey, kidNod;\n        while (parKey[0] !== null) {\n            kidKey = parKey;\n            kidNod = parNod;\n            parKey = [];\n            parNod = [];\n            toI = this._maxkey + 1;\n            i = 0;\n            len = kidKey.length;\n            for (; i<len; i++) {\n                if (toI > this._maxkey) {\n                    toN = new InnerNode();\n                    toI = 0;\n                    parNod.push(toN);\n                }\n                toN.keys[toI] = kidKey[i];\n                toN.nodePointers[toI] = kidNod[i];\n                toI++;\n            }\n            mov = this._minkyn - toN.keys.length + 1;\n            if (mov > 0 && parNod.length > 1) {\n                frN = parNod[parNod.length-2];\n                for (i = mov-1; i>=0; --i) {\n                    toN.keys.unshift(frN.keys.pop());\n                    toN.nodePointers.unshift(frN.nodePointers.pop());\n                }\n            }\n            i = 0;\n            len = parNod.length;\n            for (; i<len; ++i) {\n                parKey.push(parNod[i].keys.pop());\n            }\n        }\n        this._root = parNod[0];\n        this.goTop();\n        return (this._found);\n    }\n\n    /**\n     * Internal helper method to delete a key from the tree.\n     * @param {*} key The unique key for the record.\n     * @private\n     */\n    _del(key) {\n        const stack = [];\n        let parNod = null;\n        let parPtr = -1;\n        this._leaf = this._root;\n        while (!this._leaf.isLeaf()) {\n            stack.push(this._leaf);\n            parNod = this._leaf;\n            parPtr = this._leaf.getItem(key);\n            this._leaf = this._leaf.nodePointers[parPtr];\n        }\n        this._item = this._leaf.getItem(key,false);\n\n        // Key not in tree\n        if (this._item === -1) {\n            this._found = false;\n            return;\n        }\n        this._found = true;\n\n        // Delete key from leaf\n        this._leaf.keys.splice(this._item, 1);\n        this._leaf.records.splice(this._item, 1);\n        this._length--;\n\n        // Leaf still valid: done\n        if (this._leaf === this._root) {\n            return;\n        }\n        if (this._leaf.keys.length >= this._minkyl) {\n            if (this._item === 0) BTree._fixNodes(stack, key, this._leaf.keys[0]);\n            return;\n        }\n        let delKey;\n\n        // Steal from left sibling if possible\n        let sibL = (parPtr === 0) ? null : parNod.nodePointers[parPtr - 1];\n        if (sibL !== null && sibL.keys.length > this._minkyl) {\n            delKey = (this._item === 0) ? key : this._leaf.keys[0];\n            this._leaf.keys.unshift(sibL.keys.pop());\n            this._leaf.records.unshift(sibL.records.pop());\n            BTree._fixNodes(stack, delKey, this._leaf.keys[0]);\n            return;\n        }\n\n        // Steal from right sibling if possible\n        let sibR = (parPtr === parNod.keys.length) ? null : parNod.nodePointers[parPtr + 1];\n        if (sibR !== null && sibR.keys.length > this._minkyl) {\n            this._leaf.keys.push(sibR.keys.shift());\n            this._leaf.records.push(sibR.records.shift());\n            if (this._item === 0) BTree._fixNodes(stack, key, this._leaf.keys[0]);\n            BTree._fixNodes(stack, this._leaf.keys[this._leaf.keys.length-1], sibR.keys[0]);\n            return;\n        }\n\n        // Merge left to make one leaf\n        if (sibL !== null) {\n            delKey = (this._item === 0) ? key : this._leaf.keys[0];\n            sibL.merge(this._leaf, parNod, delKey);\n            this._leaf = sibL;\n        } else {\n            delKey = sibR.keys[0];\n            this._leaf.merge(sibR, parNod, delKey);\n            if (this._item === 0) BTree._fixNodes(stack, key, this._leaf.keys[0]);\n        }\n\n        if (stack.length === 1 && parNod.keys.length === 0) {\n            this._root = this._leaf;\n            return;\n        }\n\n        let curNod = stack.pop();\n        let parItm;\n\n        // Update all nodes\n        while (curNod.keys.length < this._minkyn && stack.length > 0) {\n\n            parNod = stack.pop();\n            parItm = parNod.getItem(delKey);\n\n            // Steal from right sibling if possible\n            sibR = (parItm === parNod.keys.length) ? null : parNod.nodePointers[parItm+1];\n            if (sibR !== null && sibR.keys.length > this._minkyn) {\n                curNod.keys.push(parNod.keys[parItm]);\n                parNod.keys[parItm] = sibR.keys.shift();\n                curNod.nodePointers.push(sibR.nodePointers.shift());\n                break;\n            }\n\n            // Steal from left sibling if possible\n            sibL = (parItm === 0) ? null : parNod.nodePointers[parItm-1];\n            if (sibL !== null && sibL.keys.length > this._minkyn) {\n                curNod.keys.unshift(parNod.keys[parItm-1]);\n                parNod.keys[parItm-1] = sibL.keys.pop();\n                curNod.nodePointers.unshift(sibL.nodePointers.pop());\n                break;\n            }\n\n            // Merge left to make one node\n            if (sibL !== null) {\n                delKey = sibL.merge(curNod, parNod, parItm-1);\n                curNod = sibL;\n            } else if (sibR !== null) {\n                delKey = curNod.merge(sibR, parNod, parItm);\n            }\n\n            // Next level\n            if (stack.length === 0 && parNod.keys.length === 0) {\n                this._root = curNod;\n                break;\n            }\n            curNod = parNod;\n        }\n    }\n\n    /**\n     * Internal helper method to replace a key within the whole stack.\n     * @param {Array.<Node>} stk The stack of nodes to examine.\n     * @param {*} frKey The key to replace.\n     * @param {*} toKey The new key to put in place.\n     * @private\n     */\n    static _fixNodes(stk, frKey, toKey) {\n        let keys, lvl = stk.length, mor = true;\n        do {\n            lvl--;\n            keys = stk[lvl].keys;\n            for (let i=keys.length-1; i>=0; --i) {\n                if (keys[i] === frKey) {\n                    keys[i] = toKey;\n                    mor = false;\n                    break;\n                }\n            }\n        } while (mor && lvl>0);\n    }\n\n    /**\n     * Advances to the smallest key k', such that either k' > lower (if lowerOpen) or k'  lower (if !lowerOpen).\n     * If lower is undefined, jump to the smallest key's entry.\n     * @param {*} lower A lower bound on the key or undefined.\n     * @param {boolean} [lowerOpen] Whether lower may be included or not.\n     * @returns {boolean} True if there is such an entry, false otherwise.\n     */\n    goToLowerBound(lower, lowerOpen=false) {\n        // TODO: it might be that there is no exact key match, then we do not need to skip!\n        if (lower !== undefined) {\n            let success = this.seek(lower, BTree.NEAR_MODE.GE);\n            if (success && lowerOpen && ComparisonUtils.equals(lower, this.currentKey)) {\n                success = this.skip();\n            }\n            return success;\n        }\n        return this.goTop();\n    }\n\n    /**\n     * Advances to the largest key k', such that either k' < upper (if upperOpen) or k'  upper (if !upperOpen).\n     * If upper is undefined, jump to the largest key's entry.\n     * @param {*} upper An upper bound on the key or undefined.\n     * @param {boolean} [upperOpen] Whether upper may be included or not.\n     * @returns {boolean} True if there is such an entry, false otherwise.\n     */\n    goToUpperBound(upper, upperOpen=false) {\n        // TODO: it might be that there is no exact key match, then we do not need to skip!\n        if (upper !== undefined) {\n            let success = this.seek(upper, BTree.NEAR_MODE.LE);\n            if (success && upperOpen && ComparisonUtils.equals(upper, this.currentKey)) {\n                success = this.skip(-1);\n            }\n            return success;\n        }\n        return this.goBottom();\n    }\n}\n/**\n * Allows to specify the seek method of a BTree.\n * @enum {number}\n */\nBTree.NEAR_MODE = {\n    NONE: 0,\n    LE: 1,\n    GE: 2\n};\nClass.register(BTree);\n","class BufferUtils {\n    static _codePointTextDecoder(u8) {\n        if (typeof TextDecoder === 'undefined') throw new Error('TextDecoder not supported');\n        if (BufferUtils._ISO_8859_15_DECODER === null) throw new Error('TextDecoder does not supprot iso-8859-15');\n        if (BufferUtils._ISO_8859_15_DECODER === undefined) {\n            try {\n                BufferUtils._ISO_8859_15_DECODER = new TextDecoder('iso-8859-15');\n            } finally {\n                BufferUtils._ISO_8859_15_DECODER = null;\n            }\n        }\n        return BufferUtils._ISO_8859_15_DECODER.decode(u8)\n            .replace('', '').replace('', '').replace('', '').replace('', '')\n            .replace('', '').replace('', '').replace('', '').replace('', '');\n    }\n\n    static _tripletToBase64(num) {\n        return BufferUtils._BASE64_LOOKUP[num >> 18 & 0x3F] + BufferUtils._BASE64_LOOKUP[num >> 12 & 0x3F] + BufferUtils._BASE64_LOOKUP[num >> 6 & 0x3F] + BufferUtils._BASE64_LOOKUP[num & 0x3F];\n    }\n\n    static _base64encodeChunk(u8, start, end) {\n        let tmp;\n        const output = [];\n        for (let i = start; i < end; i += 3) {\n            tmp = ((u8[i] << 16) & 0xFF0000) + ((u8[i + 1] << 8) & 0xFF00) + (u8[i + 2] & 0xFF);\n            output.push(BufferUtils._tripletToBase64(tmp));\n        }\n        return output.join('');\n    }\n\n    static _base64fromByteArray(u8) {\n        let tmp;\n        const len = u8.length;\n        const extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n        let output = '';\n        const parts = [];\n        const maxChunkLength = 16383; // must be multiple of 3\n\n        // go through the array every three bytes, we'll deal with trailing stuff later\n        for (let i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n            parts.push(BufferUtils._base64encodeChunk(u8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n        }\n\n        // pad the end with zeros, but make sure to not forget the extra bytes\n        if (extraBytes === 1) {\n            tmp = u8[len - 1];\n            output += BufferUtils._BASE64_LOOKUP[tmp >> 2];\n            output += BufferUtils._BASE64_LOOKUP[(tmp << 4) & 0x3F];\n            output += '==';\n        } else if (extraBytes === 2) {\n            tmp = (u8[len - 2] << 8) + (u8[len - 1]);\n            output += BufferUtils._BASE64_LOOKUP[tmp >> 10];\n            output += BufferUtils._BASE64_LOOKUP[(tmp >> 4) & 0x3F];\n            output += BufferUtils._BASE64_LOOKUP[(tmp << 2) & 0x3F];\n            output += '=';\n        }\n\n        parts.push(output);\n\n        return parts.join('');\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toBase64(buffer) {\n        if (typeof Buffer !== 'undefined' && typeof window === 'undefined') {\n            return new Buffer(buffer).toString('base64');\n        } else if (typeof TextDecoder !== 'undefined' && BufferUtils._ISO_8859_15_DECODER !== null) {\n            try {\n                return btoa(BufferUtils._codePointTextDecoder(new Uint8Array(buffer)));\n            } catch (e) {\n                // Disabled itself\n            }\n        }\n\n        return BufferUtils._base64fromByteArray(new Uint8Array(buffer));\n    }\n\n    /**\n     * @param {string} base64\n     * @return {Uint8Array}\n     */\n    static fromBase64(base64) {\n        if (!(/^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/.test(base64))) {\n            throw new Error('Invalid base64');\n        }\n        return Uint8Array.from(atob(base64), c => c.charCodeAt(0));\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toBase64lex(buffer) {\n        const base64 = BufferUtils.toBase64(buffer);\n        let base64lex = '';\n        for (let i = 0; i < base64.length; i++) {\n            base64lex += BufferUtils.BASE64_TO_BASE64_LEX[base64[i]];\n        }\n        return base64lex;\n    }\n\n    /**\n     * @param {string} base64lex\n     * @return {Uint8Array}\n     */\n    static fromBase64lex(base64lex) {\n        let base64 = '';\n        for (let i = 0; i < base64lex.length; i++) {\n            base64 += BufferUtils.BASE64_LEX_TO_BASE64[base64lex[i]];\n        }\n        return BufferUtils.fromBase64(base64);\n    }\n\n    /**\n     * @param {*} a\n     * @param {*} b\n     * @return {boolean}\n     */\n    static equals(a, b) {\n        if (a.length !== b.length) return false;\n        const viewA = new Uint8Array(a);\n        const viewB = new Uint8Array(b);\n        for (let i = 0; i < a.length; i++) {\n            if (viewA[i] !== viewB[i]) return false;\n        }\n        return true;\n    }\n\n    /**\n     * @param {*} a\n     * @param {*} b\n     * @return {number} -1 if a is smaller than b, 1 if a is larger than b, 0 if a equals b.\n     */\n    static compare(a, b) {\n        if (a.length < b.length) return -1;\n        if (a.length > b.length) return 1;\n        for (let i = 0; i < a.length; i++) {\n            if (a[i] < b[i]) return -1;\n            if (a[i] > b[i]) return 1;\n        }\n        return 0;\n    }\n}\nBufferUtils.BASE64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nBufferUtils._BASE64_LOOKUP = [];\nfor (let i = 0, len = BufferUtils.BASE64_ALPHABET.length; i < len; ++i) {\n    BufferUtils._BASE64_LOOKUP[i] = BufferUtils.BASE64_ALPHABET[i];\n}\nBufferUtils.BASE64_LEX_ALPHABET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~';\nBufferUtils.BASE64_TO_BASE64_LEX = { '=': '-' };\nBufferUtils.BASE64_LEX_TO_BASE64 = { '-': '=' };\nfor (let i = 0, len = BufferUtils.BASE64_ALPHABET.length; i < len; ++i) {\n    BufferUtils.BASE64_TO_BASE64_LEX[BufferUtils.BASE64_ALPHABET[i]] = BufferUtils.BASE64_LEX_ALPHABET[i];\n    BufferUtils.BASE64_LEX_TO_BASE64[BufferUtils.BASE64_LEX_ALPHABET[i]] = BufferUtils.BASE64_ALPHABET[i];\n}\nClass.register(BufferUtils);\n","class ComparisonUtils {\n    /**\n     * @param {*} a\n     * @param {*} b\n     * @return {boolean}\n     */\n    static equals(a, b) {\n        // Primitive values\n        if (a === b) return true;\n\n        // Set\n        if (a instanceof Set && b instanceof Set) return a.equals(b);\n\n        // ArrayBuffer/Uint8Array/Buffer\n        if (ComparisonUtils.isUint8Array(a) && ComparisonUtils.isUint8Array(b)) return BufferUtils.equals(new Uint8Array(a), new Uint8Array(b));\n\n        return false;\n    }\n\n    /**\n     * @param {*} a\n     * @param {*} b\n     * @return {boolean}\n     */\n    static compare(a, b) {\n        // ArrayBuffer/Uint8Array/Buffer\n        if (ComparisonUtils.isUint8Array(a) && ComparisonUtils.isUint8Array(b)) return BufferUtils.compare(new Uint8Array(a), new Uint8Array(b));\n\n        // Primitive values\n        if (a < b) return -1;\n        if (a > b) return 1;\n\n        return 0;\n    }\n\n    /**\n     * @param {*} obj\n     * @returns {boolean}\n     */\n    static isUint8Array(obj) {\n        if (typeof Buffer !== 'undefined' && typeof window === 'undefined' && obj instanceof Buffer) return true;\n        return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;\n    }\n}\nClass.register(ComparisonUtils);\n","class JSONUtils {\n    static stringify(value) {\n        return JSON.stringify(value, JSONUtils.jsonifyType);\n    }\n\n    static parse(value) {\n        return JSON.parse(value, JSONUtils.parseType);\n    }\n\n    static parseType(key, value) {\n        if (value && value[JSONUtils.TYPE_SYMBOL]) {\n            switch (value[JSONUtils.TYPE_SYMBOL]) {\n                case 'Uint8Array':\n                    return BufferUtils.fromBase64(value[JSONUtils.VALUE_SYMBOL]);\n                case 'Set':\n                    return Set.from(value[JSONUtils.VALUE_SYMBOL]);\n            }\n        }\n        return value;\n    }\n\n    static jsonifyType(key, value) {\n        if (value instanceof Uint8Array) {\n            return JSONUtils.typedObject('Uint8Array', BufferUtils.toBase64(value));\n        }\n        if (value instanceof Set) {\n            return JSONUtils.typedObject('Set', Array.from(value));\n        }\n        return value;\n    }\n\n    static typedObject(type, value) {\n        const obj = {};\n        obj[JSONUtils.TYPE_SYMBOL] = type;\n        obj[JSONUtils.VALUE_SYMBOL] = value;\n        return obj;\n    }\n}\nJSONUtils.TYPE_SYMBOL = '__';\nJSONUtils.VALUE_SYMBOL = 'value';\n\nClass.register(JSONUtils);\n","class Log {\n    /**\n     * @returns {Log}\n     */\n    static get instance() {\n        if (!Log._instance) {\n            Log._instance = new Log(new LogNative());\n        }\n        return Log._instance;\n    }\n\n    /**\n     * @param {LogNative} native\n     */\n    constructor(native) {\n        /** @type {LogNative} */\n        this._native = native;\n    }\n\n    /**\n     * @param {string} tag\n     * @param {Log.Level} level\n     */\n    setLoggable(tag, level) {\n        this._native.setLoggable(tag, level);\n    }\n\n    /** @type {Log.Level} */\n    get level() {\n        return this._native._global_level;\n    }\n\n    /** @type {Log.Level} */\n    set level(l) {\n        this._native._global_level = l;\n    }\n\n    /**\n     * @param {Log.Level} level\n     * @param {string|{name:string}} tag\n     * @param {Array} args\n     */\n    msg(level, tag, args) {\n        if (this._native.isLoggable(tag, level)) {\n            for (let i = 0; i < args.length; ++i) {\n                if (typeof args[i] === 'function') {\n                    args[i] = args[i]();\n                }\n                if (typeof args[i] === 'object') {\n                    if (typeof args[i].toString === 'function') {\n                        args[i] = args[i].toString();\n                    } else if (args[i].constructor && args[i].constructor.name) {\n                        args[i] = `{Object: ${args[i].constructor.name}}`;\n                    } else {\n                        args[i] = '{Object}';\n                    }\n                }\n            }\n            this._native.msg(level, tag, args);\n        }\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static d(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.DEBUG, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static e(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.ERROR, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static i(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.INFO, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static v(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.VERBOSE, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static w(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.WARNING, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static t(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.TRACE, tag, args);\n    }\n}\n/**\n * @enum {number}\n */\nLog.Level = {\n    TRACE: 1,\n    VERBOSE: 2,\n    DEBUG: 3,\n    INFO: 4,\n    WARNING: 5,\n    ERROR: 6,\n    ASSERT: 7,\n\n    /**\n     * @param {Log.Level} level\n     */\n    toStringTag: function (level) {\n        switch (level) {\n            case Log.TRACE:\n                return 'T';\n            case Log.VERBOSE:\n                return 'V';\n            case Log.DEBUG:\n                return 'D';\n            case Log.INFO:\n                return 'I';\n            case Log.WARNING:\n                return 'W';\n            case Log.ERROR:\n                return 'E';\n            case Log.ASSERT:\n                return 'A';\n            default:\n                return '*';\n        }\n    }\n};\nLog.TRACE = Log.Level.TRACE;\nLog.VERBOSE = Log.Level.VERBOSE;\nLog.DEBUG = Log.Level.DEBUG;\nLog.INFO = Log.Level.INFO;\nLog.WARNING = Log.Level.WARNING;\nLog.ERROR = Log.Level.ERROR;\nLog.ASSERT = Log.Level.ASSERT;\nLog._instance = null;\n\nLog.d.tag = (tag) => Log.d.bind(null, tag);\nLog.e.tag = (tag) => Log.e.bind(null, tag);\nLog.i.tag = (tag) => Log.i.bind(null, tag);\nLog.v.tag = (tag) => Log.v.bind(null, tag);\nLog.w.tag = (tag) => Log.w.bind(null, tag);\nLog.t.tag = (tag) => Log.t.bind(null, tag);\n\nClass.register(Log);\n","/**\n * An implementation of a LRU (least recently used) map.\n * This is a map that contains a maximum of k entries,\n * where k is specified in the constructor.\n * When the maximal number of entries is reached,\n * it will evict the least recently used entry.\n * This behaviour is useful for caches.\n * @template K The keys' type.\n * @template V The values' type.\n */\nclass LRUMap {\n    /**\n     * Instantiate a LRU map of maximum size maxSize.\n     * @param {number} maxSize The maximum size of the map.\n     */\n    constructor(maxSize) {\n        this._maxSize = maxSize;\n        /** @type {Map.<K,V>} */\n        this._map = new Map();\n        /** @type {Map.<K,number>} */\n        this._numAccesses = new Map();\n        /** @type {Array.<K>} */\n        this._accessQueue = [];\n    }\n\n    /**\n     * The current size of the map.\n     * @type {number}\n     */\n    get size() {\n        return this._map.size;\n    }\n\n    /**\n     * Clears the map.\n     */\n    clear() {\n        this._numAccesses.clear();\n        this._accessQueue = [];\n        return this._map.clear();\n    }\n\n    /**\n     * Deletes a key from the map.\n     * @param {K} key The key to delete.\n     * @returns {boolean} Whether an entry was deleted.\n     */\n    delete(key) {\n        return this._map.delete(key);\n    }\n\n    /**\n     * Returns an iterator over key value pairs [k, v].\n     * @returns {Iterator.<Array>}\n     */\n    entries() {\n        return this._map.entries();\n    }\n\n    /**\n     * Execute a given function for each key value pair in the map.\n     * @param {function(key:K, value:V):*} callback The function to be called.\n     * @param {*} [thisArg] This value will be used as this when executing the function.\n     */\n    forEach(callback, thisArg) {\n        return this._map.forEach(callback, thisArg);\n    }\n\n    /**\n     * Return the corresponding value to a specified key.\n     * @param {K} key The key to look for.\n     * @returns {V} The value the key maps to (or undefined if not present).\n     */\n    get(key) {\n        this.access(key);\n        return this._map.get(key);\n    }\n\n    /**\n     * Returns true if the specified key is to be found in the map.\n     * @param {K} key The key to look for.\n     * @returns {boolean} True, if the key is in the map, false otherwise.\n     */\n    has(key) {\n        return this._map.has(key);\n    }\n\n    /**\n     * Returns an iterator over the keys of the map.\n     * @returns {Iterator.<K>}\n     */\n    keys() {\n        return this._map.keys();\n    }\n\n    /**\n     * Evicts the k least recently used entries from the map.\n     * @param {number} [k] The number of entries to evict (default is 1).\n     */\n    evict(k=1) {\n        while (k > 0 && this._accessQueue.length > 0) {\n            const oldest = this._accessQueue.shift();\n            let accesses = this._numAccesses.get(oldest);\n            --accesses;\n            this._numAccesses.set(oldest, accesses);\n            // Check if not used in the meanwhile.\n            if (accesses !== 0) {\n                continue;\n            }\n            // Otherwise delete that.\n            this._numAccesses.delete(oldest);\n            // If it was not present however, we need to search further.\n            if (!this.delete(oldest)) {\n                continue;\n            }\n            --k;\n        }\n    }\n\n    /**\n     * Marks a key as accessed.\n     * This implicitly makes the key the most recently used key.\n     * @param {K} key The key to mark as accessed.\n     */\n    access(key) {\n        if (!this._map.has(key)) {\n            return;\n        }\n        let accesses = 0;\n        if (this._numAccesses.has(key)) {\n            accesses = this._numAccesses.get(key);\n        }\n        ++accesses;\n        this._numAccesses.set(key, accesses);\n        this._accessQueue.push(key);\n    }\n\n    /**\n     * Inserts or replaces a key's value into the map.\n     * If the maxSize of the map is exceeded, the least recently used key is evicted first.\n     * Inserting a key implicitly accesses it.\n     * @param {K} key The key to set.\n     * @param {V} value The associated value.\n     */\n    set(key, value) {\n        if (this.size >= this._maxSize) {\n            this.evict();\n        }\n        this._map.set(key, value);\n        this.access(key);\n    }\n\n    /**\n     * Returns an iterator over the values of the map.\n     * @returns {Iterator.<V>}\n     */\n    values() {\n        return this._map.values();\n    }\n\n    /**\n     * Returns an iterator over key value pairs [k, v].\n     * @returns {Iterator.<Array>}\n     */\n    [Symbol.iterator]() {\n        return this._map.entries();\n    }\n}\nClass.register(LRUMap);\n","/**\n * Utils that are related to common JavaScript objects.\n */\nclass ObjectUtils {\n    /**\n     * This method returns the value of an object at a given path.\n     * A key path is defined by a key within the object or alternatively a path through the object to a specific subkey.\n     * For example, ['a', 'b'] could be used to use 'key' as the key in the following object:\n     * { 'a': { 'b': 'key' } }\n     * @param {Object} obj The JS object to access.\n     * @param {string|Array.<string>} path The key path to access.\n     * @returns {*} The value at the given path or undefined if the path does not exist.\n     */\n    static byKeyPath(obj, path) {\n        if (!Array.isArray(path)) {\n            return obj[path];\n        }\n        let tmp = obj;\n        for (const component of path) {\n            if (tmp === undefined) {\n                return undefined;\n            }\n            tmp = tmp[component];\n        }\n        return tmp;\n    }\n}\nClass.register(ObjectUtils);\n","/**\n * Calculates the union of two sets.\n * Method of Set.\n * @memberOf Set\n * @param {Set} setB The second set.\n * @returns {Set} The union of this set and the second set.\n */\nSet.prototype.union = function(setB) {\n    const union = new Set(this);\n    for (const elem of setB) {\n        union.add(elem);\n    }\n    return union;\n};\n\n/**\n * Calculates the intersection of two sets.\n * Method of Set.\n * @memberOf Set\n * @param {Set} setB The second set.\n * @returns {Set} The intersection of this set and the second set.\n */\nSet.prototype.intersection = function(setB) {\n    const intersection = new Set();\n    for (const elem of setB) {\n        if (this.has(elem)) {\n            intersection.add(elem);\n        }\n    }\n    return intersection;\n};\n\n/**\n * Calculates the difference of two sets.\n * Method of Set.\n * @memberOf Set\n * @param {Set} setB The second set.\n * @returns {Set} The difference of this set and the second set.\n */\nSet.prototype.difference = function(setB) {\n    const difference = new Set(this);\n    for (const elem of setB) {\n        difference.delete(elem);\n    }\n    return difference;\n};\n\n/**\n * Checks whether two sets are equal to each other.\n * Method of Set.\n * @memberOf Set\n * @param {Set} setB The second set.\n * @returns {boolean} True if they contain the same elements, false otherwise.\n */\nSet.prototype.equals = function(setB) {\n    if (this.size !== setB.size) return false;\n    for (const elem of setB) {\n        if (!this.has(elem)) {\n            return false;\n        }\n    }\n    return true;\n};\n\n/**\n * Limits the number of items in the set.\n * @param {number} [limit] Limits the number of results if given.\n * @returns {Set}\n */\nSet.prototype.limit = function(limit = null) {\n    if (limit === null) return this;\n\n    const limitedResults = new Set();\n    let count = 0;\n    for (const val of this) {\n        // Limit\n        if (limit !== null && count >= limit) break;\n\n        limitedResults.add(val);\n        count++;\n    }\n    return limitedResults;\n};\n\n/**\n * Creates a Set from single values and iterables.\n * If arg is not iterable, it creates a new Set with arg as its single member.\n * If arg is iterable, it iterates over arg and puts all items into the Set.\n * Static method of Set.\n * @memberOf Set\n * @param {*} arg The argument to create the Set from.\n * @returns {Set} The resulting Set.\n */\nSet.from = function(arg) {\n    // Check if iterable and not string.\n    if (arg && typeof arg[Symbol.iterator] === 'function' && typeof arg !== 'string') {\n        return new Set(arg);\n    }\n    return new Set([arg]);\n};\n\n/**\n * Returns an element of a Set.\n * Static method of Set.\n * @memberOf Set\n * @template T\n * @param {Set.<T>} s The set to return an element from.\n * @returns {T} An element of the set.\n */\nSet.sampleElement = function(s) {\n    return s.size > 0 ? s.values().next().value : undefined;\n};\n","class SortedList {\n    constructor(sortedList = [], compare) {\n        this._list = sortedList;\n        this._compare = compare || SortedList._compare;\n    }\n\n    static _compare(a, b) {\n        return a.compare ? a.compare(b) : (a > b ? 1 : (a < b ? -1 : 0));\n    }\n\n    indexOf(o) {\n        let a = 0, b = this._list.length - 1;\n        let currentIndex = null;\n        let currentElement = null;\n\n        while (a <= b) {\n            currentIndex = Math.round((a + b) / 2);\n            currentElement = this._list[currentIndex];\n\n            if (this._compare(currentElement, o) < 0) {\n                a = currentIndex + 1;\n            }\n            else if (this._compare(currentElement, o) > 0) {\n                b = currentIndex - 1;\n            }\n            else {\n                return currentIndex;\n            }\n        }\n\n        return -1;\n    }\n\n    _insertionIndex(o) {\n        let a = 0, b = this._list.length - 1;\n        let currentIndex = null;\n        let currentElement = null;\n\n        while (a <= b) {\n            currentIndex = Math.round((a + b) / 2);\n            currentElement = this._list[currentIndex];\n\n            if (this._compare(currentElement, o) < 0) {\n                a = currentIndex + 1;\n            }\n            else if (this._compare(currentElement, o) > 0) {\n                b = currentIndex - 1;\n            }\n            else {\n                break;\n            }\n        }\n\n        return a;\n    }\n\n    add(value) {\n        this._list.splice(this._insertionIndex(value), 0, value);\n    }\n\n    has(value) {\n        return this.indexOf(value) >= 0;\n    }\n\n    shift() {\n        return this._list.shift();\n    }\n\n    pop() {\n        return this._list.pop();\n    }\n\n    peekFirst() {\n        return this._list[0];\n    }\n\n    peekLast() {\n        return this._list[this._list.length - 1];\n    }\n\n    remove(value) {\n        const index = this.indexOf(value);\n        if (index > -1) {\n            this._list.splice(index, 1);\n        }\n    }\n\n    clear() {\n        this._list = [];\n    }\n\n    values() {\n        return this._list;\n    }\n\n    /**\n     * @returns {Iterator.<V|*>}\n     */\n    [Symbol.iterator]() {\n        return this._list[Symbol.iterator]();\n    }\n\n    copy() {\n        return new SortedList(this._list.slice(), this._compare);\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._list.length;\n    }\n}\nClass.register(SortedList);\n","class Synchronizer {\n    constructor() {\n        this._queue = [];\n        this._working = false;\n    }\n\n    /**\n     * Push function to the Synchronizer for later, synchronous execution\n     * @template T\n     * @param {function():T} fn Function to be invoked later by this Synchronizer\n     * @returns {Promise.<T>}\n     */\n    push(fn) {\n        return new Promise((resolve, error) => {\n            this._queue.push({fn: fn, resolve: resolve, error: error});\n            if (!this._working) {\n                this._doWork().catch(Log.w.tag(Synchronizer));\n            }\n        });\n    }\n\n    async _doWork() {\n        this._working = true;\n\n        while (this._queue.length) {\n            const job = this._queue.shift();\n            try {\n                const result = await job.fn();\n                job.resolve(result);\n            } catch (e) {\n                if (job.error) job.error(e);\n            }\n        }\n\n        this._working = false;\n    }\n\n    /** @type {boolean} */\n    get working() {\n        return this._working;\n    }\n}\nClass.register(Synchronizer);\n","/**\n * A simple object implementing parts of the Transaction's class.\n * It is used to keep track of modifications on a persistent index\n * and to apply them all at once.\n * This class is to be used only internally.\n */\nclass EncodedTransaction {\n    /**\n     * Create a new IndexTransaction.\n     */\n    constructor(tableName) {\n        this._tableName = tableName;\n        this._modified = new Map();\n        this._removed = new Set();\n        this._truncated = false;\n    }\n\n    /** @type {string} */\n    get tableName() {\n        return this._tableName;\n    }\n\n    /** @type {Map.<string,*>} */\n    get modified() {\n        return this._modified;\n    }\n\n    /** @type {Set.<string>} */\n    get removed() {\n        return this._removed;\n    }\n\n    /** @type {boolean} */\n    get truncated() {\n        return this._truncated;\n    }\n\n    /**\n     * Empty the index transaction.\n     */\n    truncate() {\n        this._truncated = true;\n        this._modified.clear();\n        this._removed.clear();\n    }\n\n    /**\n     * Put a key-value pair into the transaction.\n     * @param {string} key The key.\n     * @param {*} value The value.\n     */\n    put(key, value) {\n        this._removed.delete(key);\n        this._modified.set(key, value);\n    }\n\n    /**\n     * Get a value from the encoded transaction.\n     * @param {string} key The key.\n     * @return {*} value The value.\n     */\n    get(key) {\n        return this._modified.get(key);\n    }\n\n    /**\n     * Remove a key-value pair from the transaction.\n     * @param {string} key The key to remove.\n     */\n    remove(key) {\n        this._removed.add(key);\n        this._modified.delete(key);\n    }\n\n}\nClass.register(EncodedTransaction);\n","class GenericValueEncoding {\n    static _encodeInteger(value) {\n        const binary = new Uint8Array(9);\n        const dv = new DataView(binary.buffer);\n        dv.setUint8(0, GenericValueEncoding.Type.INTEGER);\n        dv.setUint32(1, Math.floor(value / Math.pow(2, 32)));\n        dv.setUint32(5, value);\n        return binary;\n    }\n    static _decodeInteger(binary) {\n        const dv = new DataView(binary.buffer);\n        return dv.getUint32(1) * Math.pow(2, 32) + dv.getUint32(5);\n    }\n\n    static _encodeString(string, type = GenericValueEncoding.Type.STRING) {\n        const buf = new Uint8Array(string.length + 1);\n        buf[0] = type;\n        for (let i = 0; i < string.length; ++i) {\n            buf[i + 1] = string.charCodeAt(i);\n        }\n        return buf;\n    }\n    static _decodeString(buffer) {\n        return String.fromCharCode.apply(null, buffer.subarray(1));\n    }\n\n    static _encodeOther(obj) {\n        return GenericValueEncoding._encodeString(JSONUtils.stringify(obj), GenericValueEncoding.Type.JSON);\n    }\n    static _decodeOther(buffer) {\n        const json = GenericValueEncoding._decodeString(buffer);\n        return JSONUtils.parse(json);\n    }\n\n    static _encodeBuffer(buffer) {\n        const buf = new Uint8Array(buffer.byteLength + 1);\n        buf[0] = GenericValueEncoding.Type.BUFFER;\n        buf.set(buffer, 1);\n        return buf;\n    }\n    static _decodeBuffer(buffer) {\n        return buffer.subarray(1);\n    }\n\n    static encode(data) {\n        if (Number.isInteger(data)) {\n            return GenericValueEncoding._encodeInteger(data);\n        }\n        if (typeof data === 'string') {\n            return this._encodeString(data);\n        }\n        if (data instanceof Uint8Array) {\n            return GenericValueEncoding._encodeBuffer(data);\n        }\n        return GenericValueEncoding._encodeOther(data);\n    }\n\n    static decode(data) {\n        data = new Uint8Array(data);\n        const type = data[0];\n        switch (type) {\n            case GenericValueEncoding.Type.INTEGER:\n                return GenericValueEncoding._decodeInteger(data);\n            case GenericValueEncoding.Type.STRING:\n                return GenericValueEncoding._decodeString(data);\n            case GenericValueEncoding.Type.BUFFER:\n                return GenericValueEncoding._decodeBuffer(data);\n            default:\n                return GenericValueEncoding._decodeOther(data);\n        }\n    }\n\n    static get encoding() {\n        return JungleDB.Encoding.BINARY;\n    }\n}\n/** @enum {number} */\nGenericValueEncoding.Type = {\n    INTEGER: 0,\n    STRING: 1,\n    JSON: 2,\n    BUFFER: 3\n};\nClass.register(GenericValueEncoding);\n","/**\n * This is an intermediate layer caching the results of a backend.\n * While simple get/put queries make use of the cache,\n * more advanced queries will be forwarded to the backend.\n * @implements {IBackend}\n */\nclass CachedBackend {\n    /**\n     * Creates a new instance of the cached layer using the specified backend.\n     * @param {IBackend} backend The backend to use.\n     */\n    constructor(backend, cacheSize = CachedBackend.MAX_CACHE_SIZE, rawCacheSize = 0) {\n        this._backend = backend;\n        /** @type {Map.<string,*>} */\n        this._cache = new LRUMap(cacheSize);\n        /** @type {Map.<string,*>} */\n        this._rawCache = new LRUMap(rawCacheSize);\n    }\n\n    /** @type {boolean} */\n    get connected() {\n        return this._backend.connected;\n    }\n\n    /**\n     * A map of index names to indices as defined by the underlying backend.\n     * The index names can be used to access an index.\n     * @type {Map.<string,IIndex>}\n     */\n    get indices() {\n        return this._backend.indices;\n    }\n\n    /**\n     * A helper method to retrieve the values corresponding to a set of keys.\n     * @param {Set.<string>} keys The set of keys to get the corresponding values for.\n     * @returns {Promise.<Array.<*>>} A promise of the array of values.\n     * @protected\n     */\n    async _retrieveValues(keys) {\n        const valuePromises = [];\n        for (const key of keys) {\n            valuePromises.push(this.get(key));\n        }\n        return Promise.all(valuePromises);\n    }\n\n    /**\n     * @param {string} key\n     * @returns {boolean}\n     * @private\n     */\n    _has(key) {\n        return this._cache.has(key) || this._rawCache.has(key);\n    }\n\n    /**\n     * @param {string} key\n     * @param {RetrievalConfig} [options] Advanced retrieval options.\n     * @returns {boolean}\n     * @private\n     */\n    _get(key, options) {\n        if (options && options.raw) {\n            if (this._rawCache.has(key)) {\n                return this._rawCache.get(key);\n            } else {\n                // Transform to raw if requested\n                const value = this.encode(this._cache.get(key));\n                this._rawCache.set(key, value);\n                return value;\n            }\n        } else {\n            if (this._cache.has(key)) {\n                return this._cache.get(key);\n            } else {\n                const value = this.decode(this._rawCache.get(key), key);\n                this._cache.set(key, value);\n                return value;\n            }\n        }\n    }\n\n    /**\n     * Returns the object stored under the given primary key.\n     * Resolves to undefined if the key is not present in the object store.\n     * @abstract\n     * @param {string} key The primary key to look for.\n     * @param {SyncRetrievalConfig} [options] Advanced retrieval options.\n     * @returns {*} The object stored under the given key, or undefined if not present.\n     */\n    getSync(key, options = {}) {\n        if (this._has(key)) {\n            return this._get(key, options);\n        }\n\n        // Attempt backend\n        if (this._backend.isSynchronous()) {\n            const value = this._backend.getSync(key, options);\n            // Cache\n            if (options && options.raw) {\n                this._rawCache.set(key, value);\n            } else {\n                this._cache.set(key, value);\n            }\n            return value;\n        }\n\n        if (options && options.expectPresence) {\n            throw new Error(`Missing key in cached backend: ${key}`);\n        }\n\n        return undefined;\n    }\n\n    /**\n     * A check whether a certain key is cached.\n     * @param {string} key The key to check.\n     * @return {boolean} A boolean indicating whether the key is already in the cache.\n     */\n    isCached(key) {\n        // Since the cache may change quickly, don't promise anything to the upper layers.\n        // But we can still answer their getSync requests if we have it in the cache.\n        return false;\n    }\n\n    /**\n     * Returns a promise of the object stored under the given primary key.\n     * If the item is in the cache, the cached value will be returned.\n     * Otherwise, the value will be fetched from the backend object store..\n     * Resolves to undefined if the key is not present in the object store.\n     * @param {string} key The primary key to look for.\n     * @param {RetrievalConfig} [options] Advanced retrieval options.\n     * @returns {Promise.<*>} A promise of the object stored under the given key, or undefined if not present.\n     */\n    async get(key, options = {}) {\n        if (this._has(key)) {\n            return this._get(key, options);\n        }\n        const value = await this._backend.get(key, options);\n        // Cache\n        if (options && options.raw) {\n            this._rawCache.set(key, value);\n        } else {\n            this._cache.set(key, value);\n        }\n        return value;\n    }\n\n    /**\n     * Returns a promise of a set of keys fulfilling the given query by querying the backend.\n     * If the optional query is not given, it returns all keys in the object store.\n     * If the query is of type KeyRange, it returns all keys of the object store being within this range.\n     * If the query is of type Query, it returns all keys fulfilling the query.\n     * @param {Query|KeyRange} [query] Optional query to check keys against.\n     * @param {number} [limit] Limits the number of results if given.\n     * @returns {Promise.<Set.<string>>} A promise of the set of keys relevant to the query.\n     */\n    keys(query = null, limit = null) {\n        return this._backend.keys(query, limit);\n    }\n\n    /**\n     * Returns a promise of an array of objects whose primary keys fulfill the given query by relying on the backend.\n     * If the optional query is not given, it returns all objects in the object store.\n     * If the query is of type KeyRange, it returns all objects whose primary keys are within this range.\n     * If the query is of type Query, it returns all objects whose primary keys fulfill the query.\n     * @param {Query|KeyRange} [query] Optional query to check keys against.\n     * @param {number} [limit] Limits the number of results if given.\n     * @returns {Promise.<Array.<*>>} A promise of the array of objects relevant to the query.\n     */\n    values(query = null, limit = null) {\n        return this._backend.values(query, limit);\n    }\n\n    /**\n     * Iterates over the keys in a given range and direction.\n     * The callback is called for each primary key fulfilling the query\n     * until it returns false and stops the iteration.\n     * @param {function(key:string):boolean} callback A predicate called for each key until returning false.\n     * @param {boolean} ascending Determines the direction of traversal.\n     * @param {KeyRange} query An optional KeyRange to narrow down the iteration space.\n     */\n    keyStream(callback, ascending=true, query=null) {\n        return this._backend.keyStream(callback, ascending, query);\n    }\n\n    /**\n     * Iterates over the keys and values in a given range and direction.\n     * The callback is called for each value and primary key fulfilling the query\n     * until it returns false and stops the iteration.\n     * @param {function(value:*, key:string):boolean} callback A predicate called for each value and key until returning false.\n     * @param {boolean} ascending Determines the direction of traversal.\n     * @param {KeyRange} query An optional KeyRange to narrow down the iteration space.\n     */\n    valueStream(callback, ascending=true, query=null) {\n        return this._backend.valueStream(callback, ascending, query);\n    }\n\n    /**\n     * Returns a promise of the object whose primary key is maximal for the given range.\n     * If the optional query is not given, it returns the object whose key is maximal.\n     * If the query is of type KeyRange, it returns the object whose primary key is maximal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<*>} A promise of the object relevant to the query.\n     */\n    maxValue(query=null) {\n        return this._backend.maxValue(query);\n    }\n\n    /**\n     * Returns a promise of the key being maximal for the given range.\n     * If the optional query is not given, it returns the maximal key.\n     * If the query is of type KeyRange, it returns the key being maximal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<string>} A promise of the key relevant to the query.\n     */\n    maxKey(query=null) {\n        return this._backend.maxKey(query);\n    }\n\n    /**\n     * Returns a promise of the key being minimal for the given range.\n     * If the optional query is not given, it returns the minimal key.\n     * If the query is of type KeyRange, it returns the key being minimal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<string>} A promise of the key relevant to the query.\n     */\n    minKey(query=null) {\n        return this._backend.minKey(query);\n    }\n\n    /**\n     * Returns a promise of the object whose primary key is minimal for the given range.\n     * If the optional query is not given, it returns the object whose key is minimal.\n     * If the query is of type KeyRange, it returns the object whose primary key is minimal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<*>} A promise of the object relevant to the query.\n     */\n    minValue(query=null) {\n        return this._backend.minValue(query);\n    }\n\n    /**\n     * Returns the count of entries in the given range.\n     * If the optional query is not given, it returns the count of entries in the object store.\n     * If the query is of type KeyRange, it returns the count of entries within the given range.\n     * @param {KeyRange} [query]\n     * @returns {Promise.<number>}\n     */\n    count(query=null) {\n        return this._backend.count(query);\n    }\n\n    /**\n     * Internally applies a transaction to the cache's and backend's state.\n     * This needs to be done in batch (as a db level transaction), i.e., either the full state is updated\n     * or no changes are applied.\n     * @param {Transaction} tx The transaction to apply.\n     * @returns {Promise} The promise resolves after applying the transaction.\n     * @protected\n     */\n    _apply(tx) {\n        this._applyLocally(tx);\n        return this._backend._apply(tx);\n    }\n\n    /**\n     * Internally applies a transaction to the cache's state.\n     * @param {Transaction} tx The transaction to apply.\n     * @protected\n     */\n    _applyLocally(tx) {\n        // Update local state and push to backend for batch transaction.\n        if (tx._truncated) {\n            this._cache.clear();\n        }\n        for (const key of tx._removed) {\n            this._cache.delete(key);\n        }\n        for (const [key, value] of tx._modified) {\n            this._cache.set(key, value);\n        }\n    }\n\n    /**\n     * Empties the object store.\n     * @returns {Promise} The promise resolves after emptying the object store.\n     */\n    async truncate() {\n        this._cache.clear();\n        return this._backend.truncate();\n    }\n\n    /**\n     * Returns the index of the given name.\n     * If the index does not exist, it returns undefined.\n     * @param {string} indexName The name of the requested index.\n     * @returns {IIndex} The index associated with the given name.\n     */\n    index(indexName) {\n        return this._backend.index(indexName);\n    }\n\n    /**\n     * Creates a new secondary index on the object store.\n     * Currently, all secondary indices are non-unique.\n     * They are defined by a key within the object or alternatively a path through the object to a specific subkey.\n     * For example, ['a', 'b'] could be used to use 'key' as the key in the following object:\n     * { 'a': { 'b': 'key' } }\n     * Secondary indices may be multiEntry, i.e., if the keyPath resolves to an iterable object, each item within can\n     * be used to find this entry.\n     * If a new object does not possess the key path associated with that index, it is simply ignored.\n     *\n     * This function may only be called before the database is connected.\n     * Moreover, it is only executed on database version updates or on first creation.\n     * @param {string} indexName The name of the index.\n     * @param {string|Array.<string>} [keyPath] The path to the key within the object. May be an array for multiple levels.\n     * @param {IndexConfig} [options] An options object.\n     */\n    createIndex(indexName, keyPath, options = {}) {\n        return this._backend.createIndex(indexName, keyPath, options);\n    }\n\n    /**\n     * Deletes a secondary index from the object store.\n     * @param indexName\n     * @param {{upgradeCondition:?boolean|?function(oldVersion:number, newVersion:number):boolean}} [options]\n     */\n    deleteIndex(indexName, options = {}) {\n        return this._backend.deleteIndex(indexName, options);\n    }\n\n    /**\n     * Closes the object store and potential connections.\n     * @returns {Promise} The promise resolves after closing the object store.\n     */\n    close() {\n        return this._backend.close();\n    }\n\n    /**\n     * Returns the necessary information in order to flush a combined transaction.\n     * @abstract\n     * @param {Transaction} tx The transaction that should be applied to this backend.\n     * @returns {Promise.<*|function()|Array.<*|function()>>} For non-persistent backends: a function that effectively applies the transaction.\n     * Native backends otherwise specify their own information as needed by their JungleDB instance.\n     */\n    async applyCombined(tx) {\n        return [await this._backend.applyCombined(tx), () => this._applyLocally(tx)];\n    }\n\n    /**\n     * Checks whether an object store implements the ISynchronousObjectStore interface.\n     * @returns {boolean} The transaction object.\n     */\n    isSynchronous() {\n        return true;\n    }\n\n    /**\n     * Method called to decode a single value.\n     * @param {*} value Value to be decoded.\n     * @param {string} key Key corresponding to the value.\n     * @returns {*} The decoded value.\n     */\n    decode(value, key) {\n        return this._backend.decode(value, key);\n    }\n\n    /**\n     * Method called to encode a single value.\n     * @param {*} value Value to be encoded.\n     * @returns {*} The encoded value.\n     */\n    encode(value) {\n        return this._backend.encode(value);\n    }\n}\n/** @type {number} Maximum number of cached elements. */\nCachedBackend.MAX_CACHE_SIZE = 5000 /*elements*/;\nClass.register(CachedBackend);\n","/**\n * This is a BTree based index, which is generally stored in memory.\n * It is used by transactions.\n * @implements {IIndex}\n */\nclass InMemoryIndex {\n    /**\n     * Creates a new InMemoryIndex for a given object store.\n     * The key path describes the path of the secondary key within the stored objects.\n     * Only objects for which the key path exists are part of the secondary index.\n     *\n     * A key path is defined by a key within the object or alternatively a path through the object to a specific subkey.\n     * For example, ['a', 'b'] could be used to use 'key' as the key in the following object:\n     * { 'a': { 'b': 'key' } }\n     *\n     * If a secondary index is a multi entry index, and the value at the key path is iterable,\n     * every item of the iterable value will be associated with the object.\n     * @param {IObjectStore} objectStore The underlying object store to use.\n     * @param {string|Array.<string>} [keyPath] The key path of the indexed attribute.\n     * If the keyPath is not given, this is a primary index.\n     * @param {boolean} [multiEntry] Whether the indexed attribute is considered to be iterable or not.\n     * @param {boolean} [unique] Whether there is a unique constraint on the attribute.\n     */\n    constructor(objectStore, keyPath, multiEntry=false, unique=false) {\n        this._objectStore = objectStore;\n        this._keyPath = keyPath;\n        this._multiEntry = multiEntry;\n        this._unique = unique;\n        this._tree = new BTree();\n    }\n\n    /**\n     * Reinitialises the index.\n     */\n    truncate() {\n        this._tree = new BTree();\n    }\n\n    /**\n     * Helper method to return the attribute associated with the key path if it exists.\n     * @param {string} key The primary key of the key-value pair.\n     * @param {*} obj The value of the key-value pair.\n     * @returns {*} The attribute associated with the key path, if it exists, and undefined otherwise.\n     * @private\n     */\n    _indexKey(key, obj) {\n        if (obj === undefined) return undefined;\n        if (this.keyPath) {\n            return ObjectUtils.byKeyPath(obj, this.keyPath);\n        }\n        return key;\n    }\n\n    /**\n     * The key path associated with this index.\n     * A key path is defined by a key within the object or alternatively a path through the object to a specific subkey.\n     * For example, ['a', 'b'] could be used to use 'key' as the key in the following object:\n     * { 'a': { 'b': 'key' } }\n     * If the keyPath is undefined, this index uses the primary key of the key-value store.\n     * @type {string|Array.<string>}\n     */\n    get keyPath() {\n        return this._keyPath;\n    }\n\n    /**\n     * This value determines whether the index supports multiple secondary keys per entry.\n     * If so, the value at the key path is considered to be an iterable.\n     * @type {boolean}\n     */\n    get multiEntry() {\n        return this._multiEntry;\n    }\n\n    /**\n     * This value determines whether the index is a unique constraint.\n     * @type {boolean}\n     */\n    get unique() {\n        return this._unique;\n    }\n\n    /**\n     * A helper method to insert a primary-secondary key pair into the tree.\n     * @param {string} key The primary key.\n     * @param {*} iKey The indexed key.\n     * @throws if the uniqueness constraint is violated.\n     */\n    _insert(key, iKey) {\n        const tree = this._tree;\n        if (!this._multiEntry || !Array.isArray(iKey)) {\n            iKey = [iKey];\n        }\n        // Add all keys.\n        for (const component of iKey) {\n            if (tree.seek(component)) {\n                if (this._unique) {\n                    throw new Error(`Uniqueness constraint violated for key ${key} on path ${this._keyPath}`);\n                }\n                (/** @type {SortedList} */ tree.currentRecord).add(key);\n            } else {\n                tree.insert(component, this._unique ? key : new SortedList([key], ComparisonUtils.compare));\n            }\n        }\n    }\n\n    /**\n     * Inserts a new key-value pair into the index.\n     * For replacing an existing pair, the old value has to be passed as well.\n     * @param {string} key The primary key of the pair.\n     * @param {*} value The value of the pair. The indexed key will be extracted from this.\n     * @param {*} [oldValue] The old value associated with the primary key.\n     */\n    put(key, value, oldValue) {\n        const oldIKey = this._indexKey(key, oldValue);\n        const newIKey = this._indexKey(key, value);\n\n        if (!ComparisonUtils.equals(oldIKey, newIKey)) {\n            if (oldIKey !== undefined) {\n                this._remove(key, oldIKey);\n            }\n            if (newIKey !== undefined) {\n                this._insert(key, newIKey);\n            }\n        }\n    }\n\n    /**\n     * Removes a key-value pair from the index.\n     * @param {string} key The primary key of the pair.\n     * @param {*} oldValue The old value of the pair. The indexed key will be extracted from this.\n     */\n    remove(key, oldValue) {\n        const iKey = this._indexKey(key, oldValue);\n        if (iKey !== undefined) {\n            this._remove(key, iKey);\n        }\n    }\n\n    /**\n     * A helper method to remove a primary-secondary key pair from the tree.\n     * @param {string} key The primary key.\n     * @param {*} iKey The indexed key.\n     */\n    _remove(key, iKey) {\n        const tree = this._tree;\n        if (!this._multiEntry || !Array.isArray(iKey)) {\n            iKey = [iKey];\n        }\n        // Remove all keys.\n        for (const component of iKey) {\n            if (tree.seek(component)) {\n                if (!this._unique && (/** @type {SortedList} */ tree.currentRecord).length > 1) {\n                    (/** @type {SortedList} */ tree.currentRecord).remove(key);\n                } else {\n                    tree.remove(component);\n                }\n            }\n        }\n    }\n\n    /**\n     * A helper method to retrieve the values corresponding to a set of keys.\n     * @param {Set.<string>} keys The set of keys to get the corresponding values for.\n     * @returns {Promise.<Array.<*>>} A promise of the array of values.\n     * @protected\n     */\n    async _retrieveValues(keys) {\n        const valuePromises = [];\n        for (const key of keys) {\n            valuePromises.push(this._objectStore.get(key));\n        }\n        return Promise.all(valuePromises);\n    }\n\n    /**\n     * Returns a promise of an array of objects whose secondary keys fulfill the given query.\n     * If the optional query is not given, it returns all objects in the index.\n     * If the query is of type KeyRange, it returns all objects whose secondary keys are within this range.\n     * @param {KeyRange} [query] Optional query to check secondary keys against.\n     * @param {number} [limit] Limits the number of results if given.\n     * @returns {Promise.<Array.<*>>} A promise of the array of objects relevant to the query.\n     */\n    async values(query = null, limit = null) {\n        const keys = await this.keys(query, limit);\n        return this._retrieveValues(keys);\n    }\n\n    /**\n     * Returns a promise of a set of primary keys, whose associated objects' secondary keys are in the given range.\n     * If the optional query is not given, it returns all primary keys in the index.\n     * If the query is of type KeyRange, it returns all primary keys for which the secondary key is within this range.\n     * @param {KeyRange} [query] Optional query to check the secondary keys against.\n     * @param {number} [limit] Limits the number of results if given.\n     * @returns {Promise.<Set.<string>>} A promise of the set of primary keys relevant to the query.\n     */\n    async keys(query = null, limit = null) {\n        let resultSet = new Set();\n\n        // Shortcut for exact match.\n        if (query instanceof KeyRange && query.exactMatch) {\n            if (this._tree.seek(query.lower)) {\n                resultSet = Set.from(this._tree.currentRecord);\n            }\n            return resultSet.limit(limit);\n        }\n\n        // Find lower bound and start from there.\n        if (!(query instanceof KeyRange)) {\n            if (!this._tree.goTop()) {\n                return resultSet; // Empty\n            }\n        } else {\n            if (!this._tree.goToLowerBound(query.lower, query.lowerOpen)) {\n                return resultSet; // empty\n            }\n        }\n\n        while (!(query instanceof KeyRange) || query.includes(this._tree.currentKey)) {\n            // Limit\n            if (limit !== null && resultSet.size >= limit) {\n                break;\n            }\n\n            resultSet = resultSet.union(Set.from(this._tree.currentRecord));\n            if (!this._tree.skip()) {\n                break;\n            }\n        }\n        return resultSet.limit(limit);\n    }\n\n    /**\n     * Iterates over the primary keys in a given range of secondary keys and direction.\n     * The order is determined by the secondary keys first and by the primary keys second.\n     * The callback is called for each primary key fulfilling the query\n     * until it returns false and stops the iteration.\n     * @param {function(key:string):boolean} callback A predicate called for each key until returning false.\n     * @param {boolean} ascending Determines the direction of traversal.\n     * @param {KeyRange} query An optional KeyRange to narrow down the iteration space.\n     * @returns {Promise} The promise resolves after all elements have been streamed.\n     */\n    keyStream(callback, ascending=true, query=null) {\n        // Find lower bound and start from there.\n        if (!(query instanceof KeyRange)) {\n            if (ascending) {\n                if (!this._tree.goTop()) {\n                    return Promise.resolve();\n                }\n            } else {\n                if (!this._tree.goBottom()) {\n                    return Promise.resolve();\n                }\n            }\n        } else {\n            if (ascending) {\n                if (!this._tree.goToLowerBound(query.lower, query.lowerOpen)) {\n                    return Promise.resolve();\n                }\n            } else {\n                if (!this._tree.goToUpperBound(query.upper, query.upperOpen)) {\n                    return Promise.resolve();\n                }\n            }\n        }\n\n        outer:\n        while (!(query instanceof KeyRange) || query.includes(this._tree.currentKey)) {\n            if (this._unique) {\n                // Check unique entry\n                if (!callback(this._tree.currentRecord)) break;\n            } else {\n                // Check all entries\n                const keys = this._tree.currentRecord.values();\n                if (ascending) {\n                    for (let i = 0; i < keys.length; i++) {\n                        if (!callback(keys[i])) {\n                            break outer;\n                        }\n                    }\n                } else {\n                    for (let i = keys.length - 1; i >= 0; i--) {\n                        if (!callback(keys[i])) {\n                            break outer;\n                        }\n                    }\n                }\n            }\n\n            if (!this._tree.skip(ascending ? 1 : -1)) {\n                break;\n            }\n        }\n        return Promise.resolve();\n    }\n\n    /**\n     * Iterates over the values of the store in a given range of secondary keys and direction.\n     * The order is determined by the secondary keys first and by the primary keys second.\n     * The callback is called for each value and primary key fulfilling the query\n     * until it returns false and stops the iteration.\n     * @param {function(value:*, key:string):boolean} callback A predicate called for each value and key until returning false.\n     * @param {boolean} ascending Determines the direction of traversal.\n     * @param {KeyRange} query An optional KeyRange to narrow down the iteration space.\n     * @returns {Promise} The promise resolved after all elements have been streamed.\n     */\n    async valueStream(callback, ascending=true, query=null) {\n        // Find lower bound and start from there.\n        if (!(query instanceof KeyRange)) {\n            if (ascending) {\n                if (!this._tree.goTop()) {\n                    return;\n                }\n            } else {\n                if (!this._tree.goBottom()) {\n                    return;\n                }\n            }\n        } else {\n            if (ascending) {\n                if (!this._tree.goToLowerBound(query.lower, query.lowerOpen)) {\n                    return;\n                }\n            } else {\n                if (!this._tree.goToUpperBound(query.upper, query.upperOpen)) {\n                    return;\n                }\n            }\n        }\n\n        outer:\n        while (!(query instanceof KeyRange) || query.includes(this._tree.currentKey)) {\n            if (this._unique) {\n                // Check unique entry\n                if (!callback(await this._objectStore.get(this._tree.currentRecord), this._tree.currentRecord)) break; // eslint-disable-line no-await-in-loop\n            } else {\n                // Check all entries\n                const keys = this._tree.currentRecord.values();\n                if (ascending) {\n                    for (let i = 0; i < keys.length; i++) {\n                        if (!callback(await this._objectStore.get(keys[i]), keys[i])) { // eslint-disable-line no-await-in-loop\n                            break outer;\n                        }\n                    }\n                } else {\n                    for (let i = keys.length - 1; i >= 0; i--) {\n                        if (!callback(await this._objectStore.get(keys[i]), keys[i])) { // eslint-disable-line no-await-in-loop\n                            break outer;\n                        }\n                    }\n                }\n            }\n\n            if (!this._tree.skip(ascending ? 1 : -1)) {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Returns a promise of an array of objects whose secondary key is maximal for the given range.\n     * If the optional query is not given, it returns the objects whose secondary key is maximal within the index.\n     * If the query is of type KeyRange, it returns the objects whose secondary key is maximal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<Array.<*>>} A promise of array of objects relevant to the query.\n     */\n    async maxValues(query=null) {\n        const keys = await this.maxKeys(query);\n        return this._retrieveValues(keys);\n    }\n\n    /**\n     * Returns a promise of a set of primary keys, whose associated secondary keys are maximal for the given range.\n     * If the optional query is not given, it returns the set of primary keys, whose associated secondary key is maximal within the index.\n     * If the query is of type KeyRange, it returns the set of primary keys, whose associated secondary key is maximal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<Set.<*>>} A promise of the key relevant to the query.\n     */\n    async maxKeys(query=null) {\n        const isRange = query instanceof KeyRange;\n        if (!this._tree.goToUpperBound(isRange ? query.upper : undefined, isRange ? query.upperOpen : false)) {\n            return new Set();\n        }\n        return Set.from(this._tree.currentRecord);\n    }\n\n    /**\n     * Returns a promise of an array of objects whose secondary key is minimal for the given range.\n     * If the optional query is not given, it returns the objects whose secondary key is minimal within the index.\n     * If the query is of type KeyRange, it returns the objects whose secondary key is minimal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<Array.<*>>} A promise of array of objects relevant to the query.\n     */\n    async minValues(query=null) {\n        const keys = await this.minKeys(query);\n        return this._retrieveValues(keys);\n    }\n\n    /**\n     * Returns a promise of a set of primary keys, whose associated secondary keys are minimal for the given range.\n     * If the optional query is not given, it returns the set of primary keys, whose associated secondary key is minimal within the index.\n     * If the query is of type KeyRange, it returns the set of primary keys, whose associated secondary key is minimal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<Set.<*>>} A promise of the key relevant to the query.\n     */\n    async minKeys(query=null) {\n        const isRange = query instanceof KeyRange;\n        if (!this._tree.goToLowerBound(isRange ? query.lower : undefined, isRange ? query.lowerOpen : false)) {\n            return new Set();\n        }\n        return Set.from(this._tree.currentRecord);\n    }\n\n    /**\n     * Returns the count of entries, whose secondary key is in the given range.\n     * If the optional query is not given, it returns the count of entries in the index.\n     * If the query is of type KeyRange, it returns the count of entries, whose secondary key is within the given range.\n     * @param {KeyRange} [query]\n     * @returns {Promise.<number>}\n     */\n    async count(query=null) {\n        return (await this.keys(query)).size;\n        // The code below does only work for unique indices.\n        // if (!(query instanceof KeyRange)) {\n        //     return this._tree.length;\n        // }\n        // if (!this._tree.goToLowerBound(query.lower, query.lowerOpen)) {\n        //     return 0;\n        // }\n        // const start = this._tree.keynum();\n        // if (!this._tree.goToUpperBound(query.upper, query.upperOpen)) {\n        //     return 0;\n        // }\n        // const end = this._tree.keynum();\n        // return end - start + 1;\n    }\n}\nClass.register(InMemoryIndex);\n\n","/**\n * Transactions are created by calling the transaction method on an ObjectStore object.\n * Transactions ensure read-isolation.\n * On a given state, only *one* transaction can be committed successfully.\n * Other transactions based on the same state will end up in a conflicted state if committed.\n * Transactions opened after the successful commit of another transaction will be based on the\n * new state and hence can be committed again.\n * @implements {IBackend}\n * @implements {ISynchronousObjectStore}\n */\nclass InMemoryBackend {\n    constructor(tableName, codec=null) {\n        this._cache = new Map();\n\n        /** @type {Map.<string,InMemoryIndex>} */\n        this._indices = new Map();\n\n        this._primaryIndex = new InMemoryIndex(this, /*keyPath*/ undefined, /*multiEntry*/ false, /*unique*/ true);\n        this._tableName = tableName;\n        this._codec = codec;\n    }\n\n    /** @type {boolean} */\n    get connected() {\n        return true;\n    }\n\n    /**\n     * @type {Map.<string,IIndex>}\n     */\n    get indices() {\n        return this._indices;\n    }\n\n    /**\n     * Returns the object stored under the given primary key.\n     * Resolves to undefined if the key is not present in the object store.\n     * @abstract\n     * @param {string} key The primary key to look for.\n     * @param {SyncRetrievalConfig} [options] Advanced retrieval options.\n     * @returns {*} The object stored under the given key, or undefined if not present.\n     */\n    getSync(key, options = {}) {\n        // Ignore expectPresence here, since it is a non-cached synchronous backend!\n        const value = this._cache.get(key);\n        return (options && options.raw) ? value : this.decode(value, key);\n    }\n\n    /**\n     * @param {string} key\n     * @param {RetrievalConfig} [options] Advanced retrieval options.\n     * @returns {Promise.<*>}\n     */\n    get(key, options = {}) {\n        try {\n            return Promise.resolve(this.getSync(key, options));\n        } catch(e) {\n            return Promise.reject(e);\n        }\n    }\n\n    /**\n     * @param {Query|KeyRange} [query]\n     * @param {number} [limit]\n     * @returns {Promise.<Array.<*>>}\n     */\n    async values(query = null, limit = null) {\n        if (query !== null && query instanceof Query) {\n            return query.values(this, limit);\n        }\n        const values = [];\n        for (const key of await this.keys(query, limit)) {\n            values.push(await this.get(key));\n        }\n        return Promise.resolve(values);\n    }\n\n    /**\n     * @param {Query|KeyRange} [query]\n     * @param {number} [limit]\n     * @returns {Promise.<Set.<string>>}\n     */\n    keys(query = null, limit = null) {\n        if (query !== null && query instanceof Query) {\n            return query.keys(this, limit);\n        }\n        return this._primaryIndex.keys(query, limit);\n    }\n\n    /**\n     * Iterates over the keys in a given range and direction.\n     * The callback is called for each primary key fulfilling the query\n     * until it returns false and stops the iteration.\n     * @param {function(key:string):boolean} callback A predicate called for each key until returning false.\n     * @param {boolean} ascending Determines the direction of traversal.\n     * @param {KeyRange} query An optional KeyRange to narrow down the iteration space.\n     * @returns {Promise} The promise resolves after all elements have been streamed.\n     */\n    keyStream(callback, ascending=true, query=null) {\n        return this._primaryIndex.keyStream(callback, ascending, query);\n    }\n\n    /**\n     * Iterates over the keys and values in a given range and direction.\n     * The callback is called for each value and primary key fulfilling the query\n     * until it returns false and stops the iteration.\n     * @param {function(value:*, key:string):boolean} callback A predicate called for each value and key until returning false.\n     * @param {boolean} ascending Determines the direction of traversal.\n     * @param {KeyRange} query An optional KeyRange to narrow down the iteration space.\n     * @returns {Promise} The promise resolves after all elements have been streamed.\n     */\n    valueStream(callback, ascending=true, query=null) {\n        return this._primaryIndex.valueStream(callback, ascending, query);\n    }\n\n    /**\n     * @param {KeyRange} [query]\n     * @returns {Promise.<*>}\n     */\n    async maxValue(query=null) {\n        const maxKey = await this.maxKey(query);\n        return this.get(maxKey);\n    }\n\n    /**\n     * @param {KeyRange} [query]\n     * @returns {Promise.<string>}\n     */\n    async maxKey(query=null) {\n        const keys = await this._primaryIndex.maxKeys(query);\n        return Set.sampleElement(keys);\n    }\n\n    /**\n     * @param {KeyRange} [query]\n     * @returns {Promise.<*>}\n     */\n    async minValue(query=null) {\n        const minKey = await this.minKey(query);\n        return this.get(minKey);\n    }\n\n    /**\n     * @param {KeyRange} [query]\n     * @returns {Promise.<string>}\n     */\n    async minKey(query=null) {\n        const keys = await this._primaryIndex.minKeys(query);\n        return Set.sampleElement(keys);\n    }\n\n    /**\n     * @param {KeyRange} [query]\n     * @returns {Promise.<number>}\n     */\n    async count(query=null) {\n        return (await this.keys(query)).size;\n    }\n\n    /**\n     * @param {string} indexName\n     * @returns {IIndex}\n     */\n    index(indexName) {\n        return this._indices.get(indexName);\n    }\n\n    /**\n     * @param {Transaction} tx\n     * @returns {Promise.<boolean>}\n     * @protected\n     */\n    async _apply(tx) {\n        if (tx._truncated) {\n            this.truncateSync();\n        }\n\n        const originalValues = new Map();\n\n        for (const key of tx._removed) {\n            const oldValue = this.getSync(key);\n            if (oldValue) {\n                originalValues.set(key, oldValue);\n            }\n            this._cache.delete(key);\n        }\n        for (const [key, value] of tx._modified) {\n            const oldValue = this.getSync(key);\n            if (oldValue) {\n                originalValues.set(key, oldValue);\n            }\n            this._cache.set(key, this.encode(value));\n        }\n\n        // Update all indices.\n        InMemoryBackend._indexApply(this._primaryIndex, tx, originalValues);\n        for (const index of this._indices.values()) {\n            InMemoryBackend._indexApply(index, tx, originalValues);\n        }\n    }\n\n    /**\n     * @param {InMemoryIndex} index\n     * @param {Transaction} tx\n     * @param {Map} originalValues\n     * @private\n     */\n    static _indexApply(index, tx, originalValues) {\n        if (tx._truncated) {\n            index.truncate();\n        }\n\n        for (const key of tx._removed) {\n            index.remove(key, originalValues.get(key));\n        }\n        for (const [key, value] of tx._modified) {\n            index.put(key, value, originalValues.get(key));\n        }\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    async truncate() {\n        this.truncateSync();\n    }\n\n    truncateSync() {\n        this._cache.clear();\n\n        // Truncate all indices.\n        this._primaryIndex.truncate();\n        for (const index of this._indices.values()) {\n            index.truncate();\n        }\n    }\n\n    /**\n     * @param {function(key:string, value:*)} func\n     * @returns {Promise}\n     */\n    async map(func) {\n        for (const [key, value] of this._cache) {\n            func(key, value);\n        }\n    }\n\n    /**\n     * @param {string} indexName The name of the index.\n     * @param {string|Array.<string>} [keyPath] The path to the key within the object. May be an array for multiple levels.\n     * @param {IndexConfig} [options] An options object.\n     */\n    createIndex(indexName, keyPath, options = {}) {\n        let { multiEntry = false, unique = false, upgradeCondition = null } = options || {};\n\n        keyPath = keyPath || indexName;\n        const index = new InMemoryIndex(this, keyPath, multiEntry, unique);\n        this._indices.set(indexName, index);\n    }\n\n    /**\n     * Deletes a secondary index from the object store.\n     * @param indexName\n     * @param {{upgradeCondition:?boolean|?function(oldVersion:number, newVersion:number):boolean}} [options]\n     */\n    deleteIndex(indexName, options = {}) {\n        let { upgradeCondition = null } = options || {};\n\n        this._indices.delete(indexName);\n    }\n\n    /**\n     * Method called to decode a single value.\n     * @param {*} value Value to be decoded.\n     * @param {string} key Key corresponding to the value.\n     * @returns {*} The decoded value.\n     */\n    decode(value, key) {\n        if (value === undefined) {\n            return undefined;\n        }\n        if (this._codec !== null && this._codec !== undefined) {\n            return this._codec.decode(value, key);\n        }\n        return value;\n    }\n\n    /**\n     * Method called to encode a single value.\n     * @param {*} value Value to be encoded.\n     * @returns {*} The encoded value.\n     */\n    encode(value) {\n        if (value === undefined) {\n            return undefined;\n        }\n        if (this._codec !== null && this._codec !== undefined) {\n            return this._codec.encode(value);\n        }\n        return value;\n    }\n\n    /** @type {string} The own table name. */\n    get tableName() {\n        return this._tableName;\n    }\n\n    /**\n     * Returns the necessary information in order to flush a combined transaction.\n     * @param {Transaction} tx The transaction that should be applied to this backend.\n     * @returns {Promise.<*|function():Promise>} Either the tableName if this is a native, persistent backend\n     * or a function that effectively applies the transaction to non-persistent backends.\n     */\n    async applyCombined(tx) {\n        return () => this._apply(tx);\n    }\n\n    /**\n     * Checks whether an object store implements the ISynchronousObjectStore interface.\n     * @returns {boolean} The transaction object.\n     */\n    isSynchronous() {\n        return true;\n    }\n\n    /**\n     * A check whether a certain key is cached.\n     * @param {string} key The key to check.\n     * @return {boolean} A boolean indicating whether the key is already in the cache.\n     */\n    isCached(key) {\n        return true;\n    }\n}\nClass.register(InMemoryBackend);\n","/**\n * This class represents range queries on an index (primary and secondary).\n */\nclass KeyRange {\n    /**\n     * This constructor is only used internally.\n     * See static methods for constructing a KeyRange object.\n     * @param {*} lower\n     * @param {*} upper\n     * @param {boolean} lowerOpen\n     * @param {boolean} upperOpen\n     * @private\n     */\n    constructor(lower, upper, lowerOpen, upperOpen) {\n        this._lower = lower;\n        this._upper = upper;\n        this._lowerOpen = lowerOpen;\n        this._upperOpen = upperOpen;\n    }\n\n    /** @type {*} The lower bound of the range. */\n    get lower() {\n        return this._lower;\n    }\n\n    /** @type {*} The upper bound of the range. */\n    get upper() {\n        return this._upper;\n    }\n\n    /** @type {boolean} Whether the lower bound is NOT part of the range. */\n    get lowerOpen() {\n        return this._lowerOpen;\n    }\n\n    /** @type {boolean} Whether the upper bound is NOT part of the range. */\n    get upperOpen() {\n        return this._upperOpen;\n    }\n\n    /** @type {boolean} Whether it is a query for an exact match. */\n    get exactMatch() {\n        return this._lower === this._upper && !this._lowerOpen && !this.upperOpen;\n    }\n\n    /**\n     * Returns true if the given key is included in this range.\n     * @param {*} key The key to test for.\n     * @returns {boolean} True, if the key is included in the range and false otherwise.\n     */\n    includes(key) {\n        return (this._lower === undefined\n                || ComparisonUtils.compare(this._lower, key) < 0\n                || (!this._lowerOpen && ComparisonUtils.equals(this._lower, key)))\n            && (this._upper === undefined\n                || ComparisonUtils.compare(this._upper, key) > 0\n                || (!this._upperOpen && ComparisonUtils.equals(this._upper, key)));\n    }\n\n    /**\n     * If upperOpen is false, all keys  upper,\n     * all keys < upper otherwise.\n     * @param {*} upper The upper bound.\n     * @param {boolean} upperOpen Whether the upper bound is NOT part of the range.\n     * @returns {KeyRange} The corresponding KeyRange object.\n     */\n    static upperBound(upper, upperOpen=false) {\n        return new KeyRange(undefined, upper, false, upperOpen);\n    }\n\n    /**\n     * If lowerOpen is false, all keys  lower,\n     * all keys > lower otherwise.\n     * @param {*} lower The lower bound.\n     * @param {boolean} lowerOpen Whether the lower bound is NOT part of the range.\n     * @returns {KeyRange} The corresponding KeyRange object.\n     */\n    static lowerBound(lower, lowerOpen=false) {\n        return new KeyRange(lower, undefined, lowerOpen, false);\n    }\n\n    /**\n     * A range bounded by both a lower and upper bound.\n     * lowerOpen and upperOpen decide upon whether < (open) or  (inclusive) comparisons\n     * should be used for comparison.\n     * @param {*} lower The lower bound.\n     * @param {*} upper The upper bound.\n     * @param {boolean} lowerOpen Whether the lower bound is NOT part of the range.\n     * @param {boolean} upperOpen Whether the upper bound is NOT part of the range.\n     * @returns {KeyRange} The corresponding KeyRange object.\n     */\n    static bound(lower, upper, lowerOpen=false, upperOpen=false) {\n        return new KeyRange(lower, upper, lowerOpen, upperOpen);\n    }\n\n    /**\n     * A range matching only exactly one value.\n     * @param {*} value The value to match.\n     * @returns {KeyRange} The corresponding KeyRange object.\n     */\n    static only(value) {\n        return new KeyRange(value, value, false, false);\n    }\n}\nClass.register(KeyRange);\n","/**\n * This is the main implementation of an object store.\n * It uses a specified backend (which itself implements the very same interface)\n * and builds upon this backend to answer queries.\n * The main task of this object store is to manage transactions\n * and ensure read isolation on these transactions.\n * @implements {IObjectStore}\n * @implements {ICommittable}\n */\nclass ObjectStore {\n    /**\n     * Creates a new object store based on a backend and an underlying database.\n     * The database is only used to determine the connection status.\n     * @param {IBackend} backend The backend underlying this object store.\n     * @param {JungleDB} db The database underlying the backend.\n     * @param {string} [name] The name of the object store if existent.\n     */\n    constructor(backend, db, name) {\n        this._backend = backend;\n        this._db = db;\n        this._name = name;\n        /** @type {Array.<TransactionInfo>} */\n        this._stateStack = [];\n        this._backendInfo = new TransactionInfo(this._backend, null);\n        /**\n         * Maps transactions to their TransactionInfo objects.\n         * @type {Map.<number|string,TransactionInfo>}\n         */\n        this._transactions = new Map();\n        this._transactions.set(ObjectStore.BACKEND_ID, this._backendInfo);\n\n        /**\n         * The set of currently open snapshots.\n         * @type {Set.<Snapshot>}\n         */\n        this._snapshotManager = new SnapshotManager();\n\n        this._synchronizer = new Synchronizer();\n    }\n\n    /** @type {JungleDB} */\n    get jungleDB() {\n        return this._db;\n    }\n\n    /** @type {boolean} */\n    get connected() {\n        return this._backend.connected;\n    }\n\n    /** @type {IObjectStore} */\n    get _currentState() {\n        return this._stateStack.length > 0 ? this._stateStack[this._stateStack.length - 1].transaction : this._backend;\n    }\n\n    /** @type {TransactionInfo} */\n    get _currentStateInfo() {\n        return this._stateStack.length > 0 ? this._stateStack[this._stateStack.length - 1] : this._backendInfo;\n    }\n\n    /** @type {number|string} */\n    get _currentStateId() {\n        return this._stateStack.length > 0 ? this._stateStack[this._stateStack.length - 1].id : ObjectStore.BACKEND_ID;\n    }\n\n    /**\n     * A map of index names to indices.\n     * The index names can be used to access an index.\n     * @type {Map.<string,IIndex>}\n     */\n    get indices() {\n        if (!this._backend.connected) throw new Error('JungleDB is not connected');\n        return this._currentState.indices;\n    }\n\n    /**\n     * Returns a promise of the object stored under the given primary key.\n     * Resolves to undefined if the key is not present in the object store.\n     * @param {string} key The primary key to look for.\n     * @param {RetrievalConfig} [options] Advanced retrieval options.\n     * @returns {Promise.<*>} A promise of the object stored under the given key, or undefined if not present.\n     */\n    get(key, options = {}) {\n        if (!this._backend.connected) throw new Error('JungleDB is not connected');\n        return this._currentState.get(key, options);\n    }\n\n    /**\n     * Inserts or replaces a key-value pair.\n     * Implicitly creates a transaction for this operation and commits it.\n     * @param {string} key The primary key to associate the value with.\n     * @param {*} value The value to write.\n     * @returns {Promise.<boolean>} A promise of the success outcome.\n     */\n    async put(key, value) {\n        if (!this._backend.connected) throw new Error('JungleDB is not connected');\n        const tx = this.transaction();\n        try {\n            await tx.put(key, value);\n        } catch (err) {\n            await tx.abort();\n            throw err;\n        }\n        return tx.commit();\n    }\n\n    /**\n     * Removes the key-value pair of the given key from the object store.\n     * Implicitly creates a transaction for this operation and commits it.\n     * @param {string} key The primary key to delete along with the associated object.\n     * @returns {Promise.<boolean>} A promise of the success outcome.\n     */\n    async remove(key) {\n        if (!this._backend.connected) throw new Error('JungleDB is not connected');\n        const tx = this.transaction();\n        try {\n            await tx.remove(key);\n        } catch (err) {\n            await tx.abort();\n            throw err;\n        }\n        return tx.commit();\n    }\n\n    /**\n     * Returns the object stored under the given primary key.\n     * Resolves to undefined if the key is not present in the object store.\n     * @param {string} key The primary key to look for.\n     * @param {SyncRetrievalConfig} [options] Advanced retrieval options.\n     * @returns {*} The object stored under the given key, or undefined if not present.\n     */\n    getSync(key, options = {}) {\n        if (!this._backend.connected) throw new Error('JungleDB is not connected');\n        if (!this._currentState.isSynchronous()) throw new Error('Only works on synchronous backends');\n        return this._currentState.getSync(key, options);\n    }\n\n    /**\n     * A check whether a certain key is cached.\n     * @param {string} key The key to check.\n     * @return {boolean} A boolean indicating whether the key is already in the cache.\n     */\n    isCached(key) {\n        if (!this._backend.connected) throw new Error('JungleDB is not connected');\n        if (!this._currentState.isSynchronous()) throw new Error('Only works on synchronous backends');\n        return this._currentState.isCached(key);\n    }\n\n    /**\n     * Returns a promise of a set of keys fulfilling the given query.\n     * If the optional query is not given, it returns all keys in the object store.\n     * If the query is of type KeyRange, it returns all keys of the object store being within this range.\n     * If the query is of type Query, it returns all keys fulfilling the query.\n     * @param {Query|KeyRange} [query] Optional query to check keys against.\n     * @param {number} [limit] Limits the number of results if given.\n     * @returns {Promise.<Set.<string>>} A promise of the set of keys relevant to the query.\n     */\n    keys(query = null, limit = null) {\n        if (!this._backend.connected) throw new Error('JungleDB is not connected');\n        if (query !== null && query instanceof Query) {\n            return query.keys(this._currentState, limit);\n        }\n        return this._currentState.keys(query, limit);\n    }\n\n    /**\n     * Returns a promise of an array of objects whose primary keys fulfill the given query.\n     * If the optional query is not given, it returns all objects in the object store.\n     * If the query is of type KeyRange, it returns all objects whose primary keys are within this range.\n     * If the query is of type Query, it returns all objects whose primary keys fulfill the query.\n     * @param {Query|KeyRange} [query] Optional query to check keys against.\n     * @param {number} [limit] Limits the number of results if given.\n     * @returns {Promise.<Array.<*>>} A promise of the array of objects relevant to the query.\n     */\n    values(query = null, limit = null) {\n        if (!this._backend.connected) throw new Error('JungleDB is not connected');\n        if (query !== null && query instanceof Query) {\n            return query.values(this._currentState, limit);\n        }\n        return this._currentState.values(query, limit);\n    }\n\n    /**\n     * Iterates over the keys in a given range and direction.\n     * The callback is called for each primary key fulfilling the query\n     * until it returns false and stops the iteration.\n     * @param {function(key:string):boolean} callback A predicate called for each key until returning false.\n     * @param {boolean} ascending Determines the direction of traversal.\n     * @param {KeyRange} query An optional KeyRange to narrow down the iteration space.\n     * @returns {Promise} The promise resolves after all elements have been streamed.\n     */\n    keyStream(callback, ascending=true, query=null) {\n        return this._currentState.keyStream(callback, ascending, query);\n    }\n\n    /**\n     * Iterates over the keys and values in a given range and direction.\n     * The callback is called for each value and primary key fulfilling the query\n     * until it returns false and stops the iteration.\n     * @param {function(value:*, key:string):boolean} callback A predicate called for each value and key until returning false.\n     * @param {boolean} ascending Determines the direction of traversal.\n     * @param {KeyRange} query An optional KeyRange to narrow down the iteration space.\n     * @returns {Promise} The promise resolves after all elements have been streamed.\n     */\n    valueStream(callback, ascending=true, query=null) {\n        return this._currentState.valueStream(callback, ascending, query);\n    }\n\n    /**\n     * Returns a promise of the object whose primary key is maximal for the given range.\n     * If the optional query is not given, it returns the object whose key is maximal.\n     * If the query is of type KeyRange, it returns the object whose primary key is maximal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<*>} A promise of the object relevant to the query.\n     */\n    maxValue(query=null) {\n        if (!this._backend.connected) throw new Error('JungleDB is not connected');\n        return this._currentState.maxValue(query);\n    }\n\n    /**\n     * Returns a promise of the key being maximal for the given range.\n     * If the optional query is not given, it returns the maximal key.\n     * If the query is of type KeyRange, it returns the key being maximal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<string>} A promise of the key relevant to the query.\n     */\n    maxKey(query=null) {\n        if (!this._backend.connected) throw new Error('JungleDB is not connected');\n        return this._currentState.maxKey(query);\n    }\n\n    /**\n     * Returns a promise of the key being minimal for the given range.\n     * If the optional query is not given, it returns the minimal key.\n     * If the query is of type KeyRange, it returns the key being minimal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<string>} A promise of the key relevant to the query.\n     */\n    minKey(query=null) {\n        if (!this._backend.connected) throw new Error('JungleDB is not connected');\n        return this._currentState.minKey(query);\n    }\n\n    /**\n     * Returns a promise of the object whose primary key is minimal for the given range.\n     * If the optional query is not given, it returns the object whose key is minimal.\n     * If the query is of type KeyRange, it returns the object whose primary key is minimal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<*>} A promise of the object relevant to the query.\n     */\n    minValue(query=null) {\n        if (!this._backend.connected) throw new Error('JungleDB is not connected');\n        return this._currentState.minValue(query);\n    }\n\n    /**\n     * Returns the count of entries in the given range.\n     * If the optional query is not given, it returns the count of entries in the object store.\n     * If the query is of type KeyRange, it returns the count of entries within the given range.\n     * @param {KeyRange} [query]\n     * @returns {Promise.<number>}\n     */\n    count(query=null) {\n        if (!this._backend.connected) throw new Error('JungleDB is not connected');\n        return this._currentState.count(query);\n    }\n\n    /**\n     * This method is only used by transactions internally to commit themselves to the corresponding object store.\n     * Thus, the tx argument is non-optional.\n     * A call to this method checks whether the given transaction can be applied and pushes it to\n     * the stack of applied transactions. When there is no other transaction requiring to enforce\n     * read isolation, the state will be flattened and all transactions will be applied to the backend.\n     * @param {Transaction} tx The transaction to be applied.\n     * @returns {Promise.<boolean>} A promise of the success outcome.\n     * @protected\n     */\n    async commit(tx) {\n        if (!this._isCommittable(tx)) {\n            await this.abort(tx);\n            return false;\n        }\n        await this._commitInternal(tx);\n        return true;\n    }\n\n    /**\n     * Is used to probe whether a transaction can be committed.\n     * This, for example, includes a check whether another transaction has already been committed.\n     * @protected\n     * @param {Transaction} tx The transaction to be applied.\n     * @returns {boolean} Whether a commit will be successful.\n     */\n    _isCommittable(tx) {\n        if (!this._backend.connected) throw new Error('JungleDB is not connected');\n        if (!(tx instanceof Transaction) || tx.state !== Transaction.STATE.OPEN || !this._transactions.has(tx.id)) {\n            throw new Error('Can only commit open transactions');\n        }\n\n        const info = this._transactions.get(tx.id);\n\n        // Another transaction was already committed.\n        return info.isCommittable();\n    }\n\n    /**\n     * Commits the transaction to the backend.\n     * @returns {Promise.<boolean>} A promise of the success outcome.\n     * @protected\n     */\n    async _commitBackend() {\n        throw new Error('Cannot commit object stores');\n    }\n\n    /**\n     * Is used to commit the transaction.\n     * @protected\n     * @param {Transaction} tx The transaction to be applied.\n     * @returns {Promise} A promise that resolves upon successful application of the transaction.\n     */\n    async _commitInternal(tx) {\n        const info = this._transactions.get(tx.id);\n\n        // Create new layer on stack (might be immediately removed by a state flattening).\n        if (this._stateStack.length >= ObjectStore.MAX_STACK_SIZE) {\n            Log.e(ObjectStore, `Transaction stack size exceeded ${this.toStringFull()}`);\n            throw new Error('Transaction stack size exceeded');\n        }\n        this._stateStack.push(info);\n        info.close();\n\n        // If this is the last transaction, we push our changes to the underlying layer.\n        // This only works if the given transaction does not have dependencies or the current state is the backend.\n        if (info.isFlushable()) {\n            // The underlying layer *has to be* the last one in our stack.\n            await this._flattenState(tx);\n        }\n    }\n\n    /**\n     * Allows to change the backend of a Transaction when the state has been flushed.\n     * @param parent\n     * @protected\n     */\n    _setParent(parent) {\n        throw new Error('Unsupported operation');\n    }\n\n    /**\n     * This method is only used by transactions internally to abort themselves at the corresponding object store.\n     * Thus, the tx argument is non-optional.\n     * @param {Transaction} tx The transaction to be aborted.\n     * @returns {Promise.<boolean>} A promise of the success outcome.\n     * @protected\n     */\n    async abort(tx) {\n        if (!this._backend.connected) throw new Error('JungleDB is not connected');\n\n        if (tx instanceof Snapshot) {\n            return this._snapshotManager.abortSnapshot(tx);\n        }\n\n        if (!(tx instanceof Transaction) || tx.state !== Transaction.STATE.OPEN || !this._transactions.has(tx.id)) {\n            throw new Error('Can only abort open transactions');\n        }\n        const info = this._transactions.get(tx.id);\n        info.abort();\n\n        // If this abortion resolves a conflict, try flattening the state.\n        if (info.parent && info.parent.numOpenChildren === 0) {\n            await this._flattenState();\n        }\n        return true;\n    }\n\n    /**\n     * This internal method applies a transaction to the current state\n     * and tries flattening the stack of transactions.\n     * @param {Transaction} [tx] An optional transaction to apply to the current state.\n     * @returns {Promise.<boolean>} If a tx is given, this boolean indicates whether the state has been merged.\n     * If tx is not given, the return value is false and does not convey a meaning.\n     * @private\n     */\n    _flattenState(tx) {\n        return this._synchronizer.push(() => this._flattenStateInternal(tx));\n    }\n\n    /**\n     * This internal method applies a transaction to the current state\n     * and tries flattening the stack of transactions.\n     * @param {Transaction} [tx] An optional transaction to apply to the current state.\n     * @returns {Promise.<boolean>} If a tx is given, this boolean indicates whether the state has been merged.\n     * If tx is not given, the return value is false and does not convey a meaning.\n     * @private\n     */\n    async _flattenStateInternal(tx) {\n        // If there is a tx argument, merge it with the current state.\n        if (tx && (tx instanceof Transaction)) {\n            // Check whether the state can be flattened.\n            // For this, the following conditions have to hold:\n            // 1. the base state does not have open transactions\n            const info = this._transactions.get(tx.id);\n            if (!info.isFlushable()) {\n                return false;\n            }\n\n            // Applying is possible.\n            // We apply it first and upon successful application, we update transactions.\n            // This way, we ensure that intermediate reads still work and that transactions\n            // are still consistent even if the application fails.\n            const backend = info.parent.transaction;\n            const cleanup = () => {\n                // Change pointers in child transactions.\n                info.flush();\n                this._transactions.delete(tx.id);\n\n                // Look for tx on stack and remove it.\n                const statePosition = this._stateStack.indexOf(info);\n                if (statePosition >= 0) {\n                    this._stateStack.splice(statePosition, 1);\n                }\n\n                this._flattenState().catch(Log.w.tag(ObjectStore));\n            };\n\n            if (tx.dependency === null) {\n                // If we apply to the backend, update the snapshots.\n                if (info.parent.isBackend()) {\n                    await this._snapshotManager.applyTx(tx, backend);\n                }\n                try {\n                    await backend._apply(tx);\n                } catch (err) {\n                    // Change pointers in child transactions.\n                    info.abort();\n                    this._transactions.delete(tx.id);\n\n                    // Look for tx on stack and remove it.\n                    const statePosition = this._stateStack.indexOf(info);\n                    if (statePosition >= 0) {\n                        this._stateStack.splice(statePosition, 1);\n                    }\n                    tx._setAborted();\n                    Log.e(ObjectStore, 'Error while applying transaction', err);\n                }\n                cleanup();\n                return true;\n            } else {\n                // We apply to the backend, so also update snapshots before the flush.\n                return await tx.dependency.onFlushable(tx, cleanup, () => this._snapshotManager.applyTx(tx, backend));\n            }\n        } else {\n            // Check both ends of the stack.\n            // Start with the easy part: The last state.\n            // Start flattening at the end.\n            while (this._stateStack.length > 0) {\n                if (!(await this._flattenStateInternal(this._currentState))) {\n                    break;\n                }\n            }\n            // Then try flattening from the start.\n            while (this._stateStack.length > 0) {\n                if (!(await this._flattenStateInternal(this._stateStack[0].transaction))) {\n                    break;\n                }\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Returns the index of the given name.\n     * If the index does not exist, it returns undefined.\n     * @param {string} indexName The name of the requested index.\n     * @returns {IIndex} The index associated with the given name.\n     */\n    index(indexName) {\n        if (!this._backend.connected) throw new Error('JungleDB is not connected');\n        return this._currentState.index(indexName);\n    }\n\n    /**\n     * Creates a new secondary index on the object store.\n     * Currently, all secondary indices are non-unique.\n     * They are defined by a key within the object or alternatively a path through the object to a specific subkey.\n     * For example, ['a', 'b'] could be used to use 'key' as the key in the following object:\n     * { 'a': { 'b': 'key' } }\n     * Secondary indices may be multiEntry, i.e., if the keyPath resolves to an iterable object, each item within can\n     * be used to find this entry.\n     * If a new object does not possess the key path associated with that index, it is simply ignored.\n     *\n     * This function may only be called before the database is connected.\n     * Moreover, it is only executed on database version updates or on first creation.\n     * @param {string} indexName The name of the index.\n     * @param {string|Array.<string>} [keyPath] The path to the key within the object. May be an array for multiple levels.\n     * @param {IndexConfig} [options] An options object.\n     */\n    createIndex(indexName, keyPath, options = {}) {\n        return this._backend.createIndex(indexName, keyPath, options);\n    }\n\n    /**\n     * Deletes a secondary index from the object store.\n     * @param indexName\n     * @param {{upgradeCondition:?boolean|?function(oldVersion:number, newVersion:number):boolean}} [options]\n     */\n    deleteIndex(indexName, options = {}) {\n        return this._backend.deleteIndex(indexName, options);\n    }\n\n    /**\n     * Creates a new transaction, ensuring read isolation\n     * on the most recently successfully committed state.\n     * @param {boolean} [enableWatchdog]\n     * @returns {Transaction} The transaction object.\n     */\n    transaction(enableWatchdog=true) {\n        if (!this._backend.connected) throw new Error('JungleDB is not connected');\n\n        // Prefer synchronous transactions.\n        if (this._backend.isSynchronous()) return this.synchronousTransaction(enableWatchdog);\n\n        const tx = new Transaction(this, this._currentState, this, enableWatchdog);\n        this._transactions.set(tx.id, new TransactionInfo(tx, this._currentStateInfo));\n        return tx;\n    }\n\n    /**\n     * Creates a new synchronous transaction, ensuring read isolation\n     * on the most recently successfully committed state.\n     *\n     * WARNING: If not all required key-value-pairs are preloaded, the results of any call on a synchronous transaction\n     * might be wrong. Only use synchronous transactions, if unavoidable.\n     * @param {boolean} [enableWatchdog]\n     * @returns {SynchronousTransaction} The synchronous transaction object.\n     */\n    synchronousTransaction(enableWatchdog=true) {\n        if (!this._backend.connected) throw new Error('JungleDB is not connected');\n        const tx = new SynchronousTransaction(this, this._currentState, this, enableWatchdog);\n        this._transactions.set(tx.id, new TransactionInfo(tx, this._currentStateInfo));\n        return tx;\n    }\n\n    /**\n     * Checks whether an object store implements the ISynchronousObjectStore interface.\n     * @returns {boolean} The transaction object.\n     */\n    isSynchronous() {\n        return this._backend.isSynchronous();\n    }\n\n    /**\n     * Creates an in-memory snapshot of the current state.\n     * This snapshot only maintains the differences between the state at the time of the snapshot\n     * and the current state.\n     * To stop maintaining the snapshot, it has to be aborted.\n     * @returns {Snapshot}\n     */\n    snapshot() {\n        if (this._currentStateId !== ObjectStore.BACKEND_ID) {\n            return this._currentState.snapshot();\n        }\n        return this._snapshotManager.createSnapshot(this, this._currentState);\n    }\n\n    /**\n     * An object store is strongly connected to a backend.\n     * Hence, it does not store anything by itself and the _apply method is not supported.\n     * @param {Transaction} tx\n     * @returns {Promise.<boolean>}\n     * @protected\n     */\n    async _apply(tx) {\n        throw new Error('Unsupported operation');\n    }\n\n    /**\n     * Empties the object store.\n     * @returns {Promise} The promise resolves after emptying the object store.\n     */\n    async truncate() {\n        if (!this._backend.connected) throw new Error('JungleDB is not connected');\n        const tx = this.transaction();\n        await tx.truncate();\n        return tx.commit();\n    }\n\n    /**\n     * Closes the object store and potential connections.\n     * @returns {Promise} The promise resolves after closing the object store.\n     */\n    close() {\n        // TODO perhaps use a different strategy here\n        if (this._stateStack.length > 0) {\n            throw new Error('Cannot close database while transactions are active');\n        }\n        return this._backend.close();\n    }\n\n    /**\n     * Method called to decode a single value.\n     * @param {*} value Value to be decoded.\n     * @param {string} key Key corresponding to the value.\n     * @returns {*} The decoded value.\n     */\n    decode(value, key) {\n        return this._backend.decode(value, key);\n    }\n\n    /**\n     * Method called to encode a single value.\n     * @param {*} value Value to be encoded.\n     * @returns {*} The encoded value.\n     */\n    encode(value) {\n        return this._backend.encode(value);\n    }\n\n    toStringFull() {\n        return `ObjectStore{\n    stack=[${this._stateStack.map(tx => `{tx=${tx.toStringShort()}, open=${this._openTransactions.get(tx.id) ? this._openTransactions.get(tx.id).size : 0}}`)}],\n    db=${this._db}/${this._name ? this._name : 'unnamed'}\n}`;\n    }\n\n    toString() {\n        return `ObjectStore{stackSize=${this._stateStack.length}, db=${this._db}/${this._name ? this._name : 'unnamed'}}`;\n    }\n}\n/** @type {number} The maximum number of states to stack. */\nObjectStore.MAX_STACK_SIZE = 10;\nObjectStore.BACKEND_ID = 'backend';\nClass.register(ObjectStore);\n\nclass TransactionInfo {\n    /**\n     * @param {Transaction} transaction\n     * @param {TransactionInfo} parentInfo\n     * @param {Array.<TransactionInfo>} children\n     */\n    constructor(transaction, parentInfo, children = []) {\n        this.transaction = transaction;\n        this.children = children;\n        this._parentInfo = parentInfo;\n        this._open = true;\n\n        if (this._parentInfo) {\n            this._parentInfo.addChild(this);\n        }\n    }\n\n    /**\n     * @param {TransactionInfo} transaction\n     */\n    addChild(transaction) {\n        this.children.push(transaction);\n    }\n\n    /**\n     * @param {TransactionInfo} transaction\n     */\n    removeChild(transaction) {\n        const i = this.children.indexOf(transaction);\n        if (i >= 0) {\n            this.children.splice(i, 1);\n        }\n    }\n\n    flush() {\n        if (!this.isBackend()) {\n            const parent = this.parent;\n            this.parent.removeChild(this);\n            for (const /** @type {TransactionInfo} */ child of this.children.slice()) {\n                child.parent = parent;\n            }\n            this.children = [];\n            this._parentInfo = null;\n        }\n    }\n\n    abort() {\n        if (!this.isBackend()) {\n            this.parent.removeChild(this);\n        }\n    }\n\n    close() {\n        this._open = false;\n    }\n\n    /** @type {TransactionInfo} */\n    get parent() {\n        return this._parentInfo;\n    }\n\n    /**\n     * @param {TransactionInfo} parent\n     */\n    set parent(parent) {\n        this.parent.removeChild(this);\n        this._parentInfo = parent;\n        this.parent.addChild(this);\n        this.transaction._setParent(parent.transaction);\n    }\n\n    /** @type {number} */\n    get id() {\n        return this.isBackend() ? ObjectStore.BACKEND_ID : this.transaction.id;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isBackend() {\n        return this._parentInfo === null;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isOpen() {\n        return this._open;\n    }\n\n    /**\n     * @type {number}\n     */\n    get numOpenChildren() {\n        return this.children.filter(child => child.isOpen()).length;\n    }\n\n\n    /**\n     * @returns {*|boolean}\n     */\n    isCommittable() {\n        return this._parentInfo && this._parentInfo.children.every(child => child.isOpen());\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isFlushable() {\n        return this.parent && this.parent.numOpenChildren === 0 && (this.transaction.dependency === null || this.parent.isBackend());\n    }\n}\n","/**\n * This class represents a Query object.\n * Queries are constructed using the static helper methods.\n */\nclass Query {\n    /**\n     * Internal helper method that translates an operation to a KeyRange object.\n     * @param {Query.OPERATORS} op The operator of the query.\n     * @param {*} value The first operand of the query.\n     * @param {*} [value2] The optional second operand of the query.\n     * @private\n     */\n    static _parseKeyRange(op, value, value2) {\n        switch (op) {\n            case Query.OPERATORS.GT:\n                return KeyRange.lowerBound(value, true);\n            case Query.OPERATORS.GE:\n                return KeyRange.lowerBound(value, false);\n            case Query.OPERATORS.LT:\n                return KeyRange.upperBound(value, true);\n            case Query.OPERATORS.LE:\n                return KeyRange.upperBound(value, false);\n            case Query.OPERATORS.EQ:\n                return KeyRange.only(value);\n            case Query.OPERATORS.BETWEEN:\n                return KeyRange.bound(value, value2, true, true);\n            case Query.OPERATORS.WITHIN:\n                return KeyRange.bound(value, value2, false, false);\n        }\n        Log.e(`Unknown operator: ${op}`);\n        throw new Error('Unknown operator');\n    }\n\n    /**\n     * Returns the conjunction of multiple queries.\n     * @param {...Query} var_args The list of queries, which all have to be fulfilled.\n     * @returns {Query} The conjunction of the queries.\n     */\n    static and(var_args) {\n        const args = Array.from(arguments);\n        return new Query(args, Query.OPERATORS.AND);\n    }\n\n    /**\n     * Returns the disjunction of multiple queries.\n     * @param {...Query} var_args The list of queries, out of which at least one has to be fulfilled.\n     * @returns {Query} The disjunction of the queries.\n     */\n    static or(var_args) {\n        const args = Array.from(arguments);\n        return new Query(args, Query.OPERATORS.OR);\n    }\n\n    /**\n     * Returns a query for the max key of an index.\n     * @param {string} indexName The name of the index, whose maximal key the query matches.\n     * @returns {Query} The query for the max key of the index.\n     */\n    static max(indexName) {\n        return new Query(indexName, Query.OPERATORS.MAX);\n    }\n\n    /**\n     * Returns a query for the min key of an index.\n     * @param {string} indexName The name of the index, whose minimal key the query matches.\n     * @returns {Query} The query for the min key of the index.\n     */\n    static min(indexName) {\n        return new Query(indexName, Query.OPERATORS.MIN);\n    }\n\n    /**\n     * Returns a query that matches all keys of an index that are less than a value.\n     * The query matches all keys k, such that k < val.\n     * @param {string} indexName The name of the index.\n     * @param {*} val The upper bound of the query.\n     * @returns {Query} The resulting query object.\n     */\n    static lt(indexName, val) {\n        return new Query(indexName, Query.OPERATORS.LT, val);\n    }\n\n    /**\n     * Returns a query that matches all keys of an index that are less or equal than a value.\n     * The query matches all keys k, such that k  val.\n     * @param {string} indexName The name of the index.\n     * @param {*} val The upper bound of the query.\n     * @returns {Query} The resulting query object.\n     */\n    static le(indexName, val) {\n        return new Query(indexName, Query.OPERATORS.LE, val);\n    }\n\n    /**\n     * Returns a query that matches all keys of an index that are greater than a value.\n     * The query matches all keys k, such that k > val.\n     * @param {string} indexName The name of the index.\n     * @param {*} val The lower bound of the query.\n     * @returns {Query} The resulting query object.\n     */\n    static gt(indexName, val) {\n        return new Query(indexName, Query.OPERATORS.GT, val);\n    }\n\n    /**\n     * Returns a query that matches all keys of an index that are greater or equal than a value.\n     * The query matches all keys k, such that k  val.\n     * @param {string} indexName The name of the index.\n     * @param {*} val The lower bound of the query.\n     * @returns {Query} The resulting query object.\n     */\n    static ge(indexName, val) {\n        return new Query(indexName, Query.OPERATORS.GE, val);\n    }\n\n    /**\n     * Returns a query that matches all keys of an index that equal to a value.\n     * The query matches all keys k, such that k = val.\n     * @param {string} indexName The name of the index.\n     * @param {*} val The value to look for.\n     * @returns {Query} The resulting query object.\n     */\n    static eq(indexName, val) {\n        return new Query(indexName, Query.OPERATORS.EQ, val);\n    }\n\n    /**\n     * Returns a query that matches all keys of an index that are between two values, excluding the boundaries.\n     * The query matches all keys k, such that lower < k < upper.\n     * @param {string} indexName The name of the index.\n     * @param {*} lower The lower bound.\n     * @param {*} upper The upper bound.\n     * @returns {Query} The resulting query object.\n     */\n    static between(indexName, lower, upper) {\n        return new Query(indexName, Query.OPERATORS.BETWEEN, lower, upper);\n    }\n\n    /**\n     * Returns a query that matches all keys of an index that are between two values, including the boundaries.\n     * The query matches all keys k, such that lower  k  upper.\n     * @param {string} indexName The name of the index.\n     * @param {*} lower The lower bound.\n     * @param {*} upper The upper bound.\n     * @returns {Query} The resulting query object.\n     */\n    static within(indexName, lower, upper) {\n        return new Query(indexName, Query.OPERATORS.WITHIN, lower, upper);\n    }\n\n    /**\n     * Internal constructor for a query.\n     * Should not be called directly.\n     * @param {string|Array.<Query>} arg Either a list of queries or an index name (depending on the operator).\n     * @param {Query.OPERATORS} op The operator to apply.\n     * @param {*} [value] The first operand if applicable.\n     * @param {*} [value2] The second operand if applicable.\n     * @private\n     */\n    constructor(arg, op, value, value2) {\n        // If first argument is an array of queries, this is a combined query.\n        if (Array.isArray(arg)) {\n            if (arg.some(it => !(it instanceof Query))) {\n                throw new Error('Invalid query');\n            }\n            if (Query.COMBINED_OPERATORS.indexOf(op) < 0) {\n                throw new Error('Unknown operator');\n            }\n            this._queryType = Query.Type.COMBINED;\n            this._queries = arg;\n            this._op = op;\n        }\n        // Otherwise we have a single query.\n        else {\n            if (Query.RANGE_OPERATORS.indexOf(op) >= 0) {\n                this._queryType = Query.Type.RANGE;\n                this._keyRange = Query._parseKeyRange(op, value, value2);\n            } else if (Query.ADVANCED_OPERATORS.indexOf(op) >= 0) {\n                this._queryType = Query.Type.ADVANCED;\n                this._op = op;\n            } else {\n                throw new Error('Unknown operator');\n            }\n            this._indexName = arg;\n        }\n    }\n\n    /**\n     * Returns a promise of an array of objects fulfilling this query.\n     * @param {IObjectStore} objectStore The object store to execute the query on.\n     * @param {number} [limit] Limits the number of results if given.\n     * @returns {Promise.<Array.<*>>} A promise of the array of objects relevant to this query.\n     */\n    async values(objectStore, limit = null) {\n        const keys = await this._execute(objectStore, limit);\n        const resultPromises = [];\n        for (const key of keys) {\n            resultPromises.push(objectStore.get(key));\n        }\n        return Promise.all(resultPromises);\n    }\n\n    /**\n     * Returns a promise of a set of keys fulfilling this query.\n     * @param {IObjectStore} objectStore The object store to execute the query on.\n     * @param {number} [limit] Limits the number of results if given.\n     * @returns {Promise.<Set.<string>>} A promise of the set of keys relevant to this query.\n     */\n    keys(objectStore, limit = null) {\n        return this._execute(objectStore, limit);\n    }\n\n    /**\n     * Internal method to execute a query on an object store.\n     * @param {IObjectStore} objectStore The object store to execute the query on.\n     * @param {number} [limit] Limits the number of results if given.\n     * @returns {Promise.<Set.<string>>} A promise of the set of keys relevant to this query.\n     * @private\n     */\n    async _execute(objectStore, limit = null) {\n        switch (this._queryType) {\n            case Query.Type.COMBINED:\n                return Promise.resolve(this._executeCombined(objectStore, limit));\n\n            case Query.Type.ADVANCED:\n                return Promise.resolve(this._executeAdvanced(objectStore, limit));\n\n            case Query.Type.RANGE:\n                return this._executeRange(objectStore, limit);\n        }\n        return Promise.resolve(new Set());\n    }\n\n    /**\n     * Internal method for and/or operators.\n     * @param {IObjectStore} objectStore The object store to execute the query on.\n     * @param {number} [limit] Limits the number of results if given.\n     * @returns {Promise.<Set.<string>>} A promise of the set of keys relevant to this query.\n     * @private\n     */\n    async _executeCombined(objectStore, limit = null) {\n        // Evaluate children.\n        const resultPromises = [];\n        for (const query of this._queries) {\n            resultPromises.push(query._execute(objectStore, limit));\n        }\n        const results = await Promise.all(resultPromises);\n\n        if (this._op === Query.OPERATORS.AND) {\n            // Provide shortcuts.\n            if (results.length === 0) {\n                return new Set();\n            } else if (results.length === 1) {\n                // Limit\n                if (limit === null || limit >= 1) {\n                    return results[0];\n                }\n                return new Set();\n            }\n\n            // Set intersection of all keys.\n            const firstResult = results.shift();\n            const intersection = new Set();\n            let count = 0;\n            for (const val of firstResult) {\n                if (results.every(result => result.has(val))) {\n                    // Limit\n                    if (limit !== null && count >= limit) break;\n\n                    intersection.add(val);\n                    count++;\n                }\n            }\n            return intersection;\n        } else if (this._op === Query.OPERATORS.OR) {\n            // Set union of all keys.\n            const union = new Set();\n            let count = 0;\n            for (const result of results) {\n                for (const val of result) {\n                    // Limit\n                    if (limit !== null && count >= limit) break;\n\n                    union.add(val);\n                    count++;\n                }\n                if (limit !== null && count >= limit) break;\n            }\n            return union;\n        }\n        return new Set();\n    }\n\n    /**\n     * Internal method for min/max operators.\n     * @param {IObjectStore} objectStore The object store to execute the query on.\n     * @param {number} [limit] Limits the number of results if given.\n     * @returns {Promise.<Set.<string>>} A promise of the set of keys relevant to this query.\n     * @private\n     */\n    async _executeAdvanced(objectStore, limit = null) {\n        const index = objectStore.index(this._indexName);\n        let results = new Set();\n        switch (this._op) {\n            case Query.OPERATORS.MAX:\n                results = await index.maxKeys();\n                break;\n            case Query.OPERATORS.MIN:\n                results = await index.minKeys();\n                break;\n        }\n        return new Set(results.limit(limit));\n    }\n\n    /**\n     * Internal method for range operators.\n     * @param {IObjectStore} objectStore The object store to execute the query on.\n     * @param {number} [limit] Limits the number of results if given.\n     * @returns {Promise.<Set.<string>>} A promise of the set of keys relevant to this query.\n     * @private\n     */\n    async _executeRange(objectStore, limit = null) {\n        const index = objectStore.index(this._indexName);\n        return new Set(await index.keys(this._keyRange, limit));\n    }\n}\n/**\n * Enum for supported operators.\n * @enum {number}\n */\nQuery.OPERATORS = {\n    GT: 0,\n    GE: 1,\n    LT: 2,\n    LE: 3,\n    EQ: 4,\n    // NEQ: 5, not supported\n    BETWEEN: 7,\n    WITHIN: 8,\n    MAX: 9,\n    MIN: 10,\n    AND: 11,\n    OR: 12\n};\nQuery.RANGE_OPERATORS = [\n    Query.OPERATORS.GT,\n    Query.OPERATORS.GE,\n    Query.OPERATORS.LT,\n    Query.OPERATORS.LE,\n    Query.OPERATORS.EQ,\n    Query.OPERATORS.BETWEEN,\n    Query.OPERATORS.WITHIN\n];\nQuery.ADVANCED_OPERATORS = [Query.OPERATORS.MAX, Query.OPERATORS.MIN];\nQuery.COMBINED_OPERATORS = [Query.OPERATORS.AND, Query.OPERATORS.OR];\n/**\n * Enum for query types.\n * Each operator belongs to one of these types as specified above.\n * @enum {number}\n */\nQuery.Type = {\n    RANGE: 0,\n    ADVANCED: 1,\n    COMBINED: 2\n};\nClass.register(Query);\n\n","/**\n * This class constitutes an InMemoryIndex for Transactions.\n * It unifies the results of keys changed during the transaction\n * with the underlying backend.\n */\nclass TransactionIndex extends InMemoryIndex {\n    /**\n     * Derives the indices from the backend and returns a new map of transactions.\n     * @param {Transaction} objectStore The transaction the index should be based on.\n     * @param {IObjectStore} backend The backend underlying the transaction.\n     * @returns {Map.<string,TransactionIndex>} A map containing all indices for the transaction.\n     */\n    static derive(objectStore, backend) {\n        const indices = new Map();\n        for (const [name, index] of backend.indices) {\n            indices.set(name, new TransactionIndex(objectStore, backend, name, index.keyPath, index.multiEntry, index.unique));\n        }\n        return indices;\n    }\n\n    /** @type {IIndex} The index of the underlying backend. */\n    get _index() {\n        return this._backend.index(this._databaseDir);\n    }\n\n    /**\n     * Constructs a new TransactionIndex serving the transaction's changes\n     * and unifying the results with the underlying backend.\n     * @param {Transaction} objectStore The transaction the index should be based on.\n     * @param {IObjectStore} backend The backend underlying the transaction.\n     * @param {string|Array.<string>} keyPath The key path of the indexed attribute.\n     * @param {boolean} [multiEntry] Whether the indexed attribute is considered to be iterable or not.\n     * @param {boolean} [unique] Whether there is a unique constraint on the attribute.\n     * @protected\n     */\n    constructor(objectStore, backend, name, keyPath, multiEntry = false, unique = false) {\n        super(objectStore, keyPath, multiEntry, unique);\n        this._backend = backend;\n        this._databaseDir = name;\n    }\n\n    async checkUniqueConstraint(key, value) {\n        if (!this.unique) {\n            return;\n        }\n\n        // Calculate secondary keys.\n        let iKey = this._indexKey(key, value);\n        if (iKey !== undefined) {\n            if (!this.multiEntry || !Array.isArray(iKey)) {\n                iKey = [iKey];\n            }\n            // Check whether they already exist.\n            for (const secondaryKey of iKey) {\n                const count = await this._index.count(KeyRange.only(secondaryKey));\n                if (count > 0) {\n                    throw new Error(`Uniqueness constraint violated for key ${secondaryKey} on path ${this._keyPath}`);\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a promise of a set of primary keys, whose associated objects' secondary keys are in the given range.\n     * If the optional query is not given, it returns all primary keys in the index.\n     * If the query is of type KeyRange, it returns all primary keys for which the secondary key is within this range.\n     * @param {KeyRange} [query] Optional query to check the secondary keys against.\n     * @param {number} [limit] Limits the number of results if given.\n     * @returns {Promise.<Set.<string>>} A promise of the set of primary keys relevant to the query.\n     */\n    async keys(query = null, limit = null) {\n        const promises = [];\n        if (this._objectStore._truncated) {\n            promises.push(new Set());\n        } else {\n            promises.push(this._index.keys(query, limit));\n        }\n        promises.push(InMemoryIndex.prototype.keys.call(this, query, limit));\n        let [/** @type {Set} */ keys, /** @type {Set} */ newKeys] = await Promise.all(promises);\n        // Remove keys that have been deleted or modified.\n        keys = keys.difference(this._objectStore._removed);\n        keys = keys.difference(this._objectStore._modified.keys());\n        return keys.union(newKeys).limit(limit);\n    }\n\n    /**\n     * Returns a promise of an array of objects whose secondary keys fulfill the given query.\n     * If the optional query is not given, it returns all objects in the index.\n     * If the query is of type KeyRange, it returns all objects whose secondary keys are within this range.\n     * @param {KeyRange} [query] Optional query to check secondary keys against.\n     * @param {number} [limit] Limits the number of results if given.\n     * @returns {Promise.<Array.<*>>} A promise of the array of objects relevant to the query.\n     */\n    async values(query = null, limit = null) {\n        const keys = await this.keys(query, limit);\n        return InMemoryIndex.prototype._retrieveValues.call(this, keys);\n    }\n\n    /**\n     * Returns a promise of an array of objects whose secondary key is maximal for the given range.\n     * If the optional query is not given, it returns the objects whose secondary key is maximal within the index.\n     * If the query is of type KeyRange, it returns the objects whose secondary key is maximal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<Array.<*>>} A promise of array of objects relevant to the query.\n     */\n    async maxValues(query=null) {\n        const keys = await this.maxKeys(query);\n        return InMemoryIndex.prototype._retrieveValues.call(this, keys);\n    }\n\n    /**\n     * Returns a promise of a set of primary keys, whose associated secondary keys are maximal for the given range.\n     * If the optional query is not given, it returns the set of primary keys, whose associated secondary key is maximal within the index.\n     * If the query is of type KeyRange, it returns the set of primary keys, whose associated secondary key is maximal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<Set.<*>>} A promise of the key relevant to the query.\n     */\n    async maxKeys(query=null) {\n        let backendKeys;\n        if (this._objectStore._truncated) {\n            backendKeys = new Set();\n        } else {\n            backendKeys = await this._index.maxKeys(query);\n        }\n\n        // Remove keys that have been deleted or modified.\n        let sampleElement = Set.sampleElement(backendKeys);\n        let value = undefined, maxIKey = undefined;\n        if (sampleElement !== undefined) {\n            value = await this._backend.get(sampleElement);\n            maxIKey = ObjectUtils.byKeyPath(value, this.keyPath);\n        }\n        backendKeys = backendKeys.difference(this._objectStore._removed);\n        backendKeys = backendKeys.difference(this._objectStore._modified.keys());\n\n        while (sampleElement !== undefined && backendKeys.size === 0) {\n            const tmpQuery = KeyRange.upperBound(maxIKey, true);\n            backendKeys = await this._index.maxKeys(tmpQuery);\n\n            // Remove keys that have been deleted or modified.\n            sampleElement = Set.sampleElement(backendKeys);\n            if (sampleElement !== undefined) {\n                value = await this._backend.get(sampleElement);\n                maxIKey = ObjectUtils.byKeyPath(value, this.keyPath);\n            }\n            backendKeys = backendKeys.difference(this._objectStore._removed);\n            backendKeys = backendKeys.difference(this._objectStore._modified.keys());\n\n            // If we get out of the range, stop here.\n            if (maxIKey && query !== null && !query.includes(maxIKey)) {\n                backendKeys = new Set();\n                break;\n            }\n        }\n\n        const newKeys = await InMemoryIndex.prototype.maxKeys.call(this, query);\n\n        if (backendKeys.size === 0) {\n            return newKeys;\n        } else if (newKeys.size === 0) {\n            return backendKeys;\n        }\n\n        // Both contain elements, check which one is larger.\n        const valueTx = await this._objectStore.get(Set.sampleElement(newKeys));\n\n        const iKeyBackend = maxIKey;\n        const iKeyTx = ObjectUtils.byKeyPath(valueTx, this.keyPath);\n\n        if (ComparisonUtils.compare(iKeyBackend, iKeyTx) > 0) {\n            return backendKeys;\n        } else if (ComparisonUtils.compare(iKeyBackend, iKeyTx) < 0) {\n            return newKeys;\n        }\n        return backendKeys.union(newKeys);\n    }\n\n    /**\n     * Returns a promise of an array of objects whose secondary key is minimal for the given range.\n     * If the optional query is not given, it returns the objects whose secondary key is minimal within the index.\n     * If the query is of type KeyRange, it returns the objects whose secondary key is minimal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<Array.<*>>} A promise of array of objects relevant to the query.\n     */\n    async minValues(query=null) {\n        const keys = await this.minKeys(query);\n        return InMemoryIndex.prototype._retrieveValues.call(this, keys);\n    }\n\n    /**\n     * Returns a promise of a set of primary keys, whose associated secondary keys are minimal for the given range.\n     * If the optional query is not given, it returns the set of primary keys, whose associated secondary key is minimal within the index.\n     * If the query is of type KeyRange, it returns the set of primary keys, whose associated secondary key is minimal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<Set.<*>>} A promise of the key relevant to the query.\n     */\n    async minKeys(query=null) {\n        let backendKeys;\n        if (this._objectStore._truncated) {\n            backendKeys = new Set();\n        } else {\n            backendKeys = await this._index.minKeys(query);\n        }\n\n        // Remove keys that have been deleted or modified.\n        let sampleElement = Set.sampleElement(backendKeys);\n        let value = undefined, minIKey = undefined;\n        if (sampleElement !== undefined) {\n            value = await this._backend.get(sampleElement);\n            minIKey = ObjectUtils.byKeyPath(value, this.keyPath);\n        }\n        backendKeys = backendKeys.difference(this._objectStore._removed);\n        backendKeys = backendKeys.difference(this._objectStore._modified.keys());\n\n        while (sampleElement !== undefined && backendKeys.size === 0) {\n            const tmpQuery = KeyRange.lowerBound(minIKey, true);\n            backendKeys = await this._index.minKeys(tmpQuery);\n\n            // Remove keys that have been deleted or modified.\n            sampleElement = Set.sampleElement(backendKeys);\n            if (sampleElement !== undefined) {\n                value = await this._backend.get(sampleElement);\n                minIKey = ObjectUtils.byKeyPath(value, this.keyPath);\n            }\n            backendKeys = backendKeys.difference(this._objectStore._removed);\n            backendKeys = backendKeys.difference(this._objectStore._modified.keys());\n\n            // If we get out of the range, stop here.\n            if (minIKey && query !== null && !query.includes(minIKey)) {\n                backendKeys = new Set();\n                break;\n            }\n        }\n\n        const newKeys = await InMemoryIndex.prototype.minKeys.call(this, query);\n\n        if (backendKeys.size === 0) {\n            return newKeys;\n        } else if (newKeys.size === 0) {\n            return backendKeys;\n        }\n\n        // Both contain elements, check which one is larger.\n        const valueTx = await this._objectStore.get(Set.sampleElement(newKeys));\n\n        const iKeyBackend = minIKey;\n        const iKeyTx = ObjectUtils.byKeyPath(valueTx, this.keyPath);\n\n        if (ComparisonUtils.compare(iKeyBackend, iKeyTx) < 0) {\n            return backendKeys;\n        } else if (ComparisonUtils.compare(iKeyBackend, iKeyTx) > 0) {\n            return newKeys;\n        }\n        return backendKeys.union(newKeys);\n    }\n\n    /**\n     * Returns the count of entries, whose secondary key is in the given range.\n     * If the optional query is not given, it returns the count of entries in the index.\n     * If the query is of type KeyRange, it returns the count of entries, whose secondary key is within the given range.\n     * @param {KeyRange} [query]\n     * @returns {Promise.<number>}\n     */\n    async count(query=null) {\n        // Unfortunately, we cannot do better than getting keys + counting.\n        return (await this.keys(query)).size;\n    }\n}\nClass.register(TransactionIndex);\n","/**\n * Transactions are created by calling the transaction method on an ObjectStore object.\n * Transactions ensure read-isolation.\n * On a given state, only *one* transaction can be committed successfully.\n * Other transactions based on the same state will end up in a conflicted state if committed.\n * Transactions opened after the successful commit of another transaction will be based on the\n * new state and hence can be committed again.\n * Transactions do *not* check unique constraints of secondary indices before commiting them.\n * @implements {ISynchronousWritableObjectStore}\n * @implements {ICommittable}\n */\nclass Transaction {\n    /**\n     * This constructor should only be called by an ObjectStore object.\n     * Our transactions have a watchdog enabled by default,\n     * logging a warning after a certain time specified by WATCHDOG_TIMER.\n     * This helps to detect unclosed transactions preventing to store the state in\n     * the persistent backend.\n     * @param {ObjectStore} objectStore The object store this transaction belongs to.\n     * @param {IObjectStore} parent The backend on which the transaction is based,\n     * i.e., another transaction or the real database.\n     * @param {ICommittable} [managingBackend] The object store managing the transactions,\n     * i.e., the ObjectStore object.\n     * @param {boolean} [enableWatchdog] If this is is set to true (default),\n     * a warning will be logged if left open for longer than WATCHDOG_TIMER.\n     * @protected\n     */\n    constructor(objectStore, parent, managingBackend, enableWatchdog=true) {\n        this._id = Transaction._instanceCount++;\n        this._objectStore = objectStore;\n        this._parent = parent;\n        /** @type {ICommittable} */\n        this._managingBackend = managingBackend || parent;\n        this._modified = new Map();\n        this._removed = new Set();\n        this._truncated = false;\n        this._indices = TransactionIndex.derive(this, parent);\n\n        this._state = Transaction.STATE.OPEN;\n\n        // Keep track of nested transactions.\n        /** @type {Set.<Transaction>} */\n        this._nested = new Set();\n        this._nestedCommitted = false;\n\n        // Handle dependencies due to cross-objectstore transactions.\n        /** @type {CombinedTransaction} */\n        this._dependency = null;\n\n        this._snapshotManager = new SnapshotManager();\n\n        this._startTime = Date.now();\n        this._enableWatchdog = enableWatchdog;\n        if (this._enableWatchdog) {\n            this._watchdog = setTimeout(() => {\n                Log.w(Transaction, `Violation: tx id ${this._id} took longer than expected (still open after ${Transaction.WATCHDOG_TIMER/1000}s), ${this.toString()}.`);\n            }, Transaction.WATCHDOG_TIMER);\n        }\n    }\n\n    /** @type {ObjectStore} */\n    get objectStore() {\n        return this._objectStore;\n    }\n\n    /** @type {boolean} */\n    get nested() {\n        return this._managingBackend instanceof Transaction;\n    }\n\n    /**\n     * @type {CombinedTransaction} If existent, a combined transaction encompassing this object.\n     */\n    get dependency() {\n        return this._dependency;\n    }\n\n    /** @type {boolean} */\n    get connected() {\n        return this._managingBackend.connected;\n    }\n\n    /** @type {number} A unique transaction id. */\n    get id() {\n        return this._id;\n    }\n\n    /**\n     * A map of index names to indices.\n     * The index names can be used to access an index.\n     * @type {Map.<string,IIndex>}\n     */\n    get indices() {\n        return this._indices;\n    }\n\n    /**\n     * The transaction's current state.\n     * @returns {Transaction.STATE}\n     */\n    get state() {\n        return this._state;\n    }\n\n    /**\n     * Non-async version of _apply that does not update snapshots.\n     * Internally applies a transaction to the transaction's state.\n     * This needs to be done in batch (as a db level transaction), i.e., either the full state is updated\n     * or no changes are applied.\n     * @param {Transaction} tx The transaction to apply.\n     * @protected\n     */\n    _applySync(tx) {\n        if (tx._truncated) {\n            this.truncateSync();\n        }\n        for (const [key, value] of tx._modified) {\n            this._put(key, value);\n        }\n        for (const key of tx._removed) {\n            this._remove(key);\n        }\n    }\n\n    /**\n     * Empties the object store.\n     * @returns {Promise} The promise resolves after emptying the object store.\n     */\n    async truncate() {\n        return this.truncateSync();\n    }\n\n    /**\n     * Non-async variant to empty the object store.\n     * @protected\n     */\n    truncateSync() {\n        if (this._state !== Transaction.STATE.OPEN) {\n            throw new Error('Transaction already closed');\n        }\n\n        this._truncated = true;\n        this._modified.clear();\n        this._removed.clear();\n\n        // Update indices.\n        for (const index of this._indices.values()) {\n            index.truncate();\n        }\n    }\n\n    /**\n     * Returns a promise of the object stored under the given primary key.\n     * Resolves to undefined if the key is not present in the object store.\n     * @param {string} key The primary key to look for.\n     * @param {RetrievalConfig} [options] Advanced retrieval options.\n     * @returns {Promise.<*>} A promise of the object stored under the given key, or undefined if not present.\n     */\n    async get(key, options = {}) {\n        // Order is as follows:\n        // 1. check if removed,\n        // 2. check if modified,\n        // 3. check if truncated\n        // 4. request from backend\n        if (this._removed.has(key)) {\n            return undefined;\n        }\n        if (this._modified.has(key)) {\n            if (options && options.raw) {\n                return this.encode(this._modified.get(key));\n            }\n            return this._modified.get(key);\n        }\n        if (this._truncated) {\n            return undefined;\n        }\n        return this._parent.get(key, options);\n    }\n\n    /**\n     * Inserts or replaces a key-value pair.\n     * @param {string} key The primary key to associate the value with.\n     * @param {*} value The value to write.\n     * @returns {Promise} The promise resolves after writing to the current object store finished.\n     */\n    async put(key, value) {\n        if (this._state !== Transaction.STATE.OPEN) {\n            throw new Error('Transaction already closed');\n        }\n\n        // Check indices.\n        const constraints = [];\n        for (const index of this._indices.values()) {\n            constraints.push(index.checkUniqueConstraint(key, value));\n        }\n        await Promise.all(constraints);\n\n        this._put(key, value);\n    }\n\n    /**\n     * Inserts or replaces a key-value pair.\n     * @param {string} key The primary key to associate the value with.\n     * @param {*} value The value to write.\n     */\n    putSync(key, value) {\n        if (this._state !== Transaction.STATE.OPEN) {\n            throw new Error('Transaction already closed');\n        }\n\n        this._put(key, value);\n    }\n\n    /**\n     * Removes the key-value pair of the given key from the object store.\n     * @param {string} key The primary key to delete along with the associated object.\n     * @returns {Promise} The promise resolves after writing to the current object store finished.\n     */\n    async remove(key) {\n        if (this._state !== Transaction.STATE.OPEN) {\n            throw new Error('Transaction already closed');\n        }\n\n        this._remove(key);\n    }\n\n    /**\n     * Removes the key-value pair of the given key from the object store.\n     * @param {string} key The primary key to delete along with the associated object.\n     */\n    removeSync(key) {\n        if (this._state !== Transaction.STATE.OPEN) {\n            throw new Error('Transaction already closed');\n        }\n\n        this._remove(key);\n    }\n\n    /**\n     * Returns a promise of a set of keys fulfilling the given query.\n     * If the optional query is not given, it returns all keys in the object store.\n     * If the query is of type KeyRange, it returns all keys of the object store being within this range.\n     * If the query is of type Query, it returns all keys fulfilling the query.\n     * @param {Query|KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<Set.<string>>} A promise of the set of keys relevant to the query.\n     */\n    async keys(query=null) {\n        if (query !== null && query instanceof Query) {\n            return query.keys(this);\n        }\n        let keys = new Set();\n        if (!this._truncated) {\n            keys = await this._parent.keys(query);\n        }\n        keys = keys.difference(this._removed);\n        for (const key of this._modified.keys()) {\n            if (query === null || query.includes(key)) {\n                keys.add(key);\n            }\n        }\n        return keys;\n    }\n\n    /**\n     * Returns a promise of an array of objects whose primary keys fulfill the given query.\n     * If the optional query is not given, it returns all objects in the object store.\n     * If the query is of type KeyRange, it returns all objects whose primary keys are within this range.\n     * If the query is of type Query, it returns all objects whose primary keys fulfill the query.\n     * @param {Query|KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<Array.<*>>} A promise of the array of objects relevant to the query.\n     */\n    async values(query=null) {\n        if (query !== null && query instanceof Query) {\n            return query.values(this);\n        }\n        const keys = await this.keys(query);\n        const valuePromises = [];\n        for (const key of keys) {\n            valuePromises.push(this.get(key));\n        }\n        return Promise.all(valuePromises);\n    }\n\n    /**\n     * Iterates over the keys in a given range and direction.\n     * The callback is called for each primary key fulfilling the query\n     * until it returns false and stops the iteration.\n     * @param {function(key:string):boolean} callback A predicate called for each key until returning false.\n     * @param {boolean} ascending Determines the direction of traversal.\n     * @param {KeyRange} query An optional KeyRange to narrow down the iteration space.\n     * @returns {Promise} The promise resolves after all elements have been streamed.\n     */\n    async keyStream(callback, ascending=true, query=null) {\n        // TODO Optimize this sorting step.\n        let keys = Array.from(this._modified.keys());\n        if (query instanceof KeyRange) {\n            keys = keys.filter(key => query.includes(key));\n        }\n        keys = keys.sort();\n\n        let txIt = keys.iterator(ascending);\n        if (!this._truncated) {\n            let stopped = false;\n\n            await this._parent.keyStream(key => {\n                // Iterate over TxKeys as long as they are smaller (ascending) or larger (descending).\n                while (txIt.hasNext() && ((ascending && ComparisonUtils.compare(txIt.peek(), key) < 0) || (!ascending && ComparisonUtils.compare(txIt.peek(), key) > 0))) {\n                    const currentTxKey = txIt.next();\n                    if (!callback(currentTxKey)) {\n                        // Do not continue iteration.\n                        stopped = true;\n                        return false;\n                    }\n                }\n                // Special case: what if next key is identical (-> modified)?\n                // Present modified version and continue.\n                if (txIt.hasNext() && ComparisonUtils.equals(txIt.peek(), key)) {\n                    const currentTxKey = txIt.next();\n                    if (!callback(currentTxKey)) {\n                        // Do not continue iteration.\n                        stopped = true;\n                        return false;\n                    }\n                    return true;\n                }\n                // Then give key of the backend's key stream.\n                // But only if it hasn't been removed (lazy operator prevents calling callback in this case).\n                if (!this._removed.has(key) && !callback(key)) {\n                    // Do not continue iteration.\n                    stopped = true;\n                    return false;\n                }\n                return true;\n            }, ascending, query);\n\n            // Do not continue, if already stopped.\n            if (stopped) {\n                return;\n            }\n        }\n\n        // Iterate over the remaining TxKeys.\n        while (txIt.hasNext()) {\n            if (!callback(txIt.next())) {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Iterates over the keys and values in a given range and direction.\n     * The callback is called for each value and primary key fulfilling the query\n     * until it returns false and stops the iteration.\n     * @param {function(value:*, key:string):boolean} callback A predicate called for each value and key until returning false.\n     * @param {boolean} ascending Determines the direction of traversal.\n     * @param {KeyRange} query An optional KeyRange to narrow down the iteration space.\n     * @returns {Promise} The promise resolves after all elements have been streamed.\n     */\n    async valueStream(callback, ascending=true, query=null) {\n        // TODO Optimize this sorting step.\n        let keys = Array.from(this._modified.keys());\n        if (query instanceof KeyRange) {\n            keys = keys.filter(key => query.includes(key));\n        }\n        keys = keys.sort();\n\n        let txIt = keys.iterator(ascending);\n        if (!this._truncated) {\n            let stopped = false;\n\n            await this._parent.valueStream((value, key) => {\n                // Iterate over TxKeys as long as they are smaller (ascending) or larger (descending).\n                while (txIt.hasNext() && ((ascending && ComparisonUtils.compare(txIt.peek(), key) < 0) || (!ascending && ComparisonUtils.compare(txIt.peek(), key) > 0))) {\n                    const currentTxKey = txIt.next();\n                    const value = this._modified.get(currentTxKey);\n                    if (!callback(value, currentTxKey)) {\n                        // Do not continue iteration.\n                        stopped = true;\n                        return false;\n                    }\n                }\n                // Special case: what if next key is identical (-> modified)?\n                // Present modified version and continue.\n                if (txIt.hasNext() && ComparisonUtils.equals(txIt.peek(), key)) {\n                    const currentTxKey = txIt.next();\n                    const value = this._modified.get(currentTxKey);\n                    if (!callback(value, currentTxKey)) {\n                        // Do not continue iteration.\n                        stopped = true;\n                        return false;\n                    }\n                    return true;\n                }\n                // Then give key of the backend's key stream.\n                // But only if it hasn't been removed (lazy operator prevents calling callback in this case).\n                if (!this._removed.has(key) && !callback(value, key)) {\n                    // Do not continue iteration.\n                    stopped = true;\n                    return false;\n                }\n                return true;\n            }, ascending, query);\n\n            // Do not continue, if already stopped.\n            if (stopped) {\n                return;\n            }\n        }\n\n        // Iterate over the remaining TxKeys.\n        while (txIt.hasNext()) {\n            const key = txIt.next();\n            const value = await this.get(key);\n            if (!callback(value, key)) {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Returns a promise of the object whose primary key is maximal for the given range.\n     * If the optional query is not given, it returns the object whose key is maximal.\n     * If the query is of type KeyRange, it returns the object whose primary key is maximal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<*>} A promise of the object relevant to the query.\n     */\n    async maxValue(query=null) {\n        const maxKey = await this.maxKey(query);\n        return this.get(maxKey);\n    }\n\n    /**\n     * Returns a promise of the key being maximal for the given range.\n     * If the optional query is not given, it returns the maximal key.\n     * If the query is of type KeyRange, it returns the key being maximal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<string>} A promise of the key relevant to the query.\n     */\n    async maxKey(query=null) {\n        // Take underlying maxKey.\n        let maxKey = undefined;\n        if (!this._truncated) {\n            maxKey = await this._parent.maxKey(query);\n        }\n\n        // If this key has been removed, find next best key.\n        while (maxKey !== undefined && this._removed.has(maxKey)) {\n            const tmpQuery = KeyRange.upperBound(maxKey, true);\n            maxKey = await this._parent.maxKey(tmpQuery);\n\n            // If we get out of the range, stop here.\n            if (query !== null && !query.includes(maxKey)) {\n                maxKey = undefined;\n                break;\n            }\n        }\n\n        for (const key of this._modified.keys()) {\n            // Find better maxKey in modified data.\n            if ((query === null || query.includes(key)) && (maxKey === undefined || ComparisonUtils.compare(key, maxKey) > 0)) {\n                maxKey = key;\n            }\n        }\n        return maxKey;\n    }\n\n    /**\n     * Returns a promise of the object whose primary key is minimal for the given range.\n     * If the optional query is not given, it returns the object whose key is minimal.\n     * If the query is of type KeyRange, it returns the object whose primary key is minimal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<*>} A promise of the object relevant to the query.\n     */\n    async minValue(query=null) {\n        const minKey = await this.minKey(query);\n        return this.get(minKey);\n    }\n\n    /**\n     * Returns a promise of the key being minimal for the given range.\n     * If the optional query is not given, it returns the minimal key.\n     * If the query is of type KeyRange, it returns the key being minimal for the given range.\n     * @param {KeyRange} [query] Optional query to check keys against.\n     * @returns {Promise.<string>} A promise of the key relevant to the query.\n     */\n    async minKey(query=null) {\n        // Take underlying minKey.\n        let minKey = undefined;\n        if (!this._truncated) {\n            minKey = await this._parent.minKey(query);\n        }\n\n        // If this key has been removed, find next best key.\n        while (minKey !== undefined && this._removed.has(minKey)) {\n            const tmpQuery = KeyRange.lowerBound(minKey, true);\n            minKey = await this._parent.minKey(tmpQuery);\n\n            // If we get out of the range, stop here.\n            if (query !== null && !query.includes(minKey)) {\n                minKey = undefined;\n                break;\n            }\n        }\n\n        for (const key of this._modified.keys()) {\n            // Find better maxKey in modified data.\n            if ((query === null || query.includes(key)) && (minKey === undefined || key < minKey)) {\n                minKey = key;\n            }\n        }\n        return minKey;\n    }\n\n    /**\n     * Returns the count of entries in the given range.\n     * If the optional query is not given, it returns the count of entries in the object store.\n     * If the query is of type KeyRange, it returns the count of entries within the given range.\n     * @param {KeyRange} [query]\n     * @returns {Promise.<number>}\n     */\n    async count(query=null) {\n        // Unfortunately, we cannot do better than getting keys + counting.\n        return (await this.keys(query)).size;\n    }\n\n    /**\n     * Returns the index of the given name.\n     * If the index does not exist, it returns undefined.\n     * @param {string} indexName The name of the requested index.\n     * @returns {IIndex} The index associated with the given name.\n     */\n    index(indexName) {\n        return this._indices.get(indexName);\n    }\n\n    /**\n     * Alias for abort.\n     * @returns {Promise} The promise resolves after successful abortion of the transaction.\n     */\n    close() {\n        return this.abort();\n    }\n\n    /**\n     * Creates a nested transaction, ensuring read isolation.\n     * This makes the current transaction read-only until all sub-transactions have been closed (committed/aborted).\n     * The same semantic for commits applies: Only the first transaction that commits will be applied. Subsequent transactions will be conflicted.\n     * This behaviour has one exception: If all nested transactions are closed, the outer transaction returns to a normal state and new nested transactions can again be created and committed.\n     * @param {boolean} [enableWatchdog]\n     * @returns {Transaction} The transaction object.\n     */\n    transaction(enableWatchdog = true) {\n        if (this._state !== Transaction.STATE.OPEN && this._state !== Transaction.STATE.NESTED) {\n            throw new Error('Transaction already closed');\n        }\n        const tx = new Transaction(this._objectStore, this, this, enableWatchdog);\n        this._nested.add(tx);\n        this._state = Transaction.STATE.NESTED;\n        return tx;\n    }\n\n\n    /**\n     * Creates a nested synchronous transaction, ensuring read isolation.\n     * This makes the current transaction read-only until all sub-transactions have been closed (committed/aborted).\n     * The same semantic for commits applies: Only the first transaction that commits will be applied. Subsequent transactions will be conflicted.\n     * This behaviour has one exception: If all nested transactions are closed, the outer transaction returns to a normal state and new nested transactions can again be created and committed.\n     * @param {boolean} [enableWatchdog]\n     * @returns {SynchronousTransaction} The transaction object.\n     */\n    synchronousTransaction(enableWatchdog = true) {\n        if (this._state !== Transaction.STATE.OPEN && this._state !== Transaction.STATE.NESTED) {\n            throw new Error('Transaction already closed');\n        }\n        const tx = new SynchronousTransaction(this._objectStore, this, this, enableWatchdog);\n        this._nested.add(tx);\n        this._state = Transaction.STATE.NESTED;\n        return tx;\n    }\n\n    /**\n     * Checks whether an object store implements the ISynchronousObjectStore interface.\n     * @returns {boolean} The transaction object.\n     */\n    isSynchronous() {\n        return false;\n    }\n\n    /**\n     * Creates an in-memory snapshot of this state.\n     * This snapshot only maintains the differences between the state at the time of the snapshot\n     * and the current state.\n     * To stop maintaining the snapshot, it has to be aborted.\n     * @returns {Snapshot}\n     */\n    snapshot() {\n        if (this.state !== Transaction.STATE.COMMITTED) {\n            const snapshot = this._managingBackend.snapshot();\n            snapshot.inherit(this);\n            return snapshot;\n        }\n        return this._snapshotManager.createSnapshot(this._objectStore, this);\n    }\n\n    toString() {\n        return `Transaction{id=${this._id}, changes=${this._modified.size+this._removed.size}, truncated=${this._truncated}, objectStore=${this._objectStore}, state=${this._state}, dependency=${this._dependency}}`;\n    }\n\n    toStringShort() {\n        return `Transaction{id=${this._id}, changes=${this._modified.size+this._removed.size}, truncated=${this._truncated}, state=${this._state}, dependency=${this._dependency}}`;\n    }\n\n    /**\n     * Commits a transaction to the underlying backend.\n     * The state is only written to the persistent backend if no other transaction is open.\n     * If the commit was successful, new transactions will always be based on the new state.\n     * There are two outcomes for a commit:\n     * If there was no other transaction committed that was based on the same state,\n     * it will be successful and change the transaction's state to COMMITTED (returning true).\n     * Otherwise, the state will be CONFLICTED and the method will return false.\n     *\n     * Note that transactions may fail since secondary index constraints are *not* checked in transactions.\n     * @param {Transaction} [tx] The transaction to be applied, only used internally.\n     * @returns {Promise.<boolean>} A promise of the success outcome.\n     */\n    async commit(tx) {\n        // Transaction is given, so check whether this is a nested one.\n        if (tx !== undefined) {\n            if (!this._isCommittable(tx)) {\n                await this.abort(tx);\n                return false;\n            }\n\n            await this._commitInternal(tx);\n            return true;\n        }\n\n        if (this._dependency !== null) {\n            return this._dependency.commit();\n        }\n\n        await this._checkConstraints();\n\n        return this._commitBackend();\n    }\n\n    /**\n     * Aborts a transaction and (if this was the last open transaction) potentially\n     * persists the most recent, committed state.\n     * @param {Transaction} [tx] The transaction to be applied, only used internally.\n     * @returns {Promise.<boolean>} A promise of the success outcome.\n     */\n    async abort(tx) {\n        // Transaction is given, so check whether this is a nested one.\n        if (tx !== undefined) {\n            // Handle snapshots.\n            if (tx instanceof Snapshot) {\n                return this._snapshotManager.abortSnapshot(tx);\n            }\n\n            // Make sure transaction is based on this transaction.\n            if (!this._nested.has(tx) || tx.state !== Transaction.STATE.OPEN) {\n                throw new Error('Can only abort open, nested transactions');\n            }\n            this._nested.delete(tx);\n            // If there are no more nested transactions, change back to OPEN state.\n            if (this._nested.size === 0) {\n                this._state = Transaction.STATE.OPEN;\n                this._nestedCommitted = false;\n            }\n            return true;\n        }\n\n        if (this._dependency !== null) {\n            return this._dependency.abort();\n        }\n\n        return this._abortBackend();\n    }\n\n    /**\n     * Internally applies a transaction to the transaction's state.\n     * This needs to be done in batch (as a db level transaction), i.e., either the full state is updated\n     * or no changes are applied.\n     * @param {Transaction} tx The transaction to apply.\n     * @returns {Promise} The promise resolves after applying the transaction.\n     * @protected\n     */\n    async _apply(tx) {\n        if (!(tx instanceof Transaction)) {\n            throw new Error('Can only apply transactions');\n        }\n\n        // First handle snapshots.\n        await this._snapshotManager.applyTx(tx, this);\n\n        this._applySync(tx);\n    }\n\n    /**\n     * Commits the transaction to the backend.\n     * @returns {Promise.<boolean>} A promise of the success outcome.\n     * @protected\n     */\n    async _commitBackend() {\n        if (this._state !== Transaction.STATE.OPEN) {\n            throw new Error('Transaction already closed or in nested state');\n        }\n        if (this._enableWatchdog) {\n            clearTimeout(this._watchdog);\n        }\n\n        const commitStart = Date.now();\n        if (await this._managingBackend.commit(this)) {\n            this._state = Transaction.STATE.COMMITTED;\n            this._performanceCheck(commitStart, 'commit');\n            this._performanceCheck();\n            return true;\n        } else {\n            this._state = Transaction.STATE.CONFLICTED;\n            this._performanceCheck(commitStart, 'commit');\n            this._performanceCheck();\n            return false;\n        }\n    }\n\n    /**\n     * @param {number} [startTime]\n     * @param {string} [functionName]\n     * @private\n     */\n    _performanceCheck(startTime=this._startTime, functionName=null) {\n        const executionTime = Date.now() - startTime;\n        functionName = functionName ? ` function '${functionName}'` : '';\n        if (executionTime > Transaction.WATCHDOG_TIMER) {\n            Log.w(Transaction, `Violation: tx id ${this._id}${functionName} took ${(executionTime/1000).toFixed(2)}s (${this.toString()}).`);\n        }\n    }\n\n    /**\n     * Is used to probe whether a transaction can be committed.\n     * This, for example, includes a check whether another transaction has already been committed.\n     * @protected\n     * @param {Transaction} [tx] The transaction to be applied, if not given checks for the this transaction.\n     * @returns {boolean} Whether a commit will be successful.\n     */\n    _isCommittable(tx) {\n        if (tx !== undefined) {\n            // Make sure transaction is based on this transaction.\n            if (!this._nested.has(tx) || tx.state !== Transaction.STATE.OPEN) {\n                throw new Error('Can only commit open, nested transactions');\n            }\n            return !this._nestedCommitted;\n        }\n        return this._managingBackend._isCommittable(this);\n    }\n\n    /**\n     * Is used to commit the transaction to the in memory state.\n     * @protected\n     * @param {Transaction} tx The transaction to be applied.\n     * @returns {Promise} A promise that resolves upon successful application of the transaction.\n     */\n    async _commitInternal(tx) {\n        this._nested.delete(tx);\n        // Apply nested transaction.\n        this._nestedCommitted = true;\n        await this._apply(tx);\n        // If there are no more nested transactions, change back to OPEN state.\n        if (this._nested.size === 0) {\n            this._state = Transaction.STATE.OPEN;\n            this._nestedCommitted = false;\n        }\n    }\n\n    /**\n     * Allows to change the backend of a Transaction when the state has been flushed.\n     * @param parent\n     * @protected\n     */\n    _setParent(parent) {\n        this._parent = parent;\n    }\n\n    /**\n     * Aborts a transaction on the backend.\n     * @returns {Promise.<boolean>} A promise of the success outcome.\n     */\n    async _abortBackend() {\n        if (this._state === Transaction.STATE.ABORTED || this._state === Transaction.STATE.CONFLICTED) {\n            return true;\n        }\n        if (this._state !== Transaction.STATE.OPEN && this._state !== Transaction.STATE.NESTED) {\n            throw new Error('Transaction already closed');\n        }\n        if (this._state === Transaction.STATE.NESTED) {\n            await Promise.all(Array.from(this._nested).map(tx => tx.abort()));\n        }\n        if (this._enableWatchdog) {\n            clearTimeout(this._watchdog);\n        }\n        const abortStart = Date.now();\n        await this._managingBackend.abort(this);\n        this._setAborted();\n        this._performanceCheck(abortStart, 'abort');\n        this._performanceCheck();\n        return true;\n    }\n\n    /**\n     * Sets the state to aborted.\n     */\n    _setAborted() {\n        this._state = Transaction.STATE.ABORTED;\n    }\n\n    /**\n     * Internal method for inserting/replacing a key-value pair.\n     * @param {string} key The primary key to associate the value with.\n     * @param {*} value The value to write.\n     * @protected\n     */\n    _put(key, value) {\n        this._removed.delete(key);\n        const localOldValue = this._modified.get(key);\n        this._modified.set(key, value);\n\n        // Update indices.\n        for (const index of this._indices.values()) {\n            index.put(key, value, localOldValue);\n        }\n    }\n\n    /**\n     * Internal method for removing a key-value pair.\n     * @param {string} key The primary key to delete along with the associated object.\n     * @protected\n     */\n    _remove(key) {\n        this._removed.add(key);\n        const localOldValue = this._modified.get(key);\n        this._modified.delete(key);\n\n        // Update indices.\n        for (const index of this._indices.values()) {\n            index.remove(key, localOldValue);\n        }\n    }\n\n    /**\n     * Is used to check constraints before committing.\n     * If a constraint is not satisfied, the commitable is aborted and an exception is thrown.\n     * @returns {Promise.<boolean>}\n     * @throws\n     * @protected\n     */\n    async _checkConstraints() {\n        // Check unique indices.\n        // TODO: Improve performance (|modified| count queries).\n        const constraintChecks = [];\n        for (const /** @type {TransactionIndex} */ index of this._indices.values()) {\n            if (!index.unique) continue;\n            for (const [key, value] of this._modified) {\n                constraintChecks.push(index.checkUniqueConstraint(key, value));\n            }\n        }\n        if (constraintChecks.length > 0) {\n            try {\n                await Promise.all(constraintChecks);\n            } catch (e) {\n                await this.abort();\n                throw e;\n            }\n        }\n    }\n\n    /**\n     * Method called to decode a single value.\n     * @param {*} value Value to be decoded.\n     * @param {string} key Key corresponding to the value.\n     * @returns {*} The decoded value.\n     */\n    decode(value, key) {\n        return this._objectStore.decode(value, key);\n    }\n\n    /**\n     * Method called to encode a single value.\n     * @param {*} value Value to be encoded.\n     * @returns {*} The encoded value.\n     */\n    encode(value) {\n        return this._objectStore.encode(value);\n    }\n}\n/** @type {number} Milliseconds to wait until automatically aborting transaction. */\nTransaction.WATCHDOG_TIMER = 5000 /*ms*/;\n/**\n * The states of a transaction.\n * New transactions are in the state OPEN until they are aborted, committed or a nested transaction is created.\n * Aborted transactions move to the state ABORTED.\n * Committed transactions move to the state COMMITTED,\n * if no other transaction has been applied to the same state.\n * Otherwise, they change their state to CONFLICTED.\n * When creating a nested (not read-isolated) transaction on top of a transaction,\n * the outer transaction moves to the state NESTED until the inner transaction is either aborted or committed.\n * Again, only one inner transaction may be committed.\n * @enum {number}\n */\nTransaction.STATE = {\n    OPEN: 0,\n    COMMITTED: 1,\n    ABORTED: 2,\n    CONFLICTED: 3,\n    NESTED: 4\n};\nTransaction._instanceCount = 0;\nClass.register(Transaction);\n","/**\n * Synchronous transactions avoid unnecessary async/await calls by preloading and caching\n * all necessary key-value-pairs.\n *\n * WARNING: If not all required key-value-pairs are preloaded, the results of any call on a synchronous transaction\n * might be wrong. Only use synchronous transactions, if unavoidable.\n * @implements {ISynchronousObjectStore}\n * @implements {ICommittable}\n * @extends {Transaction}\n */\nclass SynchronousTransaction extends Transaction {\n    /**\n     * This constructor should only be called by an ObjectStore object.\n     * Our transactions have a watchdog enabled by default,\n     * logging a warning after a certain time specified by WATCHDOG_TIMER.\n     * This helps to detect unclosed transactions preventing to store the state in\n     * the persistent backend.\n     * @param {ObjectStore} objectStore The object store this transaction belongs to.\n     * @param {IObjectStore} parent The backend on which the transaction is based,\n     * i.e., another transaction or the real database.\n     * @param {ICommittable} [managingBackend] The object store managing the transactions,\n     * i.e., the ObjectStore object.\n     * @param {boolean} [enableWatchdog] If this is is set to true (default),\n     * a warning will be logged if left open for longer than WATCHDOG_TIMER.\n     * @protected\n     */\n    constructor(objectStore, parent, managingBackend, enableWatchdog=true) {\n        super(objectStore, parent, managingBackend, enableWatchdog);\n        /** @type {Map.<string,*>} */\n        this._cache = new Map();\n    }\n\n    /**\n     * This method preloads a set of keys and caches them.\n     * It can be called as often as needed.\n     * @param {Array.<string>} keys The keys to preload.\n     * @return {Promise}\n     */\n    preload(keys) {\n        keys = keys.filter(key => !this.isCached(key));\n        return Promise.all(keys.map(key => this.get(key)));\n    }\n\n    /**\n     * A check whether a certain key is cached.\n     * @param {string} key The key to check.\n     * @return {boolean} A boolean indicating whether the key is already in the cache.\n     */\n    isCached(key) {\n        // This also prevents double caching.\n        return this._cache.has(key) || (this._parent.isSynchronous() ? this._parent.isCached(key) : false);\n    }\n\n    /**\n     * @param {string} key\n     * @param {RetrievalConfig} [options] Advanced retrieval options.\n     */\n    async get(key, options = {}) {\n        options.expectPresence = false;\n        // Use cache or ask parent.\n        let value;\n        if (this.isCached(key)) {\n            value = this.getSync(key, options);\n        } else {\n            value = await Transaction.prototype.get.call(this, key, options);\n            if (options && options.raw) {\n                this._cache.set(key, this.decode(value, key));\n            } else {\n                this._cache.set(key, value);\n            }\n        }\n        return value;\n    }\n\n    /**\n     * Internal method to query cache.\n     * @param {string} key\n     * @param {SyncRetrievalConfig} [options] Advanced retrieval options.\n     * @return {*} The cached value.\n     * @private\n     */\n    _getCached(key, options = {}) {\n        const { expectPresence = true } = options || {};\n        let value = this._cache.get(key);\n\n        // Use cache only if the parent is not synchronous.\n        if (!value && this._parent.isSynchronous()) {\n            return this._parent.getSync(key, options);\n        }\n\n        if (expectPresence && !value) {\n            throw new Error(`Missing key in cache: ${key}`);\n        }\n\n        // Raw requests\n        if (options && options.raw) {\n            value = this.encode(value);\n        }\n\n        return value;\n    }\n\n    /**\n     * Returns the object stored under the given primary key.\n     * Resolves to undefined if the key is not present in the object store.\n     * @param {string} key The primary key to look for.\n     * @param {SyncRetrievalConfig} [options] Advanced retrieval options.\n     * @returns {*} The object stored under the given key, or undefined if not present.\n     */\n    getSync(key, options = {}) {\n        // Order is as follows:\n        // 1. check if removed,\n        // 2. check if modified,\n        // 3. check if truncated\n        // 4. request from backend\n        if (this._removed.has(key)) {\n            return undefined;\n        }\n        if (this._modified.has(key)) {\n            if (options && options.raw) {\n                return this.encode(this._modified.get(key));\n            }\n            return this._modified.get(key);\n        }\n        if (this._truncated) {\n            return undefined;\n        }\n        return this._getCached(key, options);\n    }\n\n    /**\n     * Checks whether an object store implements the ISynchronousObjectStore interface.\n     * @override\n     * @returns {boolean} The transaction object.\n     */\n    isSynchronous() {\n        return true;\n    }\n}\nClass.register(SynchronousTransaction);\n","/**\n * Snapshots present a read-only version of a specific state.\n * As long as a snapshot is not aborted, the object store will reflect changes to the state\n * in form of the differences to the originating state in the snapshot.\n * This makes efficient queries against a fixed state possible without blocking other transactions\n * to commit.\n * @extends {Transaction}\n */\nclass Snapshot extends Transaction {\n    /**\n     * This constructor should only be called by an ObjectStore object.\n     * @param {ObjectStore} objectStore The object store this transaction belongs to.\n     * @param {IObjectStore} backend The backend this transaction is based on.\n     * @protected\n     */\n    constructor(objectStore, backend) {\n        super(objectStore, backend, objectStore, false);\n    }\n\n    /**\n     * A specific set of changes can be assumed to be already applied by providing a Transaction or Snapshot.\n     * These differences will be inherited while the backend of the snapshot remains the current state.\n     * This is useful, if we have a transaction/snapshot to a previous state, which we do not want to commit.\n     * Then, we can still base our snapshot on this earlier state although the current backend is already ahead.\n     * @param {Transaction} tx A transaction or snapshot containing changes that have already been applied.\n     * @protected\n     */\n    inherit(tx) {\n        if (!(tx instanceof Transaction)) {\n            throw new Error('Can only inherit transactions');\n        }\n\n        return super._applySync(tx);\n    }\n\n    /**\n     * Internally applies a transaction to the snapshot state.\n     * In contrast to transactions, this tries to reflect the old state in the snapshot.\n     * @param {Transaction} tx The transaction to apply.\n     * @returns {Promise} The promise resolves after applying the transaction.\n     * @protected\n     */\n    async _apply(tx) {\n        if (!(tx instanceof Transaction)) {\n            throw new Error('Can only apply transactions');\n        }\n        if (tx._truncated) {\n            // Need to copy complete old state.\n            await this.valueStream((value, key) => {\n                if (!this._modified.has(key)) {\n                    this._put(key, value);\n                }\n                return true;\n            });\n        }\n        for (const [key, value] of tx._modified) {\n            // Continue if we already have the old value for this key.\n            if (this._modified.has(key)) {\n                continue;\n            }\n            let oldValue = await this.get(key);\n            // If this key is newly introduced,\n            // we have to mark it as removed to maintain our state.\n            if (!oldValue) {\n                this._remove(key, value);\n            } else {\n                // Otherwise store oldValue.\n                this._put(key, oldValue, value);\n            }\n        }\n        for (const key of tx._removed) {\n            // Continue if we already have the old value for this key.\n            if (this._modified.has(key)) {\n                continue;\n            }\n            // Removed values have to be remembered.\n            let oldValue = await this.get(key);\n            this._put(key, oldValue);\n        }\n    }\n\n    /**\n     * Unsupported operation for snapshots.\n     * @returns {Promise}\n     * @override\n     */\n    async truncate() {\n        throw new Error('Unsupported operation on snapshots: truncate');\n    }\n\n    /**\n     * Unsupported operation for snapshots.\n     * @override\n     */\n    truncateSync() {\n        throw new Error('Unsupported operation on snapshots: truncateSync');\n    }\n\n    /**\n     * Unsupported operation for snapshots.\n     * @override\n     * @throws\n     */\n    async commit(tx) {\n        throw new Error('Cannot commit snapshots: commit');\n    }\n\n    /**\n     * Unsupported operation for snapshots.\n     * @override\n     * @protected\n     * @param {Transaction} [tx] The transaction to be applied, if not given checks for the this transaction.\n     * @returns {boolean} Whether a commit will be successful.\n     */\n    _isCommittable(tx) {\n        return false;\n    }\n\n    /**\n     * Unsupported operation for snapshots.\n     * @override\n     * @protected\n     * @param {Transaction} tx The transaction to be applied.\n     * @returns {Promise} A promise that resolves upon successful application of the transaction.\n     */\n    async _commitInternal(tx) {\n        throw new Error('Cannot commit snapshots');\n    }\n\n    /**\n     * Commits the transaction to the backend.\n     * @override\n     * @returns {Promise.<boolean>} A promise of the success outcome.\n     * @protected\n     */\n    async _commitBackend() {\n        throw new Error('Cannot commit snapshots');\n    }\n\n    /**\n     * Aborts a snapshot and stops updating its diff.\n     * @override\n     * @param [tx]\n     * @returns {Promise.<boolean>} A promise of the success outcome.\n     */\n    abort(tx) {\n        return this._abortBackend();\n    }\n\n    /**\n     * Aborts a transaction on the backend.\n     * @returns {Promise.<boolean>} A promise of the success outcome.\n     * @override\n     */\n    async _abortBackend() {\n        if (this._state !== Transaction.STATE.OPEN) {\n            throw new Error('Snapshot already closed');\n        }\n        const result = await this._managingBackend.abort(this);\n        if (!result) {\n            return false;\n        }\n\n        this._state = Transaction.STATE.ABORTED;\n\n        // Cleanup.\n        this._truncated = true;\n        this._modified.clear();\n        this._removed.clear();\n\n        // Update indices.\n        for (const index of this._indices.values()) {\n            index.truncate();\n        }\n\n        return true;\n    }\n\n    /**\n     * Unsupported operation for snapshots.\n     * @override\n     * @returns {Promise}\n     */\n    async put(key, value) {\n        throw new Error('Unsupported operation on snapshots: put');\n    }\n\n    /**\n     * Unsupported operation for snapshots.\n     * @override\n     */\n    putSync(key, value) {\n        throw new Error('Unsupported operation on snapshots: putSync');\n    }\n\n    /**\n     * Unsupported operation for snapshots.\n     * @override\n     * @returns {Promise}\n     */\n    async remove(key) {\n        throw new Error('Unsupported operation on snapshots: remove');\n    }\n\n    /**\n     * Unsupported operation for snapshots.\n     * @override\n     */\n    removeSync(key) {\n        throw new Error('Unsupported operation on snapshots: removeSync');\n    }\n\n    /**\n     * Alias for abort.\n     * @returns {Promise} The promise resolves after successful abortion of the transaction.\n     */\n    close() {\n        return this.abort();\n    }\n\n    /**\n     * Unsupported operation for snapshots.\n     * @override\n     */\n    transaction() {\n        throw new Error('Unsupported operation on snapshots: transaction');\n    }\n\n    /**\n     * Unsupported operation for snapshots.\n     * @override\n     */\n    synchronousTransaction() {\n        throw new Error('Unsupported operation on snapshots: synchronousTransaction');\n    }\n\n    /**\n     * Unsupported operation for snapshots.\n     * @override\n     */\n    snapshot() {\n        throw new Error('Unsupported operation on snapshots: snapshot');\n    }\n}\nClass.register(Snapshot);\n","/**\n * Defines the functionality needed for handling snapshots.\n * @abstract\n */\nclass SnapshotManager {\n    constructor() {\n        this._snapshots = new Set();\n    }\n\n    /**\n     * Creates an in-memory snapshot of the current state.\n     * This snapshot only maintains the differences between the state at the time of the snapshot\n     * and the current state.\n     * To stop maintaining the snapshot, it has to be aborted.\n     * @param {ObjectStore} objectStore\n     * @param {IObjectStore} backend\n     * @returns {Snapshot}\n     */\n    createSnapshot(objectStore, backend) {\n        const snapshot = new Snapshot(objectStore, backend);\n        this._snapshots.add(snapshot);\n        return snapshot;\n    }\n\n\n    /**\n     * Aborts a snapshot.\n     * @param {Snapshot} snapshot\n     * @returns {boolean} A promise of the success outcome.\n     */\n    abortSnapshot(snapshot) {\n        return this._snapshots.delete(snapshot);\n    }\n\n    /**\n     * Updates the snapshots managed by this class.\n     * @param {Transaction} tx The transaction to apply.\n     * @param {IObjectStore} backend\n     * @returns {Promise} The promise resolves after applying the transaction.\n     */\n    async applyTx(tx, backend) {\n        if (!(tx instanceof Transaction)) {\n            throw new Error('Can only apply transactions');\n        }\n\n        // First handle snapshots:\n        // - Apply tx to own snapshots.\n        // - Take over new snapshots.\n        const applications = [];\n        for (const snapshot of this._snapshots) {\n            applications.push(snapshot._apply(tx));\n        }\n        for (const snapshot of tx._snapshotManager) {\n            snapshot._backend = backend;\n            this._snapshots.add(snapshot);\n        }\n        return Promise.all(applications);\n    }\n\n    /**\n     * Returns an iterator over the snapshots.\n     * @returns {Iterator.<Snapshot>}\n     */\n    [Symbol.iterator]() {\n        return this._snapshots.values();\n    }\n}\nClass.register(SnapshotManager);\n","/**\n * This class represents a combined transaction across object stores.\n * @implements {ICommittable}\n */\nclass CombinedTransaction {\n    /**\n     * @param {...Transaction} transactions The transactions to build the combined transaction from.\n     */\n    constructor(...transactions) {\n        if (!this.isConsistent(transactions)) {\n            throw new Error('Given set of transactions violates rules for combined transactions');\n        }\n        this._transactions = transactions;\n        /** @type {Map.<Transaction,function()>} */\n        this._flushable = new Map();\n        /** @type {Map.<Transaction,function()>} */\n        this._preprocessing = [];\n\n        // Update members.\n        this._dependency = this;\n    }\n\n    /** @type {JungleDB} */\n    get backend() {\n        return this._jdb;\n    }\n\n    /** @type {Array.<Transaction>} */\n    get transactions() {\n        return this._transactions;\n    }\n\n    /**\n     * Verifies the two most important consistency rules for combined transactions:\n     * 1. only transactions from different object stores\n     * 2. only open transactions\n     * 3. only transactions from the same JungleDB instance\n     * 4. only non-nested transactions\n     * @param {Array.<Transaction>} transactions\n     * @returns {boolean} Whether the given set of transactions is suitable for a combined transaction.\n     */\n    isConsistent(transactions) {\n        const objectStores = new Set();\n        this._jdb = null;\n        for (const tx of transactions) {\n            // Rule 2 is violated:\n            if (tx.state !== Transaction.STATE.OPEN) {\n                return false;\n            }\n            // Rule 4 is violated:\n            if (tx.nested) {\n                return false;\n            }\n            // Rule 1 is violated:\n            if (objectStores.has(tx._objectStore)) {\n                return false;\n            }\n            // Rule 3 is violated:\n            if (this._jdb === null) {\n                this._jdb = tx._objectStore.jungleDB;\n            } else if (this._jdb !== tx._objectStore.jungleDB && tx._objectStore.jungleDB !== null) { // null = InMemory\n                return false;\n            }\n            objectStores.add(tx._objectStore);\n        }\n        return true;\n    }\n\n    /**\n     * To be called when a transaction is flushable to the persistent state.\n     * Triggers combined flush as soon as all transactions are ready.\n     * @param {Transaction} tx Transaction to be reported flushable.\n     * @param {function()} [callback] A callback to be called after the transaction is flushed.\n     * @param {function():Promise} [preprocessing] A callback to be called right before the transaction is flushed.\n     * @returns {Promise.<boolean>} Whether the flushing has been triggered.\n     */\n    async onFlushable(tx, callback=null, preprocessing=null) {\n        // Save as flushable and prepare and flush only if all are flushable.\n        // Afterwards call the callbacks to cleanup the ObjectStores' transaction stacks.\n        this._flushable.set(tx, callback);\n        if (preprocessing !== null) {\n            this._preprocessing.push(preprocessing);\n        }\n\n        // All are flushable, so go ahead.\n        if (this._transactions.every(tx => this._flushable.has(tx))) {\n            // Allow to prepare final flush.\n            const preprocessings = [];\n            for (const f of this._preprocessing) {\n                preprocessings.push(f());\n            }\n            await Promise.all(preprocessings);\n\n            await JungleDB.commitCombined(this);\n            for (const value of this._flushable.values()) {\n                value();\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Is used to commit the state of an open transaction.\n     * A user only needs to call this method on Transactions without arguments.\n     * The optional tx argument is only used internally, in order to commit a transaction to the underlying store.\n     * If the commit was successful, the method returns true, and false otherwise.\n     * @returns {Promise.<boolean>} A promise of the success outcome.\n     */\n    async commit() {\n        if (this._isCommittable()) {\n            await this._checkConstraints();\n\n            await this._commitBackend();\n            return true;\n        }\n        await this.abort();\n        return false;\n    }\n\n    /**\n     * Is used to abort an open transaction.\n     * A user only needs to call this method on Transactions without arguments.\n     * The optional tx argument is only used internally, in order to abort a transaction on the underlying store.\n     * @returns {Promise} The promise resolves after successful abortion of the transaction.\n     */\n    abort() {\n        return this._abortBackend();\n    }\n\n    /**\n     * Aborts a transaction on the backend.\n     * @returns {Promise.<boolean>} A promise of the success outcome.\n     * @override\n     */\n    async _abortBackend() {\n        return (await Promise.all(this._transactions.map(tx => tx._abortBackend()))).every(r => r);\n    }\n\n    /**\n     * Creates a new transaction, ensuring read isolation\n     * on the most recently successfully committed state.\n     * @param {boolean} [enableWatchdog]\n     * @returns {Transaction} The transaction object.\n     */\n    transaction(enableWatchdog) {\n        throw new Error('Unsupported operation');\n    }\n\n    /**\n     * Creates an in-memory snapshot of the current state.\n     * This snapshot only maintains the differences between the state at the time of the snapshot\n     * and the current state.\n     * To stop maintaining the snapshot, it has to be aborted.\n     * @returns {Snapshot}\n     */\n    snapshot() {\n        throw new Error('Unsupported operation');\n    }\n\n    /**\n     * Is used to probe whether a transaction can be committed.\n     * This, for example, includes a check whether another transaction has already been committed.\n     * @protected\n     * @returns {boolean} Whether a commit will be successful.\n     */\n    _isCommittable() {\n        return this._transactions.every(tx => tx._isCommittable());\n    }\n\n    /**\n     * Is used to check constraints before committing.\n     * If a constraint is not satisfied, the commitable is aborted and an exception is thrown.\n     * @returns {Promise.<boolean>}\n     * @throws\n     * @protected\n     */\n    async _checkConstraints() {\n        try {\n            await Promise.all(this._transactions.map(tx => tx._checkConstraints()));\n        } catch (e) {\n            await this.abort();\n            throw e;\n        }\n    }\n\n    /**\n     * Is used to commit the transaction.\n     * @protected\n     * @returns {Promise} A promise that resolves upon successful application of the transaction.\n     */\n    async _commitBackend() {\n        return (await Promise.all(this._transactions.map(tx => tx._commitBackend()))).every(r => r);\n    }\n\n    /**\n     * Unsupported operation for snapshots.\n     * @protected\n     * @param {Transaction} tx The transaction to be applied.\n     * @returns {Promise} A promise that resolves upon successful application of the transaction.\n     */\n    async _commitInternal(tx) {\n        throw new Error('Cannot commit transactions to a combined transaction');\n    }\n\n    /**\n     * Allows to change the backend of a Transaction when the state has been flushed.\n     * @param parent\n     * @protected\n     */\n    _setParent(parent) {\n        throw new Error('Unsupported operation');\n    }\n\n    /**\n     * Sets a new CombinedTransaction as dependency.\n     * @param {CombinedTransaction} dependency\n     * @protected\n     */\n    set _dependency(dependency) {\n        for (const tx of this._transactions) {\n            tx._dependency = dependency;\n        }\n    }\n\n    /**\n     * @type {CombinedTransaction} If existent, a combined transaction encompassing this object.\n     */\n    get dependency() {\n        return this;\n    }\n\n    /**\n     * Returns the object store this transaction belongs to.\n     * @type {ObjectStore}\n     */\n    get objectStore() {\n        throw new Error('Unsupported operation');\n    }\n\n    toString() {\n        return `CombinedTransaction{size=${this._transactions.length}, states=[${this._transactions.map(tx => tx.state)}]}`;\n    }\n}\nClass.register(CombinedTransaction);\n","    exports._loaded = true;\n    if (typeof exports._onload === 'function') exports._onload();\n    return exports;\n})(JDB);\n","class Class {\n    static get scope() {\n        if (typeof exports !== 'undefined') return exports;\n        return window;\n    }\n\n    static register(cls) {\n        if (typeof exports !== 'undefined') exports[cls.name] = cls;\n    }\n}\nClass.register(Class);\n","class LogNative {\n    constructor() {\n        this._global_level = Log.INFO;\n        this._tag_levels = {};\n        try {\n            if (window.localStorage) {\n                try {\n                    let c = window.localStorage.getItem('log_tag_levels');\n                    if (c && typeof c === 'string') c = JSON.parse(c);\n                    if (c && typeof c === 'object') this._tag_levels = c;\n                } catch (e) {\n                    console.warn('Failed to load log configuration from local storage.');\n                }\n            }\n        } catch (e) {\n            // ignore\n        }\n    }\n\n    isLoggable(tag, level) {\n        if (tag && this._tag_levels[tag]) {\n            return this._tag_levels[tag] <= level;\n        }\n        if (this._tag_levels['*']) {\n            return this._tag_levels['*'] <= level;\n        }\n        return this._global_level <= level;\n    }\n\n    setLoggable(tag, level) {\n        if (tag && tag.name) tag = tag.name;\n        this._tag_levels[tag] = level;\n        if (window.localStorage) {\n            window.localStorage.setItem('log_tag_levels', JSON.stringify(this._tag_levels));\n        }\n    }\n\n    msg(level, tag, args) {\n        if (tag && tag.name) tag = tag.name;\n        if (!this.isLoggable(tag, level)) return;\n        if (tag) args.unshift(tag + ':');\n        args.unshift(`[${Log.Level.toStringTag(level)} ${new Date().toTimeString().substr(0, 8)}]`);\n        if (console.error && level >= Log.ERROR) {\n            console.error.apply(console, args);\n        } else if (console.warn && level >= Log.WARNING) {\n            console.warn.apply(console, args);\n        } else if (console.info && level >= Log.INFO) {\n            console.info.apply(console, args);\n        } else if (console.debug && level >= Log.DEBUG) {\n            console.debug.apply(console, args);\n        } else if (console.trace && level <= Log.TRACE) {\n            console.trace.apply(console, args);\n        } else {\n            console.log.apply(console, args);\n        }\n    }\n}\nClass.register(LogNative);\n","class Log {\n    /**\n     * @returns {Log}\n     */\n    static get instance() {\n        if (!Log._instance) {\n            Log._instance = new Log(new LogNative());\n        }\n        return Log._instance;\n    }\n\n    /**\n     * @param {LogNative} native\n     */\n    constructor(native) {\n        /** @type {LogNative} */\n        this._native = native;\n    }\n\n    /**\n     * @param {string} tag\n     * @param {Log.Level} level\n     */\n    setLoggable(tag, level) {\n        this._native.setLoggable(tag, Log.Level.get(level));\n    }\n\n    /** @type {Log.Level} */\n    get level() {\n        return this._native._global_level;\n    }\n\n    /** @type {Log.Level} */\n    set level(l) {\n        this._native._global_level = Log.Level.get(l);\n    }\n\n    /**\n     * @param {Log.Level} level\n     * @param {string|{name:string}} tag\n     * @param {Array} args\n     */\n    msg(level, tag, args) {\n        if (this._native.isLoggable(tag, level)) {\n            for (let i = 0; i < args.length; ++i) {\n                if (typeof args[i] === 'function') {\n                    args[i] = args[i]();\n                }\n                if (typeof args[i] === 'object') {\n                    if (typeof args[i].toString === 'function') {\n                        args[i] = args[i].toString();\n                    } else if (args[i].constructor && args[i].constructor.name) {\n                        args[i] = `{Object: ${args[i].constructor.name}}`;\n                    } else {\n                        args[i] = '{Object}';\n                    }\n                }\n            }\n            this._native.msg(level, tag, args);\n        }\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static d(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.DEBUG, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static e(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.ERROR, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static i(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.INFO, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static v(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.VERBOSE, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static w(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.WARNING, tag, args);\n    }\n\n    /**\n     * @param {?string|{name:string}} [tag=undefined]\n     * @param {string|function():string} message\n     * @param {...*} args\n     */\n    static t(tag, message, ...args) {\n        if (arguments.length >= 2) {\n            tag = arguments[0];\n            args = Array.prototype.slice.call(arguments, 1);\n        } else {\n            tag = undefined;\n            args = Array.prototype.slice.call(arguments, 0);\n        }\n        Log.instance.msg(Log.TRACE, tag, args);\n    }\n}\n\n/**\n * @enum {number|string}\n */\nLog.Level = {\n    TRACE: 1,\n    VERBOSE: 2,\n    DEBUG: 3,\n    INFO: 4,\n    WARNING: 5,\n    ERROR: 6,\n    ASSERT: 7,\n\n    /**\n     * @param {Log.Level} level\n     * @returns {string}\n     */\n    toStringTag: function (level) {\n        switch (level) {\n            case Log.Level.TRACE:\n                return 'T';\n            case Log.Level.VERBOSE:\n                return 'V';\n            case Log.Level.DEBUG:\n                return 'D';\n            case Log.Level.INFO:\n                return 'I';\n            case Log.Level.WARNING:\n                return 'W';\n            case Log.Level.ERROR:\n                return 'E';\n            case Log.Level.ASSERT:\n                return 'A';\n            default:\n                return '*';\n        }\n    },\n\n    toString: function (level) {\n        switch (level) {\n            case Log.Level.TRACE:\n                return 'trace';\n            case Log.Level.VERBOSE:\n                return 'verbose';\n            case Log.Level.DEBUG:\n                return 'debug';\n            case Log.Level.INFO:\n                return 'info';\n            case Log.Level.WARNING:\n                return 'warn';\n            case Log.Level.ERROR:\n                return 'error';\n            case Log.Level.ASSERT:\n                return 'assert';\n            default:\n                return 'unknown';\n        }\n    },\n\n    /**\n     * @param {string|number|Log.Level} v\n     * @returns {Log.Level}\n     */\n    get: function (v) {\n        if (typeof v === 'number') return /** @type {Log.Level} */ v;\n        if (!isNaN(parseInt(v))) return /** @type {Log.Level} */ parseInt(v);\n        switch (v.toLowerCase()) {\n            case 't':\n            case 'trace':\n                return Log.Level.TRACE;\n            case 'v':\n            case 'verbose':\n                return Log.Level.VERBOSE;\n            case 'd':\n            case 'debug':\n                return Log.Level.DEBUG;\n            case 'i':\n            case 'info':\n                return Log.Level.INFO;\n            case 'w':\n            case 'warn':\n            case 'warning':\n                return Log.Level.WARNING;\n            case 'e':\n            case 'error':\n            case 'exception':\n                return Log.Level.ERROR;\n            case 'a':\n            case 'assert':\n            case 'assertion':\n                return Log.Level.ASSERT;\n        }\n        return /** @type {Log.Level} */ 0;\n    }\n};\nLog.TRACE = Log.Level.TRACE;\nLog.VERBOSE = Log.Level.VERBOSE;\nLog.DEBUG = Log.Level.DEBUG;\nLog.INFO = Log.Level.INFO;\nLog.WARNING = Log.Level.WARNING;\nLog.ERROR = Log.Level.ERROR;\nLog.ASSERT = Log.Level.ASSERT;\nLog._instance = null;\n\nLog.d.tag = (tag) => Log.d.bind(null, tag);\nLog.e.tag = (tag) => Log.e.bind(null, tag);\nLog.i.tag = (tag) => Log.i.bind(null, tag);\nLog.v.tag = (tag) => Log.v.bind(null, tag);\nLog.w.tag = (tag) => Log.w.bind(null, tag);\nLog.t.tag = (tag) => Log.t.bind(null, tag);\n\nClass.register(Log);\n","class Observable {\n    /**\n     * @returns {string}\n     * @constant\n     */\n    static get WILDCARD() {\n        return '*';\n    }\n\n    constructor() {\n        /** @type {Map.<string, Array.<Function>>} */\n        this._listeners = new Map();\n    }\n\n    /**\n     * @param {string} type\n     * @param {Function} callback\n     * @return {number}\n     */\n    on(type, callback) {\n        if (!this._listeners.has(type)) {\n            this._listeners.set(type, [callback]);\n            return 0;\n        } else {\n            return this._listeners.get(type).push(callback) - 1;\n        }\n    }\n\n    /**\n     * @param {string} type\n     * @param {number} id\n     */\n    off(type, id) {\n        if (!this._listeners.has(type) || !this._listeners.get(type)[id]) return;\n        delete this._listeners.get(type)[id];\n    }\n\n    /**\n     * @param {string} type\n     * @param {...*} args\n     * @returns {Promise|null}\n     */\n    fire(type, ...args) {\n        const promises = [];\n        // Notify listeners for this event type.\n        if (this._listeners.has(type)) {\n            for (const i in this._listeners.get(type)) {\n                const listener = this._listeners.get(type)[i];\n                const res = listener.apply(null, args);\n                if (res instanceof Promise) promises.push(res);\n            }\n        }\n\n        // Notify wildcard listeners. Pass event type as first argument\n        if (this._listeners.has(Observable.WILDCARD)) {\n            for (const i in this._listeners.get(Observable.WILDCARD)) {\n                const listener = this._listeners.get(Observable.WILDCARD)[i];\n                const res = promises.push(listener.apply(null, arguments));\n                if (res instanceof Promise) promises.push(res);\n            }\n        }\n\n        if (promises.length > 0) return Promise.all(promises);\n        return null;\n    }\n\n    /**\n     * @param {Observable} observable\n     * @param {...string} types\n     */\n    bubble(observable, ...types) {\n        for (const type of types) {\n            let callback;\n            if (type == Observable.WILDCARD) {\n                callback = function() {\n                    this.fire.apply(this, arguments);\n                };\n            } else {\n                callback = function() {\n                    this.fire.apply(this, [type, ...arguments]);\n                };\n            }\n            observable.on(type, callback.bind(this));\n        }\n    }\n}\nClass.register(Observable);\n","/**\n * @abstract\n */\nclass DataChannel extends Observable {\n    constructor() {\n        super();\n\n        // Buffer for chunked messages.\n        // XXX We currently only support one chunked message at a time.\n        /** @type {SerialBuffer} */\n        this._buffer = null;\n\n        /** @type {Message.Type} */\n        this._msgType = 0;\n\n        /** @type {number} */\n        this._receivingTag = -1;\n\n        /** @type {number} */\n        this._sendingTag = 0;\n\n        /** @type {Map.<Message.Type, ExpectedMessage>} */\n        this._expectedMessagesByType = new Map();\n\n        /** @type {Timers} */\n        this._timers = new Timers();\n\n        /** @type {number} */\n        this._lastChunkReceivedAt = 0;\n    }\n\n    /**\n     * @param {Message.Type} type\n     * @returns {boolean}\n     */\n    isExpectingMessage(type) {\n        return this._expectedMessagesByType.has(type);\n    }\n\n    /**\n     * @param {Message.Type} type\n     * @param {boolean} success\n     */\n    confirmExpectedMessage(type, success) {\n        const expectedMsg = this._expectedMessagesByType.get(type);\n        if (!expectedMsg) return;\n\n        this._timers.clearTimeout(`chunk-${expectedMsg.id}`);\n        this._timers.clearTimeout(`msg-${expectedMsg.id}`);\n        for (const type of expectedMsg.types) {\n            this._expectedMessagesByType.delete(type);\n        }\n\n        if (!success) {\n            expectedMsg.timeoutCallback();\n        }\n    }\n\n    /**\n     * @param {Message.Type|Array.<Message.Type>} types\n     * @param {function()} timeoutCallback\n     * @param {number} [msgTimeout]\n     * @param {number} [chunkTimeout]\n     */\n    expectMessage(types, timeoutCallback, msgTimeout = DataChannel.MESSAGE_TIMEOUT, chunkTimeout = DataChannel.CHUNK_TIMEOUT) {\n        if (!Array.isArray(types)) {\n            types = [types];\n        }\n\n        if (types.length === 0) return;\n\n        const expectedMsg = new ExpectedMessage(types, timeoutCallback, msgTimeout, chunkTimeout);\n        for (const type of types) {\n            this._expectedMessagesByType.set(type, expectedMsg);\n        }\n\n        // Set timers for any of the expected types.\n        this._timers.resetTimeout(`chunk-${expectedMsg.id}`, this._onTimeout.bind(this, expectedMsg), chunkTimeout);\n        this._timers.resetTimeout(`msg-${expectedMsg.id}`, this._onTimeout.bind(this, expectedMsg), msgTimeout);\n    }\n\n    /**\n     * @abstract\n     */\n\n    /* istanbul ignore next */\n    close() { throw new Error('Not implemented'); }\n\n    /**\n     * @protected\n     */\n    _onClose() {\n        this._timers.clearAll();\n        this.fire('close', this);\n    }\n\n    /**\n     * @param {string} msg\n     * @private\n     */\n    _error(msg) {\n        this.fire('error', msg, this);\n        Log.e(DataChannel, msg);\n        this.close();\n    }\n\n    /**\n     * @param {ArrayBuffer} msg\n     * @protected\n     */\n    _onMessage(msg) {\n        try {\n            // Drop message if the channel is not open.\n            if (this.readyState !== DataChannel.ReadyState.OPEN) {\n                return;\n            }\n\n            // Drop empty messages.\n            const buffer = new SerialBuffer(msg);\n            if (buffer.byteLength === 0) {\n                return;\n            }\n\n            // Chunk is too large.\n            if (buffer.byteLength > DataChannel.CHUNK_SIZE_MAX) {\n                this._error('Received chunk larger than maximum chunk size, discarding');\n                return;\n            }\n\n            const tag = buffer.readUint8();\n\n            // Buffer length without tag.\n            const effectiveChunkLength = buffer.byteLength - buffer.readPos;\n            const chunk = buffer.read(effectiveChunkLength);\n\n            // Detect if this is a new message.\n            if (this._buffer === null && tag === (this._receivingTag + 1) % NumberUtils.UINT8_MAX) {\n                const chunkBuffer = new SerialBuffer(chunk);\n                const messageSize = Message.peekLength(chunkBuffer);\n\n                if (messageSize > DataChannel.MESSAGE_SIZE_MAX) {\n                    this._error(`Received message with excessive message size ${messageSize} > ${DataChannel.MESSAGE_SIZE_MAX}`);\n                    return;\n                }\n\n                this._buffer = new SerialBuffer(messageSize);\n                this._receivingTag = tag;\n                this._msgType = Message.peekType(chunkBuffer);\n            }\n\n            if (this._buffer === null) {\n                Log.e(DataChannel, `Message does not start with next tag ${this._receivingTag + 1} (got ${tag} instead), but buffer is null`);\n                return;\n            }\n\n            // Currently, we only support one message at a time.\n            if (tag !== this._receivingTag) {\n                this._error(`Received message with wrong message tag ${tag}, expected ${this._receivingTag}`);\n                return;\n            }\n\n            let remainingBytes = this._buffer.byteLength - this._buffer.writePos;\n\n            // Mismatch between buffer sizes.\n            if (effectiveChunkLength > remainingBytes) {\n                this._error('Received chunk larger than remaining bytes to read, discarding');\n                return;\n            }\n\n            // Write chunk and subtract remaining byte length.\n            this._buffer.write(chunk);\n            remainingBytes -= effectiveChunkLength;\n\n            // Update last chunk timestamp.\n            this._lastChunkReceivedAt = Date.now();\n\n            const expectedMsg = this._expectedMessagesByType.get(this._msgType);\n            if (remainingBytes === 0) {\n                const msg = this._buffer.buffer;\n                this._buffer = null;\n                this.fire('message', msg, this);\n            } else {\n                // Set timeout.\n                if (expectedMsg) {\n                    this._timers.resetTimeout(`chunk-${expectedMsg.id}`, this._onTimeout.bind(this, expectedMsg), expectedMsg.chunkTimeout);\n                }\n                this.fire('chunk', this._buffer);\n            }\n        } catch (e) {\n            this._error(`Error occurred while parsing incoming message, ${e.message}`);\n        }\n    }\n\n    /**\n     * @param {ExpectedMessage} [expectedMsg]\n     * @private\n     */\n    _onTimeout(expectedMsg) {\n        if (expectedMsg) {\n            this._timers.clearTimeout(`chunk-${expectedMsg.id}`);\n            this._timers.clearTimeout(`msg-${expectedMsg.id}`);\n\n            for (const type of expectedMsg.types) {\n                this._expectedMessagesByType.delete(type);\n            }\n\n            expectedMsg.timeoutCallback();\n        }\n\n        Log.e(DataChannel, 'Timeout while receiving chunked message');\n        this._buffer = null;\n    }\n\n    /**\n     * @param {Uint8Array} msg\n     */\n    send(msg) {\n        Assert.that(msg.byteLength <= DataChannel.MESSAGE_SIZE_MAX, 'DataChannel.send() max message size exceeded');\n\n        const tag = this._sendingTag;\n        this._sendingTag = (this._sendingTag + 1) % NumberUtils.UINT8_MAX;\n        this._sendChunked(msg, tag);\n    }\n\n    /**\n     * @param {Uint8Array} msg\n     * @param {number} tag\n     * @private\n     */\n    _sendChunked(msg, tag) {\n        // Send chunks.\n        let remaining = msg.byteLength;\n        let chunk = null;\n        while (remaining > 0) {\n            let buffer = null;\n            if (remaining + /*tag*/ 1 >= DataChannel.CHUNK_SIZE_MAX) {\n                buffer = new SerialBuffer(DataChannel.CHUNK_SIZE_MAX);\n                buffer.writeUint8(tag);\n                chunk = new Uint8Array(msg.buffer, msg.byteLength - remaining, DataChannel.CHUNK_SIZE_MAX - /*tag*/ 1);\n            } else {\n                buffer = new SerialBuffer(remaining + /*tag*/ 1);\n                buffer.writeUint8(tag);\n                chunk = new Uint8Array(msg.buffer, msg.byteLength - remaining, remaining);\n            }\n\n            buffer.write(chunk);\n            this.sendChunk(buffer);\n            remaining -= chunk.byteLength;\n        }\n    }\n\n    /**\n     * @abstract\n     * @param {Uint8Array} msg\n     */\n    /* istanbul ignore next */\n    sendChunk(msg) { throw  new Error('Not implemented'); }\n\n    /**\n     * @abstract\n     * @type {DataChannel.ReadyState}\n     */\n    /* istanbul ignore next */\n    get readyState() { throw new Error('Not implemented'); }\n\n    /** @type {number} */\n    get lastMessageReceivedAt() {\n        return this._lastChunkReceivedAt;\n    }\n}\n\nDataChannel.CHUNK_SIZE_MAX = 1024 * 16; // 16 kb\nDataChannel.MESSAGE_SIZE_MAX = 10 * 1024 * 1024; // 10 mb\nDataChannel.CHUNK_TIMEOUT = 1000 * 5; // 5 seconds\nDataChannel.MESSAGE_TIMEOUT = (DataChannel.MESSAGE_SIZE_MAX / DataChannel.CHUNK_SIZE_MAX) * DataChannel.CHUNK_TIMEOUT;\n\nclass ExpectedMessage {\n    /**\n     * @param {Array.<Message.Type>} types\n     * @param {function()} timeoutCallback\n     * @param {number} msgTimeout\n     * @param {number} chunkTimeout\n     */\n    constructor(types, timeoutCallback, msgTimeout = DataChannel.MESSAGE_TIMEOUT, chunkTimeout = DataChannel.CHUNK_TIMEOUT) {\n        this.id = types.join(':');\n        this.types = types;\n        this.timeoutCallback = timeoutCallback;\n        this.msgTimeout = msgTimeout;\n        this.chunkTimeout = chunkTimeout;\n    }\n}\n\n/**\n * @enum {number}\n */\nDataChannel.ReadyState = {\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSING: 2,\n    CLOSED: 3\n};\n\n/**\n * @param {string} str\n * @return {DataChannel.ReadyState}\n */\nDataChannel.ReadyState.fromString = function (str) {\n    switch (str) {\n        case 'connecting':\n            return DataChannel.ReadyState.CONNECTING;\n        case 'open':\n            return DataChannel.ReadyState.OPEN;\n        case 'closing':\n            return DataChannel.ReadyState.CLOSING;\n        case 'closed':\n            return DataChannel.ReadyState.CLOSED;\n        default:\n            throw new Error('Invalid string');\n    }\n};\n\nClass.register(DataChannel);\n","class CryptoLib {\n    /**\n     * @return {SubtleCrypto|*}\n     */\n    static get instance() {\n        if (!CryptoLib._instance) {\n            const instance = {};\n            instance.getRandomValues = (window.crypto || window.msCrypto).getRandomValues.bind(window.crypto);\n\n            CryptoLib._instance = instance;\n        }\n        return CryptoLib._instance;\n    }\n}\nCryptoLib._instance = null;\nClass.register(CryptoLib);\n","class WebRtcFactory {\n    /**\n     * @param {?RTCConfiguration} configuration\n     * @returns {RTCPeerConnection}\n     */\n    static newPeerConnection(configuration) {\n        return new RTCPeerConnection(configuration);\n    }\n\n    /**\n     * @param {*} rtcSessionDescriptionInit\n     * @returns {RTCSessionDescription}\n     */\n    static newSessionDescription(rtcSessionDescriptionInit) {\n        return new RTCSessionDescription(rtcSessionDescriptionInit);\n    }\n\n    /**\n     * @param {*} rtcIceCandidateInit\n     * @returns {RTCIceCandidate}\n     */\n    static newIceCandidate(rtcIceCandidateInit) {\n        return new RTCIceCandidate(rtcIceCandidateInit);\n    }\n}\nClass.register(WebRtcFactory);\n","class WebSocketFactory {\n    /**\n     * @static\n     * @return {Observable}\n     */\n    static newWebSocketServer() {\n        return new Observable();\n    }\n\n    /**\n     * @static\n     * @param {string} url\n     * @return {WebSocket}\n     */\n    static newWebSocket(url) {\n        return new WebSocket(url);\n    }\n}\nClass.register(WebSocketFactory);\n","class DnsUtils {\n    /**\n     * @static\n     * @param {string} host\n     * @return {Promise.<NetAddress>}\n     */\n    static lookup(host) {\n        return Promise.resolve(NetAddress.UNSPECIFIED);\n    }\n}\nClass.register(DnsUtils);\n","class ConstantHelper {\n    constructor() {\n        this._originalValues = new Map();\n    }\n\n    static get instance() {\n        if (!ConstantHelper._instance) {\n            ConstantHelper._instance = new ConstantHelper();\n        }\n        return ConstantHelper._instance;\n    }\n\n    /**\n     * @param {string} constant\n     * @return {boolean}\n     */\n    isConstant(constant) {\n        if (constant.indexOf('.') < 1) return false;\n        const clazz = constant.split('.', 2)[0];\n        constant = constant.split('.', 2)[1];\n        if (constant.startsWith('_')) return false;\n        if (constant.toUpperCase() !== constant) return false;\n        if (!(clazz in Class.scope)) return false;\n        if (!Class.scope[clazz]) return false;\n        if (!Class.scope[clazz].hasOwnProperty) return false;\n        if (!Class.scope[clazz].hasOwnProperty(constant)) return false;\n        if (!Object.keys(Class.scope[clazz]).includes(constant)) return false;\n        if (typeof Class.scope[clazz][constant] !== 'number') return false;\n        return true;\n    }\n\n    /**\n     * @param {string} constant\n     */\n    _ensureIsConstant(constant) {\n        if (!this.isConstant(constant)) {\n            throw new Error(`${constant} is not a numerical constant.`);\n        }\n    }\n\n    /**\n     * @param {string} constant\n     * @returns {number}\n     */\n    get(constant) {\n        this._ensureIsConstant(constant);\n        const clazz = constant.split('.', 2)[0];\n        constant = constant.split('.', 2)[1];\n        return Class.scope[clazz][constant];\n    }\n\n    /**\n     * @param {string} constant\n     * @param {number} value\n     */\n    set(constant, value) {\n        this._ensureIsConstant(constant);\n        if (!this._originalValues.has(constant)) {\n            this._originalValues.set(constant, this.get(constant));\n        }\n        const clazz = constant.split('.', 2)[0];\n        constant = constant.split('.', 2)[1];\n        Class.scope[clazz][constant] = value;\n    }\n\n    /**\n     * @param {string} constant\n     */\n    reset(constant) {\n        this._ensureIsConstant(constant);\n        if (this._originalValues.has(constant)) {\n            this.set(constant, this._originalValues.get(constant));\n        }\n    }\n}\n\nClass.register(ConstantHelper);\n","class Services {\n    /**\n     * @constructor\n     * @param {number} [provided=Services.NONE] Bitmap of services that can be provided by this node\n     * @param {number} [accepted=Services.NONE] Bitmap of services that can be accepted by this node\n     */\n    constructor(provided = Services.NONE, accepted = Services.NONE) {\n        this._provided = provided;\n        this._accepted = accepted;\n    }\n\n    /**\n     * @type {number}\n     */\n    get provided() {\n        return this._provided;\n    }\n\n    /**\n     * @type {number}\n     */\n    get accepted() {\n        return this._accepted;\n    }\n\n    /**\n     * @param {number} services Bitmap of services that can be provided\n     */\n    set provided(services) {\n        this._provided = services;\n    }\n\n    /**\n     * @param {number} services Bitmap of services that can be accepted\n     */\n    set accepted(services) {\n        this._accepted = services;\n    }\n\n    /**\n     * @param {number} services Bitmap of the services to check\n     * @returns {boolean}\n     */\n    static isFullNode(services) {\n        return (services & Services.FULL) !== 0;\n    }\n\n    /**\n     * @param {number} services Bitmap of the services to check\n     * @returns {boolean}\n     */\n    static isLightNode(services) {\n        return (services & Services.LIGHT) !== 0;\n    }\n\n    /**\n     * @param {number} services Bitmap of the services to check\n     * @returns {boolean}\n     */\n    static isNanoNode(services) {\n        return services === Services.NANO;\n    }\n}\nServices.NONE   = 0;\nServices.NANO   = 1;\nServices.LIGHT  = 2;\nServices.FULL   = 4;\nClass.register(Services);\n","class Timers {\n    constructor() {\n        this._timeouts = {};\n        this._intervals = {};\n    }\n\n    setTimeout(key, fn, waitTime) {\n        if (this._timeouts[key]) throw 'Duplicate timeout for key ' + key;\n        this._timeouts[key] = setTimeout(fn, waitTime);\n    }\n\n    clearTimeout(key) {\n        clearTimeout(this._timeouts[key]);\n        delete this._timeouts[key];\n    }\n\n    resetTimeout(key, fn, waitTime) {\n        clearTimeout(this._timeouts[key]);\n        this._timeouts[key] = setTimeout(fn, waitTime);\n    }\n\n    timeoutExists(key) {\n        return this._timeouts[key] !== undefined;\n    }\n\n    setInterval(key, fn, intervalTime) {\n        if (this._intervals[key]) throw 'Duplicate interval for key ' + key;\n        this._intervals[key] = setInterval(fn, intervalTime);\n    }\n\n    clearInterval(key) {\n        clearInterval(this._intervals[key]);\n        delete this._intervals[key];\n    }\n\n    resetInterval(key, fn, intervalTime) {\n        clearInterval(this._intervals[key]);\n        this._intervals[key] = setInterval(fn, intervalTime);\n    }\n\n    intervalExists(key) {\n        return this._intervals[key] !== undefined;\n    }\n\n    clearAll() {\n        for (const key in this._timeouts) {\n            this.clearTimeout(key);\n        }\n        for (const key in this._intervals) {\n            this.clearInterval(key);\n        }\n    }\n}\nClass.register(Timers);\n","class Version {\n    static isCompatible(code) {\n        // Allow future, backwards-compatible versions.\n        return code >= Version.CODE;\n    }\n}\nVersion.CODE = 1;\nClass.register(Version);\n","/**\n * This class stores and provides the network time (current system\n * time with an offset calculated from our peer's time)\n */\nclass Time {\n    /**\n     * @constructor\n     * @param {number} [offset=0]\n     */\n    constructor(offset = 0) {\n        this._offset = offset;\n    }\n\n    /**\n     * @param {number} offset\n     */\n    set offset(offset) {\n        this._offset = offset;\n    }\n\n    /**\n     * Returns the current time adjusted with the network's offset\n     * @return {number}\n     */\n    now() {\n        return Date.now() + this._offset;\n    }\n}\nClass.register(Time);\n","class ArrayUtils {\n    /**\n     * @template T\n     * @param {Array.<T>} arr\n     * @return {T}\n     */\n    static randomElement(arr) {\n        return arr[Math.floor(Math.random() * arr.length)];\n    }\n\n    /**\n     * @param {Uint8Array} uintarr\n     * @param {number} begin\n     * @param {number} end\n     * @return {Uint8Array}\n     */\n    static subarray(uintarr, begin, end) {\n        function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }\n\n        if (begin === undefined) { begin = 0; }\n        if (end === undefined) { end = uintarr.byteLength; }\n\n        begin = clamp(begin, 0, uintarr.byteLength);\n        end = clamp(end, 0, uintarr.byteLength);\n\n        let len = end - begin;\n        if (len < 0) {\n            len = 0;\n        }\n\n        return new Uint8Array(uintarr.buffer, uintarr.byteOffset + begin, len);\n    }\n\n    /**\n     * @param {Array} list\n     * @param {number} k\n     * @return {Generator}\n     */\n    static *k_combinations(list, k) {\n        const n = list.length;\n        // Shortcut:\n        if (k > n) {\n            return;\n        }\n        const indices = Array.from(new Array(k), (x,i) => i);\n        yield indices.map(i => list[i]);\n        const reverseRange = Array.from(new Array(k), (x,i) => k-i-1);\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n            let i = k-1, found = false;\n            for (i of reverseRange) {\n                if (indices[i] !== i + n - k) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return;\n            }\n            indices[i] += 1;\n            for (const j of Array.from(new Array(k-i-1), (x,k) => i+k+1)) {\n                indices[j] = indices[j-1] + 1;\n            }\n            yield indices.map(i => list[i]);\n        }\n    }\n}\nClass.register(ArrayUtils);\n","/**\n * @template K,V\n */\nclass HashMap {\n    /**\n     * @param {function(o: object): string} [fnHash]\n     */\n    constructor(fnHash = HashMap._hash) {\n        /** @type {Map.<string,V>} */\n        this._map = new Map();\n        /** @type {function(o: object): string} */\n        this._fnHash = fnHash;\n    }\n\n    /**\n     * @param {{hashCode: function():string}|*} o\n     * @returns {string}\n     * @private\n     */\n    static _hash(o) {\n        if (o === null || o === undefined) return o;\n        return o.hashCode ? o.hashCode() : o.toString();\n    }\n\n    /**\n     * @param {K|*} key\n     * @returns {V|*}\n     */\n    get(key) {\n        return this._map.get(this._fnHash(key));\n    }\n\n    /**\n     * @param {K|*} key\n     * @param {V|*} value\n     */\n    put(key, value) {\n        this._map.set(this._fnHash(key), value);\n    }\n\n    /**\n     * @param {K|*} key\n     */\n    remove(key) {\n        this._map.delete(this._fnHash(key));\n    }\n\n    clear() {\n        this._map.clear();\n    }\n\n    /**\n     * @param {K|*} key\n     * @returns {boolean}\n     */\n    contains(key) {\n        return this._map.has(this._fnHash(key));\n    }\n\n    /**\n     * @returns {Array.<K|*>}\n     */\n    keys() {\n        return Array.from(this._map.keys());\n    }\n\n    /**\n     * @returns {Iterator.<K|*>}\n     */\n    keyIterator() {\n        return this._map.keys();\n    }\n\n    /**\n     * @returns {Array.<V|*>}\n     */\n    values() {\n        return Array.from(this._map.values());\n    }\n\n    /**\n     * @returns {Iterator.<V|*>}\n     */\n    valueIterator() {\n        return this._map.values();\n    }\n\n    /**\n     * @returns {number}\n     */\n    get length() {\n        return this._map.size;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return this._map.size === 0;\n    }\n}\nClass.register(HashMap);\n","/**\n * @template V\n * @implements {Iterable.<V>}\n */\nclass HashSet {\n    constructor(fnHash = HashSet._hash) {\n        /** @type {Map.<string,V>} */\n        this._map = new Map();\n        /** @type {function(o: object): string} */\n        this._fnHash = fnHash;\n    }\n\n    /**\n     * @param {{hashCode: function():string}|*} o\n     * @returns {string}\n     * @private\n     */\n    static _hash(o) {\n        if (o === null || o === undefined) return o;\n        return o.hashCode ? o.hashCode() : o.toString();\n    }\n\n    /**\n     * @param {V|*} value\n     */\n    add(value) {\n        this._map.set(this._fnHash(value), value);\n    }\n\n    /**\n     * @param {Iterable.<V|*>} collection\n     */\n    addAll(collection) {\n        for (const value of collection) {\n            this.add(value);\n        }\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {V|*}\n     */\n    get(value) {\n        return this._map.get(this._fnHash(value));\n    }\n\n    /**\n     * @param {V|*} value\n     */\n    remove(value) {\n        this._map.delete(this._fnHash(value));\n    }\n\n    /**\n     * @param {Array.<V|*>} collection\n     */\n    removeAll(collection) {\n        for (const value of collection) {\n            this.remove(value);\n        }\n    }\n\n    clear() {\n        this._map.clear();\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {boolean}\n     */\n    contains(value) {\n        return this._map.has(this._fnHash(value));\n    }\n\n    /**\n     * @returns {Array.<V|*>}\n     */\n    values() {\n        return Array.from(this._map.values());\n    }\n\n    /**\n     * @returns {Iterator.<V|*>}\n     */\n    valueIterator() {\n        return this._map.values();\n    }\n\n    /**\n     * @returns {Iterator.<V|*>}\n     */\n    [Symbol.iterator]() {\n        return this.valueIterator();\n    }\n\n    /**\n     * @returns {number}\n     */\n    get length() {\n        return this._map.size;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return this._map.size === 0;\n    }\n}\nClass.register(HashSet);\n","/**\n * @template T\n * @implements {Iterable.<T>}\n */\nclass LimitIterable {\n    /**\n     * @param {Iterable.<T>|Iterator.<T>} it\n     * @param {number} limit\n     */\n    constructor(it, limit) {\n        /** @type {Iterator.<T>} */\n        this._iterator = it[Symbol.iterator] ? it[Symbol.iterator]() : it;\n        /** @type {number} */\n        this._limit = limit;\n    }\n\n    /**\n     * @returns {{next: function():object}}\n     */\n    [Symbol.iterator]() {\n        return LimitIterable.iterator(this._iterator, this._limit);\n    }\n\n    /**\n     * @template V\n     * @param {Iterator.<V>} iterator\n     * @param {number} limit\n     * @returns {{next: function():object}}\n     */\n    static iterator(iterator, limit) {\n        let count = 0;\n        return {\n            next: () => {\n                const done = count++ >= limit;\n                const next = iterator.next();\n                return {\n                    value: done ? undefined : next.value,\n                    done: done || next.done\n                };\n            }\n        };\n    }\n}\nClass.register(LimitIterable);\n","/**\n * @template V\n */\nclass Queue {\n    /**\n     * @param {function(o: object): string} [fnHash]\n     */\n    constructor(fnHash) {\n        /**\n         * @type {Array.<V|*>}\n         * @protected\n         */\n        this._queue = [];\n\n        /**\n         * @type {function(o: object): string}\n         * @protected\n         */\n        this._fnHash = fnHash || Queue._hash;\n    }\n\n    /**\n     * @param {{hashCode: function():string}|*} o\n     * @returns {string}\n     * @protected\n     */\n    static _hash(o) {\n        if (o === null || o === undefined) return o;\n        return o.hashCode ? o.hashCode() : o.toString();\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {void}\n     */\n    enqueue(value) {\n        this._queue.push(value);\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {void}\n     */\n    enqueueFirst(value) {\n        this._queue.unshift(value);\n    }\n\n    /**\n     * @returns {V|*}\n     */\n    dequeue() {\n        return this._queue.shift();\n    }\n\n    /**\n     * @returns {V|*}\n     */\n    peek() {\n        return this._queue[0];\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {number}\n     */\n    indexOf(value) {\n        const hash = this._fnHash(value);\n        for (let i = 0; i < this._queue.length; ++i) {\n            if (hash === this._fnHash(this._queue[i])) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {void}\n     */\n    remove(value) {\n        const index = this.indexOf(value);\n        if (index > -1) {\n            this._queue.splice(index, 1);\n        }\n    }\n\n    /**\n     * @param {number} count\n     * @returns {Array.<V|*>}\n     */\n    dequeueMulti(count) {\n        return this._queue.splice(0, count);\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {Array.<V|*>}\n     */\n    dequeueUntil(value) {\n        const index = this.indexOf(value);\n        if (index > -1) {\n            return this._queue.splice(0, index + 1);\n        }\n        return [];\n    }\n\n    /**\n     * @returns {void}\n     */\n    clear() {\n        this._queue = [];\n    }\n\n    /**\n     * @returns {Array.<V|*>}\n     */\n    values() {\n        return this._queue;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return this.length === 0;\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._queue.length;\n    }\n}\nClass.register(Queue);\n","/**\n * @template V\n */\nclass UniqueQueue extends Queue {\n    /**\n     * @param {function(o: object): string} [fnHash]\n     */\n    constructor(fnHash) {\n        super(fnHash);\n        this._set = new Set();\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {void}\n     * @override\n     */\n    enqueue(value) {\n        super.enqueue(value);\n        this._set.add(this._fnHash(value));\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {void}\n     * @override\n     */\n    enqueueFirst(value) {\n        super.enqueueFirst(value);\n        this._set.add(this._fnHash(value));\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {void}\n     * @override\n     */\n    enqueueUnique(value) {\n        const hashCode = this._fnHash(value);\n        if (this._set.has(hashCode)) return;\n\n        super.enqueue(value);\n        this._set.add(hashCode);\n    }\n\n    /**\n     * @param {Array.<V|*>} values\n     * @returns {void}\n     * @override\n     */\n    enqueueAllNew(values) {\n        for (const value of values) {\n            this.enqueueUnique(value);\n        }\n    }\n\n    /**\n     * @returns {V|*}\n     * @override\n     */\n    dequeue() {\n        const value = super.dequeue();\n        this._set.delete(this._fnHash(value));\n        return value;\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {void}\n     * @override\n     */\n    remove(value) {\n        super.remove(value);\n        this._set.delete(this._fnHash(value));\n    }\n\n    /**\n     * @param {number} count\n     * @returns {Array.<V|*>}\n     * @override\n     */\n    dequeueMulti(count) {\n        const values = super.dequeueMulti(count);\n        for (const value of values) {\n            this._set.delete(this._fnHash(value));\n        }\n        return values;\n    }\n\n    /**\n     * @param {V|*} value\n     * @returns {Array.<V|*>}\n     * @override\n     */\n    dequeueUntil(value) {\n        const values = super.dequeueUntil(value);\n        for (const val of values) {\n            this._set.delete(this._fnHash(val));\n        }\n        return values;\n    }\n}\nClass.register(UniqueQueue);\n","class ThrottledQueue extends UniqueQueue {\n    /**\n     * @param {number} [maxAtOnce]\n     * @param {number} [allowanceNum]\n     * @param {number} [allowanceInterval]\n     * @param {number} [maxSize]\n     * @param {function} [allowanceCallback]\n     */\n    constructor(maxAtOnce = Number.POSITIVE_INFINITY, allowanceNum = maxAtOnce, allowanceInterval = 1000, maxSize = Number.POSITIVE_INFINITY, allowanceCallback) {\n        super();\n        this._maxSize = maxSize;\n        this._maxAtOnce = maxAtOnce;\n        this._availableNow = this._maxAtOnce;\n\n        this._timers = new Timers();\n        this._timers.setInterval('allowance', () => {\n            this._availableNow = Math.min(this._maxAtOnce, this._availableNow + allowanceNum);\n            if (typeof allowanceCallback === 'function' && this.isAvailable()) allowanceCallback();\n        }, allowanceInterval);\n    }\n\n    stop() {\n        this._timers.clearAll();\n    }\n\n    enqueue(value) {\n        if (this.length >= this._maxSize) return;\n        super.enqueue(value);\n    }\n\n    enqueueFirst(value) {\n        super.enqueueFirst(value);\n        if (this.length > this._maxSize) this._queue.pop();\n    }\n\n    dequeue() {\n        if (this.available > 0) {\n            this._availableNow--;\n            return super.dequeue();\n        }\n        return null;\n    }\n\n    /**\n     * @param count\n     * @returns {Array}\n     */\n    dequeueMulti(count) {\n        count = Math.min(this.available, count);\n        this._availableNow -= count;\n        return super.dequeueMulti(count);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isAvailable() {\n        return this.available > 0;\n    }\n\n    get available() {\n        return Math.min(this._availableNow, this.length);\n    }\n}\n\nClass.register(ThrottledQueue);\n","class SortedList {\n    constructor(sortedList = [], compare) {\n        this._list = sortedList;\n        this._compare = compare || SortedList._compare;\n    }\n\n    static _compare(a, b) {\n        return a.compare ? a.compare(b) : (a > b ? 1 : (a < b ? -1 : 0));\n    }\n\n    indexOf(o) {\n        let a = 0, b = this._list.length - 1;\n        let currentIndex = null;\n        let currentElement = null;\n\n        while (a <= b) {\n            currentIndex = Math.round((a + b) / 2);\n            currentElement = this._list[currentIndex];\n\n            if (this._compare(currentElement, o) < 0) {\n                a = currentIndex + 1;\n            }\n            else if (this._compare(currentElement, o) > 0) {\n                b = currentIndex - 1;\n            }\n            else {\n                return currentIndex;\n            }\n        }\n\n        return -1;\n    }\n\n    _insertionIndex(o) {\n        let a = 0, b = this._list.length - 1;\n        let currentIndex = null;\n        let currentElement = null;\n\n        while (a <= b) {\n            currentIndex = Math.round((a + b) / 2);\n            currentElement = this._list[currentIndex];\n\n            if (this._compare(currentElement, o) < 0) {\n                a = currentIndex + 1;\n            }\n            else if (this._compare(currentElement, o) > 0) {\n                b = currentIndex - 1;\n            }\n            else {\n                break;\n            }\n        }\n\n        return a;\n    }\n\n    add(value) {\n        this._list.splice(this._insertionIndex(value), 0, value);\n    }\n\n    shift() {\n        return this._list.shift();\n    }\n\n    pop() {\n        return this._list.pop();\n    }\n\n    peekFirst() {\n        return this._list[0];\n    }\n\n    peekLast() {\n        return this._list[this._list.length - 1];\n    }\n\n    remove(value) {\n        const index = this.indexOf(value);\n        if (index > -1) {\n            this._list.splice(index, 1);\n        }\n    }\n\n    clear() {\n        this._list = [];\n    }\n\n    values() {\n        return this._list;\n    }\n\n    /**\n     * @returns {Iterator.<V|*>}\n     */\n    [Symbol.iterator]() {\n        return this._list[Symbol.iterator]();\n    }\n\n    copy() {\n        return new SortedList(this._list.slice(), this._compare);\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._list.length;\n    }\n}\nClass.register(SortedList);\n","class Assert {\n    /**\n     * @param {boolean} condition\n     * @param {string} [message]\n     * @returns {void}\n     */\n    static that(condition, message = 'Assertion failed') {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n}\nClass.register(Assert);\n","class BufferUtils {\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toAscii(buffer) {\n        return String.fromCharCode.apply(null, new Uint8Array(buffer));\n    }\n\n    /**\n     * @param {string} string\n     * @return {Uint8Array}\n     */\n    static fromAscii(string) {\n        const buf = new Uint8Array(string.length);\n        for (let i = 0; i < string.length; ++i) {\n            buf[i] = string.charCodeAt(i);\n        }\n        return buf;\n    }\n\n    static _codePointTextDecoder(u8) {\n        if (typeof TextDecoder === 'undefined') throw new Error('TextDecoder not supported');\n        if (BufferUtils._ISO_8859_15_DECODER === null) throw new Error('TextDecoder does not supprot iso-8859-15');\n        if (BufferUtils._ISO_8859_15_DECODER === undefined) {\n            try {\n                BufferUtils._ISO_8859_15_DECODER = new TextDecoder('iso-8859-15');\n            } finally {\n                BufferUtils._ISO_8859_15_DECODER = null;\n            }\n        }\n        return BufferUtils._ISO_8859_15_DECODER.decode(u8)\n            .replace('', '').replace('', '').replace('', '').replace('', '')\n            .replace('', '').replace('', '').replace('', '').replace('', '');\n    }\n\n    static _tripletToBase64(num) {\n        return BufferUtils._BASE64_LOOKUP[num >> 18 & 0x3F] + BufferUtils._BASE64_LOOKUP[num >> 12 & 0x3F] + BufferUtils._BASE64_LOOKUP[num >> 6 & 0x3F] + BufferUtils._BASE64_LOOKUP[num & 0x3F];\n    }\n\n    static _base64encodeChunk(u8, start, end) {\n        let tmp;\n        const output = [];\n        for (let i = start; i < end; i += 3) {\n            tmp = ((u8[i] << 16) & 0xFF0000) + ((u8[i + 1] << 8) & 0xFF00) + (u8[i + 2] & 0xFF);\n            output.push(BufferUtils._tripletToBase64(tmp));\n        }\n        return output.join('');\n    }\n\n    static _base64fromByteArray(u8) {\n        let tmp;\n        const len = u8.length;\n        const extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n        let output = '';\n        const parts = [];\n        const maxChunkLength = 16383; // must be multiple of 3\n\n        // go through the array every three bytes, we'll deal with trailing stuff later\n        for (let i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n            parts.push(BufferUtils._base64encodeChunk(u8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));\n        }\n\n        // pad the end with zeros, but make sure to not forget the extra bytes\n        if (extraBytes === 1) {\n            tmp = u8[len - 1];\n            output += BufferUtils._BASE64_LOOKUP[tmp >> 2];\n            output += BufferUtils._BASE64_LOOKUP[(tmp << 4) & 0x3F];\n            output += '==';\n        } else if (extraBytes === 2) {\n            tmp = (u8[len - 2] << 8) + (u8[len - 1]);\n            output += BufferUtils._BASE64_LOOKUP[tmp >> 10];\n            output += BufferUtils._BASE64_LOOKUP[(tmp >> 4) & 0x3F];\n            output += BufferUtils._BASE64_LOOKUP[(tmp << 2) & 0x3F];\n            output += '=';\n        }\n\n        parts.push(output);\n\n        return parts.join('');\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toBase64(buffer) {\n        if (PlatformUtils.isNodeJs()) {\n            return new Buffer(buffer).toString('base64');\n        } else if (typeof TextDecoder !== 'undefined' && BufferUtils._ISO_8859_15_DECODER !== null) {\n            try {\n                return btoa(BufferUtils._codePointTextDecoder(new Uint8Array(buffer)));\n            } catch (e) {\n                // Disabled itself\n            }\n        }\n\n        return BufferUtils._base64fromByteArray(new Uint8Array(buffer));\n    }\n\n    /**\n     * @param {string} base64\n     * @return {SerialBuffer}\n     */\n    static fromBase64(base64) {\n        return new SerialBuffer(Uint8Array.from(atob(base64), c => c.charCodeAt(0)));\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toBase64Url(buffer) {\n        return BufferUtils.toBase64(buffer).replace(/\\//g, '_').replace(/\\+/g, '-').replace(/=/g, '.');\n    }\n\n    /**\n     * @param {string} base64\n     * @return {SerialBuffer}\n     */\n    static fromBase64Url(base64) {\n        return new SerialBuffer(Uint8Array.from(atob(base64.replace(/_/g, '/').replace(/-/g, '+').replace(/\\./g, '=')), c => c.charCodeAt(0)));\n    }\n\n    /**\n     * @param {Uint8Array} buf\n     * @param {string} [alphabet] Alphabet to use\n     * @return {string}\n     */\n    static toBase32(buf, alphabet = BufferUtils.BASE32_ALPHABET.NIMIQ) {\n        let shift = 3, carry = 0, byte, symbol, i, res = '';\n\n        for (i = 0; i < buf.length; i++) {\n            byte = buf[i];\n            symbol = carry | (byte >> shift);\n            res += alphabet[symbol & 0x1f];\n\n            if (shift > 5) {\n                shift -= 5;\n                symbol = byte >> shift;\n                res += alphabet[symbol & 0x1f];\n            }\n\n            shift = 5 - shift;\n            carry = byte << shift;\n            shift = 8 - shift;\n        }\n\n        if (shift !== 3) {\n            res += alphabet[carry & 0x1f];\n        }\n\n        while (res.length % 8 !== 0 && alphabet.length === 33) {\n            res += alphabet[32];\n        }\n\n        return res;\n    }\n\n    /**\n     * @param {string} base32\n     * @param {string} [alphabet] Alphabet to use\n     * @return {Uint8Array}\n     */\n    static fromBase32(base32, alphabet = BufferUtils.BASE32_ALPHABET.NIMIQ) {\n        const charmap = [];\n        alphabet.toUpperCase().split('').forEach((c, i) => {\n            if (!(c in charmap)) charmap[c] = i;\n        });\n\n        let symbol, shift = 8, carry = 0, buf = [];\n        base32.toUpperCase().split('').forEach((char) => {\n            // ignore padding\n            if (alphabet.length === 33 && char === alphabet[32]) return;\n\n            symbol = charmap[char] & 0xff;\n\n            shift -= 5;\n            if (shift > 0) {\n                carry |= symbol << shift;\n            } else if (shift < 0) {\n                buf.push(carry | (symbol >> -shift));\n                shift += 8;\n                carry = (symbol << shift) & 0xff;\n            } else {\n                buf.push(carry | symbol);\n                shift = 8;\n                carry = 0;\n            }\n        });\n\n        if (shift !== 8 && carry !== 0) {\n            buf.push(carry);\n        }\n\n        return new Uint8Array(buf);\n    }\n\n    /**\n     * @param {*} buffer\n     * @return {string}\n     */\n    static toHex(buffer) {\n        let hex = '';\n        for (let i = 0; i < buffer.length; i++) {\n            const code = buffer[i];\n            hex += BufferUtils.HEX_ALPHABET[code >>> 4];\n            hex += BufferUtils.HEX_ALPHABET[code & 0x0F];\n        }\n        return hex;\n    }\n\n    /**\n     * @param {string} hex\n     * @return {SerialBuffer}\n     */\n    static fromHex(hex) {\n        hex = hex.trim();\n        if (!StringUtils.isHexBytes(hex)) return null;\n        return new SerialBuffer(Uint8Array.from(hex.match(/.{2}/g) || [], byte => parseInt(byte, 16)));\n    }\n\n    /**\n     * @template T\n     * @param {T} a\n     * @param {*} b\n     * @return {T}\n     */\n    static concatTypedArrays(a, b) {\n        const c = new (a.constructor)(a.length + b.length);\n        c.set(a, 0);\n        c.set(b, a.length);\n        return c;\n    }\n\n    /**\n     * @param {*} a\n     * @param {*} b\n     * @return {boolean}\n     */\n    static equals(a, b) {\n        if (a.length !== b.length) return false;\n        const viewA = new Uint8Array(a);\n        const viewB = new Uint8Array(b);\n        for (let i = 0; i < a.length; i++) {\n            if (viewA[i] !== viewB[i]) return false;\n        }\n        return true;\n    }\n\n    /**\n     * @param {*} a\n     * @param {*} b\n     * @return {number} -1 if a is smaller than b, 1 if a is larger than b, 0 if a equals b.\n     */\n    static compare(a, b) {\n        if (a.length < b.length) return -1;\n        if (a.length > b.length) return 1;\n        for (let i = 0; i < a.length; i++) {\n            if (a[i] < b[i]) return -1;\n            if (a[i] > b[i]) return 1;\n        }\n        return 0;\n    }\n\n    /**\n     * @param {Uint8Array} a\n     * @param {Uint8Array} b\n     * @return {Uint8Array}\n     */\n    static xor(a, b) {\n        const res = new Uint8Array(a.byteLength);\n        for (let i = 0; i < a.byteLength; ++i) {\n            res[i] = a[i] ^ b[i];\n        }\n        return res;\n    }\n}\nBufferUtils.BASE64_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nBufferUtils.BASE32_ALPHABET = {\n    RFC4648: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n    RFC4648_HEX: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n    NIMIQ: '0123456789ABCDEFGHJKLMNPQRSTUVXY'\n};\nBufferUtils.HEX_ALPHABET = '0123456789abcdef';\nBufferUtils._BASE64_LOOKUP = [];\nfor (let i = 0, len = BufferUtils.BASE64_ALPHABET.length; i < len; ++i) {\n    BufferUtils._BASE64_LOOKUP[i] = BufferUtils.BASE64_ALPHABET[i];\n}\n\nClass.register(BufferUtils);\n","class SerialBuffer extends Uint8Array {\n    /**\n     * @param {*} bufferOrArrayOrLength\n     */\n    constructor(bufferOrArrayOrLength) {\n        super(bufferOrArrayOrLength);\n        this._view = new DataView(this.buffer);\n        this._readPos = 0;\n        this._writePos = 0;\n    }\n\n    /**\n     * @param {number} start\n     * @param {number} end\n     * @return {Uint8Array}\n     */\n    subarray(start, end) {\n        return ArrayUtils.subarray(this, start, end);\n    }\n\n    /** @type {number} */\n    get readPos() {\n        return this._readPos;\n    }\n\n    /** @type {number} */\n    set readPos(value) {\n        if (value < 0 || value > this.byteLength) throw `Invalid readPos ${value}`;\n        this._readPos = value;\n    }\n\n    /** @type {number} */\n    get writePos() {\n        return this._writePos;\n    }\n\n    /** @type {number} */\n    set writePos(value) {\n        if (value < 0 || value > this.byteLength) throw `Invalid writePos ${value}`;\n        this._writePos = value;\n    }\n\n    /**\n     * Resets the read and write position of the buffer to zero.\n     * @returns {void}\n     */\n    reset() {\n        this._readPos = 0;\n        this._writePos = 0;\n    }\n\n    /**\n     * @param {number} length\n     * @return {Uint8Array}\n     */\n    read(length) {\n        const value = this.subarray(this._readPos, this._readPos + length);\n        this._readPos += length;\n        return value;\n    }\n\n    /**\n     * @param {*} array\n     */\n    write(array) {\n        this.set(array, this._writePos);\n        this._writePos += array.byteLength;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint8() {\n        return this._view.getUint8(this._readPos++);\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint8(value) {\n        this._view.setUint8(this._writePos++, value);\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint16() {\n        const value = this._view.getUint16(this._readPos);\n        this._readPos += 2;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint16(value) {\n        this._view.setUint16(this._writePos, value);\n        this._writePos += 2;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint32() {\n        const value = this._view.getUint32(this._readPos);\n        this._readPos += 4;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint32(value) {\n        this._view.setUint32(this._writePos, value);\n        this._writePos += 4;\n    }\n\n    /**\n     * @return {number}\n     */\n    readUint64() {\n        const value = this._view.getUint32(this._readPos) * Math.pow(2, 32) + this._view.getUint32(this._readPos + 4);\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        this._readPos += 8;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeUint64(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        this._view.setUint32(this._writePos, Math.floor(value / Math.pow(2, 32)));\n        this._view.setUint32(this._writePos + 4, value);\n        this._writePos += 8;\n    }\n\n    /**\n     * @return {number}\n     */\n    readVarUint() {\n        const value = this.readUint8();\n        if (value < 0xFD) {\n            return value;\n        } else if (value === 0xFD) {\n            return this.readUint16();\n        } else if (value === 0xFE) {\n            return this.readUint32();\n        } else /*if (value === 0xFF)*/ {\n            return this.readUint64();\n        }\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeVarUint(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        if (value < 0xFD) {\n            this.writeUint8(value);\n        } else if (value <= 0xFFFF) {\n            this.writeUint8(0xFD);\n            this.writeUint16(value);\n        } else if (value <= 0xFFFFFFFF) {\n            this.writeUint8(0xFE);\n            this.writeUint32(value);\n        } else {\n            this.writeUint8(0xFF);\n            this.writeUint64(value);\n        }\n    }\n\n    /**\n     * @param {number} value\n     * @returns {number}\n     */\n    static varUintSize(value) {\n        if (!NumberUtils.isUint64(value)) throw new Error('Malformed value');\n        if (value < 0xFD) {\n            return 1;\n        } else if (value <= 0xFFFF) {\n            return 3;\n        } else if (value <= 0xFFFFFFFF) {\n            return 5;\n        } else {\n            return 9;\n        }\n    }\n\n    /**\n     * @return {number}\n     */\n    readFloat64() {\n        const value = this._view.getFloat64(this._readPos);\n        this._readPos += 8;\n        return value;\n    }\n\n    /**\n     * @param {number} value\n     */\n    writeFloat64(value) {\n        this._view.setFloat64(this._writePos, value);\n        this._writePos += 8;\n    }\n\n    /**\n     * @param {number} length\n     * @return {string}\n     */\n    readString(length) {\n        const bytes = this.read(length);\n        return BufferUtils.toAscii(bytes);\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} length\n     */\n    writeString(value, length) {\n        if (StringUtils.isMultibyte(value) || value.length !== length) throw 'Malformed value/length';\n        const bytes = BufferUtils.fromAscii(value);\n        this.write(bytes);\n    }\n\n    /**\n     * @param {number} length\n     * @return {string}\n     */\n    readPaddedString(length) {\n        const bytes = this.read(length);\n        let i = 0;\n        while (i < length && bytes[i] !== 0x0) i++;\n        const view = new Uint8Array(bytes.buffer, bytes.byteOffset, i);\n        return BufferUtils.toAscii(view);\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} length\n     */\n    writePaddedString(value, length) {\n        if (StringUtils.isMultibyte(value) || value.length > length) throw 'Malformed value/length';\n        const bytes = BufferUtils.fromAscii(value);\n        this.write(bytes);\n        const padding = length - bytes.byteLength;\n        this.write(new Uint8Array(padding));\n    }\n\n    /**\n     * @return {string}\n     */\n    readVarLengthString() {\n        const length = this.readUint8();\n        if (this._readPos + length > this.length) throw 'Malformed length';\n        const bytes = this.read(length);\n        return BufferUtils.toAscii(bytes);\n    }\n\n    /**\n     * @param {string} value\n     */\n    writeVarLengthString(value) {\n        if (StringUtils.isMultibyte(value) || !NumberUtils.isUint8(value.length)) throw new Error('Malformed value');\n        const bytes = BufferUtils.fromAscii(value);\n        this.writeUint8(bytes.byteLength);\n        this.write(bytes);\n    }\n\n    /**\n     * @param {string} value\n     * @returns {number}\n     */\n    static varLengthStringSize(value) {\n        if (StringUtils.isMultibyte(value) || !NumberUtils.isUint8(value.length)) throw new Error('Malformed value');\n        return /*length*/ 1 + value.length;\n    }\n}\nClass.register(SerialBuffer);\n","class Synchronizer extends Observable {\n    constructor() {\n        super();\n        this._queue = [];\n        this._working = false;\n    }\n\n    /**\n     * Push function to the Synchronizer for later, synchronous execution\n     * @template T\n     * @param {function():T} fn Function to be invoked later by this Synchronizer\n     * @returns {Promise.<T>}\n     */\n    push(fn) {\n        return new Promise((resolve, reject) => {\n            this._queue.push({fn: fn, resolve: resolve, reject: reject});\n            if (!this._working) {\n                this._doWork().catch(Log.w.tag(Synchronizer));\n            }\n        });\n    }\n\n    /**\n     * Reject all jobs in the queue and clear it.\n     * @returns {void}\n     */\n    clear() {\n        for (const job of this._queue) {\n            if (job.reject) job.reject();\n        }\n        this._queue = [];\n    }\n\n    async _doWork() {\n        this._working = true;\n        this.fire('work-start', this);\n\n        while (this._queue.length > 0) {\n            const job = this._queue.shift();\n            try {\n                const result = await job.fn();\n                job.resolve(result);\n            } catch (e) {\n                if (job.reject) job.reject(e);\n            }\n        }\n\n        this._working = false;\n        this.fire('work-end', this);\n    }\n\n    /** @type {boolean} */\n    get working() {\n        return this._working;\n    }\n}\nClass.register(Synchronizer);\n","class MultiSynchronizer extends Observable {\n    constructor() {\n        super();\n        /** @type {Map.<string, Synchronizer>} */\n        this._synchronizers = new Map();\n    }\n\n    /**\n     * Push function to the Synchronizer for later, synchronous execution\n     * @template T\n     * @param {string} tag\n     * @param {function():T} fn Function to be invoked later by this Synchronizer\n     * @returns {Promise.<T>}\n     */\n    push(tag, fn) {\n        let synchonizer = this._synchronizers.get(tag);\n        if (!synchonizer) {\n            synchonizer = new Synchronizer();\n            synchonizer.on('work-start', () => this.fire('work-start', synchonizer, tag, this));\n            synchonizer.on('work-end', () => this.fire('work-end', synchonizer, tag, this));\n            this._synchronizers.set(tag, synchonizer);\n        }\n        return synchonizer.push(fn);\n    }\n\n    /**\n     * Reject all jobs in the queue and clear it.\n     * @returns {void}\n     */\n    clear() {\n        for (const synchronizer of this._synchronizers.values()) {\n            synchronizer.clear();\n        }\n        this._synchronizers.clear();\n    }\n\n    /**\n     * @param {string} tag\n     * @returns {boolean}\n     */\n    isWorking(tag) {\n        const synchonizer = this._synchronizers.get(tag);\n        return !!synchonizer && synchonizer.working;\n    }\n}\nClass.register(MultiSynchronizer);\n","class PrioritySynchronizer extends Observable {\n    /**\n     * @param {number} numPriorities\n     */\n    constructor(numPriorities) {\n        super();\n        this._queues = [];\n        for (let i = 0; i < numPriorities; i++) {\n            this._queues[i] = [];\n        }\n        this._working = false;\n    }\n\n    /**\n     * Push function to the Synchronizer for later, synchronous execution\n     * @template T\n     * @param {number} priority A discrete priority, 0 being highest.\n     * @param {function():T} fn Function to be invoked later by this Synchronizer\n     * @returns {Promise.<T>}\n     */\n    push(priority, fn) {\n        Assert.that(priority >= 0 && priority < this._queues.length && Number.isInteger(priority), 'Invalid priority');\n\n        return new Promise((resolve, reject) => {\n            this._queues[priority].push({fn: fn, resolve: resolve, reject: reject});\n            if (!this._working) {\n                this._doWork().catch(Log.w.tag(PrioritySynchronizer));\n            }\n        });\n    }\n\n    /**\n     * Reject all jobs in the queue and clear it.\n     * @returns {void}\n     */\n    clear() {\n        for (const queue of this._queues) {\n            for (const job of queue) {\n                if (job.reject) job.reject();\n            }\n        }\n        this._queues = [];\n    }\n\n    async _doWork() {\n        this._working = true;\n        this.fire('work-start', this);\n\n        for (const queue of this._queues) {\n            while (queue.length > 0) {\n                const job = queue.shift();\n                try {\n                    const result = await job.fn();\n                    job.resolve(result);\n                } catch (e) {\n                    if (job.reject) job.reject(e);\n                }\n            }\n        }\n\n        this._working = false;\n        this.fire('work-end', this);\n    }\n\n    /** @type {boolean} */\n    get working() {\n        return this._working;\n    }\n}\nClass.register(PrioritySynchronizer);\n","class RateLimit {\n    /**\n     * @param {number} allowedOccurences\n     * @param {number} [timeRange=60000]\n     */\n    constructor(allowedOccurences, timeRange = 60000) {\n        /** @type {number} */\n        this._allowedEntries = allowedOccurences;\n        /** @type {number} */\n        this._timeRange = timeRange;\n\n        /** @type {number} */\n        this._lastReset = 0;\n        /** @type {number} */\n        this._counter = 0;\n    }\n\n    /**\n     * @param {number} [number=1]\n     * @returns {boolean}\n     */\n    note(number = 1) {\n        if (this._lastReset < Date.now() - this._timeRange) {\n            this._lastReset = Date.now();\n            this._counter = 0;\n        }\n        return (this._counter += number) <= this._allowedEntries;\n    }\n}\n\nClass.register(RateLimit);\n","/**\n * @interface\n */\nclass IWorker {\n    static async createProxy(clazz, name, worker) {\n        return new (IWorker.Proxy(clazz))(worker, name);\n    }\n\n    static async startWorkerForProxy(clazz, name, workerScript) {\n        if (!IWorker._workersSupported) {\n            await IWorker._workerImplementation[clazz.name].init(name);\n            return IWorker._workerImplementation[clazz.name];\n        } else {\n            if (!workerScript) {\n                workerScript = `${Nimiq._path}worker.js`;\n            }\n            return IWorker.createProxy(clazz, name, new Worker(window.URL.createObjectURL(new Blob([`Nimiq = {_path: '${Nimiq._path}'}; importScripts('${workerScript.replace(/'/g, '')}');`]))));\n        }\n    }\n\n    static async startWorkerPoolForProxy(clazz, name, size, workerScript) {\n        return (new (IWorker.Pool(clazz))((name) => IWorker.startWorkerForProxy(clazz, name, workerScript), name, size)).start();\n    }\n\n    static async stubBaseOnMessage(msg) {\n        try {\n            if (msg.data.command === 'init') {\n                if (IWorker._workerImplementation[msg.data.args[0]]) {\n                    const res = await IWorker._workerImplementation[msg.data.args[0]].init(msg.data.args[1]);\n                    self.postMessage({status: 'OK', result: res, id: msg.data.id});\n                } else {\n                    self.postMessage({status: 'error', result: 'Unknown worker!', id: msg.data.id});\n                }\n            } else {\n                self.postMessage({status: 'error', result: 'Worker not yet initialized!', id: msg.data.id});\n            }\n        } catch (e) {\n            self.postMessage({status: 'error', result: e, id: msg.data.id});\n        }\n    }\n\n    static get _workersSupported() {\n        return typeof Worker !== 'undefined';\n    }\n\n    static get areWorkersAsync() {\n        return IWorker._workersSupported;\n    }\n\n    static get _insideWebWorker() {\n        return typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;\n    }\n\n    static get _global() {\n        return typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : null;\n    }\n\n    static prepareForWorkerUse(baseClazz, impl) {\n        if (IWorker._insideWebWorker) {\n            // Only inside WebWorker\n            self.onmessage = IWorker.stubBaseOnMessage;\n        }\n        IWorker._workerImplementation = IWorker._workerImplementation || {};\n        IWorker._workerImplementation[baseClazz.name] = impl;\n    }\n\n    static _loadBrowserScript(url, resolve) {\n        // Adding the script tag to the head as suggested before\n        const head = document.getElementsByTagName('head')[0];\n        const script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n\n        // Then bind the event to the callback function.\n        // There are several events for cross browser compatibility.\n        // These events might occur before processing, so delay them a bit.\n        const ret = () => window.setTimeout(resolve, 100);\n        script.onreadystatechange = ret;\n        script.onload = ret;\n\n        // Fire the loading\n        head.appendChild(script);\n    }\n\n    static Proxy(clazz) {\n        const proxyClass = class extends clazz {\n            /**\n             * @param {Worker} worker\n             * @param {string} [name]\n             */\n            constructor(worker, name) {\n                super();\n                this._name = name;\n                this._messageId = 0;\n                this._worker = worker;\n                this._worker.onmessage = this._receive.bind(this);\n                /** @type {Map.<number,{resolve:Function,error:Function}>} */\n                this._waiting = new Map();\n                return this._invoke('init', [clazz.name, name]).then(() => { return this; });\n            }\n\n            _receive(msg) {\n                const cb = this._waiting.get(msg.data.id);\n                if (!cb) {\n                    Log.w(WorkerProxy, 'Unknown reply', msg);\n                } else {\n                    this._waiting.delete(msg.data.id);\n                    if (msg.data.status === 'OK') {\n                        cb.resolve(msg.data.result);\n                    } else if (msg.data.status === 'error') {\n                        cb.error(msg.data.result);\n                    }\n                }\n            }\n\n            /**\n             * @param {string} command\n             * @param {object[]} [args]\n             * @returns {Promise}\n             * @private\n             */\n            _invoke(command, args = []) {\n                return new Promise((resolve, error) => {\n                    const obj = {command: command, args: args, id: this._messageId++};\n                    this._waiting.set(obj.id, {resolve, error});\n                    this._worker.postMessage(obj);\n                });\n            }\n\n            destroy() {\n                return this._invoke('destroy');\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                proxyClass.prototype[funcName] = function (...args) {\n                    return this._invoke(funcName, args);\n                };\n            }\n        }\n        return proxyClass;\n    }\n\n    /**\n     * @param {object} clazz\n     * @return {Stub}\n     * @constructor\n     */\n    static Stub(clazz) {\n        const Stub = class extends clazz {\n            constructor() {\n                super();\n            }\n\n            _result(msg, status, result) {\n                self.postMessage({status, result, id: msg.data.id});\n            }\n\n            _onmessage(msg) {\n                try {\n                    const res = this._invoke(msg.data.command, msg.data.args);\n                    if (res instanceof Promise) {\n                        res.then((finalRes) => { this._result(msg, 'OK', finalRes); });\n                    } else {\n                        this._result(msg, 'OK', res);\n                    }\n                } catch (e) {\n                    this._result(msg, 'error', e.message || e);\n                }\n            }\n\n            init(name) {\n                this._name = name;\n                if (IWorker._insideWebWorker) {\n                    self.name = name;\n                    self.onmessage = (msg) => this._onmessage(msg);\n                }\n            }\n\n            _invoke(command, args) {\n                return this[command].apply(this, args);\n            }\n\n            destroy() {\n                if (IWorker._insideWebWorker) {\n                    self.close();\n                }\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                Stub.prototype[funcName] = function () {\n                    throw `Not implemented in IWorker Stub: ${funcName}`;\n                };\n            }\n        }\n        return Stub;\n    }\n\n    static Pool(clazz) {\n        const poolClass = class extends clazz {\n            /**\n             *\n             * @param {function(string):Promise} proxyInitializer\n             * @param {string} [name]\n             * @param {number} [size] Number of workers in this pool.\n             */\n            constructor(proxyInitializer, name = 'pool', size = 1) {\n                super();\n                /** @type {function(string):Promise} */\n                this._proxyInitializer = proxyInitializer;\n                /** @type {string} */\n                this._name = name;\n                /** @type {number} */\n                this._poolSize = size;\n                /** @type {Array} */\n                this._workers = [];\n                /** @type {Array} */\n                this._freeWorkers = [];\n                /** @type {Array.<{name:string, args:Array, resolve:function, error:function}>} */\n                this._waitingCalls = [];\n            }\n\n            async start() {\n                await this._updateToSize();\n\n                return this;\n            }\n\n            get poolSize() {\n                return this._poolSize;\n            }\n\n            set poolSize(_size) {\n                this._poolSize = _size;\n                this._updateToSize().catch(Log.w.tag(IWorker));\n            }\n\n            destroy() {\n                this._poolSize = 0;\n                return this._updateToSize();\n            }\n\n            /**\n             * @param {string} name Name of the function to call on a worker\n             * @param {Array} args Arguments to pass to the function\n             * @returns {Promise}\n             */\n            _invoke(name, args) {\n                if (IWorker._workersSupported) {\n                    return new Promise((resolve, error) => {\n                        this._waitingCalls.push({name, args, resolve, error});\n                        const worker = this._freeWorkers.shift();\n                        if (worker) {\n                            this._step(worker).catch(Log.w.tag(IWorker));\n                        }\n                    });\n                } else {\n                    return this._workers[0][name].apply(this._workers[0], args);\n                }\n            }\n\n            /**\n             * @param worker\n             * @returns {Promise.<void>}\n             * @private\n             */\n            async _step(worker) {\n                let call = this._waitingCalls.shift();\n                while (call) {\n                    try {\n                        // eslint-disable-next-line no-await-in-loop\n                        call.resolve(await worker[call.name].apply(worker, call.args));\n                    } catch (e) {\n                        call.error(e);\n                    }\n                    if (this._workers.indexOf(worker) === -1) {\n                        worker.destroy();\n                        return;\n                    }\n                    call = this._waitingCalls.shift();\n                }\n                this._freeWorkers.push(worker);\n            }\n\n            async _updateToSize() {\n                if (typeof Worker === 'undefined' && this._poolSize > 1) {\n                    Log.d(IWorker, 'Pool of size larger than 1 requires WebWorker support.');\n                    this._poolSize = 1;\n                }\n\n                const workerPromises = [];\n                while (this._workers.length + workerPromises.length < this._poolSize) {\n                    workerPromises.push(this._proxyInitializer(`${this._name}#${this._workers.length + workerPromises.length}`));\n                }\n                const createdWorkers = await Promise.all(workerPromises);\n                for (const worker of createdWorkers) {\n                    this._workers.push(worker);\n                    this._step(worker).catch(Log.w.tag(IWorker));\n                }\n\n                while (this._workers.length > this._poolSize) {\n                    const worker = this._freeWorkers.shift() || this._workers.pop();\n                    const idx = this._workers.indexOf(worker);\n                    if (idx >= 0) {\n                        // This was a free worker, also remove it from the worker list and destroy it now.\n                        this._workers.splice(idx, 1);\n                        worker.destroy();\n                    }\n                }\n                return this;\n            }\n        };\n        for (const funcName of Object.getOwnPropertyNames(clazz.prototype)) {\n            if (typeof clazz.prototype[funcName] === 'function' && funcName !== 'constructor') {\n                poolClass.prototype[funcName] = function (...args) {\n                    return this._invoke(funcName, args);\n                };\n            }\n        }\n        return poolClass;\n    }\n}\n\nIWorker._moduleLoadedCallbacks = {};\nIWorker._workerImplementation = {};\nClass.register(IWorker);\n","class WasmHelper {\n\n    static async doImportBrowser() {\n        if (PlatformUtils.isNodeJs()) return;\n        if (WasmHelper._importStarted) {\n            Log.e(WasmHelper, 'doImportBrowser invoked twice');\n            return;\n        }\n        WasmHelper._importStarted = true;\n        if (await WasmHelper.importWasmBrowser('worker-wasm.wasm')) {\n            await WasmHelper.importScriptBrowser('worker-wasm.js');\n        } else {\n            await WasmHelper.importScriptBrowser('worker-js.js');\n        }\n        WasmHelper._importFinished = true;\n    }\n\n    static doImportNodeJs() {\n        if (!PlatformUtils.isNodeJs()) return;\n        if (WasmHelper.importWasmNodeJs('worker-wasm.wasm')) {\n            WasmHelper.importScriptNodeJs('worker-wasm.js');\n        } else {\n            WasmHelper.importScriptNodeJs('worker-js.js');\n        }\n    }\n\n    /**\n     * @param {string} wasm\n     * @param {string} module\n     * @returns {Promise.<boolean>}\n     */\n    static importWasmBrowser(wasm, module = 'Module') {\n        wasm = WasmHelper._adjustWasmPath(wasm);\n        if (!WasmHelper._global.WebAssembly) {\n            Log.w(WasmHelper, 'No support for WebAssembly available.');\n            return Promise.resolve(false);\n        }\n\n        return new Promise((resolve) => {\n            try {\n                const xhr = new XMLHttpRequest();\n                xhr.open('GET', wasm, true);\n                xhr.responseType = 'arraybuffer';\n                xhr.onload = function () {\n                    WasmHelper._global[module] = WasmHelper._global[module] || {};\n                    WasmHelper._global[module].wasmBinary = xhr.response;\n                    resolve(true);\n                };\n                xhr.onerror = function () {\n                    Log.w(WasmHelper, `Failed to access WebAssembly module ${wasm}`);\n                    resolve(false);\n                };\n                xhr.send(null);\n            } catch (e) {\n                Log.w(WasmHelper, `Failed to access WebAssembly module ${wasm}`);\n                resolve(false);\n            }\n        });\n    }\n\n    static importWasmNodeJs(wasm, module = 'Module') {\n        wasm = WasmHelper._adjustWasmPath(wasm);\n        if (!WasmHelper._global.WebAssembly) {\n            Log.w(WasmHelper, 'No support for WebAssembly available.');\n            return false;\n        }\n\n        const toUint8Array = function (buf) {\n            const u = new Uint8Array(buf.length);\n            for (let i = 0; i < buf.length; ++i) {\n                u[i] = buf[i];\n            }\n            return u;\n        };\n        const fs = require('fs');\n        try {\n            const data = fs.readFileSync(wasm);\n            WasmHelper._global[module] = WasmHelper._global[module] || {};\n            WasmHelper._global[module].wasmBinary = toUint8Array(data);\n            return true;\n        } catch (e) {\n            Log.w(WasmHelper, `Failed to access WebAssembly module ${wasm}: ${e}`);\n            return false;\n        }\n    }\n\n    static importScriptBrowser(script, module = 'Module') {\n        if (module && WasmHelper._global[module] && WasmHelper._global[module].asm) return false;\n        script = WasmHelper._adjustScriptPath(script);\n\n        const moduleSettings = WasmHelper._global[module] || {};\n        return new Promise(async (resolve, reject) => {\n            if (module) {\n                moduleSettings.onRuntimeInitialized = () => resolve(true);\n            }\n            if (typeof importScripts === 'function') {\n                await new Promise((resolve) => {\n                    WasmHelper._moduleLoadedCallbacks[module] = resolve;\n                    importScripts(script);\n                });\n                WasmHelper._global[module] = WasmHelper._global[module](moduleSettings);\n                if (!module) resolve(true);\n            } else if (typeof window === 'object') {\n                await new Promise((resolve) => {\n                    WasmHelper._moduleLoadedCallbacks[module] = resolve;\n                    WasmHelper._loadBrowserScript(script);\n                });\n                WasmHelper._global[module] = WasmHelper._global[module](moduleSettings);\n                if (!module) resolve(true);\n            } else if (typeof require === 'function') {\n                WasmHelper._global[module] = require(script)(moduleSettings);\n                if (!module) resolve(true);\n            } else {\n                reject('No way to load scripts.');\n            }\n        });\n    }\n\n    static importScriptNodeJs(script, module = 'Module') {\n        if (module && WasmHelper._global[module] && WasmHelper._global[module].asm) return false;\n        script = WasmHelper._adjustScriptPath(script);\n\n        const moduleSettings = WasmHelper._global[module] || {};\n\n        if (typeof require === 'function') {\n            WasmHelper._global[module] = require(script)(moduleSettings);\n            if (!module) return true;\n        }\n        return false;\n    }\n\n    static fireModuleLoaded(module = 'Module') {\n        if (typeof WasmHelper._moduleLoadedCallbacks[module] === 'function') {\n            WasmHelper._moduleLoadedCallbacks[module]();\n            WasmHelper._moduleLoadedCallbacks[module] = null;\n        }\n    }\n\n    static _loadBrowserScript(url) {\n        const head = document.getElementsByTagName('head')[0];\n        const script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n        head.appendChild(script);\n    }\n\n    static _adjustWasmPath(wasm) {\n        if (typeof Nimiq !== 'undefined' && Nimiq._path) wasm = `${Nimiq._path}${wasm}`;\n        if (typeof __dirname === 'string' && wasm.indexOf('/') === -1) wasm = `${__dirname}/${wasm}`;\n        return wasm;\n    }\n\n    static _adjustScriptPath(script) {\n        if (typeof Nimiq !== 'undefined' && Nimiq._path) script = `${Nimiq._path}${script}`;\n        if (typeof __dirname === 'string' && script.indexOf('/') === -1) script = `${__dirname}/${script}`;\n        return script;\n    }\n\n    static get _global() {\n        return typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : null;\n    }\n}\nWasmHelper._moduleLoadedCallbacks = {};\n\nClass.register(WasmHelper);\n\n","/**\n * @interface\n */\nclass CryptoWorker {\n    static get lib() { return CryptoLib.instance; }\n\n    /**\n     * @returns {Promise.<CryptoWorker>}\n     */\n    static async getInstanceAsync() {\n        if (!CryptoWorker._workerAsync) {\n            CryptoWorker._workerAsync = await IWorker.startWorkerPoolForProxy(CryptoWorker, 'crypto', 4);\n        }\n        return CryptoWorker._workerAsync;\n    }\n    /**\n     * @param {Uint8Array} input\n     * @returns {Promise.<Uint8Array>}\n     */\n    async computeArgon2d(input) {}\n\n    /**\n     * @param {Array.<Uint8Array>} inputs\n     * @returns {Promise.<Array.<Uint8Array>>}\n     */\n    async computeArgon2dBatch(inputs) {}\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @returns {Promise.<Uint8Array>}\n     */\n    async kdf(key, salt, iterations) {}\n\n    /**\n     * @param {Uint8Array} block\n     * @param {Array.<bool>} transactionValid\n     * @param {number} timeNow\n     * @param {Uint8Array} genesisHash\n     * @param {number} networkId\n     * @returns {Promise.<{valid: boolean, pow: SerialBuffer, interlinkHash: SerialBuffer, bodyHash: SerialBuffer}>}\n     */\n    async blockVerify(block, transactionValid, timeNow, genesisHash, networkId) {}\n}\n/** @type {CryptoWorker} */\nCryptoWorker._workerAsync = null;\n\nClass.register(CryptoWorker);\n","class CryptoWorkerImpl extends IWorker.Stub(CryptoWorker) {\n    constructor() {\n        super();\n        // FIXME: This is needed for Babel to work correctly. Can be removed as soon as we updated to Babel v7.\n        this._superInit = super.init;\n    }\n\n    async init(name) {\n        await this._superInit.call(this, name);\n        await WasmHelper.doImportBrowser();\n        CryptoWorker._workerAsync = this;\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    computeArgon2d(input) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.ARGON2D));\n            const res = NodeNative.node_argon2(out, new Uint8Array(input), 512);\n            if (res !== 0) {\n                throw res;\n            }\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.ARGON2D);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmIn = Module.stackAlloc(input.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                const res = Module._nimiq_argon2(wasmOut, wasmIn, input.length, 512);\n                if (res !== 0) {\n                    throw res;\n                }\n                const hash = new Uint8Array(hashSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hash;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} inputs\n     * @returns {Array.<Uint8Array>}\n     */\n    computeArgon2dBatch(inputs) {\n        const hashes = [];\n        if (PlatformUtils.isNodeJs()) {\n            for(const input of inputs) {\n                const out = new Uint8Array(Hash.getSize(Hash.Algorithm.ARGON2D));\n                const res = NodeNative.node_argon2(out, new Uint8Array(input), 512);\n                if (res !== 0) {\n                    throw res;\n                }\n                hashes.push(out);\n            }\n            return hashes;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.ARGON2D);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const stackTmp = Module.stackSave();\n                for (const input of inputs) {\n                    Module.stackRestore(stackTmp);\n                    const wasmIn = Module.stackAlloc(input.length);\n                    new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                    const res = Module._nimiq_argon2(wasmOut, wasmIn, input.length, 512);\n                    if (res !== 0) {\n                        throw res;\n                    }\n                    const hash = new Uint8Array(hashSize);\n                    hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                    hashes.push(hash);\n                }\n                return hashes;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @returns {Uint8Array}\n     */\n    kdf(key, salt, iterations) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.ARGON2D));\n            const res = NodeNative.node_kdf(out, new Uint8Array(key), new Uint8Array(salt), 512, iterations);\n            if (res !== 0) {\n                throw res;\n            }\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.ARGON2D);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmIn = Module.stackAlloc(key.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, key.length).set(key);\n                const wasmSalt = Module.stackAlloc(salt.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmSalt, salt.length).set(salt);\n                const res = Module._nimiq_kdf(wasmOut, wasmIn, key.length, wasmSalt, salt.length, 512, iterations);\n                if (res !== 0) {\n                    throw res;\n                }\n                const hash = new Uint8Array(hashSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hash;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} blockSerialized\n     * @param {Array.<boolean|undefined>} transactionValid\n     * @param {number} timeNow\n     * @param {Uint8Array} genesisHash\n     * @param {number} networkId\n     * @returns {Promise.<{valid: boolean, pow: SerialBuffer, interlinkHash: SerialBuffer, bodyHash: SerialBuffer}>}\n     */\n    async blockVerify(blockSerialized, transactionValid, timeNow, genesisHash, networkId) {\n        // The worker only uses a stub genesis config.\n        GenesisConfig = {\n            GENESIS_HASH: Hash.unserialize(new SerialBuffer(genesisHash)),\n            NETWORK_ID: networkId\n        };\n\n        const block = Block.unserialize(new SerialBuffer(blockSerialized));\n        for (let i = 0; i < transactionValid.length; i++) {\n            block.body.transactions[i]._valid = transactionValid[i];\n        }\n\n        const valid = await block._verify(timeNow);\n        const pow = await block.header.pow();\n        const interlinkHash = block.interlink.hash();\n        const bodyHash = block.body.hash();\n        return { valid: valid, pow: pow.serialize(), interlinkHash: interlinkHash.serialize(), bodyHash: bodyHash.serialize() };\n    }\n}\n\nIWorker.prepareForWorkerUse(CryptoWorker, new CryptoWorkerImpl());\n","class CRC32 {\n    static _createTable () {\n        let b;\n        const table = [];\n\n        for (let j = 0; j < 256; ++j) {\n            b = j;\n            for (let k = 0; k < 8; ++k) {\n                b = b & 1 ? CRC32._POLYNOMIAL ^ (b >>> 1) : b >>> 1;\n            }\n            table[j] = b >>> 0;\n        }\n        return table;\n    }\n\n    /**\n     * @param {Uint8Array} buf\n     * @returns {number}\n     */\n    static compute(buf) {\n        if (!CRC32._table) CRC32._table = CRC32._createTable();\n        if (!CRC32._hex_chars) CRC32._hex_chars = '0123456789abcdef'.split('');\n\n        const message = new Uint8Array(buf);\n        const initialValue = -1;\n\n        let crc = initialValue;\n        let hex = '';\n\n        for (let i = 0; i < message.length; ++i) {\n            crc = CRC32._table[(crc ^ message[i]) & 0xFF] ^ (crc >>> 8);\n        }\n        crc ^= initialValue;\n\n        hex += CRC32._hex_chars[(crc >> 28) & 0x0F] + CRC32._hex_chars[(crc >> 24) & 0x0F] +\n            CRC32._hex_chars[(crc >> 20) & 0x0F] + CRC32._hex_chars[(crc >> 16) & 0x0F] +\n            CRC32._hex_chars[(crc >> 12) & 0x0F] + CRC32._hex_chars[(crc >> 8) & 0x0F] +\n            CRC32._hex_chars[(crc >> 4) & 0x0F] + CRC32._hex_chars[crc & 0x0F];\n\n        return parseInt(hex, 16);\n    }\n}\nCRC32._table = null;\nCRC32._hex_chars = null;\nCRC32._POLYNOMIAL = 0xEDB88320;\nClass.register(CRC32);\n","class NumberUtils {\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint8(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT8_MAX;\n    }\n\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint16(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT16_MAX;\n    }\n\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint32(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT32_MAX;\n    }\n\n    /**\n     * @param {number} val\n     * @return {boolean}\n     */\n    static isUint64(val) {\n        return Number.isInteger(val)\n            && val >= 0 && val <= NumberUtils.UINT64_MAX;\n    }\n\n    /**\n     * @return {number}\n     */\n    static randomUint32() {\n        return Math.floor(Math.random() * (NumberUtils.UINT32_MAX + 1));\n    }\n\n    /**\n     * @return {number}\n     */\n    static randomUint64() {\n        return Math.floor(Math.random() * (NumberUtils.UINT64_MAX + 1));\n    }\n}\n\nNumberUtils.UINT8_MAX = 255;\nNumberUtils.UINT16_MAX = 65535;\nNumberUtils.UINT32_MAX = 4294967295;\nNumberUtils.UINT64_MAX = Number.MAX_SAFE_INTEGER;\n//Object.freeze(NumberUtils);\nClass.register(NumberUtils);\n","class MerkleTree {\n    /**\n     * @param {Array} values\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {Hash}\n     */\n    static computeRoot(values, fnHash = MerkleTree._hash) {\n        return MerkleTree._computeRoot(values, fnHash);\n    }\n\n    /**\n     * @param {Array} values\n     * @param {function(o: *):Hash} fnHash\n     * @returns {Hash}\n     * @private\n     */\n    static _computeRoot(values, fnHash) {\n        const len = values.length;\n        if (len === 0) {\n            return Hash.light(new Uint8Array(0));\n        }\n        if (len === 1) {\n            return fnHash(values[0]);\n        }\n\n        const mid = Math.round(len / 2);\n        const left = values.slice(0, mid);\n        const right = values.slice(mid);\n        const leftHash = MerkleTree._computeRoot(left, fnHash);\n        const rightHash = MerkleTree._computeRoot(right, fnHash);\n        return Hash.light(BufferUtils.concatTypedArrays(leftHash.serialize(), rightHash.serialize()));\n    }\n\n    /**\n     * @param {Hash|Uint8Array|{hash: function():Hash}|{serialize: function():Uint8Array}} o\n     * @returns {Hash}\n     * @private\n     */\n    static _hash(o) {\n        if (o instanceof Hash) {\n            return o;\n        }\n        if (typeof o.hash === 'function') {\n            return o.hash();\n        }\n        if (typeof o.serialize === 'function') {\n            return Hash.light(o.serialize());\n        }\n        if (o instanceof Uint8Array) {\n            return Hash.light(o);\n        }\n        throw new Error('MerkleTree objects must be Uint8Array or have a .hash()/.serialize() method');\n    }\n}\nClass.register(MerkleTree);\n","class MerklePath {\n    /**\n     * @param {Array.<MerklePathNode>} nodes\n     */\n    constructor(nodes) {\n        if (!Array.isArray(nodes) || !NumberUtils.isUint8(nodes.length)\n            || nodes.some(it => !(it instanceof MerklePathNode))) throw new Error('Malformed nodes');\n        /**\n         * @type {Array.<MerklePathNode>}\n         * @private\n         */\n        this._nodes = nodes;\n    }\n\n    /**\n     * @param {Array} values\n     * @param {*} leafValue\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {MerklePath}\n     */\n    static compute(values, leafValue, fnHash = MerkleTree._hash) {\n        const leafHash = fnHash(leafValue);\n        const path = [];\n        MerklePath._compute(values, leafHash, path, fnHash);\n        return new MerklePath(path);\n    }\n\n    /**\n     * @param {Array} values\n     * @param {Hash} leafHash\n     * @param {Array.<MerklePathNode>} path\n     * @param {function(o: *):Hash} fnHash\n     * @returns {{containsLeaf:boolean, inner:Hash}}\n     * @private\n     */\n    static _compute(values, leafHash, path, fnHash) {\n        const len = values.length;\n        let hash;\n        if (len === 0) {\n            hash = Hash.light(new Uint8Array(0));\n            return {containsLeaf: false, inner: hash};\n        }\n        if (len === 1) {\n            hash = fnHash(values[0]);\n            return {containsLeaf: hash.equals(leafHash), inner: hash};\n        }\n\n        const mid = Math.round(len / 2);\n        const left = values.slice(0, mid);\n        const right = values.slice(mid);\n        const {containsLeaf: leftLeaf, inner: leftHash} = MerklePath._compute(left, leafHash, path, fnHash);\n        const {containsLeaf: rightLeaf, inner: rightHash} = MerklePath._compute(right, leafHash, path, fnHash);\n        hash = Hash.light(BufferUtils.concatTypedArrays(leftHash.serialize(), rightHash.serialize()));\n\n        if (leftLeaf) {\n            path.push(new MerklePathNode(rightHash, false));\n            return {containsLeaf: true, inner: hash};\n        } else if (rightLeaf) {\n            path.push(new MerklePathNode(leftHash, true));\n            return {containsLeaf: true, inner: hash};\n        }\n\n        return {containsLeaf: false, inner: hash};\n    }\n\n    /**\n     * @param {*} leafValue\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {Hash}\n     */\n    computeRoot(leafValue, fnHash = MerkleTree._hash) {\n        /** @type {Hash} */\n        let root = fnHash(leafValue);\n        for (const node of this._nodes) {\n            const left = node.left;\n            const hash = node.hash;\n            const concat = new SerialBuffer(hash.serializedSize * 2);\n            if (left) hash.serialize(concat);\n            root.serialize(concat);\n            if (!left) hash.serialize(concat);\n            root = Hash.light(concat);\n        }\n        return root;\n    }\n\n    /**\n     * @param {Array.<MerklePathNode>} nodes\n     * @returns {Uint8Array}\n     * @private\n     */\n    static _compress(nodes) {\n        const count = nodes.length;\n        const leftBitsSize = Math.ceil(count / 8);\n        const leftBits = new Uint8Array(leftBitsSize);\n\n        for (let i = 0; i < count; i++) {\n            if (nodes[i].left) {\n                leftBits[Math.floor(i / 8)] |= 0x80 >>> (i % 8);\n            }\n        }\n\n        return leftBits;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {MerklePath}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint8();\n        const leftBitsSize = Math.ceil(count / 8);\n        const leftBits = buf.read(leftBitsSize);\n\n        const nodes = [];\n        for (let i = 0; i < count; i++) {\n            const left = (leftBits[Math.floor(i / 8)] & (0x80 >>> (i % 8))) !== 0;\n            const hash = Hash.unserialize(buf);\n            nodes.push(new MerklePathNode(hash, left));\n        }\n        return new MerklePath(nodes);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._nodes.length);\n        buf.write(MerklePath._compress(this._nodes));\n\n        for (const node of this._nodes) {\n            node.hash.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        const leftBitsSize = Math.ceil(this._nodes.length / 8);\n        return /*count*/ 1\n            + leftBitsSize\n            + this._nodes.reduce((sum, node) => sum + node.hash.serializedSize, 0);\n    }\n\n    /**\n     * @param {MerklePath} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof MerklePath\n            && this._nodes.length === o._nodes.length\n            && this._nodes.every((node, i) => node.equals(o._nodes[i]));\n    }\n\n    /** @type {Array.<MerklePathNode>} */\n    get nodes() {\n        return this._nodes;\n    }\n}\nClass.register(MerklePath);\n\nclass MerklePathNode {\n    /**\n     * @param {Hash} hash\n     * @param {boolean} left\n     */\n    constructor(hash, left) {\n        this._hash = hash;\n        this._left = left;\n    }\n\n    /** @type {Hash} */\n    get hash() {\n        return this._hash;\n    }\n\n    /** @type {boolean} */\n    get left() {\n        return this._left;\n    }\n\n    /**\n     * @param {MerklePathNode} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof MerklePathNode\n            && this._hash.equals(o.hash)\n            && this._left === o.left;\n    }\n}\nClass.register(MerklePathNode);\n","class MerkleProof {\n    /**\n     * @param {Array.<*>} hashes\n     * @param {Array.<MerkleProof.Operation>} operations\n     */\n    constructor(hashes, operations) {\n        if (!Array.isArray(hashes) || !NumberUtils.isUint16(hashes.length)) throw new Error('Malformed nodes');\n        if (!Array.isArray(operations) || !NumberUtils.isUint16(operations.length)) throw new Error('Malformed operations');\n        /**\n         * @type {Array.<*>}\n         * @private\n         */\n        this._nodes = hashes;\n        this._operations = operations;\n    }\n\n    /**\n     * @param {Array} values\n     * @param {Array.<*>} leafValues\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {MerkleProof}\n     */\n    static compute(values, leafValues, fnHash = MerkleTree._hash) {\n        const leafHashes = leafValues.map(fnHash);\n        const {containsLeaf, operations, path, inner} = MerkleProof._compute(values, leafHashes, fnHash);\n        return new MerkleProof(path, operations);\n    }\n\n    /**\n     * Assumes ordered array of values.\n     * @param {Array} values\n     * @param {Array.<*>} leafValues\n     * @param {function(a: *, b: *):number} fnCompare\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {MerkleProof}\n     */\n    static computeWithAbsence(values, leafValues, fnCompare, fnHash = MerkleTree._hash) {\n        const leaves = new Set();\n        leafValues = leafValues.slice();\n        leafValues.sort(fnCompare);\n        // Find missing leaves and include neighbours instead.\n        let leafIndex = 0, valueIndex = 0;\n        while (valueIndex < values.length && leafIndex < leafValues.length) {\n            const value = values[valueIndex];\n            const comparisonResult = fnCompare(value, leafValues[leafIndex]);\n            // Leave is included.\n            if (comparisonResult === 0) {\n                leaves.add(leafValues[leafIndex]);\n                ++leafIndex;\n            }\n            // Leave should already have been there, so it is missing.\n            else if (comparisonResult > 0) {\n                // Use both, prevValue and value, as a proof of absence.\n                // Special case: prevValue unknown as we're at the first value.\n                if (valueIndex > 0) {\n                    leaves.add(values[valueIndex - 1]);\n                }\n                leaves.add(value);\n                ++leafIndex;\n            }\n            // This value is not interesting for us, skip it.\n            else {\n                ++valueIndex;\n            }\n        }\n        // If we processed all values but not all leaves, these are missing. Add last value as proof.\n        if (leafIndex < leafValues.length && values.length > 0) {\n            leaves.add(values[values.length - 1]);\n        }\n\n        return MerkleProof.compute(values, Array.from(leaves), fnHash);\n    }\n\n    /**\n     * @param {Array} values\n     * @param {Array.<Hash>} leafHashes\n     * @param {function(o: *):Hash} fnHash\n     * @returns {{containsLeaf:boolean, inner:Hash}}\n     * @private\n     */\n    static _compute(values, leafHashes, fnHash) {\n        const len = values.length;\n        let hash;\n        if (len === 0) {\n            hash = Hash.light(new Uint8Array(0));\n            return {containsLeaf: false, operations: [MerkleProof.Operation.CONSUME_PROOF], path: [hash], inner: hash};\n        }\n        if (len === 1) {\n            hash = fnHash(values[0]);\n            const isLeaf = leafHashes.some(h => hash.equals(h));\n            return {\n                containsLeaf: isLeaf,\n                operations: [isLeaf ? MerkleProof.Operation.CONSUME_INPUT : MerkleProof.Operation.CONSUME_PROOF],\n                path: isLeaf ? [] : [hash],\n                inner: hash\n            };\n        }\n\n        const mid = Math.round(len / 2);\n        const left = values.slice(0, mid);\n        const right = values.slice(mid);\n        const {containsLeaf: leftLeaf, operations: leftOps, path: leftPath, inner: leftHash} = MerkleProof._compute(left, leafHashes, fnHash);\n        const {containsLeaf: rightLeaf, operations: rightOps, path: rightPath, inner: rightHash} = MerkleProof._compute(right, leafHashes, fnHash);\n        hash = Hash.light(BufferUtils.concatTypedArrays(leftHash.serialize(), rightHash.serialize()));\n\n        // If a branch does not contain a leaf, we can directly use its hash and discard any inner operations.\n        if (!leftLeaf && !rightLeaf) {\n            return {containsLeaf: false, operations: [MerkleProof.Operation.CONSUME_PROOF], path: [hash], inner: hash};\n        }\n\n        // At least one branch contains a leaf, so execute all operations.\n        let operations = leftOps;\n        operations = operations.concat(rightOps);\n        let path = leftPath;\n        path = path.concat(rightPath);\n\n        operations.push(MerkleProof.Operation.HASH);\n\n        return {containsLeaf: true, operations: operations, path: path, inner: hash};\n    }\n\n    /**\n     * @param {Array.<*>} leafValues\n     * @param {function(o: *):Hash} [fnHash]\n     * @returns {Hash}\n     */\n    computeRoot(leafValues, fnHash = MerkleTree._hash) {\n        /** @type {Array.<Hash>} */\n        const inputs = leafValues.map(fnHash);\n        const stack = [];\n        const proofNodes = this._nodes.slice();\n        for (const op of this._operations) {\n            switch (op) {\n                case MerkleProof.Operation.CONSUME_PROOF:\n                    if (proofNodes.length === 0) {\n                        throw new Error('Invalid operation.');\n                    }\n                    stack.push(proofNodes.shift());\n                    break;\n                case MerkleProof.Operation.CONSUME_INPUT:\n                    if (inputs.length === 0) {\n                        throw new Error('Invalid operation.');\n                    }\n                    stack.push(inputs.shift());\n                    break;\n                case MerkleProof.Operation.HASH: {\n                    if (stack.length < 2) {\n                        throw new Error('Invalid operation.');\n                    }\n                    const hashStack = stack.splice(-2, 2);\n                    const concat = new SerialBuffer(hashStack.reduce((size, hash) => size + hash.serializedSize, 0));\n                    const [left, right] = hashStack;\n                    left.serialize(concat);\n                    right.serialize(concat);\n                    stack.push(Hash.light(concat));\n                    break;\n                }\n                default:\n                    throw new Error('Invalid operation.');\n            }\n        }\n\n        // Everything but the root needs to be consumed.\n        if (stack.length !== 1 || proofNodes.length !== 0 || inputs.length !== 0) {\n            throw Error('Did not consume all nodes.');\n        }\n\n        return stack[0];\n    }\n\n    /**\n     * @param {Array.<MerkleProof.Operation>} operations\n     * @returns {Uint8Array}\n     * @private\n     */\n    static _compress(operations) {\n        const count = operations.length;\n        const opBitsSize = Math.ceil(count / 4);\n        const opBits = new Uint8Array(opBitsSize);\n\n        for (let i = 0; i < count; i++) {\n            const op = operations[i] & 0x3;\n            opBits[Math.floor(i / 4)] |= op << (i % 4) * 2;\n        }\n\n        return opBits;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {MerkleProof}\n     */\n    static unserialize(buf) {\n        const opCount = buf.readUint16();\n        const opBitsSize = Math.ceil(opCount / 4);\n        const opBits = buf.read(opBitsSize);\n\n        const operations = [];\n        for (let i = 0; i < opCount; i++) {\n            const op = ((opBits[Math.floor(i / 4)] >>> (i % 4) * 2) & 0x3);\n            operations.push(op);\n        }\n\n        const countNodes = buf.readUint16();\n        const hashes = [];\n        for (let i = 0; i < countNodes; i++) {\n            hashes.push(Hash.unserialize(buf));\n        }\n        return new MerkleProof(hashes, operations);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._operations.length);\n        buf.write(MerkleProof._compress(this._operations));\n        buf.writeUint16(this._nodes.length);\n        for (const hash of this._nodes) {\n            hash.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        const opBitsSize = Math.ceil(this._operations.length / 4);\n        return /*counts*/ 4\n            + opBitsSize\n            + this._nodes.reduce((sum, node) => sum + node.serializedSize, 0);\n    }\n\n    /**\n     * @param {MerkleProof} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof MerkleProof\n            && this._nodes.length === o._nodes.length\n            && this._nodes.every((node, i) => node.equals(o._nodes[i]))\n            && this._operations.length === o._operations.length\n            && this._operations.every((op, i) => op === o._operations[i]);\n    }\n\n    /** @type {Array.<Hash>} */\n    get nodes() {\n        return this._nodes;\n    }\n}\n/** @enum {number} */\nMerkleProof.Operation = {\n    CONSUME_PROOF: 0,\n    CONSUME_INPUT: 1,\n    HASH: 2\n};\nClass.register(MerkleProof);\n","class PlatformUtils {\n    /**\n     * @returns {boolean}\n     */\n    static isBrowser() {\n        return typeof window !== 'undefined';\n    }\n\n    /**\n     * @return {boolean}\n     */\n    static isNodeJs() {\n        return !PlatformUtils.isBrowser() && typeof process === 'object' && typeof require === 'function';\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    static supportsWebRTC() {\n        let RTCPeerConnection = PlatformUtils.isBrowser() ? (window.RTCPeerConnection || window.webkitRTCPeerConnection) : null;\n        return !!RTCPeerConnection;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    static isOnline() {\n        return (!PlatformUtils.isBrowser() || !('onLine' in window.navigator)) || window.navigator.onLine;\n    }\n}\nClass.register(PlatformUtils);\n","class StringUtils {\n    /**\n     * @param {string} str\n     * @returns {boolean}\n     */\n    static isMultibyte(str) {\n        return /[\\uD800-\\uDFFF]/.test(str);\n    }\n\n    /**\n     * @param {string} str\n     * @returns {boolean}\n     */\n    static isHex(str) {\n        return /^[0-9A-Fa-f]*$/.test(str);\n    }\n\n    /**\n     * @param {string} str\n     * @param {number} [length]\n     * @returns {boolean}\n     */\n    static isHexBytes(str, length) {\n        if (!StringUtils.isHex(str)) return false;\n        if (str.length % 2 !== 0) return false;\n        if (typeof length === 'number' && str.length / 2 !== length) return false;\n        return true;\n    }\n\n    /**\n     * @param {string} str1\n     * @param {string} str2\n     * @returns {string}\n     */\n    static commonPrefix(str1, str2) {\n        let i = 0;\n        for (; i < str1.length; ++i) {\n            if (str1[i] !== str2[i]) break;\n        }\n        return str1.substr(0, i);\n    }\n\n}\nClass.register(StringUtils);\n","class Policy {\n    /**\n     * Convert Nimiq decimal to Number of Satoshis.\n     * @param {number} coins Nimiq count in decimal\n     * @return {number} Number of Satoshis\n     */\n    static coinsToSatoshis(coins) {\n        return Math.round(coins * Policy.SATOSHIS_PER_COIN);\n    }\n\n    /**\n     * Convert Number of Satoshis to Nimiq decimal.\n     * @param {number} satoshis Number of Satoshis.\n     * @return {number} Nimiq count in decimal.\n     */\n    static satoshisToCoins(satoshis) {\n        return satoshis / Policy.SATOSHIS_PER_COIN;\n    }\n\n    /**\n     * Circulating supply after block.\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static supplyAfter(blockHeight) {\n        // Calculate last entry in supply cache that is below blockHeight.\n        let startHeight = Math.floor(blockHeight / Policy._supplyCacheInterval) * Policy._supplyCacheInterval;\n        startHeight = Math.max(0, Math.min(startHeight, Policy._supplyCacheMax));\n\n        // Calculate respective block for the last entry of the cache and the targeted height.\n        const startI = startHeight / Policy._supplyCacheInterval;\n        const endI = Math.floor(blockHeight / Policy._supplyCacheInterval);\n\n        // The starting supply is the initial supply at the beginning and a cached value afterwards.\n        let supply = startHeight === 0 ? Policy.INITIAL_SUPPLY : Policy._supplyCache.get(startHeight);\n        // Use and update cache.\n        for (let i = startI; i < endI; ++i) {\n            startHeight = i * Policy._supplyCacheInterval;\n            // Since the cache stores the supply *before* a certain block, subtract one.\n            const endHeight = (i + 1) * Policy._supplyCacheInterval - 1;\n            supply = Policy._supplyAfter(supply, endHeight, startHeight);\n            // Don't forget to add one again.\n            Policy._supplyCache.set(endHeight + 1, supply);\n            Policy._supplyCacheMax = endHeight + 1;\n        }\n\n        // Calculate remaining supply (this also adds the block reward for endI*interval).\n        return Policy._supplyAfter(supply, blockHeight, endI * Policy._supplyCacheInterval);\n    }\n\n    /**\n     * Circulating supply after block.\n     * @param {number} initialSupply\n     * @param {number} blockHeight\n     * @param {number} [startHeight]\n     * @return {number}\n     */\n    static _supplyAfter(initialSupply, blockHeight, startHeight=0) {\n        let supply = initialSupply;\n        for (let i = startHeight; i <= blockHeight; ++i) {\n            supply += Policy._blockRewardAt(supply, i);\n        }\n        return supply;\n    }\n\n    /**\n     * Miner reward per block.\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static blockRewardAt(blockHeight) {\n        const currentSupply = Policy.supplyAfter(blockHeight - 1);\n        return Policy._blockRewardAt(currentSupply, blockHeight);\n    }\n\n    /**\n     * Miner reward per block.\n     * @param {number} currentSupply\n     * @param {number} blockHeight\n     * @return {number}\n     */\n    static _blockRewardAt(currentSupply, blockHeight) {\n        if (blockHeight <= 0) return 0;\n        const remaining = Policy.TOTAL_SUPPLY - currentSupply;\n        if (blockHeight >= Policy.EMISSION_TAIL_START && remaining >= Policy.EMISSION_TAIL_REWARD) {\n            return Policy.EMISSION_TAIL_REWARD;\n        }\n        const remainder = remaining % Policy.EMISSION_SPEED;\n        return (remaining - remainder) / Policy.EMISSION_SPEED;\n    }\n}\n\n/**\n * Targeted block time in seconds.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_TIME = 60;\n\n/**\n * Maximum block size in bytes.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_SIZE_MAX = 1e5; // 100 kb\n\n/**\n * The highest (easiest) block PoW target.\n * @type {number}\n * @constant\n */\nPolicy.BLOCK_TARGET_MAX = Math.pow(2, 240);\n\n/**\n * Number of blocks we take into account to calculate next difficulty.\n * @type {number}\n * @constant\n */\nPolicy.DIFFICULTY_BLOCK_WINDOW = 120;\n\n/**\n * Limits the rate at which the difficulty is adjusted min/max.\n * @type {number}\n * @constant\n */\nPolicy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR = 2;\n\n/**\n * Number of blocks a transaction is valid.\n * @type {number}\n * @constant\n */\nPolicy.TRANSACTION_VALIDITY_WINDOW = 120;\n\n\n/* Supply & Emission Parameters */\n\n/**\n * Number of Satoshis per Nimiq.\n * @type {number}\n * @constant\n */\nPolicy.SATOSHIS_PER_COIN = 1e5;\n\n/**\n * Targeted total supply in satoshis.\n * @type {number}\n * @constant\n */\nPolicy.TOTAL_SUPPLY = 21e14;\n\n/**\n * Initial supply before genesis block in satoshis.\n * FIXME: Change for main net.\n * @type {number}\n * @constant\n */\nPolicy.INITIAL_SUPPLY = 252000000000000;\n\n/**\n * Emission speed.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_SPEED = Math.pow(2, 22);\n\n/**\n * First block using constant tail emission until total supply is reached.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_TAIL_START = 48692960;\n\n/**\n * Constant tail emission in satoshis until total supply is reached.\n * @type {number}\n * @constant\n */\nPolicy.EMISSION_TAIL_REWARD = 4000;\n\n/* Security parameters */\n\n/**\n * NIPoPoW Security parameter M\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.M = 240;\n\n/**\n * NIPoPoW Security parameter K\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.K = 120;\n\n/**\n * NIPoPoW Security parameter DELTA\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.DELTA = 0.1;\n\n/**\n * Number of blocks the light client downloads to verify the AccountsTree construction.\n * FIXME naming\n * @type {number}\n * @constant\n */\nPolicy.NUM_BLOCKS_VERIFICATION = 250;\n\n\n/* Snapshot Parameters */\n\n/**\n * Maximum number of snapshots.\n * @type {number}\n * @constant\n */\nPolicy.NUM_SNAPSHOTS_MAX = 20;\n\n\n/**\n * Stores the circulating supply before the given block.\n * @type {Map.<number, number>}\n * @private\n */\nPolicy._supplyCache = new Map();\nPolicy._supplyCacheMax = 0; // blocks\nPolicy._supplyCacheInterval = 5000; // blocks\nClass.register(Policy);\n","/**\n * @abstract\n */\nclass Serializable {\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Serializable && BufferUtils.equals(this.serialize(), o.serialize());\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {number} negative if this is smaller than o, positive if this is larger than o, zero if equal.\n     */\n    compare(o) {\n        return BufferUtils.compare(this.serialize(), o.serialize());\n    }\n\n    hashCode() {\n        return this.toBase64();\n    }\n\n    /**\n     * @abstract\n     * @param {SerialBuffer} [buf]\n     */\n    serialize(buf) {}\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return this.toBase64();\n    }\n\n    /**\n     * @return {string}\n     */\n    toBase64() {\n        return BufferUtils.toBase64(this.serialize());\n    }\n\n    /**\n     * @return {string}\n     */\n    toHex() {\n        return BufferUtils.toHex(this.serialize());\n    }\n}\n\nClass.register(Serializable);\n","class Hash extends Serializable {\n    /**\n     * @param {Hash} o\n     * @returns {Hash}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const obj = new Uint8Array(o._obj);\n        return new Hash(obj);\n    }\n\n    /**\n     * @param {?Uint8Array} arg\n     * @param {Hash.Algorithm} [algorithm]\n     * @private\n     */\n    constructor(arg, algorithm = Hash.Algorithm.BLAKE2B) {\n        if (arg === null) {\n            arg = new Uint8Array(Hash.getSize(algorithm));\n        } else {\n            if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n            if (arg.length !== Hash.getSize(algorithm)) throw new Error('Primitive: Invalid length');\n        }\n        super();\n        this._obj = arg;\n        /** @type {Hash.Algorithm} */\n        this._algorithm = algorithm;\n    }\n\n    /**\n     * @deprecated\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static light(arr) {\n        return Hash.blake2b(arr);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static blake2b(arr) {\n        return new Hash(Hash.computeBlake2b(arr), Hash.Algorithm.BLAKE2B);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @deprecated\n     * @returns {Promise.<Hash>}\n     */\n    static hard(arr) {\n        return Hash.argon2d(arr);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Promise.<Hash>}\n     */\n    static async argon2d(arr) {\n        return new Hash(await (await CryptoWorker.getInstanceAsync()).computeArgon2d(arr), Hash.Algorithm.ARGON2D);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @returns {Hash}\n     */\n    static sha256(arr) {\n        return new Hash(Hash.computeSha256(arr), Hash.Algorithm.SHA256);\n    }\n\n    /**\n     * @param {Uint8Array} arr\n     * @param {Hash.Algorithm} algorithm\n     * @returns {Hash}\n     */\n    static compute(arr, algorithm) {\n        // !! The algorithms supported by this function are the allowed hash algorithms for HTLCs !!\n        switch (algorithm) {\n            case Hash.Algorithm.BLAKE2B: return Hash.blake2b(arr);\n            case Hash.Algorithm.SHA256: return Hash.sha256(arr);\n            // Hash.Algorithm.ARGON2 intentionally omitted\n            default: throw new Error('Invalid hash algorithm');\n        }\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @param {Hash.Algorithm} [algorithm]\n     * @returns {Hash}\n     */\n    static unserialize(buf, algorithm = Hash.Algorithm.BLAKE2B) {\n        return new Hash(buf.read(Hash.getSize(algorithm)), algorithm);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /**\n     * @param {number} begin\n     * @param {number} end\n     * @returns {Uint8Array}\n     */\n    subarray(begin, end) {\n        return this._obj.subarray(begin, end);\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Hash.SIZE.get(this._algorithm);\n    }\n\n    /** @type {Uint8Array} */\n    get array() {\n        return this._obj;\n    }\n\n    /** @type {Hash.Algorithm} */\n    get algorithm() {\n        return this._algorithm;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof Hash && o._algorithm === this._algorithm && super.equals(o);\n    }\n\n    /**\n     * @param {string} base64\n     * @returns {Hash}\n     */\n    static fromBase64(base64) {\n        return new Hash(BufferUtils.fromBase64(base64));\n    }\n\n    /**\n     * @param {string} hex\n     * @returns {Hash}\n     */\n    static fromHex(hex) {\n        return new Hash(BufferUtils.fromHex(hex));\n    }\n\n    /**\n     * @param {string} str\n     * @returns {Hash}\n     */\n    static fromString(str) {\n        try {\n            return Hash.fromHex(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Hash.fromBase64(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        throw new Error('Invalid hash format');\n    }\n\n    /**\n     * @param {Hash} o\n     * @returns {boolean}\n     */\n    static isHash(o) {\n        return o instanceof Hash;\n    }\n\n    /**\n     * @param {Hash.Algorithm} algorithm\n     * @returns {number}\n     */\n    static getSize(algorithm) {\n        const size = Hash.SIZE.get(algorithm);\n        if (typeof size !== 'number') throw new Error('Invalid hash algorithm');\n        return size;\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    static computeBlake2b(input) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.BLAKE2B));\n            NodeNative.node_blake2(out, new Uint8Array(input));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.BLAKE2B);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmIn = Module.stackAlloc(input.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                const res = Module._nimiq_blake2(wasmOut, wasmIn, input.length);\n                if (res !== 0) {\n                    throw res;\n                }\n                const hash = new Uint8Array(hashSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hash;\n            } catch (e) {\n                Log.w(Hash, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} input\n     * @returns {Uint8Array}\n     */\n    static computeSha256(input) {\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.SHA256));\n            NodeNative.node_sha256(out, new Uint8Array(input));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.SHA256);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmIn = Module.stackAlloc(input.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, input.length).set(input);\n                Module._nimiq_sha256(wasmOut, wasmIn, input.length);\n                const hash = new Uint8Array(hashSize);\n                hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hash;\n            } catch (e) {\n                Log.w(Hash, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\n/**\n * @enum {number}\n */\nHash.Algorithm = {\n    BLAKE2B: 1,\n    ARGON2D: 2,\n    SHA256: 3,\n    SHA512: 4\n};\n/**\n * @type {Map<Hash.Algorithm, number>}\n */\nHash.SIZE = new Map();\nHash.SIZE.set(Hash.Algorithm.BLAKE2B, 32);\nHash.SIZE.set(Hash.Algorithm.ARGON2D, 32);\nHash.SIZE.set(Hash.Algorithm.SHA256, 32);\nHash.SIZE.set(Hash.Algorithm.SHA512, 64);\n\nHash.NULL = new Hash(new Uint8Array(32));\nClass.register(Hash);\n","class PrivateKey extends Serializable {\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== PrivateKey.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @return {PrivateKey}\n     */\n    static generate() {\n        const privateKey = new Uint8Array(PrivateKey.SIZE);\n        CryptoWorker.lib.getRandomValues(privateKey);\n        return new PrivateKey(privateKey);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {PrivateKey}\n     */\n    static unserialize(buf) {\n        return new PrivateKey(buf.read(PrivateKey.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return PrivateKey.SIZE;\n    }\n\n    /**\n     * Overwrite this private key with a replacement in-memory\n     * @param {PrivateKey} privateKey\n     */\n    overwrite(privateKey) {\n        this._obj.set(privateKey._obj);\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PrivateKey && super.equals(o);\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Uint8Array}\n     */\n    static _privateKeyDelinearize(privateKey, publicKey, publicKeysHash) {\n        if (privateKey.byteLength !== PrivateKey.SIZE\n            || publicKey.byteLength !== PublicKey.SIZE\n            || publicKeysHash.byteLength !== Hash.getSize(Hash.Algorithm.SHA512)) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_derive_delinearized_private_key(out, new Uint8Array(publicKeysHash), new Uint8Array(publicKey), new Uint8Array(privateKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const wasmInPrivateKey = Module.stackAlloc(privateKey.length);\n                const wasmInPublicKey = Module.stackAlloc(publicKey.length);\n                const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPrivateKey, privateKey.length).set(privateKey);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);\n                Module._ed25519_derive_delinearized_private_key(wasmOut, wasmInPublicKeysHash, wasmInPublicKey, wasmInPrivateKey);\n                const delinearizedPrivateKey = new Uint8Array(PrivateKey.SIZE);\n                delinearizedPrivateKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PrivateKey.SIZE));\n                return delinearizedPrivateKey;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nPrivateKey.SIZE = 32;\n\nClass.register(PrivateKey);\n","class PublicKey extends Serializable {\n    /**\n     * @param {PublicKey} o\n     * @returns {PublicKey}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new PublicKey(new Uint8Array(o._obj));\n    }\n\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== PublicKey.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @return {PublicKey}\n     */\n    static derive(privateKey) {\n        return new PublicKey(PublicKey._publicKeyDerive(privateKey._obj));\n    }\n\n    /**\n     * @param {Array.<PublicKey>} publicKeys\n     * @return {PublicKey}\n     */\n    static sum(publicKeys) {\n        publicKeys = publicKeys.slice();\n        publicKeys.sort((a, b) => a.compare(b));\n        return PublicKey._delinearizeAndAggregatePublicKeys(publicKeys);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {PublicKey}\n     */\n    static unserialize(buf) {\n        return new PublicKey(buf.read(PublicKey.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return PublicKey.SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PublicKey && super.equals(o);\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        return Hash.light(this.serialize());\n    }\n\n    /**\n     * @param {PublicKey} o\n     * @return {number}\n     */\n    compare(o) {\n        return BufferUtils.compare(this._obj, o._obj);\n    }\n\n    /**\n     * @return {Address}\n     */\n    toAddress() {\n        return Address.fromHash(this.hash());\n    }\n\n    /**\n     * @return {PeerId}\n     */\n    toPeerId() {\n        return new PeerId(this.hash().subarray(0, 16));\n    }\n\n    /**\n     * @param {Array.<PublicKey>} publicKeys\n     * @returns {PublicKey}\n     */\n    static _delinearizeAndAggregatePublicKeys(publicKeys) {\n        const publicKeysObj = publicKeys.map(k => k.serialize());\n        const publicKeysHash = PublicKey._publicKeysHash(publicKeysObj);\n        const raw = PublicKey._publicKeysDelinearizeAndAggregate(publicKeysObj, publicKeysHash);\n        return new PublicKey(raw);\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @returns {Uint8Array}\n     */\n    static _publicKeyDerive(privateKey) {\n        if (privateKey.byteLength !== PrivateKey.SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_public_key_derive(out, new Uint8Array(privateKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const pubKeyBuffer = new Uint8Array(Module.HEAP8.buffer, wasmOut, PrivateKey.SIZE);\n                pubKeyBuffer.set(privateKey);\n                const wasmIn = Module.stackAlloc(privateKey.length);\n                const privKeyBuffer = new Uint8Array(Module.HEAP8.buffer, wasmIn, PrivateKey.SIZE);\n                privKeyBuffer.set(privateKey);\n\n                Module._ed25519_public_key_derive(wasmOut, wasmIn);\n                privKeyBuffer.fill(0);\n                const publicKey = new Uint8Array(PublicKey.SIZE);\n                publicKey.set(pubKeyBuffer);\n                return publicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @returns {Uint8Array}\n     */\n    static _publicKeysHash(publicKeys) {\n        if (publicKeys.some(publicKey => publicKey.byteLength !== PublicKey.SIZE)) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedPublicKeys = new Uint8Array(publicKeys.length * PublicKey.SIZE);\n        for (let i = 0; i < publicKeys.length; ++i) {\n            concatenatedPublicKeys.set(publicKeys[i], i * PublicKey.SIZE);\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Hash.getSize(Hash.Algorithm.SHA512));\n            NodeNative.node_ed25519_hash_public_keys(out, concatenatedPublicKeys, publicKeys.length);\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const hashSize = Hash.getSize(Hash.Algorithm.SHA512);\n                const wasmOut = Module.stackAlloc(hashSize);\n                const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);\n                Module._ed25519_hash_public_keys(wasmOut, wasmInPublicKeys, publicKeys.length);\n                const hashedPublicKey = new Uint8Array(hashSize);\n                hashedPublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hashSize));\n                return hashedPublicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Uint8Array}\n     */\n    static _publicKeyDelinearize(publicKey, publicKeysHash) {\n        if (publicKey.byteLength !== PublicKey.SIZE\n            || publicKeysHash.byteLength !== Hash.getSize(Hash.Algorithm.SHA512)) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_delinearize_public_key(out, new Uint8Array(publicKeysHash), new Uint8Array(publicKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const wasmInPublicKey = Module.stackAlloc(publicKey.length);\n                const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);\n                Module._ed25519_delinearize_public_key(wasmOut, wasmInPublicKeysHash, wasmInPublicKey);\n                const delinearizedPublicKey = new Uint8Array(PublicKey.SIZE);\n                delinearizedPublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PublicKey.SIZE));\n                return delinearizedPublicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} publicKeysHash\n     * @returns {Uint8Array}\n     */\n    static _publicKeysDelinearizeAndAggregate(publicKeys, publicKeysHash) {\n        if (publicKeys.some(publicKey => publicKey.byteLength !== PublicKey.SIZE)\n            || publicKeysHash.byteLength !== Hash.getSize(Hash.Algorithm.SHA512)) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedPublicKeys = new Uint8Array(publicKeys.length * PublicKey.SIZE);\n        for (let i = 0; i < publicKeys.length; ++i) {\n            concatenatedPublicKeys.set(publicKeys[i], i * PublicKey.SIZE);\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_aggregate_delinearized_public_keys(out, new Uint8Array(publicKeysHash), concatenatedPublicKeys, publicKeys.length);\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);\n                const wasmInPublicKeysHash = Module.stackAlloc(publicKeysHash.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeysHash, publicKeysHash.length).set(publicKeysHash);\n                Module._ed25519_aggregate_delinearized_public_keys(wasmOut, wasmInPublicKeysHash, wasmInPublicKeys, publicKeys.length);\n                const aggregatePublicKey = new Uint8Array(PublicKey.SIZE);\n                aggregatePublicKey.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PublicKey.SIZE));\n                return aggregatePublicKey;\n            } catch (e) {\n                Log.w(PublicKey, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nPublicKey.SIZE = 32;\n\nClass.register(PublicKey);\n","class KeyPair extends Serializable {\n    /**\n     * @param {PrivateKey} privateKey\n     * @param {PublicKey} publicKey\n     * @param {boolean} locked\n     * @param {Uint8Array} lockSalt\n     * @private\n     */\n    constructor(privateKey, publicKey, locked = false, lockSalt = null) {\n        if (!(privateKey instanceof Object)) throw new Error('Primitive: Invalid type');\n        if (!(publicKey instanceof Object)) throw new Error('Primitive: Invalid type');\n        super();\n\n        /** @type {boolean} */\n        this._locked = locked;\n        /** @type {boolean} */\n        this._lockedInternally = locked;\n        /** @type {Uint8Array} */\n        this._lockSalt = lockSalt;\n        /** @type {PublicKey} */\n        this._publicKey = publicKey;\n        /** @type {PrivateKey} */\n        this._internalPrivateKey = new PrivateKey(privateKey.serialize());\n    }\n\n    /**\n     * @return {KeyPair}\n     */\n    static generate() {\n        const privateKey = PrivateKey.generate();\n        return new KeyPair(privateKey, PublicKey.derive(privateKey));\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @return {KeyPair}\n     */\n    static derive(privateKey) {\n        return new KeyPair(privateKey, PublicKey.derive(privateKey));\n    }\n\n    /**\n     * @param {string} hexBuf\n     * @return {KeyPair}\n     */\n    static fromHex(hexBuf) {\n        return KeyPair.unserialize(BufferUtils.fromHex(hexBuf));\n    }\n\n    /**\n     *\n     * @param {SerialBuffer} buf\n     * @param {Uint8Array} key\n     * @return {Promise<KeyPair>}\n     */\n    static async fromEncrypted(buf, key) {\n        const type = buf.readUint8();\n        if (type !== 1) throw new Error('Unsupported type');\n        const roundsLog = buf.readUint8();\n        if (roundsLog > 32) throw new Error('Rounds out-of-bounds');\n        const rounds = Math.pow(2, roundsLog);\n        const encryptedKey = PrivateKey.unserialize(buf);\n        const salt = buf.read(KeyPair.EXPORT_SALT_LENGTH);\n        const check = buf.read(KeyPair.EXPORT_CHECKSUM_LENGTH);\n\n        const privateKey = new PrivateKey(await KeyPair._otpKdf(encryptedKey.serialize(), key, salt, rounds));\n        const keyPair = KeyPair.derive(privateKey);\n        const pubHash = keyPair.publicKey.hash();\n        if (!BufferUtils.equals(pubHash.subarray(0, 4), check)) {\n            throw new Error('Invalid key');\n        }\n        return keyPair;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {KeyPair}\n     */\n    static unserialize(buf) {\n        const privateKey = PrivateKey.unserialize(buf);\n        const publicKey = PublicKey.unserialize(buf);\n        let locked = false;\n        let lockSalt = null;\n        if (buf.readPos < buf.byteLength) {\n            const extra = buf.readUint8();\n            if (extra === 1) {\n                locked = true;\n                lockSalt = buf.read(32);\n            }\n        }\n        return new KeyPair(privateKey, publicKey, locked, lockSalt);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._privateKey.serialize(buf);\n        this.publicKey.serialize(buf);\n        if (this._locked) {\n            buf.writeUint8(1);\n            buf.write(this._lockSalt);\n        } else {\n            buf.writeUint8(0);\n        }\n        return buf;\n    }\n\n    /**\n     * The unlocked private key.\n     * @type {PrivateKey}\n     */\n    get privateKey() {\n        if (this.isLocked) throw new Error('Wallet is locked');\n        return this._privateKey;\n    }\n\n    /**\n     * The private key in its current state, i.e., depending on this._locked.\n     * If this._locked, it is the internally locked private key.\n     * If !this._locked, it is either the internally unlocked private key (if !this._lockedInternally)\n     * or this._unlockedPrivateKey.\n     * @type {PrivateKey}\n     */\n    get _privateKey() {\n        return this._unlockedPrivateKey || this._internalPrivateKey;\n    }\n\n    /** @type {PublicKey} */\n    get publicKey() {\n        return this._publicKey || (this._publicKey = new PublicKey(this._obj.publicKey));\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._privateKey.serializedSize + this.publicKey.serializedSize + (this._locked ? this._lockSalt.byteLength + 1 : 1);\n    }\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} [unlockKey]\n     * @return {Promise.<Uint8Array>}\n     */\n    async exportEncrypted(key, unlockKey) {\n        const wasLocked = this._locked;\n        if (this._locked) {\n            try {\n                await this.unlock(unlockKey || key);\n            } catch (e) {\n                throw new Error('KeyPair is locked and lock key mismatches');\n            }\n        }\n\n        const salt = new Uint8Array(KeyPair.EXPORT_SALT_LENGTH);\n        CryptoWorker.lib.getRandomValues(salt);\n\n        const buf = new SerialBuffer(this.encryptedSize);\n        buf.writeUint8(1); // Argon2 KDF\n        buf.writeUint8(Math.log2(KeyPair.EXPORT_KDF_ROUNDS));\n        buf.write(await KeyPair._otpKdf(this.privateKey.serialize(), key, salt, KeyPair.EXPORT_KDF_ROUNDS));\n        buf.write(salt);\n        buf.write(this.publicKey.hash().subarray(0, KeyPair.EXPORT_CHECKSUM_LENGTH));\n\n        if (wasLocked) this.relock();\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get encryptedSize() {\n        return 2 + this.privateKey.serializedSize + KeyPair.EXPORT_SALT_LENGTH + KeyPair.EXPORT_CHECKSUM_LENGTH;\n    }\n\n    /**\n     * @param {Uint8Array} key\n     * @param {Uint8Array} [lockSalt]\n     */\n    async lock(key, lockSalt) {\n        if (this._locked) throw new Error('KeyPair already locked');\n\n        if (lockSalt) this._lockSalt = lockSalt;\n        if (!this._lockSalt || this._lockSalt.length === 0) {\n            this._lockSalt = new Uint8Array(32);\n            CryptoWorker.lib.getRandomValues(this._lockSalt);\n        }\n\n        this._internalPrivateKey.overwrite(await this._otpPrivateKey(key));\n        this._clearUnlockedPrivateKey();\n        this._locked = true;\n        this._lockedInternally = true;\n    }\n\n    /**\n     * @param {Uint8Array} key\n     */\n    async unlock(key) {\n        if (!this._locked) throw new Error('KeyPair not locked');\n\n        const privateKey = await this._otpPrivateKey(key);\n        const verifyPub = PublicKey.derive(privateKey);\n        if (verifyPub.equals(this.publicKey)) {\n            // Only set this._internalPrivateKey, but keep this._obj locked.\n            this._unlockedPrivateKey = privateKey;\n            this._locked = false;\n        } else {\n            throw new Error('Invalid key');\n        }\n    }\n\n    /**\n     * Destroy cached unlocked private key if the internal key is in locked state.\n     */\n    relock() {\n        if (this._locked) throw new Error('KeyPair already locked');\n        if (!this._lockedInternally) throw new Error('KeyPair was never locked');\n        this._clearUnlockedPrivateKey();\n        this._locked = true;\n    }\n\n    _clearUnlockedPrivateKey() {\n        // If this wallet is not locked internally and unlocked, this method does not have any effect.\n        if (!this._lockedInternally || this._locked) return;\n\n        // Overwrite cached key in this._unlockedPrivateKey with 0s.\n        this._unlockedPrivateKey.overwrite(PrivateKey.unserialize(new SerialBuffer(this._unlockedPrivateKey.serializedSize)));\n        // Then, reset it.\n        this._unlockedPrivateKey = null;\n    }\n\n    /**\n     * @param {Uint8Array} key\n     * @return {Promise<PrivateKey>}\n     * @private\n     */\n    async _otpPrivateKey(key) {\n        return new PrivateKey(await KeyPair._otpKdf(this._privateKey.serialize(), key, this._lockSalt, KeyPair.LOCK_KDF_ROUNDS));\n    }\n\n    /**\n     * @param {Uint8Array} message\n     * @param {Uint8Array} key\n     * @param {Uint8Array} salt\n     * @param {number} iterations\n     * @return {Promise<Uint8Array>}\n     * @private\n     */\n    static async _otpKdf(message, key, salt, iterations) {\n        return BufferUtils.xor(message, await (await CryptoWorker.getInstanceAsync()).kdf(key, salt, iterations));\n    }\n\n    get isLocked() {\n        return this._locked;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof KeyPair && super.equals(o);\n    }\n}\nKeyPair.LOCK_KDF_ROUNDS = 256;\nKeyPair.EXPORT_KDF_ROUNDS = 256;\nKeyPair.EXPORT_CHECKSUM_LENGTH = 4;\nKeyPair.EXPORT_SALT_LENGTH = 16;\n\nClass.register(KeyPair);\n","class RandomSecret extends Serializable {\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== RandomSecret.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {RandomSecret}\n     */\n    static unserialize(buf) {\n        return new RandomSecret(buf.read(RandomSecret.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return RandomSecret.SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof RandomSecret && super.equals(o);\n    }\n}\n\nRandomSecret.SIZE = 32;\n\nClass.register(RandomSecret);\n","class Signature extends Serializable {\n    /**\n     * @param {Signature} o\n     * @returns {Signature}\n     */\n    static copy(o) {\n        if (!o) return o;\n        // FIXME Move this to Crypto class.\n        const obj = new Uint8Array(o._obj);\n        return new Signature(obj);\n    }\n\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== Signature.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @param {PublicKey} publicKey\n     * @param {Uint8Array} data\n     * @return {Signature}\n     */\n    static create(privateKey, publicKey, data) {\n        return new Signature(Signature._signatureCreate(privateKey._obj, publicKey._obj, data));\n    }\n\n    /**\n     * @param {Commitment} commitment\n     * @param {Array.<PartialSignature>} signatures\n     * @return {Signature}\n     */\n    static fromPartialSignatures(commitment, signatures) {\n        const raw = Signature._combinePartialSignatures(commitment.serialize(), signatures.map(s => s.serialize()));\n        return new Signature(raw);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Signature}\n     */\n    static unserialize(buf) {\n        return new Signature(buf.read(Signature.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Signature.SIZE;\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Uint8Array} data\n     * @return {boolean}\n     */\n    verify(publicKey, data) {\n        return Signature._signatureVerify(publicKey._obj, data, this._obj);\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Signature && super.equals(o);\n    }\n\n    /**\n     * @param {Uint8Array} combinedCommitment\n     * @param {Array.<Uint8Array>} partialSignatures\n     * @returns {Uint8Array}\n     */\n    static _combinePartialSignatures(combinedCommitment, partialSignatures) {\n        const combinedSignature = Signature._aggregatePartialSignatures(partialSignatures);\n        return BufferUtils.concatTypedArrays(combinedCommitment, combinedSignature);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} partialSignatures\n     * @returns {Uint8Array}\n     */\n    static _aggregatePartialSignatures(partialSignatures) {\n        return partialSignatures.reduce((sigA, sigB) => Signature._scalarsAdd(sigA, sigB));\n    }\n\n    /**\n     * @param {Uint8Array} a\n     * @param {Uint8Array} b\n     * @returns {Uint8Array}\n     */\n    static _scalarsAdd(a, b) {\n        if (a.byteLength !== PartialSignature.SIZE || b.byteLength !== PartialSignature.SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PartialSignature.SIZE);\n            NodeNative.node_ed25519_add_scalars(out, new Uint8Array(a), new Uint8Array(b));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOutSum = Module.stackAlloc(PartialSignature.SIZE);\n                const wasmInA = Module.stackAlloc(a.length);\n                const wasmInB = Module.stackAlloc(b.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInA, a.length).set(a);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInB, b.length).set(b);\n                Module._ed25519_add_scalars(wasmOutSum, wasmInA, wasmInB);\n                const sum = new Uint8Array(PartialSignature.SIZE);\n                sum.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutSum, PartialSignature.SIZE));\n                return sum;\n            } catch (e) {\n                Log.w(Signature, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} message\n     * @returns {Uint8Array}\n     */\n    static _signatureCreate(privateKey, publicKey, message) {\n        if (publicKey.byteLength !== PublicKey.SIZE\n            || privateKey.byteLength !== PrivateKey.SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(Signature.SIZE);\n            NodeNative.node_ed25519_sign(out, new Uint8Array(message), new Uint8Array(publicKey), new Uint8Array(privateKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOutSignature = Module.stackAlloc(Signature.SIZE);\n                const signatureBuffer = new Uint8Array(Module.HEAP8.buffer, wasmOutSignature, Signature.SIZE);\n                const wasmInMessage = Module.stackAlloc(message.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInMessage, message.length).set(message);\n                const wasmInPubKey = Module.stackAlloc(publicKey.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInPubKey, publicKey.length).set(publicKey);\n                const wasmInPrivKey = Module.stackAlloc(privateKey.length);\n                const privKeyBuffer = new Uint8Array(Module.HEAP8.buffer, wasmInPrivKey, privateKey.length);\n                privKeyBuffer.set(privateKey);\n\n                Module._ed25519_sign(wasmOutSignature, wasmInMessage, message.byteLength, wasmInPubKey, wasmInPrivKey);\n                privKeyBuffer.fill(0);\n\n                const signature = new Uint8Array(Signature.SIZE);\n                signature.set(signatureBuffer);\n                return signature;\n            } catch (e) {\n                Log.w(Signature, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n\n    /**\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} message\n     * @param {Uint8Array} signature\n     * @returns {boolean}\n     */\n    static _signatureVerify(publicKey, message, signature) {\n        if (PlatformUtils.isNodeJs()) {\n            return !!NodeNative.node_ed25519_verify(new Uint8Array(signature), new Uint8Array(message), new Uint8Array(publicKey));\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmInPubKey = Module.stackAlloc(publicKey.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInPubKey, publicKey.length).set(publicKey);\n                const wasmInMessage = Module.stackAlloc(message.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInMessage, message.length).set(message);\n                const wasmInSignature = Module.stackAlloc(signature.length);\n                new Uint8Array(Module.HEAP8.buffer, wasmInSignature, signature.length).set(signature);\n\n                return !!Module._ed25519_verify(wasmInSignature, wasmInMessage, message.byteLength, wasmInPubKey);\n            } catch (e) {\n                Log.w(Signature, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nSignature.SIZE = 64;\n\nClass.register(Signature);\n","class Commitment extends Serializable {\n    /**\n     * @param {Commitment} o\n     * @returns {Commitment}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new Commitment(new Uint8Array(o._obj));\n    }\n\n    /**\n     * @param {Array.<Commitment>} commitments\n     * @return {Commitment}\n     */\n    static sum(commitments) {\n        return new Commitment(Commitment._commitmentsAggregate(commitments.map(c => c._obj)));\n    }\n\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== Commitment.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Commitment}\n     */\n    static unserialize(buf) {\n        return new Commitment(buf.read(Commitment.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return Commitment.SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Commitment && super.equals(o);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} commitments\n     * @returns {Uint8Array}\n     */\n    static _commitmentsAggregate(commitments) {\n        if (commitments.some(commitment => commitment.byteLength !== PublicKey.SIZE)) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedCommitments = new Uint8Array(commitments.length * PublicKey.SIZE);\n        for (let i = 0; i < commitments.length; ++i) {\n            concatenatedCommitments.set(commitments[i], i * PublicKey.SIZE);\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PublicKey.SIZE);\n            NodeNative.node_ed25519_aggregate_commitments(out, concatenatedCommitments, commitments.length);\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PublicKey.SIZE);\n                const wasmInCommitments = Module.stackAlloc(concatenatedCommitments.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInCommitments, concatenatedCommitments.length).set(concatenatedCommitments);\n                Module._ed25519_aggregate_commitments(wasmOut, wasmInCommitments, commitments.length);\n                const aggCommitments = new Uint8Array(PublicKey.SIZE);\n                aggCommitments.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PublicKey.SIZE));\n                return aggCommitments;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nCommitment.SIZE = 32;\n\nClass.register(Commitment);\n","class CommitmentPair extends Serializable {\n    /**\n     * @param {RandomSecret} arg\n     * @param {Commitment} arg\n     * @private\n     */\n    constructor(secret, commitment) {\n        super();\n        if (!(secret instanceof RandomSecret)) throw new Error('Primitive: Invalid type');\n        if (!(commitment instanceof Commitment)) throw new Error('Primitive: Invalid type');\n        this._secret = secret;\n        this._commitment = commitment;\n    }\n\n    /**\n     * @return {CommitmentPair}\n     */\n    static generate() {\n        const randomness = new Uint8Array(CommitmentPair.RANDOMNESS_SIZE);\n        CryptoWorker.lib.getRandomValues(randomness);\n        const raw = CommitmentPair._commitmentCreate(randomness);\n        return new CommitmentPair(new RandomSecret(raw.secret), new Commitment(raw.commitment));\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {CommitmentPair}\n     */\n    static unserialize(buf) {\n        const secret = RandomSecret.unserialize(buf);\n        const commitment = Commitment.unserialize(buf);\n        return new CommitmentPair(secret, commitment);\n    }\n\n    /**\n     * @param {string} hexBuf\n     * @return {CommitmentPair}\n     */\n    static fromHex(hexBuf) {\n        return this.unserialize(BufferUtils.fromHex(hexBuf));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this.secret.serialize(buf);\n        this.commitment.serialize(buf);\n        return buf;\n    }\n\n    /** @type {RandomSecret} */\n    get secret() {\n        return this._secret;\n    }\n\n    /** @type {Commitment} */\n    get commitment() {\n        return this._commitment;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this.secret.serializedSize + this.commitment.serializedSize;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof CommitmentPair && super.equals(o);\n    }\n\n    /**\n     * @param {Uint8Array} randomness\n     * @returns {{commitment:Uint8Array, secret:Uint8Array}}\n     */\n    static _commitmentCreate(randomness) {\n        if (PlatformUtils.isNodeJs()) {\n            const commitment = new Uint8Array(PublicKey.SIZE);\n            const secret = new Uint8Array(PrivateKey.SIZE);\n            NodeNative.node_ed25519_create_commitment(secret, commitment, randomness);\n            return {commitment, secret};\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOutCommitment = Module.stackAlloc(PublicKey.SIZE);\n                const wasmOutSecret = Module.stackAlloc(PrivateKey.SIZE);\n                const wasmIn = Module.stackAlloc(randomness.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmIn, randomness.length).set(randomness);\n                const res = Module._ed25519_create_commitment(wasmOutSecret, wasmOutCommitment, wasmIn);\n                if (res !== 1) {\n                    throw new Error(`Secret must not be 0 or 1: ${res}`);\n                }\n                const commitment = new Uint8Array(PublicKey.SIZE);\n                const secret = new Uint8Array(PrivateKey.SIZE);\n                commitment.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutCommitment, PublicKey.SIZE));\n                secret.set(new Uint8Array(Module.HEAPU8.buffer, wasmOutSecret, PrivateKey.SIZE));\n                return {commitment, secret};\n            } catch (e) {\n                Log.w(CommitmentPair, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nCommitmentPair.SERIALIZED_SIZE = RandomSecret.SIZE + Signature.SIZE;\nCommitmentPair.RANDOMNESS_SIZE = 32;\n\nClass.register(CommitmentPair);\n","class PartialSignature extends Serializable {\n    /**\n     * @param {Uint8Array} arg\n     * @private\n     */\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== PartialSignature.SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * @param {PrivateKey} privateKey\n     * @param {PublicKey} publicKey\n     * @param {Array.<PublicKey>} publicKeys\n     * @param {RandomSecret} secret\n     * @param {Commitment} aggregateCommitment\n     * @param {Uint8Array} data\n     * @return {PartialSignature}\n     */\n    static create(privateKey, publicKey, publicKeys, secret, aggregateCommitment, data) {\n        const raw = PartialSignature._delinearizedPartialSignatureCreate(publicKeys.map(o => o._obj), privateKey._obj,\n            publicKey._obj, secret._obj, aggregateCommitment._obj, data);\n        return new PartialSignature(raw);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {PartialSignature}\n     */\n    static unserialize(buf) {\n        return new PartialSignature(buf.read(PartialSignature.SIZE));\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return PartialSignature.SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PartialSignature && super.equals(o);\n    }\n\n    /**\n     * @param {Array.<Uint8Array>} publicKeys\n     * @param {Uint8Array} privateKey\n     * @param {Uint8Array} publicKey\n     * @param {Uint8Array} secret\n     * @param {Uint8Array} aggregateCommitment\n     * @param {Uint8Array} message\n     * @returns {Uint8Array}\n     */\n    static _delinearizedPartialSignatureCreate(publicKeys, privateKey, publicKey, secret, aggregateCommitment, message) {\n        if (publicKeys.some(publicKey => publicKey.byteLength !== PublicKey.SIZE)\n            || privateKey.byteLength !== PrivateKey.SIZE\n            || publicKey.byteLength !== PublicKey.SIZE\n            || secret.byteLength !== RandomSecret.SIZE\n            || aggregateCommitment.byteLength !== Commitment.SIZE) {\n            throw Error('Wrong buffer size.');\n        }\n        const concatenatedPublicKeys = new Uint8Array(publicKeys.length * PublicKey.SIZE);\n        for (let i = 0; i < publicKeys.length; ++i) {\n            concatenatedPublicKeys.set(publicKeys[i], i * PublicKey.SIZE);\n        }\n        if (PlatformUtils.isNodeJs()) {\n            const out = new Uint8Array(PartialSignature.SIZE);\n            NodeNative.node_ed25519_delinearized_partial_sign(out, new Uint8Array(message), new Uint8Array(aggregateCommitment), new Uint8Array(secret), new Uint8Array(concatenatedPublicKeys), publicKeys.length, new Uint8Array(publicKey), new Uint8Array(privateKey));\n            return out;\n        } else {\n            let stackPtr;\n            try {\n                stackPtr = Module.stackSave();\n                const wasmOut = Module.stackAlloc(PartialSignature.SIZE);\n                const wasmInPublicKeys = Module.stackAlloc(concatenatedPublicKeys.length);\n                const wasmInPrivateKey = Module.stackAlloc(privateKey.length);\n                const wasmInPublicKey = Module.stackAlloc(publicKey.length);\n                const wasmInSecret = Module.stackAlloc(secret.length);\n                const wasmInCommitment = Module.stackAlloc(aggregateCommitment.length);\n                const wasmInMessage = Module.stackAlloc(message.length);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKeys, concatenatedPublicKeys.length).set(concatenatedPublicKeys);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPrivateKey, privateKey.length).set(privateKey);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInPublicKey, publicKey.length).set(publicKey);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInSecret, secret.length).set(secret);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInCommitment, aggregateCommitment.length).set(aggregateCommitment);\n                new Uint8Array(Module.HEAPU8.buffer, wasmInMessage, message.length).set(message);\n                Module._ed25519_delinearized_partial_sign(wasmOut, wasmInMessage, message.length, wasmInCommitment, wasmInSecret, wasmInPublicKeys, publicKeys.length, wasmInPublicKey, wasmInPrivateKey);\n                const partialSignature = new Uint8Array(PartialSignature.SIZE);\n                partialSignature.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, PartialSignature.SIZE));\n                return partialSignature;\n            } catch (e) {\n                Log.w(CryptoWorkerImpl, e);\n                throw e;\n            } finally {\n                if (stackPtr !== undefined) Module.stackRestore(stackPtr);\n            }\n        }\n    }\n}\n\nPartialSignature.SIZE = 32;\nClass.register(PartialSignature);\n","class Address extends Serializable {\n    /**\n     * @param {Address} o\n     * @returns {Address}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const obj = new Uint8Array(o._obj);\n        return new Address(obj);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Address}\n     */\n    static fromHash(hash) {\n        return new Address(hash.subarray(0, Address.SERIALIZED_SIZE));\n    }\n\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== Address.SERIALIZED_SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * Create Address object from binary form.\n     * @param {SerialBuffer} buf Buffer to read from.\n     * @return {Address} Newly created Account object.\n     */\n    static unserialize(buf) {\n        return new Address(buf.read(Address.SERIALIZED_SIZE));\n    }\n\n    /**\n     * Serialize this Address object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    subarray(begin, end) {\n        return this._obj.subarray(begin, end);\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        return Address.SERIALIZED_SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Address\n            && super.equals(o);\n    }\n\n    static fromString(str) {\n        try {\n            return Address.fromUserFriendlyAddress(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Address.fromHex(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        try {\n            return Address.fromBase64(str);\n        } catch (e) {\n            // Ignore\n        }\n\n        throw new Error('Invalid address format');\n    }\n\n    /**\n     * @param {string} base64\n     * @return {Address}\n     */\n    static fromBase64(base64) {\n        return new Address(BufferUtils.fromBase64(base64));\n    }\n\n    /**\n     * @param {string} hex\n     * @return {Address}\n     */\n    static fromHex(hex) {\n        return new Address(BufferUtils.fromHex(hex));\n    }\n\n    /**\n     * @param {string} str\n     * @return {Address}\n     */\n    static fromUserFriendlyAddress(str) {\n        str = str.replace(/ /g, '');\n        if (str.substr(0, 2).toUpperCase() !== Address.CCODE) {\n            throw new Error('Invalid Address: Wrong country code');\n        }\n        if (str.length !== 36) {\n            throw new Error('Invalid Address: Should be 36 chars (ignoring spaces)');\n        }\n        if (Address._ibanCheck(str.substr(4) + str.substr(0, 4)) !== 1) {\n            throw new Error('Invalid Address: Checksum invalid');\n        }\n        return new Address(BufferUtils.fromBase32(str.substr(4)));\n    }\n\n    static _ibanCheck(str) {\n        const num = str.split('').map((c) => {\n            const code = c.toUpperCase().charCodeAt(0);\n            return code >= 48 && code <= 57 ? c : (code - 55).toString();\n        }).join('');\n        let tmp = '';\n\n        for (let i = 0; i < Math.ceil(num.length / 6); i++) {\n            tmp = (parseInt(tmp + num.substr(i * 6, 6)) % 97).toString();\n        }\n\n        return parseInt(tmp);\n    }\n\n    /**\n     * @param {boolean} [withSpaces]\n     * @return {string}\n     */\n    toUserFriendlyAddress(withSpaces = true) {\n        const base32 = BufferUtils.toBase32(this.serialize());\n        // eslint-disable-next-line prefer-template\n        const check = ('00' + (98 - Address._ibanCheck(base32 + Address.CCODE + '00'))).slice(-2);\n        let res = Address.CCODE + check + base32;\n        if (withSpaces) res = res.replace(/.{4}/g, '$& ').trim();\n        return res;\n    }\n}\nAddress.CCODE = 'NQ';\nAddress.SERIALIZED_SIZE = 20;\nAddress.HEX_SIZE = 40;\nAddress.NULL = new Address(new Uint8Array(Address.SERIALIZED_SIZE));\nAddress.CONTRACT_CREATION = new Address(new Uint8Array(Address.SERIALIZED_SIZE));\nClass.register(Address);\n","/**\n * @abstract\n */\nclass Account {\n    /**\n     * @param {Account.Type} type\n     * @param {number} balance\n     */\n    constructor(type, balance) {\n        if (!NumberUtils.isUint8(type)) throw new Error('Malformed type');\n        if (!NumberUtils.isUint64(balance)) throw new Error('Malformed balance');\n\n        /** @type {Account.Type} */\n        this._type = type;\n        /** @type {number} */\n        this._balance = balance;\n    }\n\n    /**\n     * Create Account object from binary form.\n     * @param {SerialBuffer} buf Buffer to read from.\n     * @return {Account} Newly created Account object.\n     */\n    static unserialize(buf) {\n        const type = /** @type {Account.Type} */ buf.readUint8();\n        buf.readPos--;\n\n        if (!Account.TYPE_MAP.has(type)) {\n            throw new Error('Unknown account type');\n        }\n\n        return Account.TYPE_MAP.get(type).unserialize(buf);\n    }\n\n    /**\n     * Serialize this Account object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._type);\n        buf.writeUint64(this._balance);\n        return buf;\n    }\n\n    /**\n     * @return {number}\n     */\n    get serializedSize() {\n        return /*type*/ 1\n            + /*balance*/ 8;\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return BufferUtils.equals(this.serialize(), o.serialize());\n    }\n\n    toString() {\n        return `Account{type=${this._type}, balance=${this._balance.toString()}`;\n    }\n\n    /**\n     * @type {number} Account balance\n     */\n    get balance() {\n        return this._balance;\n    }\n\n    /** @type {Account.Type} */\n    get type() {\n        return this._type;\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) { throw new Error('Not yet implemented.'); }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionsCache\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert = false) {\n        if (!revert) {\n            const newBalance = this._balance - transaction.value - transaction.fee;\n            if (newBalance < 0) {\n                throw new Error('Balance Error!');\n            }\n            if (blockHeight < transaction.validityStartHeight\n                || blockHeight >= transaction.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n                throw new Error('Validity Error!');\n            }\n            if (transactionsCache.containsTransaction(transaction)) {\n                throw new Error('Double Transaction Error!');\n            }\n            return this.withBalance(newBalance);\n        } else {\n            if (blockHeight < transaction.validityStartHeight\n                || blockHeight >= transaction.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n                throw new Error('Validity Error!');\n            }\n            return this.withBalance(this._balance + transaction.value + transaction.fee);\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        if (!revert) {\n            return this.withBalance(this._balance + transaction.value);\n        } else {\n            const newBalance = this._balance - transaction.value;\n            if (newBalance < 0) {\n                throw new Error('Balance Error!');\n            }\n            return this.withBalance(newBalance);\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withContractCommand(transaction, blockHeight, revert = false) {\n        throw new Error('Not yet implemented');\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isInitial() {\n        return this === Account.INITIAL;\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isToBePruned() {\n        return this._balance === 0 && !this.isInitial();\n    }\n}\n\n/**\n * Enum for Account types.\n * Non-zero values are contracts.\n * @enum\n */\nAccount.Type = {\n    /**\n     * Basic account type.\n     * @see {BasicAccount}\n     */\n    BASIC: 0,\n    /**\n     * Account with vesting functionality.\n     * @see {VestingContract}\n     */\n    VESTING: 1,\n    /**\n     * Hashed Time-Locked Contract\n     * @see {HashedTimeLockedContract}\n     */\n    HTLC: 2\n};\n/**\n * @type {Map.<Account.Type, {copy: function(o: *):Account, unserialize: function(buf: SerialBuffer):Account, create: function(balance: number, blockHeight: number, transaction: Transaction):Account, verifyOutgoingTransaction: function(transaction: Transaction):Promise.<boolean>, verifyIncomingTransaction: function(transaction: Transaction):Promise.<boolean>}>}\n */\nAccount.TYPE_MAP = new Map();\n\nClass.register(Account);\n","class PrunedAccount {\n    /**\n     * @param {Address} address\n     * @param {Account} account\n     */\n    constructor(address, account) {\n        if (!(address instanceof Address)) throw new Error('Malformed address');\n\n        /** @type {Address} */\n        this._address = address;\n        /** @type {Account} */\n        this._account = account;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {PrunedAccount}\n     */\n    static unserialize(buf) {\n        return new PrunedAccount(Address.unserialize(buf), Account.unserialize(buf));\n    }\n\n    /**\n     * @param {PrunedAccount} o\n     * @return {number} negative if this is smaller than o, positive if this is larger than o, zero if equal.\n     */\n    compare(o) {\n        return this._address.compare(o._address);\n    }\n\n    /**\n     * @returns {Address}\n     */\n    get address() {\n        return this._address;\n    }\n\n    /**\n     * @returns {Account}\n     */\n    get account() {\n        return this._account;\n    }\n\n    /**\n     * @param buf\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._address.serialize(buf);\n        this._account.serialize(buf);\n        return this;\n    }\n\n    get serializedSize() {\n        return this._address.serializedSize + this._account.serializedSize;\n    }\n}\n\nClass.register(PrunedAccount);\n","/**\n * This is a classic account that can send all his funds and receive any transaction.\n * All outgoing transactions are signed using the key corresponding to this address.\n */\nclass BasicAccount extends Account {\n    /**\n     * @param {BasicAccount} o\n     * @returns {BasicAccount}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new BasicAccount(o._balance);\n    }\n\n    /**\n     * @param {number} [balance]\n     */\n    constructor(balance = 0) {\n        super(Account.Type.BASIC, balance);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {BasicAccount}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        if (type !== Account.Type.BASIC) throw new Error('Invalid account type');\n\n        const balance = buf.readUint64();\n        return new BasicAccount(balance);\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return o instanceof BasicAccount\n            && this._type === o._type\n            && this._balance === o._balance;\n    }\n\n    toString() {\n        return `BasicAccount{balance=${this._balance}}`;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyOutgoingTransaction(transaction) {\n        return SignatureProof.verifyTransaction(transaction);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        if (transaction.data.byteLength > 64) return false;\n        return true;\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) {\n        return new BasicAccount(balance);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        if (!revert) {\n            const isContractCreation = transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION);\n            const isTypeChange = transaction.recipientType !== this._type;\n            if (isContractCreation !== isTypeChange) {\n                throw new Error('Data Error!');\n            }\n        }\n        return super.withIncomingTransaction(transaction, blockHeight, revert);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withContractCommand(transaction, blockHeight, revert = false) {\n        if (!revert && transaction.recipientType !== this._type && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {\n            // Contract creation\n            return Account.TYPE_MAP.get(transaction.recipientType).create(this._balance, blockHeight, transaction);\n        }\n        return this;\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isInitial() {\n        return this._balance === 0;\n    }\n}\n\nAccount.INITIAL = new BasicAccount(0);\nAccount.TYPE_MAP.set(Account.Type.BASIC, BasicAccount);\nClass.register(BasicAccount);\n","class Contract extends Account {\n    /**\n     * @param {Account.Type} type\n     * @param {number} balance\n     */\n    constructor(type, balance) {\n        super(type, balance);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        if (!transaction.recipient.equals(transaction.getContractCreationAddress())) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        if (!revert && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {\n            // Contract already created\n            throw new Error('Data error');\n        }\n        return super.withIncomingTransaction(transaction, blockHeight, revert);\n    }\n\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withContractCommand(transaction, blockHeight, revert = false) {\n        if (revert && transaction.hasFlag(Transaction.Flag.CONTRACT_CREATION)) {\n            // Revert contract creation\n            return new BasicAccount(this.balance);\n        }\n        return this;\n    }\n}\n\nClass.register(Contract);\n","class HashedTimeLockedContract extends Contract {\n    /**\n     * @param {number} balance\n     * @param {Address} sender\n     * @param {Address} recipient\n     * @param {Hash} hashRoot\n     * @param {number} hashCount\n     * @param {number} timeout\n     * @param {number} totalAmount\n     */\n    constructor(balance = 0, sender = Address.NULL, recipient = Address.NULL, hashRoot = Hash.NULL, hashCount = 1, timeout = 0, totalAmount = balance) {\n        super(Account.Type.HTLC, balance);\n        if (!(sender instanceof Address)) throw new Error('Malformed address');\n        if (!(recipient instanceof Address)) throw new Error('Malformed address');\n        if (!(hashRoot instanceof Hash)) throw new Error('Malformed address');\n        if (!NumberUtils.isUint8(hashCount) || hashCount === 0) throw new Error('Malformed hashCount');\n        if (!NumberUtils.isUint32(timeout)) throw new Error('Malformed timeout');\n        if (!NumberUtils.isUint64(totalAmount)) throw new Error('Malformed totalAmount');\n\n        /** @type {Address} */\n        this._sender = sender;\n        /** @type {Address} */\n        this._recipient = recipient;\n        /** @type {Hash} */\n        this._hashRoot = hashRoot;\n        /** @type {number} */\n        this._hashCount = hashCount;\n        /** @type {number} */\n        this._timeout = timeout;\n        /** @type {number} */\n        this._totalAmount = totalAmount;\n    }\n\n    /**\n     * @param {number} balance\n     * @param {number} blockHeight\n     * @param {Transaction} transaction\n     */\n    static create(balance, blockHeight, transaction) {\n        const buf = new SerialBuffer(transaction.data);\n\n        const sender = Address.unserialize(buf);\n        const recipient = Address.unserialize(buf);\n        const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n        const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n        const hashCount = buf.readUint8();\n        const timeout = buf.readUint32();\n\n        return new HashedTimeLockedContract(balance, sender, recipient, hashRoot, hashCount, timeout);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {HashedTimeLockedContract}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        if (type !== Account.Type.HTLC) throw new Error('Invalid account type');\n\n        const balance = buf.readUint64();\n        const sender = Address.unserialize(buf);\n        const recipient = Address.unserialize(buf);\n        const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n        const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n        const hashCount = buf.readUint8();\n        const timeout = buf.readUint32();\n        const totalAmount = buf.readUint64();\n        return new HashedTimeLockedContract(balance, sender, recipient, hashRoot, hashCount, timeout, totalAmount);\n    }\n\n\n    /**\n     * Serialize this HTLC object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._sender.serialize(buf);\n        this._recipient.serialize(buf);\n        buf.writeUint8(this._hashRoot.algorithm);\n        this._hashRoot.serialize(buf);\n        buf.writeUint8(this._hashCount);\n        buf.writeUint32(this._timeout);\n        buf.writeUint64(this._totalAmount);\n        return buf;\n    }\n\n    /**\n     * @return {number}\n     */\n    get serializedSize() {\n        return super.serializedSize\n            + this._sender.serializedSize\n            + this._recipient.serializedSize\n            + /*hashAlgorithm*/ 1\n            + this._hashRoot.serializedSize\n            + /*hashCount*/ 1\n            + /*timeout*/ 4\n            + /*totalAmount*/ 8;\n    }\n\n    /** @type {Address} */\n    get sender() {\n        return this._sender;\n    }\n\n    /** @type {Address} */\n    get recipient() {\n        return this._recipient;\n    }\n\n    /** @type {Hash} */\n    get hashRoot() {\n        return this._hashRoot;\n    }\n\n    /** @type {number} */\n    get hashCount() {\n        return this._hashCount;\n    }\n\n    /** @type {number} */\n    get timeout() {\n        return this._timeout;\n    }\n\n    /** @type {number} */\n    get totalAmount() {\n        return this._totalAmount;\n    }\n\n    toString() {\n        return `HashedTimeLockedContract{balance=${this._balance}, sender=${this._sender.toUserFriendlyAddress(false)}, recipient=${this._sender.toUserFriendlyAddress(false)}, amount=${this._totalAmount}/${this._hashCount}, timeout=${this._timeout}}`;\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return o instanceof HashedTimeLockedContract\n            && this._type === o._type\n            && this._balance === o._balance\n            && this._sender.equals(o._sender)\n            && this._recipient.equals(o._recipient)\n            && this._hashRoot.equals(o._hashRoot)\n            && this._hashCount === o._hashCount\n            && this._timeout === o._timeout\n            && this._totalAmount === o._totalAmount;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyOutgoingTransaction(transaction) {\n        try {\n            const buf = new SerialBuffer(transaction.proof);\n            const type = buf.readUint8();\n            switch (type) {\n                case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER: {\n                    const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n                    const hashDepth = buf.readUint8();\n                    const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n                    let preImage = Hash.unserialize(buf, hashAlgorithm);\n\n                    // Verify that the preImage hashed hashDepth times matches the _provided_ hashRoot.\n                    for (let i = 0; i < hashDepth; ++i) {\n                        preImage = Hash.compute(preImage.array, hashAlgorithm);\n                    }\n                    if (!hashRoot.equals(preImage)) {\n                        return false;\n                    }\n\n                    // Signature proof of the HTLC recipient\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n                    break;\n                }\n                case HashedTimeLockedContract.ProofType.EARLY_RESOLVE: {\n                    // Signature proof of the HTLC recipient\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n\n                    // Signature proof of the HTLC creator\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n                    break;\n                }\n                case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE:\n                    // Signature proof of the HTLC creator\n                    if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n                        return false;\n                    }\n                    break;\n                default:\n                    return false;\n            }\n\n            // Reject overlong proof.\n            if (buf.readPos !== buf.byteLength) {\n                return false;\n            }\n\n            return true; // Accept\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        try {\n            const buf = new SerialBuffer(transaction.data);\n\n            Address.unserialize(buf); // sender address\n            Address.unserialize(buf); // recipient address\n            const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n            Hash.unserialize(buf, hashAlgorithm);\n            buf.readUint8(); // hash count\n            buf.readUint32(); // timeout\n\n            // Blacklist Argon2 hash function.\n            if (hashAlgorithm === Hash.Algorithm.ARGON2D) {\n                return false;\n            }\n\n            if (buf.readPos !== buf.byteLength) {\n                return false;\n            }\n\n            return Contract.verifyIncomingTransaction(transaction);\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) {\n        return new HashedTimeLockedContract(balance, this._sender, this._recipient, this._hashRoot, this._hashCount, this._timeout, this._totalAmount);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionsCache\n     * @param {boolean} [revert]\n     * @return {Account|*}\n     */\n    withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert = false) {\n        const buf = new SerialBuffer(transaction.proof);\n        const type = buf.readUint8();\n        let minCap = 0;\n        switch (type) {\n            case HashedTimeLockedContract.ProofType.REGULAR_TRANSFER: {\n                // Check that the contract has not expired yet.\n                if (this._timeout < blockHeight) {\n                    throw new Error('Proof Error!');\n                }\n\n                // Check that the provided hashRoot is correct.\n                const hashAlgorithm = /** @type {Hash.Algorithm} */ buf.readUint8();\n                const hashDepth = buf.readUint8();\n                const hashRoot = Hash.unserialize(buf, hashAlgorithm);\n                if (!hashRoot.equals(this._hashRoot)) {\n                    throw new Error('Proof Error!');\n                }\n\n                // Ignore the preImage.\n                Hash.unserialize(buf, hashAlgorithm);\n\n                // Verify that the transaction is signed by the authorized recipient.\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._recipient)) {\n                    throw new Error('Proof Error!');\n                }\n\n                minCap = Math.max(0, Math.floor((1 - (hashDepth / this._hashCount)) * this._totalAmount));\n\n                break;\n            }\n            case HashedTimeLockedContract.ProofType.EARLY_RESOLVE: {\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._recipient)) {\n                    throw new Error('Proof Error!');\n                }\n\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._sender)) {\n                    throw new Error('Proof Error!');\n                }\n\n                break;\n            }\n            case HashedTimeLockedContract.ProofType.TIMEOUT_RESOLVE: {\n                if (this._timeout >= blockHeight) {\n                    throw new Error('Proof Error!');\n                }\n\n                if (!SignatureProof.unserialize(buf).isSignedBy(this._sender)) {\n                    throw new Error('Proof Error!');\n                }\n\n                break;\n            }\n            default:\n                throw new Error('Proof Error!');\n        }\n\n        if (!revert) {\n            const newBalance = this._balance - transaction.value - transaction.fee;\n            if (newBalance < minCap) {\n                throw new Error('Balance Error!');\n            }\n        }\n\n        return super.withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert);\n    }\n\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        throw new Error('Illegal incoming transaction');\n    }\n}\n\nHashedTimeLockedContract.ProofType = {\n    REGULAR_TRANSFER: 1,\n    EARLY_RESOLVE: 2,\n    TIMEOUT_RESOLVE: 3\n};\n\nAccount.TYPE_MAP.set(Account.Type.HTLC, HashedTimeLockedContract);\nClass.register(HashedTimeLockedContract);\n","class VestingContract extends Contract {\n    /**\n     * @param {number} [balance]\n     * @param {Address} [owner]\n     * @param {number} [vestingStart]\n     * @param {number} [vestingStepBlocks]\n     * @param {number} [vestingStepAmount]\n     * @param {number} [vestingTotalAmount]\n     */\n    constructor(balance = 0, owner = Address.NULL, vestingStart = 0, vestingStepBlocks = 0, vestingStepAmount = balance, vestingTotalAmount = balance) {\n        super(Account.Type.VESTING, balance);\n        if (!(owner instanceof Address)) throw new Error('Malformed address');\n        if (!NumberUtils.isUint32(vestingStart)) throw new Error('Malformed vestingStart');\n        if (!NumberUtils.isUint32(vestingStepBlocks)) throw new Error('Malformed vestingStepBlocks');\n        if (!NumberUtils.isUint64(vestingStepAmount)) throw new Error('Malformed vestingStepAmount');\n        if (!NumberUtils.isUint64(vestingTotalAmount)) throw new Error('Malformed lowerCap');\n\n        /** @type {Address} */\n        this._owner = owner;\n        /** @type {number} */\n        this._vestingStart = vestingStart;\n        /** @type {number} */\n        this._vestingStepBlocks = vestingStepBlocks;\n        /** @type {number} */\n        this._vestingStepAmount = vestingStepAmount;\n        /** @type {number} */\n        this._vestingTotalAmount = vestingTotalAmount;\n    }\n\n    /**\n     * @param {number} balance\n     * @param {number} blockHeight\n     * @param {Transaction} transaction\n     */\n    static create(balance, blockHeight, transaction) {\n        /** @type {number} */\n        let vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount;\n        const buf = new SerialBuffer(transaction.data);\n        const owner = Address.unserialize(buf);\n        vestingTotalAmount = transaction.value;\n        switch (transaction.data.length) {\n            case Address.SERIALIZED_SIZE + 4:\n                // Only block number: vest full amount at that block\n                vestingStart = 0;\n                vestingStepBlocks = buf.readUint32();\n                vestingStepAmount = vestingTotalAmount;\n                break;\n            case Address.SERIALIZED_SIZE + 16:\n                vestingStart = buf.readUint32();\n                vestingStepBlocks = buf.readUint32();\n                vestingStepAmount = buf.readUint64();\n                break;\n            case Address.SERIALIZED_SIZE + 24:\n                // Create a vesting account with some instantly vested funds or additional funds considered.\n                vestingStart = buf.readUint32();\n                vestingStepBlocks = buf.readUint32();\n                vestingStepAmount = buf.readUint64();\n                vestingTotalAmount = buf.readUint64();\n                break;\n            default:\n                throw new Error('Invalid transaction data');\n        }\n        return new VestingContract(balance, owner, vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {VestingContract}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        if (type !== Account.Type.VESTING) throw new Error('Invalid account type');\n\n        const balance = buf.readUint64();\n        const owner = Address.unserialize(buf);\n        const vestingStart = buf.readUint32();\n        const vestingStepBlocks = buf.readUint32();\n        const vestingStepAmount = buf.readUint64();\n        const vestingTotalAmount = buf.readUint64();\n        return new VestingContract(balance, owner, vestingStart, vestingStepBlocks, vestingStepAmount, vestingTotalAmount);\n    }\n\n    /**\n     * Serialize this VestingContract object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._owner.serialize(buf);\n        buf.writeUint32(this._vestingStart);\n        buf.writeUint32(this._vestingStepBlocks);\n        buf.writeUint64(this._vestingStepAmount);\n        buf.writeUint64(this._vestingTotalAmount);\n        return buf;\n    }\n\n    /**\n     * @return {number}\n     */\n    get serializedSize() {\n        return super.serializedSize\n            + this._owner.serializedSize\n            + /*vestingStart*/ 4\n            + /*vestingStepBlocks*/ 4\n            + /*vestingStepAmount*/ 8\n            + /*vestingTotalAmount*/ 8;\n    }\n\n    /** @type {Address} */\n    get owner() {\n        return this._owner;\n    }\n\n    /** @type {number} */\n    get vestingStart() {\n        return this._vestingStart;\n    }\n\n    /** @type {number} */\n    get vestingStepBlocks() {\n        return this._vestingStepBlocks;\n    }\n\n    /** @type {number} */\n    get vestingStepAmount() {\n        return this._vestingStepAmount;\n    }\n\n    /** @type {number} */\n    get vestingTotalAmount() {\n        return this._vestingTotalAmount;\n    }\n\n    toString() {\n        return `VestingAccount{balance=${this._balance}, owner=${this._owner.toUserFriendlyAddress()}`;\n    }\n\n    /**\n     * Check if two Accounts are the same.\n     * @param {Account} o Object to compare with.\n     * @return {boolean} Set if both objects describe the same data.\n     */\n    equals(o) {\n        return o instanceof VestingContract\n            && this._type === o._type\n            && this._balance === o._balance\n            && this._owner.equals(o._owner)\n            && this._vestingStart === o._vestingStart\n            && this._vestingStepBlocks === o._vestingStepBlocks\n            && this._vestingStepAmount === o._vestingStepAmount\n            && this._vestingTotalAmount === o._vestingTotalAmount;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyOutgoingTransaction(transaction) {\n        const buf = new SerialBuffer(transaction.proof);\n\n        if (!SignatureProof.unserialize(buf).verify(null, transaction.serializeContent())) {\n            return false;\n        }\n\n        if (buf.readPos !== buf.byteLength) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    static verifyIncomingTransaction(transaction) {\n        switch (transaction.data.length) {\n            case Address.SERIALIZED_SIZE + 4:\n            case Address.SERIALIZED_SIZE + 16:\n            case Address.SERIALIZED_SIZE + 24:\n                return Contract.verifyIncomingTransaction(transaction);\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * @param {number} balance\n     * @return {Account|*}\n     */\n    withBalance(balance) {\n        return new VestingContract(balance, this._owner, this._vestingStart, this._vestingStepBlocks, this._vestingStepAmount, this._vestingTotalAmount);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionsCache\n     * @param {boolean} [revert]\n     * @return {Account|*}\n     */\n    withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert = false) {\n        if (!revert) {\n            const minCap = this.getMinCap(blockHeight);\n            const newBalance = this._balance - transaction.value - transaction.fee;\n            if (newBalance < minCap) {\n                throw new Error('Balance Error!');\n            }\n\n            const buf = new SerialBuffer(transaction.proof);\n            if (!SignatureProof.unserialize(buf).isSignedBy(this._owner)) {\n                throw new Error('Proof Error!');\n            }\n        }\n        return super.withOutgoingTransaction(transaction, blockHeight, transactionsCache, revert);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @return {Account}\n     */\n    withIncomingTransaction(transaction, blockHeight, revert = false) {\n        throw new Error('Illegal incoming transaction');\n    }\n\n    /**\n     * @param {number} blockHeight\n     * @returns {number}\n     */\n    getMinCap(blockHeight) {\n        return this._vestingStepBlocks && this._vestingStepAmount > 0\n            ? Math.max(0, this._vestingTotalAmount - Math.floor((blockHeight - this._vestingStart) / this._vestingStepBlocks) * this._vestingStepAmount)\n            : 0;\n    }\n}\n\nAccount.TYPE_MAP.set(Account.Type.VESTING, VestingContract);\nClass.register(VestingContract);\n","class AccountsTreeNode {\n    /**\n     * @param {string} prefix\n     * @param {Account} account\n     * @returns {AccountsTreeNode}\n     */\n    static terminalNode(prefix, account) {\n        return new AccountsTreeNode(AccountsTreeNode.TERMINAL, prefix, account);\n    }\n\n    /**\n     * @param {string} prefix\n     * @param {Array.<string>} childrenSuffixes\n     * @param {Array.<Hash>} childrenHashes\n     * @returns {AccountsTreeNode}\n     */\n    static branchNode(prefix, childrenSuffixes = [], childrenHashes = []) {\n        if (childrenSuffixes.length !== childrenHashes.length) {\n            throw new Error('Invalid list of children for branch node');\n        }\n        return new AccountsTreeNode(AccountsTreeNode.BRANCH, prefix, childrenSuffixes, childrenHashes);\n    }\n\n    /**\n     * @param type\n     * @param {string} prefix\n     * @param {Account|Array.<string>} arg\n     * @param {Array.<Hash>} [arg2]\n     */\n    constructor(type, prefix = '', arg, arg2 = []) {\n        this._type = type;\n        /** @type {string} */\n        this._prefix = prefix;\n        if (this.isBranch()) {\n            /** @type {Array.<string>} */\n            this._childrenSuffixes = arg;\n            /** @type {Array.<Hash>} */\n            this._childrenHashes = arg2;\n        } else if (this.isTerminal()) {\n            /** @type {Account} */\n            this._account = arg;\n        } else {\n            throw `Invalid AccountsTreeNode type: ${type}`;\n        }\n    }\n\n    /**\n     * @param type\n     * @returns {boolean}\n     */\n    static isTerminalType(type) {\n        return type === AccountsTreeNode.TERMINAL;\n    }\n\n    /**\n     * @param type\n     * @returns {boolean}\n     */\n    static isBranchType(type) {\n        return type === AccountsTreeNode.BRANCH;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {AccountsTreeNode}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        const prefix = buf.readVarLengthString();\n\n        if (AccountsTreeNode.isTerminalType(type)) {\n            // Terminal node\n            const account = Account.unserialize(buf);\n            return AccountsTreeNode.terminalNode(prefix, account);\n        } else if (AccountsTreeNode.isBranchType(type)) {\n            // Branch node\n            const childrenSuffixes = [], childrenHashes = [];\n            const childCount = buf.readUint8();\n            for (let i = 0; i < childCount; ++i) {\n                const childSuffix = buf.readVarLengthString();\n                const childHash = Hash.unserialize(buf);\n                const childIndex = parseInt(childSuffix[0], 16);\n                childrenSuffixes[childIndex] = childSuffix;\n                childrenHashes[childIndex] = childHash;\n            }\n            return AccountsTreeNode.branchNode(prefix, childrenSuffixes, childrenHashes);\n        } else {\n            throw `Invalid AccountsTreeNode type: ${type}`;\n        }\n    }\n\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._type);\n        buf.writeVarLengthString(this._prefix);\n        if (this.isTerminal()) {\n            // Terminal node\n            this._account.serialize(buf);\n        } else {\n            // Branch node\n            const childCount = this._childrenSuffixes.reduce((count, child) => count + !!child, 0);\n            buf.writeUint8(childCount);\n            for (let i = 0; i < this._childrenSuffixes.length; ++i) {\n                if (this._childrenHashes[i]) {\n                    buf.writeVarLengthString(this._childrenSuffixes[i]);\n                    this._childrenHashes[i].serialize(buf);\n                }\n            }\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let payloadSize;\n        if (this.isTerminal()) {\n            payloadSize = this._account.serializedSize;\n        } else {\n            // The children array contains undefined values for non existing children.\n            // Only count existing ones.\n            const childrenSize = this._childrenHashes.reduce((sum, child, i) => {\n                return sum + (child ? child.serializedSize + SerialBuffer.varLengthStringSize(this._childrenSuffixes[i]) : 0);\n            }, 0);\n            payloadSize = /*childCount*/ 1 + childrenSize;\n        }\n\n        return /*type*/ 1\n            + SerialBuffer.varLengthStringSize(this._prefix)\n            + payloadSize;\n    }\n\n    /**\n     * @param {string} prefix\n     * @returns {?Hash}\n     */\n    getChildHash(prefix) {\n        return this._childrenHashes && this._childrenHashes[this._getChildIndex(prefix)];\n    }\n\n    /**\n     * @param {string} prefix\n     * @returns {?string}\n     */\n    getChild(prefix) {\n        const suffix = this._childrenSuffixes && this._childrenSuffixes[this._getChildIndex(prefix)];\n        if (suffix) {\n            return this.prefix + suffix;\n        }\n        return suffix;\n    }\n\n    /**\n     * @param {string} prefix\n     * @param {Hash} childHash\n     * @returns {AccountsTreeNode}\n     */\n    withChild(prefix, childHash) {\n        const childrenSuffixes = this._childrenSuffixes.slice() || [];\n        const childrenHashes = this._childrenHashes.slice() || [];\n        childrenSuffixes[this._getChildIndex(prefix)] = prefix.substr(this.prefix.length);\n        childrenHashes[this._getChildIndex(prefix)] = childHash;\n        return AccountsTreeNode.branchNode(this._prefix, childrenSuffixes, childrenHashes);\n    }\n\n    /**\n     * @param {string} prefix\n     * @returns {AccountsTreeNode}\n     */\n    withoutChild(prefix) {\n        const childrenSuffixes = this._childrenSuffixes.slice() || [];\n        const childrenHashes = this._childrenHashes.slice() || [];\n        delete childrenSuffixes[this._getChildIndex(prefix)];\n        delete childrenHashes[this._getChildIndex(prefix)];\n        return AccountsTreeNode.branchNode(this._prefix, childrenSuffixes, childrenHashes);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    hasChildren() {\n        return this._childrenSuffixes && this._childrenSuffixes.some(child => !!child);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    hasSingleChild() {\n        return this._childrenSuffixes && this._childrenSuffixes.reduce((count, child) => count + !!child, 0) === 1;\n    }\n\n    /**\n     * @returns {?string}\n     */\n    getFirstChild() {\n        if (!this._childrenSuffixes) {\n            return undefined;\n        }\n        const suffix = this._childrenSuffixes.find(child => !!child);\n        return suffix ? this.prefix + suffix : undefined;\n    }\n\n    /**\n     * @returns {?string}\n     */\n    getLastChild() {\n        if (!this._childrenSuffixes) {\n            return undefined;\n        }\n        for (let i = this._childrenSuffixes.length - 1; i >= 0; --i) {\n            if (this._childrenSuffixes[i]) {\n                return this.prefix + this._childrenSuffixes[i];\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * @returns {?Array.<string>}\n     */\n    getChildren() {\n        if (!this._childrenSuffixes) {\n            return undefined;\n        }\n        return this._childrenSuffixes.filter(child => !!child).map(child => this.prefix + child);\n    }\n\n    /** @type {Account} */\n    get account() {\n        return this._account;\n    }\n\n    /** @type {string} */\n    get prefix() {\n        return this._prefix;\n    }\n\n    /** @type {string} */\n    set prefix(value) {\n        this._prefix = value;\n        this._hash = undefined;\n    }\n\n    /**\n     * @param {Account} account\n     * @returns {AccountsTreeNode}\n     */\n    withAccount(account) {\n        return AccountsTreeNode.terminalNode(this._prefix, account);\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    hash() {\n        if (!this._hash) {\n            this._hash = Hash.light(this.serialize());\n        }\n        return this._hash;\n    }\n\n    /**\n     * Tests if this node is a child of some other node.\n     * @param {AccountsTreeNode} parent\n     * @returns {boolean}\n     */\n    isChildOf(parent) {\n        return parent.getChildren() && parent.getChildren().includes(this._prefix);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isTerminal() {\n        return AccountsTreeNode.isTerminalType(this._type);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isBranch() {\n        return AccountsTreeNode.isBranchType(this._type);\n    }\n\n    /**\n     * @param {string} prefix\n     * @returns {number}\n     * @private\n     */\n    _getChildIndex(prefix) {\n        Assert.that(prefix.substr(0, this.prefix.length) === this.prefix, `Prefix ${prefix} is not a child of the current node ${this.prefix}`);\n        return parseInt(prefix[this.prefix.length], 16);\n    }\n\n    /**\n     * @param {AccountsTreeNode} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        if (!(o instanceof AccountsTreeNode)) return false;\n        if (!Object.is(this.prefix, o.prefix)) return false;\n        if (this.isTerminal()) {\n            return o.isTerminal() && o._account.equals(this._account);\n        } else {\n            if (!o.isBranch()) return false;\n            if (this._childrenSuffixes.length !== o._childrenSuffixes.length) return false;\n            if (o._childrenSuffixes.length !== o._childrenHashes.length) return false;\n            for (let i = 0; i < this._childrenSuffixes.length; ++i) {\n                // hashes of child nodes\n                const ourChild = this._childrenHashes[i];\n                const otherChild = o._childrenHashes[i];\n                if (ourChild) {\n                    if (!otherChild || !ourChild.equals(otherChild)) return false;\n                } else {\n                    if (otherChild) return false;\n                }\n                if (this._childrenSuffixes[i] !== o._childrenSuffixes[i]) return false;\n            }\n        }\n        return true;\n    }\n}\nAccountsTreeNode.BRANCH = 0x00;\nAccountsTreeNode.TERMINAL = 0xff;\nClass.register(AccountsTreeNode);\n","class AccountsTreeStore {\n    /**\n     * @param {JungleDB} jdb\n     */\n    static initPersistent(jdb) {\n        jdb.createObjectStore('Accounts', { codec: new AccountsTreeStoreCodec() });\n    }\n\n    /**\n     * @param {JungleDB} jdb\n     * @returns {AccountsTreeStore}\n     */\n    static getPersistent(jdb) {\n        return new AccountsTreeStore(jdb.getObjectStore('Accounts'));\n    }\n\n    /**\n     * @returns {AccountsTreeStore}\n     */\n    static createVolatile() {\n        const store = JDB.JungleDB.createVolatileObjectStore();\n        return new AccountsTreeStore(store);\n    }\n\n    /**\n     * @param {IObjectStore} store\n     */\n    constructor(store) {\n        this._store = store;\n    }\n\n    /**\n     * @override\n     * @param {string} key\n     * @returns {Promise.<AccountsTreeNode>}\n     */\n    get(key) {\n        return this._store.get(key);\n    }\n\n    /**\n     * @override\n     * @param {AccountsTreeNode} node\n     * @returns {Promise.<string>}\n     */\n    async put(node) {\n        const key = node.prefix;\n        await this._store.put(key, node);\n        return key;\n    }\n\n    /**\n     * @override\n     * @param {AccountsTreeNode} node\n     * @returns {Promise.<string>}\n     */\n    async remove(node) {\n        const key = node.prefix;\n        await this._store.remove(key);\n        return key;\n    }\n\n    /**\n     * @returns {Promise.<AccountsTreeNode>}\n     */\n    getRootNode() {\n        return this.get('');\n    }\n\n    /**\n     * @param startPrefix This prefix will *not* be included.\n     * @param size\n     * @returns {Promise.<Array.<AccountsTreeNode>>}\n     */\n    async getTerminalNodes(startPrefix, size) {\n        const relevantKeys = [];\n        await this._store.keyStream(key => {\n            if (key.length === Address.HEX_SIZE) {\n                relevantKeys.push(key);\n                if (relevantKeys.length === size) {\n                    return false;\n                }\n            }\n            return true;\n        }, true, JDB.KeyRange.lowerBound(startPrefix, true));\n        const nodes = [];\n        for (const key of relevantKeys) {\n            nodes.push(this._store.get(key));\n        }\n        return Promise.all(nodes);\n    }\n\n    /**\n     * @param {AccountsTreeStore} [tx]\n     * @returns {AccountsTreeStore}\n     */\n    snapshot(tx) {\n        const snapshot = this._store.snapshot();\n        if (tx) {\n            snapshot.inherit(tx._store);\n        }\n        return new AccountsTreeStore(snapshot);\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {AccountsTreeStore}\n     */\n    transaction(enableWatchdog = true) {\n        const tx = this._store.transaction(enableWatchdog);\n        return new AccountsTreeStore(tx);\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {SynchronousAccountsTreeStore}\n     */\n    synchronousTransaction(enableWatchdog = true) {\n        const tx = this._store.synchronousTransaction(enableWatchdog);\n        return new SynchronousAccountsTreeStore(tx);\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    truncate() {\n        return this._store.truncate();\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    commit() {\n        return this._store.commit();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    abort() {\n        return this._store.abort();\n    }\n\n    /** @type {Transaction} */\n    get tx() {\n        if (this._store instanceof JDB.Transaction) {\n            return this._store;\n        }\n        return undefined;\n    }\n}\nClass.register(AccountsTreeStore);\n\n/**\n * @implements {ICodec}\n */\nclass AccountsTreeStoreCodec {\n    /**\n     * @param {*} obj The object to encode before storing it.\n     * @returns {*} Encoded object.\n     */\n    encode(obj) {\n        return obj.serialize();\n    }\n\n    /**\n     * @param {*} obj The object to decode.\n     * @param {string} key The object's primary key.\n     * @returns {*} Decoded object.\n     */\n    decode(obj, key) {\n        return AccountsTreeNode.unserialize(new SerialBuffer(obj));\n    }\n\n    /**\n     * @type {{encode: function(val:*):*, decode: function(val:*):*, buffer: boolean, type: string}|void}\n     */\n    get valueEncoding() {\n        return JDB.JungleDB.BINARY_ENCODING;\n    }\n}\n","class SynchronousAccountsTreeStore extends AccountsTreeStore {\n    /**\n     * @param {SynchronousTransaction} store\n     */\n    constructor(store) {\n        super(store);\n        this._syncStore = store;\n    }\n\n    /**\n     * @param {Array.<string>} keys\n     */\n    async preload(keys) {\n        await this._syncStore.preload(keys);\n    }\n\n    /**\n     * @param {string} key\n     * @param {boolean} [expectedToBePresent]\n     * @returns {AccountsTreeNode}\n     */\n    getSync(key, expectedToBePresent = true) {\n        return this._syncStore.getSync(key, { expectPresence: expectedToBePresent });\n    }\n\n    /**\n     * @param {AccountsTreeNode} node\n     * @returns {string}\n     */\n    putSync(node) {\n        const key = node.prefix;\n        this._syncStore.putSync(key, node);\n        return key;\n    }\n\n    /**\n     * @param {AccountsTreeNode} node\n     * @returns {string}\n     */\n    removeSync(node) {\n        const key = node.prefix;\n        this._syncStore.removeSync(key);\n        return key;\n    }\n\n    /**\n     * @returns {AccountsTreeNode}\n     */\n    getRootNodeSync() {\n        return this.getSync('');\n    }\n}\nClass.register(SynchronousAccountsTreeStore);\n","class AccountsProof {\n    /**\n     * @param {Array.<AccountsTreeNode>} nodes\n     */\n    constructor(nodes) {\n        if (!nodes || !Array.isArray(nodes) || !NumberUtils.isUint16(nodes.length)\n            || nodes.some(it => !(it instanceof AccountsTreeNode))) throw 'Malformed nodes';\n\n        /** @type {Array.<AccountsTreeNode>} */\n        this._nodes = nodes;\n        /** @type {HashMap.<Hash,AccountsTreeNode>} */\n        this._index = null;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {AccountsProof}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint16();\n        const nodes = [];\n        for (let i = 0; i < count; i++) {\n            nodes.push(AccountsTreeNode.unserialize(buf));\n        }\n        return new AccountsProof(nodes);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._nodes.length);\n        for (const node of this._nodes) {\n            node.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let size = /*count*/ 2;\n        for (const node of this._nodes) {\n            size += node.serializedSize;\n        }\n        return size;\n    }\n\n    /**\n     * Assumes nodes to be in post order and hashes nodes to check internal consistency of proof.\n     * XXX Abuse this method to index the nodes contained in the proof. This forces callers to explicitly verify()\n     * the proof before retrieving accounts.\n     * @returns {boolean}\n     */\n    verify() {\n        /** @type {Array.<AccountsTreeNode>} */\n        const children = [];\n        this._index = new HashMap();\n        for (const node of this._nodes) {\n            // If node is a branch node, validate its children.\n            if (node.isBranch()) {\n                let child;\n                while (child = children.pop()) { // eslint-disable-line no-cond-assign\n                    if (child.isChildOf(node)) {\n                        const hash = child.hash();\n                        // If the child is not valid, return false.\n                        if (!node.getChildHash(child.prefix).equals(hash) || node.getChild(child.prefix) !== child.prefix) {\n                            return false;\n                        }\n                        this._index.put(hash, child);\n                    } else {\n                        children.push(child);\n                        break;\n                    }\n                }\n            }\n\n            // Append child.\n            children.push(node);\n        }\n\n        // The last element must be the root node.\n        return children.length === 1 && children[0].prefix === '' && children[0].isBranch();\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {?Account}\n     */\n    getAccount(address) {\n        if (!this._index) {\n            throw new Error('AccountsProof must be verified before retrieving accounts. Call verify() first.');\n        }\n\n        const rootNode = this._nodes[this._nodes.length - 1];\n        const prefix = address.toHex();\n        return this._getAccount(rootNode, prefix);\n    }\n\n    /**\n     * @param {AccountsTreeNode} node\n     * @param {string} prefix\n     * @returns {?Account}\n     * @private\n     */\n    _getAccount(node, prefix) {\n        // Find common prefix between node and requested address.\n        const commonPrefix = StringUtils.commonPrefix(node.prefix, prefix);\n\n        // If the prefix does not fully match, the requested account does not exist.\n        if (commonPrefix.length !== node.prefix.length) return null;\n\n        // If the remaining address is empty, we have found the requested node.\n        if (commonPrefix === prefix) return node.account;\n\n        // Descend into the matching child node if one exists.\n        const childKey = node.getChildHash(prefix);\n        if (childKey) {\n            const childNode = this._index.get(childKey);\n\n            // If the child exists but is not part of the proof, fail.\n            if (!childNode) {\n                throw new Error('Requested address not part of AccountsProof');\n            }\n\n            return this._getAccount(childNode, prefix);\n        }\n\n        // No matching child exists, the requested account does not exist.\n        return null;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `AccountsProof{length=${this.length}}`;\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    root() {\n        return this._nodes[this._nodes.length - 1].hash();\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._nodes.length;\n    }\n\n    /** @type {Array.<AccountsTreeNode>} */\n    get nodes() {\n        return this._nodes;\n    }\n}\nClass.register(AccountsProof);\n","class AccountsTreeChunk {\n    /**\n     * @param {Array.<AccountsTreeNode>} nodes\n     * @param {AccountsProof} proof\n     */\n    constructor(nodes, proof) {\n        if (!nodes || !NumberUtils.isUint16(nodes.length)\n            || nodes.some(it => !(it instanceof AccountsTreeNode) || !it.isTerminal())) throw 'Malformed nodes';\n\n        /** @type {Array.<AccountsTreeNode>} */\n        this._nodes = nodes;\n        this._proof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {AccountsTreeChunk}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint16();\n        const nodes = [];\n        for (let i = 0; i < count; i++) {\n            nodes.push(AccountsTreeNode.unserialize(buf));\n        }\n        const proof = AccountsProof.unserialize(buf);\n        return new AccountsTreeChunk(nodes, proof);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._nodes.length);\n        for (const node of this._nodes) {\n            node.serialize(buf);\n        }\n        this._proof.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let size = /*count*/ 2;\n        for (const node of this._nodes) {\n            size += node.serializedSize;\n        }\n        size += this._proof.serializedSize;\n        return size;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    verify() {\n        if (!this._proof.verify()) {\n            return false;\n        }\n\n        let lastPrefix = null;\n        for (let i = 0; i <= this._nodes.length; ++i) {\n            const node = i < this._nodes.length ? this._nodes[i] : this.tail;\n            if (lastPrefix && lastPrefix >= node.prefix) {\n                return false;\n            }\n            lastPrefix = node.prefix;\n        }\n        return true;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `AccountsTreeChunk{length=${this.length}}`;\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    root() {\n        return this._proof.root();\n    }\n\n    /** @type {Array.<AccountsTreeNode>} */\n    get terminalNodes() {\n        return this._nodes.concat([this.tail]);\n    }\n\n    /** @type {AccountsProof} */\n    get proof() {\n        return this._proof;\n    }\n\n    /** @type {AccountsTreeNode} */\n    get head() {\n        return this._nodes[0];\n    }\n\n    /** @type {AccountsTreeNode} */\n    get tail() {\n        return this._proof.nodes[0];\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._nodes.length + 1;\n    }\n}\nAccountsTreeChunk.SIZE_MAX = 1000;\nAccountsTreeChunk.EMPTY = new AccountsTreeChunk([], new AccountsProof([]));\nClass.register(AccountsTreeChunk);\n","class AccountsTree extends Observable {\n    /**\n     * @returns {Promise.<AccountsTree>}\n     */\n    static async getPersistent(jdb) {\n        const store = AccountsTreeStore.getPersistent(jdb);\n        const tree = new AccountsTree(store);\n        return tree._init();\n    }\n\n    /**\n     * @returns {Promise.<AccountsTree>}\n     */\n    static async createVolatile() {\n        const store = AccountsTreeStore.createVolatile();\n        const tree = new AccountsTree(store);\n        return tree._init();\n    }\n\n    /**\n     * @private\n     * @param {AccountsTreeStore} store\n     * @returns {AccountsTree}\n     */\n    constructor(store) {\n        super();\n        /** @type {AccountsTreeStore} */\n        this._store = store;\n        this._synchronizer = new Synchronizer();\n    }\n\n    /**\n     * @returns {Promise.<AccountsTree>}\n     * @protected\n     */\n    async _init() {\n        let rootNode = await this._store.getRootNode();\n        if (!rootNode) {\n            rootNode = AccountsTreeNode.branchNode(/*prefix*/ '', /*childrenSuffixes*/ [], /*childrenHashes*/ []);\n            await this._store.put(rootNode);\n        }\n        return this;\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Account} account\n     * @returns {Promise}\n     */\n    put(address, account) {\n        return this._synchronizer.push(() => {\n            return this._put(address, account);\n        });\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Account} account\n     * @returns {Promise}\n     * @private\n     */\n    async _put(address, account) {\n        if (account.isInitial() && !(await this.get(address))) {\n            return;\n        }\n\n        // Fetch the root node.\n        const rootNode = await this._store.getRootNode();\n        Assert.that(!!rootNode, 'Corrupted store: Failed to fetch AccountsTree root node');\n\n        // Insert account into the tree at address.\n        const prefix = address.toHex();\n        await this._insert(rootNode, prefix, account, []);\n    }\n\n    /**\n     * @param {AccountsTreeNode} node\n     * @param {string} prefix\n     * @param {Account} account\n     * @param {Array.<AccountsTreeNode>} rootPath\n     * @returns {Promise}\n     * @private\n     */\n    async _insert(node, prefix, account, rootPath) {\n        // Find common prefix between node and new address.\n        const commonPrefix = StringUtils.commonPrefix(node.prefix, prefix);\n\n        // If the node prefix does not fully match the new address, split the node.\n        if (commonPrefix.length !== node.prefix.length) {\n            // Insert the new account node.\n            const newChild = AccountsTreeNode.terminalNode(prefix, account);\n            const newChildHash = newChild.hash();\n            await this._store.put(newChild);\n\n            // Insert the new parent node.\n            const newParent = AccountsTreeNode.branchNode(commonPrefix)\n                .withChild(node.prefix, node.hash())\n                .withChild(newChild.prefix, newChildHash);\n            const newParentHash = newParent.hash();\n            await this._store.put(newParent);\n\n            return this._updateKeys(newParent.prefix, newParentHash, rootPath);\n        }\n\n        // If the commonPrefix is the specified address, we have found an (existing) node\n        // with the given address. Update the account.\n        if (commonPrefix === prefix) {\n            // XXX How does this generalize to more than one account type?\n            // Special case: If the new balance is the initial balance\n            // (i.e. balance=0, nonce=0), it is like the account never existed\n            // in the first place. Delete the node in this case.\n            if (account.isInitial()) {\n                await this._store.remove(node);\n                // We have already deleted the node, remove the subtree it was on.\n                return this._prune(node.prefix, rootPath);\n            }\n\n            // Update the account.\n            node = node.withAccount(account);\n            const nodeHash = node.hash();\n            await this._store.put(node);\n\n            return this._updateKeys(node.prefix, nodeHash, rootPath);\n        }\n\n        // If the node prefix matches and there are address bytes left, descend into\n        // the matching child node if one exists.\n        const childPrefix = node.getChild(prefix);\n        if (childPrefix) {\n            const childNode = await this._store.get(childPrefix);\n            rootPath.push(node);\n            return this._insert(childNode, prefix, account, rootPath);\n        }\n\n        // If no matching child exists, add a new child account node to the current node.\n        const newChild = AccountsTreeNode.terminalNode(prefix, account);\n        const newChildHash = newChild.hash();\n        await this._store.put(newChild);\n\n        node = node.withChild(newChild.prefix, newChildHash);\n        const nodeHash = node.hash();\n        await this._store.put(node);\n\n        return this._updateKeys(node.prefix, nodeHash, rootPath);\n    }\n\n    /**\n     * @param {string} prefix\n     * @param {Array.<AccountsTreeNode>} rootPath\n     * @returns {Promise}\n     * @private\n     */\n    async _prune(prefix, rootPath) {\n        // Walk along the rootPath towards the root node starting with the\n        // immediate predecessor of the node specified by 'prefix'.\n        let i = rootPath.length - 1;\n        for (; i >= 0; --i) {\n            let node = rootPath[i];\n\n            node = node.withoutChild(prefix);\n\n            // If the node has only a single child, merge it with the next node.\n            if (node.hasSingleChild() && node.prefix !== '') {\n                await this._store.remove(node); // eslint-disable-line no-await-in-loop\n\n                const childPrefix = node.getFirstChild();\n                const childNode = await this._store.get(childPrefix); // eslint-disable-line no-await-in-loop\n\n                await this._store.put(childNode); // eslint-disable-line no-await-in-loop\n                const childHash = childNode.hash();\n                return this._updateKeys(childNode.prefix, childHash, rootPath.slice(0, i));\n            }\n            // Otherwise, if the node has children left, update it and all keys on the\n            // remaining root path. Pruning finished.\n            // XXX Special case: We start with an empty root node. Don't delete it.\n            else if (node.hasChildren() || node.prefix === '') {\n                const nodeHash = node.hash();\n                await this._store.put(node); // eslint-disable-line no-await-in-loop\n                return this._updateKeys(node.prefix, nodeHash, rootPath.slice(0, i));\n            }\n\n            // The node has no children left, continue pruning.\n            prefix = node.prefix;\n        }\n\n        // XXX This should never be reached.\n        return undefined;\n    }\n\n    /**\n     * @param {string} prefix\n     * @param {Hash} nodeHash\n     * @param {Array.<AccountsTreeNode>} rootPath\n     * @returns {Promise}\n     * @private\n     */\n    async _updateKeys(prefix, nodeHash, rootPath) {\n        // Walk along the rootPath towards the root node starting with the\n        // immediate predecessor of the node specified by 'prefix'.\n        let i = rootPath.length - 1;\n        for (; i >= 0; --i) {\n            let node = rootPath[i];\n\n            node = node.withChild(prefix, nodeHash);\n            await this._store.put(node); // eslint-disable-line no-await-in-loop\n            nodeHash = node.hash();\n            prefix = node.prefix;\n        }\n\n        return nodeHash;\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise.<?Account>}\n     */\n    async get(address) {\n        const node = await this._store.get(address.toHex());\n        return node !== undefined ? node.account : null;\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<AccountsProof>}\n     */\n    async getAccountsProof(addresses) {\n        const rootNode = await this._store.getRootNode();\n        Assert.that(!!rootNode, 'Corrupted store: Failed to fetch AccountsTree root node');\n\n        const prefixes = [];\n        for (const address of addresses) {\n            prefixes.push(address.toHex());\n        }\n        // We sort the addresses to simplify traversal in post order (leftmost addresses first).\n        prefixes.sort();\n\n        const nodes = [];\n        await this._getAccountsProof(rootNode, prefixes, nodes);\n        return new AccountsProof(nodes);\n    }\n\n    /**\n     * Constructs the accounts proof in post-order.\n     * @param {AccountsTreeNode} node\n     * @param {Array.<string>} prefixes\n     * @param {Array.<AccountsTreeNode>} nodes\n     * @returns {Promise.<*>}\n     * @private\n     */\n    async _getAccountsProof(node, prefixes, nodes) {\n        // For each prefix, descend the tree individually.\n        let includeNode = false;\n        for (let i = 0; i < prefixes.length; ) {\n            let prefix = prefixes[i];\n\n            // Find common prefix between node and the current requested prefix.\n            const commonPrefix = StringUtils.commonPrefix(node.prefix, prefix);\n\n            // If the prefix fully matches, we have found the requested node.\n            // If the prefix does not fully match, the requested address is not part of this node.\n            // Include the node in the proof nevertheless to prove that the account doesn't exist.\n            if (commonPrefix.length !== node.prefix.length || node.prefix === prefix) {\n                includeNode = true;\n                i++;\n                continue;\n            }\n\n            // Descend into the matching child node if one exists.\n            const childKey = node.getChild(prefix);\n            if (childKey) {\n                const childNode = await this._store.get(childKey); // eslint-disable-line no-await-in-loop\n\n                // Group addresses with same prefix:\n                // Because of our ordering, they have to be located next to the current prefix.\n                // Hence, we iterate over the next prefixes, until we don't find commonalities anymore.\n                // In the next main iteration we can skip those we already requested here.\n                const subPrefixes = [prefix];\n                // Find other prefixes to descend into this tree as well.\n                let j = i + 1;\n                for (; j < prefixes.length; ++j) {\n                    // Since we ordered prefixes, there can't be any other prefixes with commonalities.\n                    if (!prefixes[j].startsWith(childNode.prefix)) break;\n                    // But if there is a commonality, add it to the list.\n                    subPrefixes.push(prefixes[j]);\n                }\n                // Now j is the last index which doesn't have commonalities,\n                // we continue from there in the next iteration.\n                i = j;\n\n                includeNode = (await this._getAccountsProof(childNode, subPrefixes, nodes)) || includeNode; // eslint-disable-line no-await-in-loop\n            }\n            // No child node exists with the requested prefix. Include the current node to prove the absence of the requested account.\n            else {\n                includeNode = true;\n                i++;\n            }\n        }\n\n        // If this branch contained at least one account, we add this node.\n        if (includeNode) {\n            nodes.push(node);\n        }\n\n        return includeNode;\n    }\n\n    /**\n     * @param {string} startPrefix The prefix to start with.\n     * @param {number} size The maximum number of terminal nodes to include.\n     * @returns {Promise.<AccountsTreeChunk>}\n     */\n    async getChunk(startPrefix, size) {\n        const chunk = await this._store.getTerminalNodes(startPrefix, size);\n        const lastNode = chunk.pop();\n        let /** @type {AccountsProof} */ proof;\n        if (lastNode) {\n            proof = await this.getAccountsProof([Address.fromHex(lastNode.prefix)]);\n        } else {\n            // The proof that the last address does not exist is sufficient to prove that there is no such chunk.\n            proof = await this.getAccountsProof([Address.fromHex('ffffffffffffffffffffffffffffffffffffffff')]);\n        }\n        return new AccountsTreeChunk(chunk, proof);\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {Promise.<AccountsTree>}\n     */\n    transaction(enableWatchdog = true) {\n        const tree = new AccountsTree(this._store.transaction(enableWatchdog));\n        return tree._init();\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {Promise.<SynchronousAccountsTree>}\n     */\n    synchronousTransaction(enableWatchdog = true) {\n        const tx = this._store.synchronousTransaction(enableWatchdog);\n        const tree = new SynchronousAccountsTree(tx);\n        return tree._init();\n    }\n\n    /**\n     * @returns {Promise.<PartialAccountsTree>}\n     */\n    async partialTree() {\n        const tx = this._store.synchronousTransaction(false);\n        await tx.truncate();\n        const tree = new PartialAccountsTree(tx);\n        return tree._init();\n    }\n\n    /**\n     * @param {AccountsTree} [tx]\n     * @returns {Promise.<AccountsTree>}\n     */\n    snapshot(tx) {\n        const tree = new AccountsTree(this._store.snapshot(tx ? tx._store : undefined));\n        return tree._init();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    async commit() {\n        Assert.that(!(await this.root()).equals(new Hash(null)));\n        return this._store.commit();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    abort() {\n        return this._store.abort();\n    }\n\n    /**\n     * @returns {Promise.<Hash>}\n     */\n    async root() {\n        const rootNode = await this._store.getRootNode();\n        return rootNode && rootNode.hash();\n    }\n\n    /** @type {Transaction} */\n    get tx() {\n        return this._store.tx;\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    async isEmpty() {\n        const rootNode = await this._store.getRootNode();\n        return !rootNode.hasChildren();\n    }\n}\nClass.register(AccountsTree);\n\n","class SynchronousAccountsTree extends AccountsTree {\n    /**\n     * @private\n     * @param {SynchronousAccountsTreeStore} store\n     * @returns {SynchronousAccountsTree}\n     */\n    constructor(store) {\n        super(store);\n        /** @type {SynchronousAccountsTreeStore} */\n        this._syncStore = store;\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     * @returns {Promise}\n     */\n    async preloadAddresses(addresses) {\n        const rootNode = await this._syncStore.getRootNode();\n        Assert.that(!!rootNode, 'Corrupted store: Failed to fetch AccountsTree root node');\n\n        const prefixes = [];\n        for (const address of addresses) {\n            prefixes.push(address.toHex());\n        }\n        // We sort the addresses to simplify traversal in post order (leftmost addresses first).\n        prefixes.sort();\n\n        await this._preloadAddresses(rootNode, prefixes);\n    }\n\n    /**\n     * @param {AccountsTreeNode} node\n     * @param {Array.<string>} prefixes\n     * @private\n     */\n    async _preloadAddresses(node, prefixes) {\n        if (node.hasChildren()) {\n            await this._syncStore.preload(node.getChildren());\n        }\n        \n        // For each prefix, descend the tree individually.\n        for (let i = 0; i < prefixes.length; ) {\n            const prefix = prefixes[i];\n\n            // Find common prefix between node and the current requested prefix.\n            const commonPrefix = StringUtils.commonPrefix(node.prefix, prefix);\n\n            // If the prefix fully matches, we have found the requested node.\n            // If the prefix does not fully match, the requested address is not part of this node.\n            // Include the node in the proof nevertheless to prove that the account doesn't exist.\n            if (commonPrefix.length !== node.prefix.length || node.prefix === prefix) {\n                i++;\n                continue;\n            }\n\n            // Descend into the matching child node if one exists.\n            const childKey = node.getChild(prefix);\n            if (childKey) {\n                const childNode = this._syncStore.getSync(childKey);\n\n                // Group addresses with same prefix:\n                // Because of our ordering, they have to be located next to the current prefix.\n                // Hence, we iterate over the next prefixes, until we don't find commonalities anymore.\n                // In the next main iteration we can skip those we already requested here.\n                const subPrefixes = [prefix];\n                // Find other prefixes to descend into this tree as well.\n                let j = i + 1;\n                for (; j < prefixes.length; ++j) {\n                    // Since we ordered prefixes, there can't be any other prefixes with commonalities.\n                    if (!prefixes[j].startsWith(childNode.prefix)) break;\n                    // But if there is a commonality, add it to the list.\n                    subPrefixes.push(prefixes[j]);\n                }\n                // Now j is the last index which doesn't have commonalities,\n                // we continue from there in the next iteration.\n                i = j;\n\n                await this._preloadAddresses(childNode, subPrefixes); // eslint-disable-line no-await-in-loop\n            }\n            // No child node exists with the requested prefix. Include the current node to prove the absence of the requested account.\n            else {\n                i++;\n            }\n        }\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Account} account\n     */\n    putSync(address, account) {\n        this.putBatch(address, account);\n        this.finalizeBatch();\n    }\n\n    finalizeBatch() {\n        const rootNode = this._syncStore.getRootNodeSync();\n        this._updateHashes(rootNode);\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Account} account\n     * @private\n     */\n    putBatch(address, account) {\n        if (account.isInitial() && !this.getSync(address, false)) {\n            return;\n        }\n\n        // Fetch the root node.\n        const rootNode = this._syncStore.getRootNodeSync();\n        Assert.that(!!rootNode, 'Corrupted store: Failed to fetch AccountsTree root node');\n\n        // Insert account into the tree at address.\n        const prefix = address.toHex();\n        this._insertBatch(rootNode, prefix, account, []);\n    }\n\n    /**\n     * @param {AccountsTreeNode} node\n     * @param {string} prefix\n     * @param {Account} account\n     * @param {Array.<AccountsTreeNode>} rootPath\n     * @protected\n     */\n    _insertBatch(node, prefix, account, rootPath) {\n        // Find common prefix between node and new address.\n        const commonPrefix = StringUtils.commonPrefix(node.prefix, prefix);\n\n        // If the node prefix does not fully match the new address, split the node.\n        if (commonPrefix.length !== node.prefix.length) {\n            // Insert the new account node.\n            const newChild = AccountsTreeNode.terminalNode(prefix, account);\n            this._syncStore.putSync(newChild);\n\n            // Insert the new parent node.\n            const newParent = AccountsTreeNode.branchNode(commonPrefix)\n                .withChild(node.prefix, new Hash(null))\n                .withChild(newChild.prefix, new Hash(null));\n            this._syncStore.putSync(newParent);\n\n            return this._updateKeysBatch(newParent.prefix, rootPath);\n        }\n\n        // If the commonPrefix is the specified address, we have found an (existing) node\n        // with the given address. Update the account.\n        if (commonPrefix === prefix) {\n            // XXX How does this generalize to more than one account type?\n            // Special case: If the new balance is the initial balance\n            // (i.e. balance=0, nonce=0), it is like the account never existed\n            // in the first place. Delete the node in this case.\n            if (account.isInitial()) {\n                this._syncStore.removeSync(node);\n                // We have already deleted the node, remove the subtree it was on.\n                return this._pruneBatch(node.prefix, rootPath);\n            }\n\n            // Update the account.\n            node = node.withAccount(account);\n            this._syncStore.putSync(node);\n\n            return this._updateKeysBatch(node.prefix, rootPath);\n        }\n\n        // If the node prefix matches and there are address bytes left, descend into\n        // the matching child node if one exists.\n        const childPrefix = node.getChild(prefix);\n        if (childPrefix) {\n            const childNode = this._syncStore.getSync(childPrefix);\n            rootPath.push(node);\n            return this._insertBatch(childNode, prefix, account, rootPath);\n        }\n\n        // If no matching child exists, add a new child account node to the current node.\n        const newChild = AccountsTreeNode.terminalNode(prefix, account);\n        this._syncStore.putSync(newChild);\n\n        node = node.withChild(newChild.prefix, new Hash(null));\n        this._syncStore.putSync(node);\n\n        return this._updateKeysBatch(node.prefix, rootPath);\n    }\n\n    /**\n     * @param {string} prefix\n     * @param {Array.<AccountsTreeNode>} rootPath\n     * @private\n     */\n    _pruneBatch(prefix, rootPath) {\n        // Walk along the rootPath towards the root node starting with the\n        // immediate predecessor of the node specified by 'prefix'.\n        let i = rootPath.length - 1;\n        for (; i >= 0; --i) {\n            let node = rootPath[i];\n\n            node = node.withoutChild(prefix);\n\n            // If the node has only a single child, merge it with the next node.\n            if (node.hasSingleChild() && node.prefix !== '') {\n                this._syncStore.removeSync(node);\n\n                const childPrefix = node.getFirstChild();\n                const childNode = this._syncStore.getSync(childPrefix);\n\n                this._syncStore.putSync(childNode);\n                return this._updateKeysBatch(childNode.prefix, rootPath.slice(0, i));\n            }\n            // Otherwise, if the node has children left, update it and all keys on the\n            // remaining root path. Pruning finished.\n            // XXX Special case: We start with an empty root node. Don't delete it.\n            else if (node.hasChildren() || node.prefix === '') {\n                this._syncStore.putSync(node);\n                return this._updateKeysBatch(node.prefix, rootPath.slice(0, i));\n            }\n\n            // The node has no children left, continue pruning.\n            prefix = node.prefix;\n        }\n\n        // XXX This should never be reached.\n        return undefined;\n    }\n\n    /**\n     * @param {string} prefix\n     * @param {Array.<AccountsTreeNode>} rootPath\n     * @private\n     */\n    _updateKeysBatch(prefix, rootPath) {\n        // Walk along the rootPath towards the root node starting with the\n        // immediate predecessor of the node specified by 'prefix'.\n        let i = rootPath.length - 1;\n        for (; i >= 0; --i) {\n            let node = rootPath[i];\n\n            node = node.withChild(prefix, new Hash(null));\n            this._syncStore.putSync(node);\n            prefix = node.prefix;\n        }\n    }\n\n    /**\n     * This method updates all empty hashes (and only such).\n     * @param {AccountsTreeNode} node\n     * @protected\n     */\n    _updateHashes(node) {\n        if (node.isTerminal()) {\n            return node.hash();\n        }\n\n        const zeroHash = new Hash(null);\n        // Compute sub hashes if necessary.\n        const subHashes = node.getChildren().map(child => {\n            const currentHash = node.getChildHash(child);\n            if (!currentHash.equals(zeroHash)) {\n                return currentHash;\n            }\n            const childNode = this._syncStore.getSync(child);\n            return this._updateHashes(childNode);\n        });\n\n        // Then prepare new node and update.\n        let newNode = node;\n        node.getChildren().forEach((child, i) => {\n            newNode = newNode.withChild(child, subHashes[i]);\n        });\n        this._syncStore.putSync(newNode);\n        return newNode.hash();\n    }\n\n    /**\n     * @param {Address} address\n     * @param {boolean} [expectedToBePresent]\n     * @returns {?Account}\n     */\n    getSync(address, expectedToBePresent = true) {\n        const node = this._syncStore.getSync(address.toHex(), expectedToBePresent);\n        return node !== undefined ? node.account : null;\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    rootSync() {\n        const rootNode = this._syncStore.getRootNodeSync();\n        return rootNode && rootNode.hash();\n    }\n}\nClass.register(SynchronousAccountsTree);\n\n","class PartialAccountsTree extends SynchronousAccountsTree {\n    /**\n     * @private\n     * @param {SynchronousAccountsTreeStore} store\n     */\n    constructor(store) {\n        super(store);\n        this._complete = false;\n        /** @type {string} */\n        this._lastPrefix = '';\n    }\n\n    /**\n     * @param {AccountsTreeChunk} chunk\n     * @returns {Promise.<PartialAccountsTree.Status>}\n     */\n    async pushChunk(chunk) {\n        // First verify the proof.\n        if (!chunk.verify()) {\n            return PartialAccountsTree.Status.ERR_INCORRECT_PROOF;\n        }\n\n        const tx = this.synchronousTransaction();\n\n        // Then apply all\n        tx._putLight(chunk.terminalNodes);\n\n        // Check if proof can be merged.\n        if (!tx._mergeProof(chunk.proof, chunk.tail.prefix)) {\n            await tx.abort();\n            return PartialAccountsTree.Status.ERR_UNMERGEABLE;\n        }\n        this._complete = tx.complete;\n\n        // Now, we can put all nodes into the store.\n        await tx.commit();\n\n        // Update last prefix.\n        this._lastPrefix = chunk.tail.prefix;\n\n        // And return OK code depending on internal state.\n        return this._complete ? PartialAccountsTree.Status.OK_COMPLETE : PartialAccountsTree.Status.OK_UNFINISHED;\n    }\n\n    /**\n     * @param {AccountsProof} proof\n     * @param {string} upperBound\n     * @returns {boolean}\n     * @private\n     */\n    _mergeProof(proof, upperBound) {\n        // Retrieve rightmost path of the in-memory tree.\n        let node = this._store.getRootNodeSync();\n        let nodeChildren = node.getChildren();\n        let complete = true;\n\n        // Iterate over the proof and check for consistency.\n        let j = proof.length - 1;\n        for (; j > 0; --j) {\n            const proofNode = proof.nodes[j];\n            // The node's prefix might be shorter than the proof node's prefix if it is a newly\n            // introduces node in the proof.\n            if (StringUtils.commonPrefix(node.prefix, proofNode.prefix) !== node.prefix) {\n                return false;\n            }\n\n            const proofChildren = proofNode.getChildren();\n\n            // The tree node may not have more children than the proof node.\n            if (nodeChildren.length > proofChildren.length) {\n                return false;\n            }\n\n            // The nextChild we descend to.\n            const nextChild = node.getLastChild();\n            let insertedNode = false;\n\n            // There are three cases:\n            // 1) the child is in our inner tree (so between lower and upper bound), then the hashes must coincide.\n            // 2) the child is left of our chunk, so it must be in the store.\n            // 3) the child is right of our chunk, so it is a dangling reference.\n            let i = 0;\n            for (const proofChild of proofChildren) {\n                const upperBoundPrefix = upperBound.substr(0, proofChild.length);\n                if (proofChild <= upperBoundPrefix) {\n                    // An inner node.\n                    const child = nodeChildren.shift();\n\n                    // This is the next child.\n                    if (StringUtils.commonPrefix(nextChild, proofChild) === proofChild) {\n                        // If it is a real prefix of the next child, we have inserted a new node.\n                        if (proofChild !== nextChild) {\n                            insertedNode = true;\n                        }\n                        continue;\n                    }\n\n                    if (child !== proofChild) {\n                        return false;\n                    }\n                    // The child is equal and not the next child, so the hash must coincide.\n                    const nodeHash = node.getChildHash(child);\n                    const proofHash = proofNode.getChildHash(child);\n                    if (!nodeHash || !proofHash || !nodeHash.equals(proofHash)) {\n                        return false;\n                    }\n                } else {\n                    // The others may be dangling references.\n                    break;\n                }\n                ++i;\n            }\n\n            // We must have consumed all children!\n            if (nodeChildren.length !== 0) {\n                return false;\n            }\n\n            // If not all of the proof children have been tested, we are definitely incomplete.\n            complete = complete && (i === proofChildren.length - 1);\n\n            // If the prefix was the same, we can move on.\n            if (insertedNode) {\n                nodeChildren = [nextChild];\n            } else {\n                // We should never end here with a terminal node.\n                if (node.isTerminal()) {\n                    return false;\n                }\n                node = this._store.getSync(node.getLastChild());\n                nodeChildren = node.getChildren();\n                if (node.isTerminal()) {\n                    break;\n                }\n            }\n        }\n\n        // Check the terminal nodes.\n        if (!node.equals(proof.nodes[0])) {\n            return false;\n        }\n\n        this._complete = complete;\n        return true;\n    }\n\n    /**\n     * @param {Array.<AccountsTreeNode>} nodes\n     * @private\n     */\n    _putLight(nodes) {\n        Assert.that(nodes.every(node => node.isTerminal()), 'Can only build tree from terminal nodes');\n\n        // Fetch the root node.\n        let rootNode = this._store.getRootNodeSync();\n        Assert.that(!!rootNode, 'Corrupted store: Failed to fetch AccountsTree root node');\n\n        // TODO: Bulk insertion instead of sequential insertion!\n        for (const node of nodes) {\n            this._insertBatch(rootNode, node.prefix, node.account, []);\n            rootNode = this._store.getRootNodeSync();\n            Assert.that(!!rootNode, 'Corrupted store: Failed to fetch AccountsTree root node');\n        }\n        this._updateHashes(rootNode);\n    }\n\n    /** @type {boolean} */\n    get complete() {\n        return this._complete;\n    }\n\n    /** @type {string} */\n    get missingPrefix() {\n        return this._lastPrefix;\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {PartialAccountsTree}\n     */\n    synchronousTransaction(enableWatchdog = true) {\n        const tree = new PartialAccountsTree(this._store.synchronousTransaction(enableWatchdog));\n        tree._complete = this._complete;\n        tree._lastPrefix = this._lastPrefix;\n        return tree;\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {AccountsTree}\n     */\n    transaction(enableWatchdog = true) {\n        if (!this.complete) {\n            throw new Error('Can only construct AccountsTree from complete PartialAccountsTree');\n        }\n        // Use a synchronous transaction here to enable better caching.\n        return new AccountsTree(this._store.synchronousTransaction(enableWatchdog));\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    commit() {\n        return this._store.commit();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    abort() {\n        return this._store.abort();\n    }\n}\n\n/**\n * @enum {number}\n */\nPartialAccountsTree.Status = {\n    ERR_HASH_MISMATCH: -3,\n    ERR_INCORRECT_PROOF: -2,\n    ERR_UNMERGEABLE: -1,\n    OK_COMPLETE: 0,\n    OK_UNFINISHED: 1\n};\nClass.register(PartialAccountsTree);\n\n","class Accounts extends Observable {\n    /**\n     * Generate an Accounts object that is persisted to the local storage.\n     * @returns {Promise.<Accounts>} Accounts object\n     */\n    static async getPersistent(jdb) {\n        const tree = await AccountsTree.getPersistent(jdb);\n        return new Accounts(tree);\n    }\n\n    /**\n     * Generate an Accounts object that loses it's data after usage.\n     * @returns {Promise.<Accounts>} Accounts object\n     */\n    static async createVolatile() {\n        const tree = await AccountsTree.createVolatile();\n        return new Accounts(tree);\n    }\n\n    /**\n     * @param {AccountsTree} accountsTree\n     */\n    constructor(accountsTree) {\n        super();\n        this._tree = accountsTree;\n\n        // Forward balance change events to listeners registered on this Observable.\n        this.bubble(this._tree, '*');\n    }\n\n    /**\n     * @param {Block} genesisBlock\n     * @param {string} encodedAccounts\n     * @returns {Promise.<void>}\n     */\n    async initialize(genesisBlock, encodedAccounts) {\n        Assert.that(await this._tree.isEmpty());\n\n        const tree = await this._tree.synchronousTransaction();\n        try {\n            const buf = BufferUtils.fromBase64(encodedAccounts);\n            const count = buf.readUint16();\n            for (let i = 0; i < count; i++) {\n                const address = Address.unserialize(buf);\n                const account = Account.unserialize(buf);\n                tree.putSync(address, account);\n            }\n\n            await this._commitBlockBody(tree, genesisBlock.body, genesisBlock.height, new TransactionCache());\n\n            tree.finalizeBatch();\n        } catch (e) {\n            await tree.abort();\n            throw e;\n        }\n\n        const hash = tree.rootSync();\n        if (!genesisBlock.accountsHash.equals(hash)) {\n            await tree.abort();\n            throw new Error('Genesis AccountsHash mismatch');\n        }\n\n        return tree.commit();\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<AccountsProof>}\n     */\n    getAccountsProof(addresses) {\n        return this._tree.getAccountsProof(addresses);\n    }\n\n    /**\n     * @param {string} startPrefix\n     * @returns {Promise.<AccountsTreeChunk>}\n     */\n    getAccountsTreeChunk(startPrefix) {\n        return this._tree.getChunk(startPrefix, AccountsTreeChunk.SIZE_MAX);\n    }\n\n    /**\n     * @param {Block} block\n     * @param {TransactionCache} transactionCache\n     * @return {Promise}\n     */\n    async commitBlock(block, transactionCache) {\n        const tree = await this._tree.synchronousTransaction();\n        await tree.preloadAddresses(block.body.getAddresses());\n        try {\n            this._commitBlockBody(tree, block.body, block.height, transactionCache);\n        } catch (e) {\n            await tree.abort();\n            throw e;\n        }\n\n        tree.finalizeBatch();\n\n        const hash = tree.rootSync();\n        if (!block.accountsHash.equals(hash)) {\n            await tree.abort();\n            throw new Error('AccountsHash mismatch');\n        }\n        return tree.commit();\n    }\n\n    /**\n     * @param {BlockBody} body\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionCache\n     * @return {Promise}\n     */\n    async commitBlockBody(body, blockHeight, transactionCache) {\n        const tree = await this._tree.synchronousTransaction();\n        await tree.preloadAddresses(body.getAddresses());\n        try {\n            this._commitBlockBody(tree, body, blockHeight, transactionCache);\n        } catch (e) {\n            await tree.abort();\n            throw e;\n        }\n        tree.finalizeBatch();\n        return tree.commit();\n    }\n\n    /**\n     * @param {Array.<Transaction>} transactions\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionCache\n     * @return {Promise<Array.<PrunedAccount>>}\n     */\n    async gatherToBePrunedAccounts(transactions, blockHeight, transactionCache) {\n        const tree = await this._tree.synchronousTransaction();\n        const addresses = [];\n        for (const tx of transactions) {\n            addresses.push(tx.sender, tx.recipient);\n        }\n        await tree.preloadAddresses(addresses);\n        try {\n            this._processSenderAccounts(tree, transactions, blockHeight, transactionCache);\n            this._processRecipientAccounts(tree, transactions, blockHeight);\n            this._processContracts(tree, transactions, blockHeight);\n\n            const toBePruned = [];\n            for (const tx of transactions) {\n                const senderAccount = this._getSync(tx.sender, undefined, tree);\n                if (senderAccount.isToBePruned()) {\n                    toBePruned.push(new PrunedAccount(tx.sender, senderAccount));\n                }\n            }\n            return toBePruned.sort((a, b) => a.compare(b));\n        } finally {\n            await tree.abort();\n        }\n    }\n\n    /**\n     * @param {Block} block\n     * @param {TransactionCache} transactionCache\n     * @return {Promise}\n     */\n    async revertBlock(block, transactionCache) {\n        if (!block) throw new Error('block undefined');\n\n        const hash = await this._tree.root();\n        if (!block.accountsHash.equals(hash)) {\n            throw new Error('AccountsHash mismatch');\n        }\n        return this.revertBlockBody(block.body, block.height, transactionCache);\n    }\n\n    /**\n     * @param {BlockBody} body\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionCache\n     * @return {Promise}\n     */\n    async revertBlockBody(body, blockHeight, transactionCache) {\n        const tree = await this._tree.synchronousTransaction();\n        await tree.preloadAddresses(body.getAddresses());\n        try {\n            this._revertBlockBody(tree, body, blockHeight, transactionCache);\n        } catch (e) {\n            await tree.abort();\n            throw e;\n        }\n        tree.finalizeBatch();\n        return tree.commit();\n    }\n\n    /**\n     * Gets the {@link Account}-object for an address.\n     *\n     * @param {Address} address\n     * @param {Account.Type} [accountType]\n     * @param {AccountsTree} [tree]\n     * @return {Promise.<Account>}\n     */\n    async get(address, accountType, tree = this._tree) {\n        const account = await tree.get(address);\n        if (!account) {\n            if (typeof accountType === 'undefined') {\n                return Account.INITIAL;\n            }\n            throw new Error('Account type was given but account not present');\n        } else if (typeof accountType !== 'undefined' && account.type !== accountType) {\n            throw new Error('Account type does match actual account');\n        }\n        return account;\n    }\n\n    /**\n     * Gets the {@link Account}-object for an address.\n     *\n     * @param {Address} address\n     * @param {Account.Type} [accountType]\n     * @param {SynchronousAccountsTree} tree\n     * @private\n     * @return {Account}\n     */\n    _getSync(address, accountType, tree) {\n        const account = tree.getSync(address, false);\n        if (!account) {\n            if (typeof accountType === 'undefined') {\n                return Account.INITIAL;\n            }\n            throw new Error('Account type was given but account not present');\n        } else if (typeof accountType !== 'undefined' && account.type !== accountType) {\n            throw new Error('Account type does match actual account');\n        }\n        return account;\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {Promise.<Accounts>}\n     */\n    async transaction(enableWatchdog = true) {\n        return new Accounts(await this._tree.transaction(enableWatchdog));\n    }\n\n    /**\n     * @param {Accounts} [tx]\n     * @returns {Promise.<Accounts>}\n     */\n    async snapshot(tx) {\n        return new Accounts(await this._tree.snapshot(tx ? tx._tree : undefined));\n    }\n\n    /**\n     * @returns {Promise.<PartialAccountsTree>}\n     */\n    partialAccountsTree() {\n        return this._tree.partialTree();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    commit() {\n        return this._tree.commit();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    abort() {\n        return this._tree.abort();\n    }\n\n    /**\n     * Step 1)\n     * @param {SynchronousAccountsTree} tree\n     * @param {Array.<Transaction>} transactions\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionCache\n     * @param {boolean} [revert]\n     * @private\n     */\n    _processSenderAccounts(tree, transactions, blockHeight, transactionCache, revert = false) {\n        for (const tx of transactions) {\n            const senderAccount = this._getSync(tx.sender, !revert ? tx.senderType : undefined, tree);\n            tree.putBatch(tx.sender, senderAccount.withOutgoingTransaction(tx, blockHeight, transactionCache, revert));\n        }\n    }\n\n    /**\n     * Step 2)\n     * @param {SynchronousAccountsTree} tree\n     * @param {Array.<Transaction>} transactions\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @private\n     */\n    _processRecipientAccounts(tree, transactions, blockHeight, revert = false) {\n        for (const tx of transactions) {\n            const recipientAccount = this._getSync(tx.recipient, undefined, tree);\n            tree.putBatch(tx.recipient, recipientAccount.withIncomingTransaction(tx, blockHeight, revert));\n        }\n    }\n\n    /**\n     * Step 3)\n     * @param {SynchronousAccountsTree} tree\n     * @param {Array.<Transaction>} transactions\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @private\n     */\n    _processContracts(tree, transactions, blockHeight, revert = false) {\n        // TODO: Filter & sort contract command.\n        if (revert) {\n            transactions = transactions.slice().reverse();\n        }\n        for (const tx of transactions) {\n            const recipientAccount = this._getSync(tx.recipient, !revert ? undefined : tx.recipientType, tree);\n            tree.putBatch(tx.recipient, recipientAccount.withContractCommand(tx, blockHeight, revert));\n        }\n    }\n\n    /**\n     * @param {SynchronousAccountsTree} tree\n     * @param {BlockBody} body\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionCache\n     * @private\n     */\n    _commitBlockBody(tree, body, blockHeight, transactionCache) {\n        this._processSenderAccounts(tree, body.transactions, blockHeight, transactionCache);\n        this._processRecipientAccounts(tree, body.transactions, blockHeight);\n        this._processContracts(tree, body.transactions, blockHeight);\n\n        const prunedAccounts = body.prunedAccounts.slice();\n        for (const tx of body.transactions) {\n            const senderAccount = this._getSync(tx.sender, undefined, tree);\n            if (senderAccount.isToBePruned()) {\n                const accIdx = prunedAccounts.findIndex((acc) => acc.address.equals(tx.sender));\n                if (accIdx === -1 || !senderAccount.equals(prunedAccounts[accIdx].account)) {\n                    throw new Error('Account was not pruned correctly');\n                } else {\n                    // Pruned accounts are reset to their initial state\n                    tree.putBatch(tx.sender, Account.INITIAL);\n                    prunedAccounts.splice(accIdx, 1);\n                }\n            }\n        }\n        if (prunedAccounts.length > 0) {\n            throw new Error('Account was invalidly pruned');\n        }\n\n        this._rewardMiner(tree, body, blockHeight, false);\n    }\n\n    /**\n     * @param {SynchronousAccountsTree} tree\n     * @param {BlockBody} body\n     * @param {number} blockHeight\n     * @param {TransactionCache} transactionCache\n     * @private\n     */\n    _revertBlockBody(tree, body, blockHeight, transactionCache) {\n        this._rewardMiner(tree, body, blockHeight, true);\n\n        for (const acc of body.prunedAccounts) {\n            tree.putBatch(acc.address, acc.account);\n        }\n\n        // Execute transactions in reverse order.\n        this._processContracts(tree, body.transactions, blockHeight, true);\n        this._processRecipientAccounts(tree, body.transactions, blockHeight, true);\n        this._processSenderAccounts(tree, body.transactions, blockHeight, transactionCache, true);\n    }\n\n    /**\n     * @param {SynchronousAccountsTree} tree\n     * @param {BlockBody} body\n     * @param {number} blockHeight\n     * @param {boolean} [revert]\n     * @private\n     */\n    _rewardMiner(tree, body, blockHeight, revert = false) {\n        // Sum up transaction fees.\n        const txFees = body.transactions.reduce((sum, tx) => sum + tx.fee, 0);\n\n        // \"Coinbase transaction\"\n        const coinbaseTransaction = new ExtendedTransaction(\n            Address.NULL, Account.Type.BASIC,\n            body.minerAddr, Account.Type.BASIC,\n            txFees + Policy.blockRewardAt(blockHeight),\n            0, // Fee\n            0, // ValidityStartHeight\n            Transaction.Flag.NONE,\n            new Uint8Array(0));\n\n        const recipientAccount = this._getSync(body.minerAddr, undefined, tree);\n        tree.putBatch(body.minerAddr, recipientAccount.withIncomingTransaction(coinbaseTransaction, blockHeight, revert));\n    }\n\n    /**\n     * @returns {Promise.<Hash>}\n     */\n    hash() {\n        return this._tree.root();\n    }\n\n    /** @type {Transaction} */\n    get tx() {\n        return this._tree.tx;\n    }\n}\nClass.register(Accounts);\n","class BlockHeader {\n    /**\n     * @param {BlockHeader} o\n     * @returns {BlockHeader}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const prevHash = Hash.copy(o._prevHash);\n        const interlinkHash = Hash.copy(o._interlinkHash);\n        const bodyHash = Hash.copy(o._bodyHash);\n        const accountsHash = Hash.copy(o._accountsHash);\n        return new BlockHeader(\n            prevHash, interlinkHash, bodyHash, accountsHash,\n            o._nBits, o._height, o._timestamp, o._nonce, o._version\n        );\n    }\n\n    /**\n     * @param {Hash} prevHash\n     * @param {Hash} interlinkHash\n     * @param {Hash} bodyHash\n     * @param {Hash} accountsHash\n     * @param {number} nBits\n     * @param {number} height\n     * @param {number} timestamp\n     * @param {number} nonce\n     * @param {number} version\n     */\n    constructor(prevHash, interlinkHash, bodyHash, accountsHash, nBits, height, timestamp, nonce, version = BlockHeader.CURRENT_VERSION) {\n        if (!NumberUtils.isUint16(version)) throw 'Malformed version';\n        if (!Hash.isHash(prevHash)) throw 'Malformed prevHash';\n        if (!Hash.isHash(interlinkHash)) throw 'Malformed interlinkHash';\n        if (!Hash.isHash(bodyHash)) throw 'Malformed bodyHash';\n        if (!Hash.isHash(accountsHash)) throw 'Malformed accountsHash';\n        if (!NumberUtils.isUint32(nBits) || !BlockUtils.isValidCompact(nBits)) throw 'Malformed nBits';\n        if (!NumberUtils.isUint32(height)) throw 'Invalid height';\n        if (!NumberUtils.isUint32(timestamp)) throw 'Malformed timestamp';\n        if (!NumberUtils.isUint32(nonce)) throw 'Malformed nonce';\n\n        /** @type {number} */\n        this._version = version;\n        /** @type {Hash} */\n        this._prevHash = prevHash;\n        /** @type {Hash} */\n        this._interlinkHash = interlinkHash;\n        /** @type {Hash} */\n        this._bodyHash = bodyHash;\n        /** @type {Hash} */\n        this._accountsHash = accountsHash;\n        /** @type {number} */\n        this._nBits = nBits;\n        /** @type {number} */\n        this._height = height;\n        /** @type {number} */\n        this._timestamp = timestamp;\n        /** @type {number} */\n        this._nonce = nonce;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {BlockHeader}\n     */\n    static unserialize(buf) {\n        const version = buf.readUint16();\n        if (!BlockHeader.SUPPORTED_VERSIONS.includes(version)) throw new Error(`Unsupported block version ${version}`);\n        const prevHash = Hash.unserialize(buf);\n        const interlinkHash = Hash.unserialize(buf);\n        const bodyHash = Hash.unserialize(buf);\n        const accountsHash = Hash.unserialize(buf);\n        const nBits = buf.readUint32();\n        const height = buf.readUint32();\n        const timestamp = buf.readUint32();\n        const nonce = buf.readUint32();\n        return new BlockHeader(prevHash, interlinkHash, bodyHash, accountsHash, nBits, height, timestamp, nonce, version);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._version);\n        this._prevHash.serialize(buf);\n        this._interlinkHash.serialize(buf);\n        this._bodyHash.serialize(buf);\n        this._accountsHash.serialize(buf);\n        buf.writeUint32(this._nBits);\n        buf.writeUint32(this._height);\n        buf.writeUint32(this._timestamp);\n        buf.writeUint32(this._nonce);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*version*/ 2\n            + this._prevHash.serializedSize\n            + this._interlinkHash.serializedSize\n            + this._bodyHash.serializedSize\n            + this._accountsHash.serializedSize\n            + /*nBits*/ 4\n            + /*height*/ 4\n            + /*timestamp*/ 4\n            + /*nonce*/ 4;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Promise.<boolean>}\n     */\n    async verifyProofOfWork(buf) {\n        const pow = await this.pow(buf);\n        return BlockUtils.isProofOfWork(pow, this.target);\n    }\n\n    /**\n     * @param {BlockHeader} prevHeader\n     * @returns {boolean}\n     */\n    isImmediateSuccessorOf(prevHeader) {\n        // Check that the height is one higher than the previous height.\n        if (this.height !== prevHeader.height + 1) {\n            return false;\n        }\n\n        // Check that the timestamp is greater or equal to the predecessor's timestamp.\n        if (this.timestamp < prevHeader.timestamp) {\n            return false;\n        }\n\n        // Check that the hash of the predecessor block equals prevHash.\n        const prevHash = prevHeader.hash();\n        if (!this.prevHash.equals(prevHash)) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Hash}\n     */\n    hash(buf) {\n        this._hash = this._hash || Hash.light(this.serialize(buf));\n        return this._hash;\n    }\n    \n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {Promise.<Hash>}\n     */\n    async pow(buf) {\n        this._pow = this._pow || await Hash.hard(this.serialize(buf));\n        return this._pow;\n    }\n\n    /**\n     * @param {BlockHeader|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof BlockHeader\n            && this._prevHash.equals(o.prevHash)\n            && this._interlinkHash.equals(o.interlinkHash)\n            && this._bodyHash.equals(o.bodyHash)\n            && this._accountsHash.equals(o.accountsHash)\n            && this._nBits === o.nBits\n            && this._height === o.height\n            && this._timestamp === o.timestamp\n            && this._nonce === o.nonce;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return 'BlockHeader{'\n            + `prevHash=${this._prevHash}, `\n            + `interlinkHash=${this._interlinkHash}, `\n            + `bodyHash=${this._bodyHash}, `\n            + `accountsHash=${this._accountsHash}, `\n            + `nBits=${this._nBits.toString(16)}, `\n            + `height=${this._height}, `\n            + `timestamp=${this._timestamp}, `\n            + `nonce=${this._nonce}`\n            + '}';\n    }\n\n    /** @type {number} */\n    get version() {\n        return this._version;\n    }\n\n    /** @type {Hash} */\n    get prevHash() {\n        return this._prevHash;\n    }\n\n    /** @type {Hash} */\n    get interlinkHash() {\n        return this._interlinkHash;\n    }\n\n    /** @type {Hash} */\n    get bodyHash() {\n        return this._bodyHash;\n    }\n\n    /** @type {Hash} */\n    get accountsHash() {\n        return this._accountsHash;\n    }\n\n    /** @type {number} */\n    get nBits() {\n        return this._nBits;\n    }\n\n    /** @type {number} */\n    get target() {\n        return BlockUtils.compactToTarget(this._nBits);\n    }\n\n    /** @type {number} */\n    get difficulty() {\n        return BlockUtils.compactToDifficulty(this._nBits);\n    }\n\n    /** @type {number} */\n    get height() {\n        return this._height;\n    }\n\n    /** @type {number} */\n    get timestamp() {\n        return this._timestamp;\n    }\n\n    /** @type {number} */\n    get nonce() {\n        return this._nonce;\n    }\n\n    // XXX The miner changes the nonce of an existing BlockHeader during the\n    // mining process.\n    /** @type {number} */\n    set nonce(n) {\n        this._nonce = n;\n        this._hash = null;\n        this._pow = null;\n    }\n}\n// FIXME: Clean up for mainnet.\nBlockHeader.Version = {\n    V1: 1\n};\nBlockHeader.CURRENT_VERSION = BlockHeader.Version.V1;\nBlockHeader.SUPPORTED_VERSIONS = [\n    BlockHeader.Version.V1\n];\nBlockHeader.SERIALIZED_SIZE = 146;\nClass.register(BlockHeader);\n","class BlockInterlink {\n    /**\n     * @param {BlockInterlink} o\n     * @returns {BlockInterlink}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const hashes = o._hashes.map(it => Hash.copy(it));\n        const repeatBits = new Uint8Array(o._repeatBits);\n        const compressed = o._compressed.map(it => Hash.copy(it));\n        return new BlockInterlink(hashes, undefined, repeatBits, compressed);\n    }\n\n    /**\n     * @param {Array.<Hash>} hashes\n     * @param {Hash} prevHash\n     * @returns {{repeatBits: Uint8Array, compressed: Array.<Hash>}}\n     * @protected\n     */\n    static _compress(hashes, prevHash) {\n        const count = hashes.length;\n        const repeatBitsSize = Math.ceil(count / 8);\n        const repeatBits = new Uint8Array(repeatBitsSize);\n\n        let lastHash = prevHash;\n        const compressed = [];\n        for (let i = 0; i < count; i++) {\n            const hash = hashes[i];\n            if (!hash.equals(lastHash)) {\n                compressed.push(hash);\n                lastHash = hash;\n            } else {\n                repeatBits[Math.floor(i / 8)] |= 0x80 >>> (i % 8);\n            }\n        }\n\n        return {repeatBits, compressed};\n    }\n\n    /**\n     * @param {Array.<Hash>} hashes\n     * @param {Hash} [prevHash]\n     * @param {Uint8Array} [repeatBits]\n     * @param {Array.<Hash>} [compressed]\n     */\n    constructor(hashes, prevHash, repeatBits, compressed) {\n        if (!Array.isArray(hashes) || !NumberUtils.isUint8(hashes.length)\n            || hashes.some(it => !(it instanceof Hash))) throw new Error('Malformed hashes');\n        if ((repeatBits || compressed) && !(repeatBits && compressed)) throw new Error('Malformed repeatBits/compressed');\n        if (!prevHash && !repeatBits) throw new Error('Either prevHash or repeatBits/compressed required');\n\n        if (!repeatBits) {\n            ({repeatBits, compressed} = BlockInterlink._compress(hashes, prevHash));\n        }\n\n        /** @type {Array.<Hash>} */\n        this._hashes = hashes;\n        /** @type {Uint8Array} */\n        this._repeatBits = repeatBits;\n        /** @type {Array.<Hash>} */\n        this._compressed = compressed;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @param {Hash} prevHash\n     * @returns {BlockInterlink}\n     */\n    static unserialize(buf, prevHash) {\n        const count = buf.readUint8();\n        const repeatBitsSize = Math.ceil(count / 8);\n        const repeatBits = buf.read(repeatBitsSize);\n\n        let hash = prevHash;\n        const hashes = [];\n        const compressed = [];\n        for (let i = 0; i < count; i++) {\n            const repeated = (repeatBits[Math.floor(i / 8)] & (0x80 >>> (i % 8))) !== 0;\n            if (!repeated) {\n                hash = Hash.unserialize(buf);\n                compressed.push(hash);\n            }\n            hashes.push(hash);\n        }\n\n        return new BlockInterlink(hashes, prevHash, repeatBits, compressed);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._hashes.length);\n        buf.write(this._repeatBits);\n        for (const hash of this._compressed) {\n            hash.serialize(buf);\n        }\n        return buf;\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        return /*count*/ 1\n            + this._repeatBits.length\n            + this._compressed.reduce((sum, hash) => sum + hash.serializedSize, 0);\n    }\n\n    /**\n     * @param {BlockInterlink|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof BlockInterlink\n            && this._hashes.length === o._hashes.length\n            && this._hashes.every((hash, i) => hash.equals(o.hashes[i]));\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    hash() {\n        if (!this._hash) {\n            this._hash = MerkleTree.computeRoot([this._repeatBits, GenesisConfig.GENESIS_HASH, ...this._compressed]);\n        }\n        return this._hash;\n    }\n\n    /**\n     * @type {Array.<Hash>}\n     */\n    get hashes() {\n        return this._hashes;\n    }\n\n    /**\n     * @type {number}\n     */\n    get length() {\n        return this._hashes.length;\n    }\n}\nClass.register(BlockInterlink);\n","class BlockBody {\n    /**\n     * @param {Uint8Array} extraData\n     * @returns {number}\n     */\n    static getMetadataSize(extraData) {\n        return Address.SERIALIZED_SIZE\n            + /*extraDataLength*/ 1\n            + extraData.byteLength\n            + /*transactionsLength*/ 2\n            + /*prunedAccountsLength*/ 2;\n    }\n\n    /**\n     * @param {Address} minerAddr\n     * @param {Array.<Transaction>} transactions\n     * @param {Uint8Array} [extraData]\n     * @param {Array.<PrunedAccount>} prunedAccounts\n     */\n    constructor(minerAddr, transactions, extraData = new Uint8Array(0), prunedAccounts = []) {\n        if (!(minerAddr instanceof Address)) throw 'Malformed minerAddr';\n        if (!Array.isArray(transactions) || transactions.some(it => !(it instanceof Transaction))) throw 'Malformed transactions';\n        if (!(extraData instanceof Uint8Array) || !NumberUtils.isUint8(extraData.byteLength)) throw 'Malformed extraData';\n\n        /** @type {Address} */\n        this._minerAddr = minerAddr;\n        /** @type {Uint8Array} */\n        this._extraData = extraData;\n        /** @type {Array.<Transaction>} */\n        this._transactions = transactions;\n        /** @type {Array.<PrunedAccount>} */\n        this._prunedAccounts = prunedAccounts;\n        /** @type {Hash} */\n        this._hash = null;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {BlockBody}\n     */\n    static unserialize(buf) {\n        const minerAddr = Address.unserialize(buf);\n        const extraDataLength = buf.readUint8();\n        const extraData = buf.read(extraDataLength);\n        const numTransactions = buf.readUint16();\n        const transactions = new Array(numTransactions);\n        for (let i = 0; i < numTransactions; i++) {\n            transactions[i] = Transaction.unserialize(buf);\n        }\n        const numPrunedAccounts = buf.readUint16();\n        const prunedAccounts = [];\n        for (let i = 0; i < numPrunedAccounts; i++) {\n            prunedAccounts.push(PrunedAccount.unserialize(buf));\n        }\n        return new BlockBody(minerAddr, transactions, extraData, prunedAccounts);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._minerAddr.serialize(buf);\n        buf.writeUint8(this._extraData.byteLength);\n        buf.write(this._extraData);\n        buf.writeUint16(this._transactions.length);\n        for (const tx of this._transactions) {\n            tx.serialize(buf);\n        }\n        buf.writeUint16(this._prunedAccounts.length);\n        for (const acc of this._prunedAccounts) {\n            acc.serialize(buf);\n        }\n        return buf;\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        let size = this._minerAddr.serializedSize\n            + /*extraDataLength*/ 1\n            + this._extraData.byteLength\n            + /*transactionsLength*/ 2\n            + /*prunedAccountsLength*/ 2;\n        for (const tx of this._transactions) {\n            size += tx.serializedSize;\n        }\n        size += this._prunedAccounts.reduce((sum, acc) => sum + acc.serializedSize, 0);\n        return size;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    verify() {\n        /** @type {Transaction} */\n        let previousTx = null;\n        for (const tx of this._transactions) {\n            // Ensure transactions are ordered and unique.\n            if (previousTx && previousTx.compareBlockOrder(tx) >= 0) {\n                Log.w(BlockBody, 'Invalid block - transactions not ordered.');\n                return false;\n            }\n            previousTx = tx;\n\n            // Check that all transactions are valid.\n            if (!tx.verify()) {\n                Log.w(BlockBody, 'Invalid block - invalid transaction');\n                return false;\n            }\n        }\n\n        let previousAcc = null;\n        for (const acc of this._prunedAccounts) {\n            // Ensure pruned accounts are ordered and unique.\n            if (previousAcc && previousAcc.compare(acc) >= 0) {\n                Log.w(BlockBody, 'Invalid block - pruned accounts not ordered.');\n                return false;\n            }\n            previousAcc = acc;\n            \n            // Check that pruned accounts are actually supposed to be pruned\n            if (!acc.account.isToBePruned()) {\n                Log.w(BlockBody, 'Invalid block - invalid pruned account');\n                return false;\n            }\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {Array}\n     */\n    getMerkleLeafs() {\n        return [this._minerAddr, this._extraData, ...this._transactions, ...this.prunedAccounts];\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        if (!this._hash) {\n            this._hash = MerkleTree.computeRoot(this.getMerkleLeafs());\n        }\n        return this._hash;\n    }\n\n    /**\n     * @param {BlockBody} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof BlockBody\n            && this._minerAddr.equals(o.minerAddr)\n            && BufferUtils.equals(this._extraData, o.extraData)\n            && this._transactions.length === o.transactions.length\n            && this._transactions.every((tx, i) => tx.equals(o.transactions[i]));\n    }\n\n    /**\n     * @return {Array.<Address>}\n     */\n    getAddresses() {\n        const addresses = [this._minerAddr];\n        for (const tx of this._transactions) {\n            addresses.push(tx.sender, tx.recipient);\n        }\n        return addresses;\n    }\n\n    /** @type {Uint8Array} */\n    get extraData() {\n        return this._extraData;\n    }\n\n    /** @type {Address} */\n    get minerAddr() {\n        return this._minerAddr;\n    }\n\n    /** @type {Array.<Transaction>} */\n    get transactions() {\n        return this._transactions;\n    }\n\n    /** @type {number} */\n    get transactionCount() {\n        return this._transactions.length;\n    }\n\n    /** @type {Array.<PrunedAccount>} */\n    get prunedAccounts() {\n        return this._prunedAccounts;\n    }\n}\n\nClass.register(BlockBody);\n","class BlockUtils {\n    /**\n     * @param {number} compact\n     * @returns {number}\n     */\n    static compactToTarget(compact) {\n        return (compact & 0xffffff) * Math.pow(2, (8 * ((compact >> 24) - 3)));\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static targetToCompact(target) {\n        if (!Number.isFinite(target) || Number.isNaN(target)) throw 'Invalid Target';\n\n        // Divide to get first byte\n        let size = Math.max(Math.ceil(Math.log2(target) / 8), 1);\n        const firstByte = target / Math.pow(2, (size - 1) * 8);\n\n        // If the first (most significant) byte is greater than 127 (0x7f),\n        // prepend a zero byte.\n        if (firstByte >= 0x80) {\n            size++;\n        }\n\n        // The first byte of the 'compact' format is the number of bytes,\n        // including the prepended zero if it's present.\n        // The following three bytes are the first three bytes of the above\n        // representation. If less than three bytes are present, then one or\n        // more of the last bytes of the compact representation will be zero.\n        return (size << 24) + ((target / Math.pow(2, (size - 3) * 8)) & 0xffffff);\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static getTargetHeight(target) {\n        return Math.ceil(Math.log2(target));\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static getTargetDepth(target) {\n        return BlockUtils.getTargetHeight(Policy.BLOCK_TARGET_MAX) - BlockUtils.getTargetHeight(target);\n    }\n\n    /**\n     * @param {number} compact\n     * @returns {number}\n     */\n    static compactToDifficulty(compact) {\n        return Policy.BLOCK_TARGET_MAX / BlockUtils.compactToTarget(compact);\n    }\n\n    /**\n     * @param {number} difficulty\n     * @returns {number}\n     */\n    static difficultyToCompact(difficulty) {\n        return BlockUtils.targetToCompact(BlockUtils.difficultyToTarget(difficulty));\n    }\n\n    /**\n     * @param {number} difficulty\n     * @returns {number}\n     */\n    static difficultyToTarget(difficulty) {\n        return Policy.BLOCK_TARGET_MAX / difficulty;\n    }\n\n    /**\n     * @param {number} target\n     * @returns {number}\n     */\n    static targetToDifficulty(target) {\n        return Policy.BLOCK_TARGET_MAX / target;\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {number}\n     */\n    static hashToTarget(hash) {\n        return parseInt(hash.toHex(), 16);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {number}\n     */\n    static realDifficulty(hash) {\n        return BlockUtils.targetToDifficulty(BlockUtils.hashToTarget(hash));\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {number}\n     */\n    static getHashDepth(hash) {\n        return BlockUtils.getTargetDepth(BlockUtils.hashToTarget(hash));\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {number} target\n     * @returns {boolean}\n     */\n    static isProofOfWork(hash, target) {\n        return parseInt(hash.toHex(), 16) <= target;\n    }\n\n    /**\n     * @param {number} compact\n     * @returns {boolean}\n     */\n\n    static isValidCompact(compact) {\n        return BlockUtils.isValidTarget(BlockUtils.compactToTarget(compact));\n    }\n\n    /**\n     * @param {number} target\n     * @returns {boolean}\n     */\n    static isValidTarget(target) {\n        return target >= 1 && target <= Policy.BLOCK_TARGET_MAX;\n    }\n\n    /**\n     * @param {BlockHeader} headBlock\n     * @param {BlockHeader} tailBlock\n     * @param {number} deltaTotalDifficulty\n     * @returns {number}\n     */\n    static getNextTarget(headBlock, tailBlock, deltaTotalDifficulty) {\n        Assert.that(\n            (headBlock.height - tailBlock.height === Policy.DIFFICULTY_BLOCK_WINDOW)\n                || (headBlock.height <= Policy.DIFFICULTY_BLOCK_WINDOW && tailBlock.height === 1),\n            `Tail and head block must be ${Policy.DIFFICULTY_BLOCK_WINDOW} blocks apart`);\n\n        let actualTime = headBlock.timestamp - tailBlock.timestamp;\n\n        // Simulate that the Policy.BLOCK_TIME was achieved for the blocks before the genesis block, i.e. we simulate\n        // a sliding window that starts before the genesis block. Assume difficulty = 1 for these blocks.\n        if (headBlock.height <= Policy.DIFFICULTY_BLOCK_WINDOW) {\n            actualTime += (Policy.DIFFICULTY_BLOCK_WINDOW - headBlock.height + 1) * Policy.BLOCK_TIME;\n            deltaTotalDifficulty += Policy.DIFFICULTY_BLOCK_WINDOW - headBlock.height + 1;\n        }\n\n        // Compute the target adjustment factor.\n        const expectedTime = Policy.DIFFICULTY_BLOCK_WINDOW * Policy.BLOCK_TIME;\n        let adjustment = actualTime / expectedTime;\n\n        // Clamp the adjustment factor to [1 / MAX_ADJUSTMENT_FACTOR, MAX_ADJUSTMENT_FACTOR].\n        adjustment = Math.max(adjustment, 1 / Policy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR);\n        adjustment = Math.min(adjustment, Policy.DIFFICULTY_MAX_ADJUSTMENT_FACTOR);\n\n        // Compute the next target.\n        const averageDifficulty = deltaTotalDifficulty / Policy.DIFFICULTY_BLOCK_WINDOW;\n        const averageTarget = BlockUtils.difficultyToTarget(averageDifficulty);\n        let nextTarget = averageTarget * adjustment;\n\n        // Make sure the target is below or equal the maximum allowed target (difficulty 1).\n        // Also enforce a minimum target of 1.\n        nextTarget = Math.min(nextTarget, Policy.BLOCK_TARGET_MAX);\n        nextTarget = Math.max(nextTarget, 1);\n\n        // XXX Reduce target precision to nBits precision.\n        const nBits = BlockUtils.targetToCompact(nextTarget);\n        return BlockUtils.compactToTarget(nBits);\n    }\n}\nClass.register(BlockUtils);\n","class Subscription {\n    /**\n     * @param {Array.<Address>} addresses\n     */\n    static fromAddresses(addresses) {\n        return new Subscription(Subscription.Type.ADDRESSES, addresses);\n    }\n\n    /**\n     * @param {number} addresses\n     */\n    static fromMinFeePerByte(minFeePerByte) {\n        return new Subscription(Subscription.Type.MIN_FEE, minFeePerByte);\n    }\n\n    /**\n     * @param {Subscription.Type} type\n     * @param {Array.<Address>|number} [filter]\n     */\n    constructor(type, filter=null) {\n        if (!NumberUtils.isUint8(type)) throw new Error('Invalid type');\n        if (type === Subscription.Type.ADDRESSES\n            && (!Array.isArray(filter) || !NumberUtils.isUint16(filter.length)\n            || filter.some(it => !(it instanceof Address)))) throw new Error('Invalid addresses');\n        if (type === Subscription.Type.MIN_FEE && !NumberUtils.isUint64(filter)) throw new Error('Invalid minFeePerByte');\n        this._type = type;\n\n        this._addresses = new HashSet();\n        this._minFeePerByte = 0;\n\n        switch (type) {\n            case Subscription.Type.ADDRESSES:\n                this._addresses.addAll(filter);\n                break;\n            case Subscription.Type.MIN_FEE:\n                this._minFeePerByte = filter;\n                break;\n        }\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Subscription}\n     */\n    static unserialize(buf) {\n        const type = /** @type {Subscription.Type} */ buf.readUint8();\n        let filter = null;\n        switch (type) {\n            case Subscription.Type.ADDRESSES: {\n                filter = [];\n                const size = buf.readUint16();\n                for (let i = 0; i < size; ++i) {\n                    filter.push(Address.unserialize(buf));\n                }\n                break;\n            }\n            case Subscription.Type.MIN_FEE:\n                filter = buf.readUint64();\n                break;\n        }\n        return new Subscription(type, filter);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._type);\n        switch (this._type) {\n            case Subscription.Type.ADDRESSES:\n                buf.writeUint16(this._addresses.length);\n                for (const address of this._addresses) {\n                    address.serialize(buf);\n                }\n                break;\n            case Subscription.Type.MIN_FEE:\n                buf.writeUint64(this._minFeePerByte);\n                break;\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let additionalSize = 0;\n        switch (this._type) {\n            case Subscription.Type.ADDRESSES:\n                additionalSize = /*length*/ 2;\n                for (const address of this._addresses) {\n                    additionalSize += address.serializedSize;\n                }\n                break;\n            case Subscription.Type.MIN_FEE:\n                additionalSize = /*minFeePerByte*/ 8;\n                break;\n        }\n        return /*type*/ 1\n            + additionalSize;\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {boolean}\n     */\n    matchesBlock(block) {\n        switch (this._type) {\n            case Subscription.Type.NONE:\n                return false;\n            case Subscription.Type.ANY:\n            case Subscription.Type.ADDRESSES:\n            case Subscription.Type.MIN_FEE:\n                return true;\n            default:\n                throw new Error('Unknown type');\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @returns {boolean}\n     */\n    matchesTransaction(transaction) {\n        switch (this._type) {\n            case Subscription.Type.NONE:\n                return false;\n            case Subscription.Type.ANY:\n                return true;\n            case Subscription.Type.ADDRESSES:\n                return this._addresses.contains(transaction.recipient) || this._addresses.contains(transaction.sender);\n            case Subscription.Type.MIN_FEE:\n                return transaction.fee / transaction.serializedSize >= this._minFeePerByte;\n            default:\n                throw new Error('Unknown type');\n        }\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `Subscription{type=${this._type}, addresses=[${this._addresses.values()}], minFeePerByte=${this._minFeePerByte}}`;\n    }\n\n    /** @type {Subscription.Type} */\n    get type() {\n        return this._type;\n    }\n\n    /** @type {Array.<Address>} */\n    get addresses() {\n        return this._addresses.values();\n    }\n\n    /** @type {number} */\n    get minFeePerByte() {\n        return this._minFeePerByte;\n    }\n}\n/** @enum {number} */\nSubscription.Type = {\n    NONE: 0,\n    ANY: 1,\n    ADDRESSES: 2,\n    MIN_FEE: 3\n};\nSubscription.NONE = new Subscription(Subscription.Type.NONE);\nSubscription.BLOCKS_ONLY = new Subscription(Subscription.Type.ADDRESSES, []);\nSubscription.ANY = new Subscription(Subscription.Type.ANY);\nClass.register(Subscription);\n","/**\n * @abstract\n */\nclass Transaction {\n    /**\n     * @param {Transaction.Format} format\n     * @param {Address} sender\n     * @param {Account.Type} senderType\n     * @param {Address} recipient\n     * @param {Account.Type} recipientType\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Transaction.Flag | *} flags\n     * @param {Uint8Array} data\n     * @param {Uint8Array} [proof]\n     * @param {number} [networkId]\n     */\n    constructor(format, sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof, networkId = GenesisConfig.NETWORK_ID) {\n        if (!(sender instanceof Address)) throw new Error('Malformed sender');\n        if (!NumberUtils.isUint8(senderType)) throw new Error('Malformed sender type');\n        if (!(recipient instanceof Address)) throw new Error('Malformed recipient');\n        if (!NumberUtils.isUint8(recipientType)) throw new Error('Malformed recipient type');\n        if (!NumberUtils.isUint64(value) || value === 0) throw new Error('Malformed value');\n        if (!NumberUtils.isUint64(fee)) throw new Error('Malformed fee');\n        if (!NumberUtils.isUint32(validityStartHeight)) throw new Error('Malformed validityStartHeight');\n        if (!NumberUtils.isUint8(flags) && (flags & ~(Transaction.Flag.ALL)) > 0) throw new Error('Malformed flags');\n        if (!(data instanceof Uint8Array) || !(NumberUtils.isUint16(data.byteLength))) throw new Error('Malformed data');\n        if (proof && (!(proof instanceof Uint8Array) || !(NumberUtils.isUint16(proof.byteLength)))) throw new Error('Malformed proof');\n        if (!NumberUtils.isUint8(networkId)) throw new Error('Malformed networkId');\n\n        /** @type {Transaction.Format} */\n        this._format = format;\n        /** @type {Address} */\n        this._sender = sender;\n        /** @type {Account.Type} */\n        this._senderType = senderType;\n        /** @type {Address} */\n        this._recipient = recipient;\n        /** @type {Account.Type} */\n        this._recipientType = recipientType;\n        /** @type {number} */\n        this._value = value;\n        /** @type {number} */\n        this._fee = fee;\n        /** @type {number} */\n        this._networkId = networkId;\n        /** @type {number} */\n        this._validityStartHeight = validityStartHeight;\n        /** @type {Transaction.Flag | *} */\n        this._flags = flags;\n        /** @type {Uint8Array} */\n        this._data = data;\n        /** @type {Uint8Array} */\n        this._proof = proof;\n\n        if (this._recipient === Address.CONTRACT_CREATION) this._recipient = this.getContractCreationAddress();\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const format = /** @type {Transaction.Format} */ buf.readUint8();\n        buf.readPos--;\n\n        if (!Transaction.FORMAT_MAP.has(format)) throw new Error('Invalid transaction type');\n        return Transaction.FORMAT_MAP.get(format).unserialize(buf);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serializeContent(buf) {\n        buf = buf || new SerialBuffer(this.serializedContentSize);\n        buf.writeUint16(this._data.byteLength);\n        buf.write(this._data);\n        this._sender.serialize(buf);\n        buf.writeUint8(this._senderType);\n        this._recipient.serialize(buf);\n        buf.writeUint8(this._recipientType);\n        buf.writeUint64(this._value);\n        buf.writeUint64(this._fee);\n        buf.writeUint32(this._validityStartHeight);\n        buf.writeUint8(this._networkId);\n        buf.writeUint8(this._flags);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedContentSize() {\n        return /*dataSize*/ 2\n            + this._data.byteLength\n            + this._sender.serializedSize\n            + /*senderType*/ 1\n            + this._recipient.serializedSize\n            + /*recipientType*/ 1\n            + /*value*/ 8\n            + /*fee*/ 8\n            + /*validityStartHeight*/ 4\n            + /*networkId*/ 1\n            + /*flags*/ 1;\n    }\n\n    /**\n     * @param {number} [networkId]\n     * @returns {boolean}\n     */\n    verify(networkId) {\n        if (this._valid === undefined) {\n            this._valid = this._verify(networkId);\n        }\n        return this._valid;\n    }\n\n    /**\n     * @param {number} [networkId]\n     * @returns {boolean}\n     * @private\n     */\n    _verify(networkId = GenesisConfig.NETWORK_ID) {\n        if (this._networkId !== networkId) {\n            Log.w(Transaction, 'Transaction is not valid in this network', this);\n            return false;\n        }\n        // Check that sender != recipient.\n        if (this._recipient.equals(this._sender)) {\n            Log.w(Transaction, 'Sender and recipient must not match', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.has(this._senderType) || !Account.TYPE_MAP.has(this._recipientType)) {\n            Log.w(Transaction, 'Invalid account type', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.get(this._senderType).verifyOutgoingTransaction(this)) {\n            Log.w(Transaction, 'Invalid for sender', this);\n            return false;\n        }\n        if (!Account.TYPE_MAP.get(this._recipientType).verifyIncomingTransaction(this)) {\n            Log.w(Transaction, 'Invalid for recipient', this);\n            return false;\n        }\n        return true;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        throw new Error('Getter needs to be overwritten by subclasses');\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        throw new Error('Method needs to be overwritten by subclasses');\n    }\n\n    /**\n     * @return {Hash}\n     */\n    hash() {\n        // Exclude the signature, we don't want transactions to be malleable.\n        this._hash = this._hash || Hash.light(this.serializeContent());\n        return this._hash;\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {number}\n     */\n    compare(o) {\n        if (this.fee / this.serializedSize > o.fee / o.serializedSize) return -1;\n        if (this.fee / this.serializedSize < o.fee / o.serializedSize) return 1;\n        if (this.serializedSize > o.serializedSize) return -1;\n        if (this.serializedSize < o.serializedSize) return 1;\n        if (this.fee > o.fee) return -1;\n        if (this.fee < o.fee) return 1;\n        if (this.value > o.value) return -1;\n        if (this.value < o.value) return 1;\n        return this.compareBlockOrder(o);\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {number}\n     */\n    compareBlockOrder(o) {\n        // This function must return 0 iff this.equals(o).\n        const recCompare = this._recipient.compare(o._recipient);\n        if (recCompare !== 0) return recCompare;\n        if (this._validityStartHeight < o._validityStartHeight) return -1;\n        if (this._validityStartHeight > o._validityStartHeight) return 1;\n        if (this._fee > o._fee) return -1;\n        if (this._fee < o._fee) return 1;\n        if (this._value > o._value) return -1;\n        if (this._value < o._value) return 1;\n        const senderCompare = this._sender.compare(o._sender);\n        if (senderCompare !== 0) return senderCompare;\n        if (this._recipientType < o._recipientType) return -1;\n        if (this._recipientType > o._recipientType) return 1;\n        if (this._senderType < o._senderType) return -1;\n        if (this._senderType > o._senderType) return 1;\n        if (this._flags < o._flags) return -1;\n        if (this._flags > o._flags) return 1;\n        return BufferUtils.compare(this._data, o._data);\n    }\n\n    /**\n     * @param {Transaction} o\n     * @return {boolean}\n     */\n    equals(o) {\n        // This ignores format and proof to be consistent with hash():\n        //   tx1.hash() == tx2.hash() iff tx1.equals(t2)\n        return o instanceof Transaction\n            && this._sender.equals(o._sender)\n            && this._senderType === o._senderType\n            && this._recipient.equals(o._recipient)\n            && this._recipientType === o._recipientType\n            && this._value === o._value\n            && this._fee === o._fee\n            && this._validityStartHeight === o._validityStartHeight\n            && this._networkId === o._networkId\n            && this._flags === o._flags\n            && BufferUtils.equals(this._data, o._data);\n    }\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return `Transaction{`\n            + `sender=${this._sender.toBase64()}, `\n            + `recipient=${this._recipient.toBase64()}, `\n            + `value=${this._value}, `\n            + `fee=${this._fee}, `\n            + `validityStartHeight=${this._validityStartHeight}, `\n            + `networkId=${this._networkId}`\n            + `}`;\n    }\n\n    /**\n     * @return {Address}\n     */\n    getContractCreationAddress() {\n        const tx = Transaction.unserialize(this.serialize());\n        tx._recipient = Address.NULL;\n        tx._hash = null;\n        return Address.fromHash(tx.hash());\n    }\n\n    /** @type {Address} */\n    get sender() {\n        return this._sender;\n    }\n\n    /** @type {Account.Type} */\n    get senderType() {\n        return this._senderType;\n    }\n\n    /** @type {Address} */\n    get recipient() {\n        return this._recipient;\n    }\n\n    /** @type {Account.Type} */\n    get recipientType() {\n        return this._recipientType;\n    }\n\n    /** @type {number} */\n    get value() {\n        return this._value;\n    }\n\n    /** @type {number} */\n    get fee() {\n        return this._fee;\n    }\n\n    /** @type {number} */\n    get feePerByte() {\n        return this._fee / this.serializedSize;\n    }\n\n    /** @type {number} */\n    get networkId() {\n        return this._networkId;\n    }\n\n    /** @type {number} */\n    get validityStartHeight() {\n        return this._validityStartHeight;\n    }\n\n    /** @type {number} */\n    get flags() {\n        return this._flags;\n    }\n\n    /**\n     * @param {Transaction.Flag} flag\n     * @returns {boolean}\n     */\n    hasFlag(flag) {\n        return (this._flags & flag) > 0;\n    }\n\n    /** @type {Uint8Array} */\n    get data() {\n        return this._data;\n    }\n\n    /** @type {Uint8Array} */\n    get proof() {\n        return this._proof;\n    }\n\n    // Sender proof is set by the Wallet after signing a transaction.\n    /** @type {Uint8Array} */\n    set proof(proof) {\n        this._proof = proof;\n    }\n}\n\n/**\n * Enum for Transaction formats.\n * @enum\n */\nTransaction.Format = {\n    BASIC: 0,\n    EXTENDED: 1\n};\n/**\n * @enum\n */\nTransaction.Flag = {\n    NONE: 0,\n    CONTRACT_CREATION: 0b1,\n    ALL: 0b1\n};\n/** @type {Map.<Transaction.Format, {unserialize: function(buf: SerialBuffer):Transaction}>} */\nTransaction.FORMAT_MAP = new Map();\n\nClass.register(Transaction);\n","class SignatureProof {\n    /**\n     * @param {Transaction} transaction\n     * @returns {boolean}\n     */\n    static verifyTransaction(transaction) {\n        try {\n            const buffer = new SerialBuffer(transaction.proof);\n            const proof = SignatureProof.unserialize(buffer);\n\n            // Reject proof if it is longer than needed.\n            if (buffer.readPos !== buffer.byteLength) {\n                Log.w(SignatureProof, 'Invalid SignatureProof - overlong');\n                return false;\n            }\n\n            return proof.verify(transaction.sender, transaction.serializeContent());\n        } catch (e) {\n            Log.w(SignatureProof, `Failed to verify transaction: ${e.message || e}`, e);\n            return false;\n        }\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Signature} signature\n     * @returns {SignatureProof}\n     */\n    static singleSig(publicKey, signature) {\n        return new SignatureProof(publicKey, new MerklePath([]), signature);\n    }\n\n    /**\n     * @param {PublicKey} signerKey\n     * @param {Array.<PublicKey>} publicKeys\n     * @param {Signature} signature\n     * @returns {SignatureProof}\n     */\n    static multiSig(signerKey, publicKeys, signature) {\n        const merklePath = MerklePath.compute(publicKeys, signerKey);\n        return new SignatureProof(signerKey, merklePath, signature);\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {MerklePath} merklePath\n     * @param {Signature} signature\n     */\n    constructor(publicKey, merklePath, signature) {\n        if (!(publicKey instanceof PublicKey)) throw new Error('Malformed publickKey');\n        if (!(merklePath instanceof MerklePath)) throw new Error('Malformed merklePath');\n        if (signature && !(signature instanceof Signature)) throw new Error('Malformed signature');\n\n        /**\n         * @type {PublicKey}\n         * @private\n         */\n        this._publicKey = publicKey;\n        /**\n         * @type {MerklePath}\n         * @private\n         */\n        this._merklePath = merklePath;\n        /**\n         * @type {Signature}\n         * @private\n         */\n        this._signature = signature;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {SignatureProof}\n     */\n    static unserialize(buf) {\n        const publicKey = PublicKey.unserialize(buf);\n        const merklePath = MerklePath.unserialize(buf);\n        const signature = Signature.unserialize(buf);\n        return new SignatureProof(publicKey, merklePath, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._publicKey.serialize(buf);\n        this._merklePath.serialize(buf);\n\n        // The SignatureProof is sometimes serialized before the signature is set (e.g. when creating transactions).\n        // Simply don't serialize the signature if it's missing as this should never go over the wire.\n        // We always expect the signature to be present when unserializing.\n        if (this._signature) {\n            this._signature.serialize(buf);\n        }\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._publicKey.serializedSize\n            + this._merklePath.serializedSize\n            + (this._signature ? this._signature.serializedSize : 0);\n    }\n\n    /**\n     * @param {SignatureProof} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof SignatureProof\n            && this._publicKey.equals(o._publicKey)\n            && this._merklePath.equals(o._merklePath)\n            && (this._signature ? this._signature.equals(o._signature) : this._signature === o._signature);\n    }\n\n    /**\n     * @param {?Address} sender\n     * @param {Uint8Array} data\n     * @returns {boolean}\n     */\n    verify(sender, data) {\n        if (sender !== null && !this.isSignedBy(sender)) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signer does not match sender address');\n            return false;\n        }\n\n        if (!this._signature) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signature is missing');\n            return false;\n        }\n\n        if (!this._signature.verify(this._publicKey, data)) {\n            Log.w(SignatureProof, 'Invalid SignatureProof - signature is invalid');\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {Address} sender\n     * @returns {boolean}\n     */\n    isSignedBy(sender) {\n        const merkleRoot = this._merklePath.computeRoot(this._publicKey);\n        const signerAddr = Address.fromHash(merkleRoot);\n        return signerAddr.equals(sender);\n    }\n\n    /** @type {PublicKey} */\n    get publicKey() {\n        return this._publicKey;\n    }\n\n    /** @type {MerklePath} */\n    get merklePath() {\n        return this._merklePath;\n    }\n\n    /** @type {Signature} */\n    get signature() {\n        return this._signature;\n    }\n\n    /** @type {Signature} */\n    set signature(signature) {\n        this._signature = signature;\n    }\n}\n\nClass.register(SignatureProof);\n","class BasicTransaction extends Transaction {\n    /**\n     * @param {PublicKey} senderPubKey\n     * @param {Address} recipient\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Signature} [signature]\n     * @param {number} [networkId]\n     */\n    constructor(senderPubKey, recipient, value, fee, validityStartHeight, signature, networkId) {\n        if (!(senderPubKey instanceof PublicKey)) throw new Error('Malformed senderPubKey');\n        // Signature may be initially empty and can be set later.\n        if (signature !== undefined && !(signature instanceof Signature)) throw new Error('Malformed signature');\n\n        const proof = SignatureProof.singleSig(senderPubKey, signature);\n        super(Transaction.Format.BASIC, senderPubKey.toAddress(), Account.Type.BASIC, recipient, Account.Type.BASIC, value, fee, validityStartHeight, Transaction.Flag.NONE, new Uint8Array(0), proof.serialize(), networkId);\n\n        /**\n         * @type {SignatureProof}\n         * @private\n         */\n        this._signatureProof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const type = buf.readUint8();\n        Assert.that(type === Transaction.Format.BASIC);\n\n        const senderPubKey = PublicKey.unserialize(buf);\n        const recipient = Address.unserialize(buf);\n        const value = buf.readUint64();\n        const fee = buf.readUint64();\n        const validityStartHeight = buf.readUint32();\n        const networkId = buf.readUint8();\n        const signature = Signature.unserialize(buf);\n        return new BasicTransaction(senderPubKey, recipient, value, fee, validityStartHeight, signature, networkId);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(Transaction.Format.BASIC);\n        this.senderPubKey.serialize(buf);\n        this._recipient.serialize(buf);\n        buf.writeUint64(this._value);\n        buf.writeUint64(this._fee);\n        buf.writeUint32(this._validityStartHeight);\n        buf.writeUint8(this._networkId);\n        this.signature.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*type*/ 1\n            + this.senderPubKey.serializedSize\n            + this._recipient.serializedSize\n            + /*value*/ 8\n            + /*fee*/ 8\n            + /*validityStartHeight*/ 4\n            + /*networkId*/ 1\n            + this.signature.serializedSize;\n    }\n\n    /**\n     * @type {PublicKey}\n     */\n    get senderPubKey() {\n        return this._signatureProof.publicKey;\n    }\n\n    /**\n     * @type {Signature}\n     */\n    get signature() {\n        return this._signatureProof.signature;\n    }\n\n    /**\n     * @type {Signature}\n     */\n    set signature(signature) {\n        this._signatureProof.signature = signature;\n        this._proof = this._signatureProof.serialize();\n    }\n}\nTransaction.FORMAT_MAP.set(Transaction.Format.BASIC, BasicTransaction);\nClass.register(BasicTransaction);\n","class ExtendedTransaction extends Transaction {\n\n    /**\n     * @param {Address} sender\n     * @param {Account.Type} senderType\n     * @param {Address} recipient\n     * @param {Account.Type} recipientType\n     * @param {number} value\n     * @param {number} fee\n     * @param {number} validityStartHeight\n     * @param {Transaction.Flag | *} flags\n     * @param {Uint8Array} data\n     * @param {Uint8Array} [proof]\n     * @param {number} [networkId]\n     */\n    constructor(sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof = new Uint8Array(0), networkId) {\n        super(Transaction.Format.EXTENDED, sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof, networkId);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {Transaction}\n     */\n    static unserialize(buf) {\n        const type = /** @type {Transaction.Format} */ buf.readUint8();\n        Assert.that(type === Transaction.Format.EXTENDED);\n\n        const dataSize = buf.readUint16();\n        const data = buf.read(dataSize);\n        const sender = Address.unserialize(buf);\n        const senderType = /** @type {Account.Type} */ buf.readUint8();\n        const recipient = Address.unserialize(buf);\n        const recipientType = /** @type {Account.Type} */ buf.readUint8();\n        const value = buf.readUint64();\n        const fee = buf.readUint64();\n        const validityStartHeight = buf.readUint32();\n        const networkId = buf.readUint8();\n        const flags = buf.readUint8();\n        const proofSize = buf.readUint16();\n        const proof = buf.read(proofSize);\n        return new ExtendedTransaction(sender, senderType, recipient, recipientType, value, fee, validityStartHeight, flags, data, proof, networkId);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(Transaction.Format.EXTENDED);\n        this.serializeContent(buf);\n        buf.writeUint16(this._proof.byteLength);\n        buf.write(this._proof);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*type*/ 1\n            + this.serializedContentSize\n            + /*proofSize*/ 2\n            + this._proof.byteLength;\n    }\n}\n\nTransaction.FORMAT_MAP.set(Transaction.Format.EXTENDED, ExtendedTransaction);\nClass.register(ExtendedTransaction);\n","class TransactionsProof {\n    /**\n     * @param {Array.<Transaction>} transactions\n     * @param {MerkleProof} proof\n     */\n    constructor(transactions, proof) {\n        if (!Array.isArray(transactions) || !NumberUtils.isUint16(transactions.length)\n            || transactions.some(it => !(it instanceof Transaction))) throw new Error('Malformed transactions');\n        if (!(proof instanceof MerkleProof)) throw new Error('Malformed merkle proof');\n\n        /** @type {Array.<Transaction>} */\n        this._transactions = transactions;\n        /** @type {MerkleProof} */\n        this._proof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {TransactionsProof}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint16();\n        const transactions = [];\n        for (let i = 0; i < count; ++i) {\n            transactions.push(Transaction.unserialize(buf));\n        }\n        const proof = MerkleProof.unserialize(buf);\n        return new TransactionsProof(transactions, proof);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._transactions.length);\n        for (const transaction of this._transactions) {\n            transaction.serialize(buf);\n        }\n        this._proof.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*count*/ 2\n            + this._transactions.reduce((sum, transaction) => sum + transaction.serializedSize, 0)\n            + this._proof.serializedSize;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `TransactionsProof{length=${this.length}}`;\n    }\n\n    /**\n     * @returns {Hash}\n     */\n    root() {\n        return this._proof.computeRoot(this._transactions);\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._transactions.length;\n    }\n\n    /** @type {Array.<Transaction>} */\n    get transactions() {\n        return this._transactions;\n    }\n\n    /** @type {MerkleProof} */\n    get proof() {\n        return this._proof;\n    }\n}\nClass.register(TransactionsProof);\n","class TransactionCache {\n    /**\n     * @param {Iterable.<Transaction>} [transactions]\n     * @param {Array.<Block>} [blockOrder]\n     */\n    constructor(transactions = [], blockOrder = []) {\n        /** @type {HashSet.<Transaction>} */\n        this._transactions = new HashSet(tx => tx.hash().toBase64());\n        this._transactions.addAll(transactions);\n        /** @type {Array.<Block>} */\n        this._blockOrder = blockOrder;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @returns {boolean}\n     */\n    containsTransaction(transaction) {\n        return this._transactions.contains(transaction);\n    }\n\n    /**\n     * @param {Block} block\n     */\n    pushBlock(block) {\n        this._blockOrder.push(block);\n        this._transactions.addAll(block.transactions);\n\n        if (this._blockOrder.length > Policy.TRANSACTION_VALIDITY_WINDOW) {\n            this.shiftBlock();\n        }\n    }\n\n    shiftBlock() {\n        const block = this._blockOrder.shift();\n        if (block) {\n            this._transactions.removeAll(block.transactions);\n        }\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {number}\n     */\n    revertBlock(block) {\n        if (this._transactions.isEmpty()) {\n            return this.missingBlocks;\n        }\n\n        const blockFromOrder = this._blockOrder.pop();\n        Assert.that(blockFromOrder.equals(block), 'Invalid block to revert');\n        if (block) {\n            this._transactions.removeAll(block.transactions);\n        }\n\n        return this.missingBlocks;\n    }\n\n    /**\n     * @param {Array.<Block>} blocks\n     */\n    prependBlocks(blocks) {\n        if (blocks.length + this._blockOrder.length > Policy.TRANSACTION_VALIDITY_WINDOW) {\n            throw new Error('Exceeding transaction cache size');\n        }\n        this._blockOrder.unshift(...blocks);\n        blocks.forEach(b => this._transactions.addAll(b.transactions));\n    }\n\n    /** @type {number} */\n    get missingBlocks() {\n        return Policy.TRANSACTION_VALIDITY_WINDOW - this._blockOrder.length;\n    }\n\n    /** @type {HashSet.<Transaction>} */\n    get transactions() {\n        return this._transactions;\n    }\n\n    /**\n     * @returns {TransactionCache}\n     */\n    clone() {\n        return new TransactionCache(/** @type {Iterable.<Transaction>} */ this._transactions, this._blockOrder.slice());\n    }\n}\nClass.register(TransactionCache);\n","class TransactionStoreEntry {\n    /**\n     * @param {Hash} transactionHash\n     * @param {Address} sender\n     * @param {Address} recipient\n     * @param {number} blockHeight\n     * @param {Hash} blockHash\n     * @param {number} index\n     */\n    constructor(transactionHash, sender, recipient, blockHeight, blockHash, index) {\n        this._transactionHash = transactionHash;\n        this._sender = sender;\n        this._recipient = recipient;\n        this._blockHeight = blockHeight;\n        this._blockHash = blockHash;\n        this._index = index;\n        this.senderBuffer = this._sender.serialize();\n        this.recipientBuffer = this._recipient.serialize();\n        this.transactionHashBuffer = this._transactionHash.serialize();\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Array.<TransactionStoreEntry>}\n     */\n    static fromBlock(block) {\n        const blockHash = block.hash();\n        /** @type {Array.<TransactionStoreEntry>} */\n        const entries = [];\n        for (let i = 0; i < block.transactions.length; ++i) {\n            const transaction = block.transactions[i];\n            entries.push(new TransactionStoreEntry(transaction.hash(), transaction.sender, transaction.recipient, block.height, blockHash, i));\n        }\n        return entries;\n    }\n\n    /**\n     * @param {string} id\n     * @param {{transactionHashBuffer: Uint8Array, senderBuffer: Uint8Array, recipientBuffer: Uint8Array, blockHeight: number, blockHash: string, index: number}} o\n     * @returns {TransactionStoreEntry}\n     */\n    static fromJSON(id, o) {\n        return new TransactionStoreEntry(\n            Hash.unserialize(new SerialBuffer(o.transactionHashBuffer)),\n            Address.unserialize(new SerialBuffer(o.senderBuffer)),\n            Address.unserialize(new SerialBuffer(o.recipientBuffer)),\n            o.blockHeight,\n            Hash.fromBase64(o.blockHash),\n            o.index\n        );\n    }\n\n    /**\n     * @returns {{transactionHashBuffer: Uint8Array, senderBuffer: Uint8Array, recipientBuffer: Uint8Array, blockHeight: number, blockHash: string, index: number}}\n     */\n    toJSON() {\n        return {\n            transactionHashBuffer: this.transactionHashBuffer,\n            senderBuffer: this.senderBuffer,\n            recipientBuffer: this.recipientBuffer,\n            blockHeight: this.blockHeight,\n            blockHash: this.blockHash.toBase64(),\n            index: this.index\n        };\n    }\n\n    /** @type {Hash} */\n    get transactionHash() {\n        return this._transactionHash;\n    }\n\n    /** @type {Address} */\n    get sender() {\n        return this._sender;\n    }\n\n    /** @type {Address} */\n    get recipient() {\n        return this._recipient;\n    }\n\n    /** @type {number} */\n    get blockHeight() {\n        return this._blockHeight;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n\n    /** @type {number} */\n    get index() {\n        return this._index;\n    }\n}\nClass.register(TransactionStoreEntry);\n","class TransactionStore {\n    /**\n     * @param {JungleDB} jdb\n     */\n    static initPersistent(jdb) {\n        // TODO: NUMBER_ENCODING in LMDB stores 32bit integers. This will only be safe for the next ~11 years assuming only full blocks.\n        jdb.deleteObjectStore('Transactions', {upgradeCondition: oldVersion => oldVersion < 4, indexNames: ['sender', 'recipient']}); // New transaction store layout starting in ConsensusDB 4\n        const store = jdb.createObjectStore('Transactions', { codec: new TransactionStoreCodec(), keyEncoding: JDB.JungleDB.NUMBER_ENCODING });\n        store.createIndex('sender', ['senderBuffer'], { keyEncoding: JDB.JungleDB.BINARY_ENCODING });\n        store.createIndex('recipient', ['recipientBuffer'], { keyEncoding: JDB.JungleDB.BINARY_ENCODING });\n        store.createIndex('transactionHash', ['transactionHashBuffer'], { keyEncoding: JDB.JungleDB.BINARY_ENCODING, unique: true });\n    }\n\n    /**\n     * @param {JungleDB} jdb\n     * @returns {TransactionStore}\n     */\n    static getPersistent(jdb) {\n        return new TransactionStore(jdb.getObjectStore('Transactions'));\n    }\n\n    /**\n     * @returns {TransactionStore}\n     */\n    static createVolatile() {\n        const store = JDB.JungleDB.createVolatileObjectStore();\n        store.createIndex('sender', ['senderBuffer']);\n        store.createIndex('recipient', ['recipientBuffer']);\n        store.createIndex('transactionHash', ['transactionHashBuffer'], { unique: true });\n        return new TransactionStore(store);\n    }\n\n    /**\n     * @param {IObjectStore} store\n     */\n    constructor(store) {\n        this._store = store;\n    }\n\n    /**\n     * @param {JDB.Transaction} [tx]\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _currentId(tx) {\n        tx = tx || this._store;\n        return (await tx.maxKey()) || 0;\n    }\n\n    /**\n     * @param {Hash} transactionHash\n     * @param {JDB.Transaction} [tx]\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _idForHash(transactionHash, tx) {\n        tx = tx || this._store;\n        const index = tx.index('transactionHash');\n        const result = await index.keys(JDB.KeyRange.only(transactionHash.serialize()));\n        // Should only contain one result due to unique constraint\n        for (const id of result) {\n            return id;\n        }\n        return null;\n    }\n\n    /**\n     * @param {Hash} transactionHash\n     * @returns {Promise.<TransactionStoreEntry>}\n     */\n    async get(transactionHash) {\n        const index = this._store.index('transactionHash');\n        const result = await index.values(JDB.KeyRange.only(transactionHash.serialize()));\n        return result && result.length > 0 ? result[0] : null;\n    }\n\n    /**\n     * @param {Address} sender\n     * @param {number} [limit]\n     * @returns {Promise.<Array.<TransactionStoreEntry>>}\n     */\n    async getBySender(sender, limit = null) {\n        const index = this._store.index('sender');\n        const entries = [];\n        await index.valueStream((value, key) => {\n            if (limit !== null && entries.length >= limit) return false;\n            entries.push(value);\n            return true;\n        }, /*ascending*/ false, JDB.KeyRange.only(sender.serialize()));\n        return entries;\n    }\n\n    /**\n     * @param {Address} recipient\n     * @param {number} [limit]\n     * @returns {Promise.<Array.<TransactionStoreEntry>>}\n     */\n    async getByRecipient(recipient, limit = null) {\n        const index = this._store.index('recipient');\n        const entries = [];\n        await index.valueStream((value, key) => {\n            if (limit !== null && entries.length >= limit) return false;\n            entries.push(value);\n            return true;\n        }, /*ascending*/ false, JDB.KeyRange.only(recipient.serialize()));\n        return entries;\n    }\n\n    /**\n     * @override\n     * @param {Block} block\n     * @returns {Promise}\n     */\n    async put(block) {\n        const indexedTransactions = TransactionStoreEntry.fromBlock(block);\n        const tx = this._store.transaction();\n        let currentId = await this._currentId(tx);\n        for (const indexedTransaction of indexedTransactions) {\n            currentId++;\n            tx.putSync(currentId, indexedTransaction);\n        }\n        return tx.commit();\n    }\n\n    /**\n     * @override\n     * @param {Block} block\n     * @returns {Promise}\n     */\n    async remove(block) {\n        const tx = this._store.transaction();\n        for (const transaction of block.transactions) {\n            tx.removeSync(await this._idForHash(transaction.hash(), tx));  // eslint-disable-line no-await-in-loop\n        }\n        return tx.commit();\n    }\n\n    /**\n     * @param {TransactionStore} [tx]\n     * @returns {TransactionStore}\n     */\n    snapshot(tx) {\n        const snapshot = this._store.snapshot();\n        if (tx) {\n            snapshot.inherit(tx._store);\n        }\n        return new TransactionStore(snapshot);\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {TransactionStore}\n     */\n    transaction(enableWatchdog = true) {\n        const tx = this._store.transaction(enableWatchdog);\n        return new TransactionStore(tx);\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    truncate() {\n        return this._store.truncate();\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    commit() {\n        return this._store.commit();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    abort() {\n        return this._store.abort();\n    }\n\n    /** @type {Transaction} */\n    get tx() {\n        if (this._store instanceof JDB.Transaction) {\n            return this._store;\n        }\n        return undefined;\n    }\n}\nClass.register(TransactionStore);\n\n/**\n * @implements {ICodec}\n */\nclass TransactionStoreCodec {\n    /**\n     * @param {*} obj The object to encode before storing it.\n     * @returns {*} Encoded object.\n     */\n    encode(obj) {\n        return obj.toJSON();\n    }\n\n    /**\n     * @param {*} obj The object to decode.\n     * @param {string} key The object's primary key.\n     * @returns {*} Decoded object.\n     */\n    decode(obj, key) {\n        return TransactionStoreEntry.fromJSON(key, obj);\n    }\n\n    /**\n     * @type {{encode: function(val:*):*, decode: function(val:*):*, buffer: boolean, type: string}|void}\n     */\n    get valueEncoding() {\n        return JDB.JungleDB.JSON_ENCODING;\n    }\n}\n","class TransactionReceipt {\n    /**\n     * @param {Hash} transactionHash\n     * @param {Hash} blockHash\n     * @param {number} blockHeight\n     */\n    constructor(transactionHash, blockHash, blockHeight) {\n        this._transactionHash = transactionHash;\n        this._blockHash = blockHash;\n        this._blockHeight = blockHeight;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {TransactionReceipt}\n     */\n    static unserialize(buf) {\n        const transactionHash = Hash.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const blockHeight = buf.readUint32();\n        return new TransactionReceipt(transactionHash, blockHash, blockHeight);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._transactionHash.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeUint32(this._blockHeight);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._transactionHash.serializedSize\n            + this._blockHash.serializedSize\n            + /*blockHeight*/ 4;\n    }\n\n    /** @type {Hash} */\n    get transactionHash() {\n        return this._transactionHash;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n\n    /** @type {number} */\n    get blockHeight() {\n        return this._blockHeight;\n    }\n}\nClass.register(TransactionReceipt);\n","class Block {\n    /**\n     * @param {Block} o\n     * @returns {Block}\n     */\n    static copy(o) {\n        if (!o) return o;\n        return new Block(\n            BlockHeader.copy(o._header),\n            BlockInterlink.copy(o._interlink),\n            BlockBody.copy(o._body)\n        );\n    }\n\n    /**\n     * @param {BlockHeader} header\n     * @param {BlockInterlink} interlink\n     * @param {BlockBody} [body]\n     */\n    constructor(header, interlink, body) {\n        if (!(header instanceof BlockHeader)) throw 'Malformed header';\n        if (!(interlink instanceof BlockInterlink)) throw 'Malformed interlink';\n        if (body && !(body instanceof BlockBody)) throw 'Malformed body';\n\n        /** @type {BlockHeader} */\n        this._header = header;\n        /** @type {BlockInterlink} */\n        this._interlink = interlink;\n        /** @type {BlockBody} */\n        this._body = body;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {Block}\n     */\n    static unserialize(buf) {\n        const header = BlockHeader.unserialize(buf);\n        const interlink = BlockInterlink.unserialize(buf, header.prevHash);\n\n        let body = undefined;\n        const bodyPresent = buf.readUint8();\n        if (bodyPresent) {\n            body = BlockBody.unserialize(buf);\n        }\n\n        return new Block(header, interlink, body);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._header.serialize(buf);\n        this._interlink.serialize(buf);\n\n        if (this._body) {\n            buf.writeUint8(1);\n            this._body.serialize(buf);\n        } else {\n            buf.writeUint8(0);\n        }\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return this._header.serializedSize\n            + this._interlink.serializedSize\n            + /*bodyPresent*/ 1\n            + (this._body ? this._body.serializedSize : 0);\n    }\n\n    /**\n     * @param {Time} time\n     * @returns {Promise.<boolean>}\n     */\n    async verify(time) {\n        if (this._valid === undefined) {\n            if (this.isLight() || this.body.transactions.length < 150 || !IWorker.areWorkersAsync) {\n                // worker overhead doesn't pay off for small transaction numbers\n                this._valid = await this._verify(time.now());\n            } else {\n                const transactionValid = this.body.transactions.map(t => t._valid);\n                const worker = await CryptoWorker.getInstanceAsync();\n                const {valid, pow, interlinkHash, bodyHash} = await worker.blockVerify(this.serialize(),\n                    transactionValid, time.now(), GenesisConfig.GENESIS_HASH.serialize(), GenesisConfig.NETWORK_ID);\n                this._valid = valid;\n                this.header._pow = Hash.unserialize(new SerialBuffer(pow));\n                this.interlink._hash = Hash.unserialize(new SerialBuffer(interlinkHash));\n                this.body._hash = Hash.unserialize(new SerialBuffer(bodyHash));\n            }\n        }\n        return this._valid;\n    }\n\n    /**\n     * @param {number} timeNow\n     * @returns {Promise.<boolean>}\n     */\n    async _verify(timeNow) {\n        // Check that the timestamp is not too far into the future.\n        if (this._header.timestamp * 1000 > timeNow + Block.TIMESTAMP_DRIFT_MAX * 1000) {\n            Log.w(Block, 'Invalid block - timestamp too far in the future');\n            return false;\n        }\n\n        // Check that the header hash matches the difficulty.\n        if (!(await this._header.verifyProofOfWork())) {\n            Log.w(Block, 'Invalid block - PoW verification failed');\n            return false;\n        }\n\n        // Check that the maximum block size is not exceeded.\n        if (this.serializedSize > Policy.BLOCK_SIZE_MAX) {\n            Log.w(Block, 'Invalid block - max block size exceeded');\n            return false;\n        }\n\n        // Verify that the interlink is valid.\n        if (!this._verifyInterlink()) {\n            return false;\n        }\n\n        // XXX Verify the body only if it is present.\n        if (this.isFull() && !this._verifyBody()) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n    _verifyInterlink() {\n        // Skip check for genesis block due to the cyclic dependency (since the interlink hash contains the genesis block hash).\n        if (this.height === 1 && this._header.interlinkHash.equals(new Hash(null))) {\n            return true;\n        }\n\n        // Check that the interlinkHash given in the header matches the actual interlinkHash.\n        const interlinkHash = this._interlink.hash();\n        if (!this._header.interlinkHash.equals(interlinkHash)) {\n            Log.w(Block, 'Invalid block - interlink hash mismatch');\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n    _verifyBody() {\n        // Check that the body is valid.\n        if (!this._body.verify()) {\n            return false;\n        }\n\n        // Check that bodyHash given in the header matches the actual body hash.\n        const bodyHash = this._body.hash();\n        if (!this._header.bodyHash.equals(bodyHash)) {\n            Log.w(Block, 'Invalid block - body hash mismatch');\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {Block} predecessor\n     * @returns {Promise.<boolean>}\n     */\n    async isImmediateSuccessorOf(predecessor) {\n        // Check the header.\n        if (!this._header.isImmediateSuccessorOf(predecessor.header)) {\n            return false;\n        }\n\n        // Check that the interlink is correct.\n        const interlink = await predecessor.getNextInterlink(this.target, this.version);\n        if (!this._interlink.equals(interlink)) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {Block} predecessor\n     * @returns {Promise.<boolean>}\n     */\n    async isInterlinkSuccessorOf(predecessor) {\n        // Check that the height is higher than the predecessor's.\n        if (this._header.height <= predecessor.header.height) {\n            Log.v(Block, 'No interlink successor - height');\n            return false;\n        }\n\n        // Check that the timestamp is greater or equal to the predecessor's timestamp.\n        if (this._header.timestamp < predecessor.header.timestamp) {\n            Log.v(Block, 'No interlink successor - timestamp');\n            return false;\n        }\n\n        // Check that the predecessor is contained in this block's interlink and verify its position.\n        const prevHash = predecessor.hash();\n        if (!GenesisConfig.GENESIS_HASH.equals(prevHash)) {\n            const prevPow = await predecessor.pow();\n            const targetHeight = BlockUtils.getTargetHeight(this.target);\n            let blockFound = false;\n\n            let depth = 0;\n            for (; depth < this._interlink.length; depth++) {\n                if (prevHash.equals(this._interlink.hashes[depth])) {\n                    blockFound = true;\n                    if (!BlockUtils.isProofOfWork(prevPow, Math.pow(2, targetHeight - depth))) {\n                        Log.v(Block, 'No interlink successor - invalid position in interlink');\n                        return false;\n                    }\n                }\n            }\n\n            if (!blockFound) {\n                Log.v(Block, 'No interlink successor - not in interlink');\n                return false;\n            }\n        }\n\n        // If the predecessor happens to be the immediate predecessor, check additionally:\n        // - that the height of the successor is one higher\n        // - that the interlink is correct.\n        if (this._header.prevHash.equals(prevHash)) {\n            if (this._header.height !== predecessor.header.height + 1) {\n                Log.v(Block, 'No interlink successor - immediate height');\n                return false;\n            }\n\n            const interlink = await predecessor.getNextInterlink(this.target, this.version);\n            const interlinkHash = interlink.hash();\n            if (!this._header.interlinkHash.equals(interlinkHash)) {\n                Log.v(Block, 'No interlink successor - immediate interlink');\n                return false;\n            }\n        }\n        // Otherwise, if the prevHash doesn't match but the blocks should be adjacent according to their height fields,\n        // this cannot be a valid successor of predecessor.\n        else if (this._header.height === predecessor.height.height + 1) {\n            Log.v(Block, 'No interlink successor - immediate height (2)');\n            return false;\n        }\n        // Otherwise, check that the interlink construction is valid given the information we have.\n        else {\n            // TODO Take different targets into account.\n\n            // The number of new blocks in the interlink is bounded by the height difference.\n            /** @type {HashSet.<Hash>} */\n            const hashes = new HashSet();\n            hashes.addAll(this._interlink.hashes);\n            hashes.removeAll(predecessor.interlink.hashes);\n            if (hashes.length > this._header.height - predecessor.header.height) {\n                Log.v(Block, 'No interlink successor - too many new blocks');\n                return false;\n            }\n\n            // Check that the interlink is not too short.\n            const thisDepth = BlockUtils.getTargetDepth(this.target);\n            const prevDepth = BlockUtils.getTargetDepth(predecessor.target);\n            const depthDiff = thisDepth - prevDepth;\n            if (this._interlink.length < predecessor.interlink.length - depthDiff) {\n                Log.v(Block, 'No interlink successor - interlink too short');\n                return false;\n            }\n\n            // If the same block is found in both interlinks, all blocks at lower depths must be the same in both interlinks.\n            let commonBlock = false;\n            const thisInterlink = this._interlink.hashes;\n            const prevInterlink = predecessor.interlink.hashes;\n            for (let i = 1; i < prevInterlink.length && i - depthDiff < thisInterlink.length; i++) {\n                if (prevInterlink[i].equals(thisInterlink[i - depthDiff])) {\n                    commonBlock = true;\n                }\n                else if (commonBlock) {\n                    Log.v(Block, 'No interlink successor - invalid common suffix');\n                    return false;\n                }\n            }\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @param {Block} predecessor\n     * @returns {Promise.<boolean>}\n     */\n    async isSuccessorOf(predecessor) {\n        // TODO Improve this! Lots of duplicate checks.\n        return (await this.isImmediateSuccessorOf(predecessor)) || (await this.isInterlinkSuccessorOf(predecessor));\n    }\n\n    /**\n     * @param {number} nextTarget\n     * @param {number} [nextVersion]\n     * @returns {Promise.<BlockInterlink>}\n     */\n    async getNextInterlink(nextTarget, nextVersion = BlockHeader.CURRENT_VERSION) {\n        /** @type {Array.<Hash>} */\n        const hashes = [];\n        const hash = this.hash();\n\n        // Compute how many times this blockHash should be included in the next interlink.\n        const thisPowDepth = BlockUtils.getHashDepth(await this.pow());\n        const nextTargetDepth = BlockUtils.getTargetDepth(nextTarget);\n        const numOccurrences = Math.max(thisPowDepth - nextTargetDepth + 1, 0);\n\n        // Push this blockHash numOccurrences times onto the next interlink.\n        for (let i = 0; i < numOccurrences; i++) {\n            hashes.push(hash);\n        }\n\n        // Compute how many blocks to omit from the beginning of this interlink.\n        const thisTargetDepth = BlockUtils.getTargetDepth(this.target);\n        const targetOffset = nextTargetDepth - thisTargetDepth;\n        const interlinkOffset = numOccurrences + targetOffset;\n\n        // Push the remaining hashes from this interlink.\n        for (let i = interlinkOffset; i < this.interlink.length; i++) {\n            hashes.push(this.interlink.hashes[i]);\n        }\n        \n        return new BlockInterlink(hashes, hash);\n    }\n\n    /**\n     * @param {Block|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof Block\n            && this._header.equals(o._header)\n            && this._interlink.equals(o._interlink)\n            && (this._body ? this._body.equals(o._body) : !o._body);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isLight() {\n        return !this._body;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isFull() {\n        return !!this._body;\n    }\n\n    /**\n     * @returns {Block}\n     */\n    toLight() {\n        return this.isLight() ? this : new Block(this._header, this._interlink);\n    }\n\n    /**\n     * @param {BlockBody} body\n     * @returns {Block}\n     */\n    toFull(body) {\n        return this.isFull() ? this : new Block(this._header, this._interlink, body);\n    }\n\n    /**\n     * @type {BlockHeader}\n     */\n    get header() {\n        return this._header;\n    }\n\n    /**\n     * @type {BlockInterlink}\n     */\n    get interlink() {\n        return this._interlink;\n    }\n\n    /**\n     * @type {BlockBody}\n     */\n    get body() {\n        if (this.isLight()) {\n            throw 'Cannot access body of light block';\n        }\n        return this._body;\n    }\n\n    /**\n     * @returns {number}\n     */\n    get version() {\n        return this._header.version;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    get prevHash() {\n        return this._header.prevHash;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    get bodyHash() {\n        return this._header.bodyHash;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    get accountsHash() {\n        return this._header.accountsHash;\n    }\n\n    /**\n     * @type {number}\n     */\n    get nBits() {\n        return this._header.nBits;\n    }\n\n    /**\n     * @type {number}\n     */\n    get target() {\n        return this._header.target;\n    }\n\n    /**\n     * @type {number}\n     */\n    get difficulty() {\n        return this._header.difficulty;\n    }\n\n    /**\n     * @type {number}\n     */\n    get height() {\n        return this._header.height;\n    }\n    \n    /**\n     * @type {number}\n     */\n    get timestamp() {\n        return this._header.timestamp;\n    }\n\n    /**\n     * @type {number}\n     */\n    get nonce() {\n        return this._header.nonce;\n    }\n\n    /**\n     * @type {Address}\n     */\n    get minerAddr() {\n        return this._body.minerAddr;\n    }\n\n    /**\n     * @type {Array.<Transaction>}\n     */\n    get transactions() {\n        return this._body.transactions;\n    }\n\n    /**\n     * @type {number}\n     */\n    get transactionCount() {\n        return this._body.transactionCount;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {Hash}\n     */\n    hash(buf) {\n        return this._header.hash(buf);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {Promise.<Hash>}\n     */\n    pow(buf) {\n        return this._header.pow(buf);\n    }\n\n}\nBlock.TIMESTAMP_DRIFT_MAX = 600 /* seconds */; // 10 minutes\nClass.register(Block);\n","/**\n * @interface\n */\nclass IBlockchain extends Observable {\n    /**\n     * @abstract\n     * @type {Block}\n     */\n    get head() {}\n\n    /**\n     * @abstract\n     * @type {Hash}\n     */\n    get headHash() {}\n\n    /**\n     * @abstract\n     * @type {number}\n     */\n    get height() {}\n}\nClass.register(IBlockchain);\n","/**\n * @abstract\n */\nclass BaseChain extends IBlockchain {\n    /**\n     * @param {ChainDataStore} store\n     */\n    constructor(store) {\n        super();\n        this._store = store;\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {boolean} [includeForks]\n     * @param {boolean} [includeBody]\n     * @returns {Promise.<?Block>}\n     */\n    async getBlock(hash, includeForks = false, includeBody = false) {\n        const chainData = await this._store.getChainData(hash, includeBody);\n        return chainData && (chainData.onMainChain || includeForks) ? chainData.head : null;\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {boolean} [includeForks]\n     * @returns {Promise.<?Uint8Array>}\n     */\n    getRawBlock(hash, includeForks = false) {\n        return this._store.getRawBlock(hash, includeForks);\n    }\n\n    /**\n     * @param {number} height\n     * @param {boolean} [includeBody]\n     * @returns {Promise.<?Block>}\n     */\n    getBlockAt(height, includeBody = false) {\n        return this._store.getBlockAt(height, includeBody) || null;\n    }\n\n    /**\n     * @param {number} height\n     * @param {boolean} [lower]\n     * @returns {Promise.<?Block>}\n     */\n    getNearestBlockAt(height, lower = true) {\n        return this._store.getNearestBlockAt(height, lower) || null;\n    }\n\n    /**\n     * @returns {Promise.<Array.<Hash>>}\n     */\n    async getBlockLocators() {\n        // Push top 10 hashes first, then back off exponentially.\n        /** @type {Array.<Hash>} */\n        const locators = [this.headHash];\n\n        let block = this.head;\n        for (let i = Math.min(10, this.height) - 1; i > 0; i--) {\n            if (!block) {\n                break;\n            }\n            locators.push(block.prevHash);\n            block = await this.getBlock(block.prevHash); // eslint-disable-line no-await-in-loop\n        }\n\n        let step = 2;\n        for (let i = this.height - 10 - step; i > 0; i -= step) {\n            block = await this.getBlockAt(i); // eslint-disable-line no-await-in-loop\n            if (block) {\n                locators.push(await block.hash()); // eslint-disable-line no-await-in-loop\n            }\n            step *= 2;\n        }\n\n        // Push the genesis block hash.\n        if (locators.length === 0 || !locators[locators.length - 1].equals(GenesisConfig.GENESIS_HASH)) {\n            locators.push(GenesisConfig.GENESIS_HASH);\n        }\n\n        return locators;\n    }\n\n    /**\n     * Computes the target value for the block after the given block or the head of this chain if no block is given.\n     * @param {Block} [block]\n     * @returns {Promise.<number>}\n     */\n    async getNextTarget(block) {\n        /** @type {ChainData} */\n        let headData;\n        if (block) {\n            const hash = block.hash();\n            headData = await this._store.getChainData(hash);\n            Assert.that(!!headData);\n        } else {\n            block = this.head;\n            headData = this._mainChain;\n        }\n\n        // Retrieve the timestamp of the block that appears DIFFICULTY_BLOCK_WINDOW blocks before the given block in the chain.\n        // The block might not be on the main chain.\n        const tailHeight = Math.max(block.height - Policy.DIFFICULTY_BLOCK_WINDOW, 1);\n        /** @type {ChainData} */\n        let tailData;\n        if (headData.onMainChain) {\n            tailData = await this._store.getChainDataAt(tailHeight);\n        } else {\n            let prevData = headData;\n            for (let i = 0; i < Policy.DIFFICULTY_BLOCK_WINDOW && !prevData.onMainChain; i++) {\n                prevData = await this._store.getChainData(prevData.head.prevHash);\n                if (!prevData) {\n                    // Not enough blocks are available to compute the next target, fail.\n                    return -1;\n                }\n            }\n\n            if (prevData.onMainChain && prevData.head.height > tailHeight) {\n                tailData = await this._store.getChainDataAt(tailHeight);\n            } else {\n                tailData = prevData;\n            }\n        }\n\n        if (!tailData || tailData.totalDifficulty < 1) {\n            // Not enough blocks are available to compute the next target, fail.\n            return -1;\n        }\n\n        const deltaTotalDifficulty = headData.totalDifficulty - tailData.totalDifficulty;\n        return BlockUtils.getNextTarget(headData.head.header, tailData.head.header, deltaTotalDifficulty);\n    }\n\n\n\n    /* NIPoPoW Prover functions */\n\n    /**\n     * MUST be synchronized with .pushBlock() and variants!\n     * @returns {Promise.<ChainProof>}\n     * @protected\n     */\n    _getChainProof() {\n        return this._prove(Policy.M, Policy.K, Policy.DELTA);\n    }\n\n    /**\n     * The \"Prove\" algorithm from the NIPoPow paper.\n     * @param {number} m\n     * @param {number} k\n     * @param {number} delta\n     * @returns {Promise.<ChainProof>}\n     * @private\n     */\n    async _prove(m, k, delta) {\n        Assert.that(m >= 1, 'm must be >= 1');\n        Assert.that(delta > 0, 'delta must be > 0');\n        let prefix = new BlockChain([]);\n\n        // B <- C[0]\n        let startHeight = 1;\n\n        /** @type {ChainData} */\n        const headData = await this._store.getChainDataAt(Math.max(this.height - k, 1)); // C[-k]\n        const maxDepth = headData.superBlockCounts.getCandidateDepth(m);\n\n        // for mu = |C[-k].interlink| down to 0 do\n        for (let depth = maxDepth; depth >= 0; depth--) {\n            // alpha = C[:-k]{B:}|^mu\n            /** @type {Array.<ChainData>} */\n            const alpha = await this._getSuperChain(depth, headData, startHeight); // eslint-disable-line no-await-in-loop\n\n            // pi = pi (union) alpha\n            prefix = BlockChain.merge(prefix, new BlockChain(alpha.map(data => data.head.toLight())));\n\n            // if good_(delta,m)(C, alpha, mu) then\n            if (BaseChain._isGoodSuperChain(alpha, depth, m, delta)) {\n                Assert.that(alpha.length >= m, `Good superchain expected to be at least ${m} long`);\n                Log.v(BaseChain, () => `Found good superchain at depth ${depth} with length ${alpha.length} (#${startHeight} - #${headData.head.height})`);\n                // B <- alpha[-m]\n                startHeight = alpha[alpha.length - m].head.height;\n            }\n        }\n\n        // X <- C[-k:]\n        const suffix = await this._getHeaderChain(this.height - headData.head.height);\n\n        // return piX\n        return new ChainProof(prefix, suffix);\n    }\n\n    /**\n     * @param {number} depth\n     * @param {ChainData} headData\n     * @param {number} [tailHeight]\n     * @returns {Promise.<Array.<ChainData>>}\n     * @private\n     */\n    async _getSuperChain(depth, headData, tailHeight = 1) {\n        Assert.that(tailHeight >= 1, 'tailHeight must be >= 1');\n        /** @type {Array.<ChainData>} */\n        const chain = [];\n\n        // Include head if it is at the requested depth or below.\n        const headDepth = BlockUtils.getHashDepth(await headData.head.pow());\n        if (headDepth >= depth) {\n            chain.push(headData);\n        }\n\n        // Follow the interlink pointers back at the requested depth.\n        /** @type {ChainData} */\n        let chainData = headData;\n        let j = Math.max(depth - BlockUtils.getTargetDepth(chainData.head.target), -1);\n        while (j < chainData.head.interlink.hashes.length && chainData.head.height > tailHeight) {\n            const reference = j < 0 ? chainData.head.prevHash : chainData.head.interlink.hashes[j];\n            chainData = await this._store.getChainData(reference); // eslint-disable-line no-await-in-loop\n            if (!chainData) {\n                // This can happen in the light/nano client if chain superquality is harmed.\n                // Return a best-effort chain in this case.\n                Log.w(BaseChain, `Failed to find block ${reference} while constructing SuperChain at depth ${depth} - returning truncated chain`);\n                break;\n            }\n            chain.push(chainData);\n\n            j = Math.max(depth - BlockUtils.getTargetDepth(chainData.head.target), -1);\n        }\n\n        if ((chain.length === 0 || chain[chain.length - 1].head.height > 1) && tailHeight === 1) {\n            chain.push(await ChainData.initial(GenesisConfig.GENESIS_BLOCK));\n        }\n\n        return chain.reverse();\n    }\n\n    /**\n     * @param {Array.<ChainData>} superchain\n     * @param {number} depth\n     * @param {number} m\n     * @param {number} delta\n     * @returns {boolean}\n     */\n    static _isGoodSuperChain(superchain, depth, m, delta) {\n        return BaseChain._hasSuperQuality(superchain, depth, m, delta)\n            && BaseChain._hasMultiLevelQuality(superchain, depth, m, delta);\n    }\n\n    /**\n     * @param {Array.<ChainData>} superchain\n     * @param {number} depth\n     * @param {number} m\n     * @param {number} delta\n     * @returns {boolean}\n     * @private\n     */\n    static _hasSuperQuality(superchain, depth, m, delta) {\n        Assert.that(m >= 1, 'm must be >= 1');\n        if (superchain.length < m) {\n            return false;\n        }\n\n        for (let i = m; i <= superchain.length; i++) {\n            const underlyingLength = superchain[superchain.length - 1].head.height - superchain[superchain.length - i].head.height + 1;\n            if (!BaseChain._isLocallyGood(i, underlyingLength, depth, delta)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     *\n     * @param {Array.<ChainData>} superchain\n     * @param {number} depth\n     * @param {number} k1\n     * @param {number} delta\n     * @returns {boolean}\n     * @private\n     */\n    static _hasMultiLevelQuality(superchain, depth, k1, delta) {\n        if (depth <= 0) {\n            return true;\n        }\n\n        for (let i = 0; i < superchain.length - k1; i++) {\n            const tailData = superchain[i];\n            const headData = superchain[i + k1];\n\n            for (let mu = depth; mu >= 1; mu--) {\n                const upperChainLength = headData.superBlockCounts.get(mu) - tailData.superBlockCounts.get(mu);\n\n                switch (BaseChain.MULTILEVEL_STRATEGY) {\n                    case BaseChain.MultilevelStrategy.STRICT: {\n                        const lowerChainLength = headData.superBlockCounts.get(mu - 1) - tailData.superBlockCounts.get(mu - 1);\n\n                        /*\n                        // Original paper badness check:\n                        if (lowerChainLength > Math.pow(1 + delta, 1 / depth) * 2 * upperChainLength) {\n                            Log.d(BaseChain, `Chain badness detected at depth ${depth}, failing at ${mu}/${mu - 1}`\n                                + ` with ${upperChainLength}/${Math.pow(1 + delta, 1 / depth) * 2 * upperChainLength}/${lowerChainLength} blocks`);\n                            return false;\n                        }\n                        */\n\n                        // Alternative badness check:\n                        if (2 * upperChainLength < Math.pow(1 - delta, 1 / depth) * lowerChainLength) {\n                            Log.d(BaseChain, `Chain badness detected at depth ${depth}, failing at ${mu}/${mu - 1}`\n                                + ` with ${upperChainLength}/${Math.pow(1 - delta, 1 / depth) * lowerChainLength}/${lowerChainLength} blocks`);\n                            return false;\n                        }\n                        break;\n                    }\n\n                    default:\n                    case BaseChain.MultilevelStrategy.MODERATE: {\n                        // Relaxed badness check:\n                        for (let j = mu - 1; j >= 0; j--) {\n                            const lowerChainLength = headData.superBlockCounts.get(j) - tailData.superBlockCounts.get(j);\n                            if (!BaseChain._isLocallyGood(upperChainLength, lowerChainLength, mu - j, delta)) {\n                                Log.d(BaseChain, `Chain badness detected at depth ${depth}[${i}:${i + k1}], failing at ${mu}/${j}`);\n                                return false;\n                            }\n                        }\n                        break;\n                    }\n\n                    case BaseChain.MultilevelStrategy.RELAXED: {\n                        // Local goodness only:\n                        const lowerChainLength = headData.superBlockCounts.get(mu - 1) - tailData.superBlockCounts.get(mu - 1);\n                        if (!BaseChain._isLocallyGood(lowerChainLength, headData.head.height - tailData.head.height, depth, delta)) {\n                            Log.d(BaseChain, `Chain badness detected at depth ${depth}[${i}:${i + k1}], failing at ${mu}`);\n                            return false;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {number} superLength\n     * @param {number} underlyingLength\n     * @param {number} depth\n     * @param {number} delta\n     * @returns {boolean}\n     * @private\n     */\n    static _isLocallyGood(superLength, underlyingLength, depth, delta) {\n        // |C'| > (1 - delta) * 2^(-mu) * |C|\n        return superLength > (1 - delta) * Math.pow(2, -depth) * underlyingLength;\n    }\n\n    /**\n     * @param {number} length\n     * @param {Block} [head]\n     * @returns {Promise.<HeaderChain>}\n     * @private\n     */\n    async _getHeaderChain(length, head = this.head) {\n        const headers = [];\n        while (head && headers.length < length) {\n            headers.push(head.header);\n            head = await this.getBlock(head.prevHash); // eslint-disable-line no-await-in-loop\n        }\n        return new HeaderChain(headers.reverse());\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @param {BlockHeader} header\n     * @param {boolean} [failOnBadness]\n     * @returns {Promise.<ChainProof>}\n     * @protected\n     */\n    async _extendChainProof(proof, header, failOnBadness = true) {\n        // Append new header to proof suffix.\n        const suffix = proof.suffix.headers.slice();\n        suffix.push(header);\n\n        // If the suffix is not long enough (short chain), we're done.\n        const prefix = proof.prefix.blocks.slice();\n        if (suffix.length <= Policy.K) {\n            return new ChainProof(new BlockChain(prefix), new HeaderChain(suffix));\n        }\n\n        // Cut the tail off the suffix.\n        const suffixTail = suffix.shift();\n\n        // Construct light block out of the old suffix tail.\n        const interlink = await proof.prefix.head.getNextInterlink(suffixTail.target, suffixTail.version);\n        const prefixHead = new Block(suffixTail, interlink);\n\n        // Append old suffix tail block to prefix.\n        prefix.push(prefixHead);\n\n        // Extract layered superchains from prefix. Make a copy because we are going to change the chains array.\n        const chains = (await proof.prefix.getSuperChains()).slice();\n\n        // Append new prefix head to chains.\n        const depth = BlockUtils.getHashDepth(await prefixHead.pow());\n        for (let i = depth; i >= 0; i--) {\n            // Append block. Don't modify the chain, create a copy.\n            if (!chains[i]) {\n                chains[i] = new BlockChain([prefixHead]);\n            } else {\n                chains[i] = new BlockChain([...chains[i].blocks, prefixHead]);\n            }\n        }\n\n        // If the new header isn't a superblock, we're done.\n        if (depth - BlockUtils.getTargetDepth(prefixHead.target) <= 0) {\n            return new ChainProof(new BlockChain(prefix, chains), new HeaderChain(suffix));\n        }\n\n        // Prune unnecessary blocks if the chain is good.\n        // Try to extend proof if the chain is bad.\n        const deletedBlockHeights = new Set();\n        for (let i = depth; i >= 0; i--) {\n            const superchain = chains[i];\n            if (superchain.length < Policy.M) {\n                continue;\n            }\n\n            // XXX Hack: Convert BlockChain to array of pseudo-ChainData for the super quality check.\n            const _superchain = superchain.blocks.map(block => ({ head: block }));\n            if (!BaseChain._hasSuperQuality(_superchain, i, Policy.M, Policy.DELTA)) {\n                Log.w(BaseChain, `Chain quality badness detected at depth ${i}`);\n                // TODO extend superchains at lower levels\n                if (failOnBadness) {\n                    return null;\n                }\n                continue;\n            }\n\n            // Remove all blocks in lower chains up to (including) superchain[-m].\n            const referenceBlock = superchain.blocks[superchain.length - Policy.M];\n            for (let j = i - 1; j >= 0; j--) {\n                let numBlocksToDelete = 0;\n                let candidateBlock = chains[j].blocks[numBlocksToDelete];\n                while (candidateBlock.height <= referenceBlock.height) {\n                    // eslint-disable-next-line no-await-in-loop\n                    const candidateDepth = BlockUtils.getHashDepth(await candidateBlock.pow());\n                    if (candidateDepth === j && candidateBlock.height > 1) {\n                        deletedBlockHeights.add(candidateBlock.height);\n                    }\n\n                    numBlocksToDelete++;\n                    candidateBlock = chains[j].blocks[numBlocksToDelete];\n                }\n\n                if (numBlocksToDelete > 0) {\n                    // Don't modify the chain, create a copy.\n                    chains[j] = new BlockChain(chains[j].blocks.slice(numBlocksToDelete));\n                }\n            }\n        }\n\n        // Remove all deleted blocks from prefix.\n        const newPrefix = new BlockChain(prefix.filter(block => !deletedBlockHeights.has(block.height)), chains);\n\n        // Return the extended proof.\n        return new ChainProof(newPrefix, new HeaderChain(suffix));\n    }\n\n    /**\n     * MUST be synchronized with .pushBlock() and variants!\n     * @param {Block} blockToProve\n     * @param {Block} knownBlock\n     * @returns {Promise.<?BlockChain>}\n     * @protected\n     */\n    async _getBlockProof(blockToProve, knownBlock) {\n        /**\n         * @param {Block} block\n         * @param {number} depth\n         * @returns {Hash}\n         */\n        const getInterlinkReference = (block, depth) => {\n            const index = Math.min(depth - BlockUtils.getTargetDepth(block.target), block.interlink.length - 1);\n            return index < 0 ? block.prevHash : block.interlink.hashes[index];\n        };\n\n        const blocks = [];\n        const hashToProve = blockToProve.hash();\n\n        const proveTarget = BlockUtils.hashToTarget(await blockToProve.pow());\n        const proveDepth = BlockUtils.getTargetDepth(proveTarget);\n\n        let depth = BlockUtils.getTargetDepth(knownBlock.target) + knownBlock.interlink.length - 1;\n        let block = knownBlock;\n\n        let reference = getInterlinkReference(block, depth);\n        while (!hashToProve.equals(reference)) {\n            const nextBlock = await this.getBlock(reference); // eslint-disable-line no-await-in-loop\n            if (!nextBlock) {\n                // This can happen in the light/nano client if the blockToProve is known but blocks between tailBlock\n                // and blockToProve are missing.\n                Log.w(BaseChain, `Failed to find block ${reference} while constructing inclusion proof`);\n                return null;\n            }\n\n            if (nextBlock.height < blockToProve.height) {\n                // We have gone past the blockToProve, but are already at proveDepth, fail.\n                if (depth <= proveDepth) {\n                    return null;\n                }\n\n                // Decrease depth and thereby step size.\n                depth--;\n                reference = getInterlinkReference(block, depth);\n            } else if (nextBlock.height > blockToProve.height) {\n                // We are still in front of blockToProve, add block to result and advance.\n                blocks.push(nextBlock.toLight());\n\n                block = nextBlock;\n                reference = getInterlinkReference(block, depth);\n            } else {\n                // We found a reference to a different block than blockToProve at its height.\n                Log.w(BaseChain, `Failed to prove block ${hashToProve} - different block ${reference} at its height ${block.height}`);\n                return null;\n            }\n        }\n\n        // Include the blockToProve in the result.\n        blocks.push(blockToProve.toLight());\n\n        return new BlockChain(blocks.reverse());\n    }\n\n    /**\n     * @param {Array.<BlockHeader>} headers\n     * @return {Promise.<void>}\n     */\n    static async manyPow(headers) {\n        const worker = await CryptoWorker.getInstanceAsync();\n        const size = worker.poolSize || 1;\n        const partitions = [];\n        let j = 0;\n        for (let i = 0; i < size; ++i) {\n            partitions.push([]);\n            for (; j < ((i + 1) / size) * headers.length; ++j) {\n                partitions[i].push(headers[j].serialize());\n            }\n        }\n        const promises = [];\n        for (const part of partitions) {\n            promises.push(worker.computeArgon2dBatch(part));\n        }\n        const pows = (await Promise.all(promises)).reduce((a, b) => [...a, ...b], []);\n        for(let i = 0; i < headers.length; ++i) {\n            headers[i]._pow = new Hash(pows[i]);\n        }\n    }\n\n\n    /* NiPoPoW Verifier functions */\n\n    /**\n     * @param {ChainProof} proof1\n     * @param {ChainProof} proof2\n     * @param {number} m\n     * @returns {boolean}\n     */\n    static async isBetterProof(proof1, proof2, m) {\n        const lca = BlockChain.lowestCommonAncestor(proof1.prefix, proof2.prefix);\n        const score1 = await NanoChain._getProofScore(proof1.prefix, lca, m);\n        const score2 = await NanoChain._getProofScore(proof2.prefix, lca, m);\n        return score1 === score2\n            ? proof1.suffix.totalDifficulty() >= proof2.suffix.totalDifficulty()\n            : score1 > score2;\n    }\n\n    /**\n     *\n     * @param {BlockChain} chain\n     * @param {Block} lca\n     * @param {number} m\n     * @returns {Promise.<number>}\n     * @protected\n     */\n    static async _getProofScore(chain, lca, m) {\n        const counts = [];\n        for (const block of chain.blocks) {\n            if (block.height < lca.height) {\n                continue;\n            }\n\n            const depth = BlockUtils.getHashDepth(await block.pow()); // eslint-disable-line no-await-in-loop\n            counts[depth] = counts[depth] ? counts[depth] + 1 : 1;\n        }\n\n        let sum = 0;\n        let depth;\n        for (depth = counts.length - 1; sum < m && depth >= 0; depth--) {\n            sum += counts[depth] ? counts[depth] : 0;\n        }\n\n        let maxScore = Math.pow(2, depth + 1) * sum;\n        let length = sum;\n        for (let i = depth; i >= 0; i--) {\n            length += counts[i] ? counts[i] : 0;\n            const score = Math.pow(2, i) * length;\n            maxScore = Math.max(maxScore, score);\n        }\n\n        return maxScore;\n    }\n}\nBaseChain.MultilevelStrategy = {\n    STRICT: 1,\n    MODERATE: 2,\n    RELAXED: 3\n};\nBaseChain.MULTILEVEL_STRATEGY = BaseChain.MultilevelStrategy.MODERATE;\nClass.register(BaseChain);\n","class BlockChain {\n    /**\n     * @param {BlockChain} chain1\n     * @param {BlockChain} chain2\n     * @returns {BlockChain}\n     */\n    static merge(chain1, chain2) {\n        const merged = [];\n        let i1 = 0, i2 = 0;\n        while (i1 < chain1.length && i2 < chain2.length) {\n            const block1 = chain1.blocks[i1];\n            const block2 = chain2.blocks[i2];\n\n            if (block1.height === block2.height) {\n                Assert.that(block1.equals(block2), 'Encountered different blocks at same height during chain merge');\n                merged.push(block1);\n                i1++;\n                i2++;\n            } else if (block1.height < block2.height) {\n                merged.push(block1);\n                i1++;\n            } else {\n                merged.push(block2);\n                i2++;\n            }\n        }\n\n        for (; i1 < chain1.length; i1++) {\n            merged.push(chain1.blocks[i1]);\n        }\n        for (; i2 < chain2.length; i2++) {\n            merged.push(chain2.blocks[i2]);\n        }\n\n        return new BlockChain(merged);\n    }\n\n    /**\n     * @param {BlockChain} chain1\n     * @param {BlockChain} chain2\n     * @returns {?Block}\n     */\n    static lowestCommonAncestor(chain1, chain2) {\n        let i1 = chain1.length - 1;\n        let i2 = chain2.length - 1;\n        while (i1 >= 0 && i2 >= 0) {\n            const block1 = chain1.blocks[i1];\n            const block2 = chain2.blocks[i2];\n\n            if (block1.equals(block2)) {\n                return block1;\n            } else if (block1.height > block2.height) {\n                i1--;\n            } else {\n                i2--;\n            }\n        }\n        return undefined;\n    }\n\n    /**\n     * @param {Array.<Block>} blocks\n     * @param {Array.<BlockChain>} [superChains]\n     */\n    constructor(blocks, superChains) {\n        if (!Array.isArray(blocks) || !NumberUtils.isUint16(blocks.length)\n            || blocks.some(it => !(it instanceof Block) || !it.isLight())) throw new Error('Malformed blocks');\n\n        /** @type {Array.<Block>} */\n        this._blocks = blocks;\n        /** @type {Array.<BlockChain>} */\n        this._chains = superChains;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {BlockChain}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint16();\n        const blocks = [];\n        for (let i = 0; i < count; i++) {\n            blocks.push(Block.unserialize(buf));\n        }\n        return new BlockChain(blocks);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._blocks.length);\n        for (const block of this._blocks) {\n            block.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*count*/ 2\n            + this._blocks.reduce((sum, block) => sum + block.serializedSize, 0);\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    async verify() {\n        // For performance reasons, we DO NOT VERIFY the validity of the blocks in the chain here.\n        // Block validity is checked by the Nano/LightChain upon receipt of a ChainProof.\n\n        // Check that all blocks in the chain are valid successors of one another.\n        for (let i = this._blocks.length - 1; i >= 1; i--) {\n            if (!(await this._blocks[i].isSuccessorOf(this._blocks[i - 1]))) { // eslint-disable-line no-await-in-loop\n                return false;\n            }\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {Array.<Block>}\n     */\n    denseSuffix() {\n        // Compute the dense suffix.\n        const denseSuffix = [this.head];\n        let denseSuffixHead = this.head;\n        for (let i = this.length - 2; i >= 0; i--) {\n            const block = this.blocks[i];\n            const hash = block.hash();\n            if (!hash.equals(denseSuffixHead.prevHash)) {\n                break;\n            }\n\n            denseSuffix.push(block);\n            denseSuffixHead = block;\n        }\n        denseSuffix.reverse();\n        return denseSuffix;\n    }\n\n    /**\n     * @returns {Promise.<Array.<BlockChain>>}\n     */\n    async getSuperChains() {\n        if (!this._chains) {\n            this._chains = [];\n            for (let i = 0; i < this.length; i++) {\n                const block = this.blocks[i];\n                const depth = BlockUtils.getHashDepth(await block.pow());\n\n                if (this._chains[depth]) {\n                    this._chains[depth].blocks.push(block);\n                } else if (!this._chains[depth]) {\n                    this._chains[depth] = new BlockChain([block]);\n                }\n\n                for (let j = depth - 1; j >= 0; j--) {\n                    if (this._chains[j]) {\n                        this._chains[j].blocks.push(block);\n                    }\n                }\n            }\n\n            for (let i = 0; i < this._chains.length; i++) {\n                if (!this._chains[i]) {\n                    this._chains[i] = new BlockChain([]);\n                }\n            }\n        }\n        return this._chains;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isAnchored() {\n        return GenesisConfig.GENESIS_HASH.equals(this.tail.hash());\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `BlockChain{length=${this.length}}`;\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._blocks.length;\n    }\n\n    /** @type {Array.<Block>} */\n    get blocks() {\n        return this._blocks;\n    }\n\n    /** @type {Block} */\n    get head() {\n        return this._blocks[this.length - 1];\n    }\n\n    /** @type {Block} */\n    get tail() {\n        return this._blocks[0];\n    }\n\n    /**\n     * @returns {number}\n     */\n    totalDifficulty() {\n        return this._blocks.reduce((sum, block) => sum + BlockUtils.targetToDifficulty(block.target), 0);\n    }\n}\nClass.register(BlockChain);\n","class HeaderChain {\n    /**\n     * @param {Array.<BlockHeader>} headers\n     */\n    constructor(headers) {\n        if (!headers || !Array.isArray(headers) || !NumberUtils.isUint16(headers.length)\n            || headers.some(it => !(it instanceof BlockHeader))) throw new Error('Malformed headers');\n\n        /** @type {Array.<BlockHeader>} */\n        this._headers = headers;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {HeaderChain}\n     */\n    static unserialize(buf) {\n        const count = buf.readUint16();\n        const headers = [];\n        for (let i = 0; i < count; i++) {\n            headers.push(BlockHeader.unserialize(buf));\n        }\n        return new HeaderChain(headers);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint16(this._headers.length);\n        for (const header of this._headers) {\n            header.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*count*/ 2\n            + this._headers.reduce((sum, header) => sum + header.serializedSize, 0);\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    async verify() {\n        // For performance reasons, we DO NOT VERIFY the validity of the blocks in the chain here.\n        // Block validity is checked by the Nano/LightChain upon receipt of a ChainProof.\n\n        // Check that all headers in the chain are valid successors of one another.\n        for (let i = this._headers.length - 1; i >= 1; i--) {\n            if (!this._headers[i].isImmediateSuccessorOf(this._headers[i - 1])) {\n                return false;\n            }\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `HeaderChain{length=${this.length}}`;\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._headers.length;\n    }\n\n    /** @type {Array.<BlockHeader>} */\n    get headers() {\n        return this._headers;\n    }\n\n    /** @type {BlockHeader} */\n    get head() {\n        return this._headers[this.length - 1];\n    }\n\n    /** @type {BlockHeader} */\n    get tail() {\n        return this._headers[0];\n    }\n\n    /**\n     * @returns {number}\n     */\n    totalDifficulty() {\n        return this._headers.reduce((sum, header) => sum + BlockUtils.targetToDifficulty(header.target), 0);\n    }\n}\nClass.register(HeaderChain);\n","class ChainProof {\n    /**\n     * @param {BlockChain} prefix\n     * @param {HeaderChain} suffix\n     */\n    constructor(prefix, suffix) {\n        if (!(prefix instanceof BlockChain) || !prefix.length) throw new Error('Malformed prefix');\n        if (!(suffix instanceof HeaderChain)) throw new Error('Malformed suffix');\n\n        /** @type {BlockChain} */\n        this._prefix = prefix;\n        /** @type {HeaderChain} */\n        this._suffix = suffix;\n    }\n\n    static unserialize(buf) {\n        const prefix = BlockChain.unserialize(buf);\n        const suffix = HeaderChain.unserialize(buf);\n        return new ChainProof(prefix, suffix);\n    }\n\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        this._prefix.serialize(buf);\n        this._suffix.serialize(buf);\n        return buf;\n    }\n\n    get serializedSize() {\n        return this._prefix.serializedSize\n            + this._suffix.serializedSize;\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    async verify() {\n        // Check that the prefix chain is anchored.\n        if (!this._prefix.isAnchored()) {\n            return false;\n        }\n\n        // Check that both prefix and suffix are valid chains.\n        if (!(await this._prefix.verify()) || !(await this._suffix.verify())) {\n            return false;\n        }\n\n        // Check that the suffix connects to the prefix.\n        if (this._suffix.length > 0 && !this._suffix.tail.isImmediateSuccessorOf(this._prefix.head.header)) {\n            return false;\n        }\n\n        // Verify the block targets where possible.\n        if (!this._verifyDifficulty()) {\n            return false;\n        }\n\n        // Everything checks out.\n        return true;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n    _verifyDifficulty() {\n        // Extract the dense suffix of the prefix.\n        /** Array.<BlockHeader> */\n        const denseSuffix = this.prefix.denseSuffix().map(block => block.header);\n        /** Array.<BlockHeader> */\n        const denseChain = denseSuffix.concat(this.suffix.headers);\n\n        // Compute totalDifficulty for each block of the dense chain.\n        let totalDifficulty = 0;\n        const totalDifficulties = [];\n        for (let i = 0; i < denseChain.length; i++) {\n            totalDifficulty += denseChain[i].difficulty;\n            totalDifficulties[i] = totalDifficulty;\n        }\n\n        let headIndex = denseChain.length - 2;\n        let tailIndex = headIndex - Policy.DIFFICULTY_BLOCK_WINDOW;\n        while (tailIndex >= 0 && headIndex >= 0) {\n            const headBlock = denseChain[headIndex];\n            const tailBlock = denseChain[tailIndex];\n            const deltaTotalDifficulty = totalDifficulties[headIndex] - totalDifficulties[tailIndex];\n            const target = BlockUtils.getNextTarget(headBlock, tailBlock, deltaTotalDifficulty);\n            const nBits = BlockUtils.targetToCompact(target);\n\n            /** @type {BlockHeader} */\n            const checkBlock = denseChain[headIndex + 1];\n            if (checkBlock.nBits !== nBits) {\n                Log.w(ChainProof, `Block target mismatch: expected=${nBits}, got=${checkBlock.nBits}`);\n                return false;\n            }\n\n            --headIndex;\n            if (tailIndex !== 0 || tailBlock.height !== 1) {\n                --tailIndex;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `ChainProof{prefix=${this._prefix.length}, suffix=${this._suffix.length}, height=${this.head.height}}`;\n    }\n\n    /** @type {BlockChain} */\n    get prefix() {\n        return this._prefix;\n    }\n\n    /** @type {HeaderChain} */\n    get suffix() {\n        return this._suffix;\n    }\n\n    /** @type {BlockHeader} */\n    get head() {\n        return this._suffix.length > 0 ? this._suffix.head : this._prefix.head.header;\n    }\n}\nClass.register(ChainProof);\n","class ChainData {\n    /**\n     * @param {Block} block\n     * @param {SuperBlockCounts} [superBlockCounts]\n     * @returns {Promise.<ChainData>}\n     */\n    static async initial(block, superBlockCounts) {\n        const pow = await block.pow();\n        const totalWork = BlockUtils.realDifficulty(pow);\n\n        const depth = BlockUtils.getHashDepth(pow);\n        if (superBlockCounts) {\n            superBlockCounts = superBlockCounts.copyAndAdd(depth);\n        } else {\n            superBlockCounts = new SuperBlockCounts();\n            superBlockCounts.add(depth);\n        }\n\n        return new ChainData(block, block.difficulty, totalWork, superBlockCounts, true);\n    }\n\n    /**\n     * @param {Block} head\n     * @param {number} totalDifficulty\n     * @param {number} totalWork\n     * @param {SuperBlockCounts} superBlockCounts\n     * @param {boolean} [onMainChain]\n     * @param {Hash} [mainChainSuccessor]\n     */\n    constructor(head, totalDifficulty, totalWork, superBlockCounts, onMainChain = false, mainChainSuccessor = null) {\n        this._head = head;\n        this._totalDifficulty = totalDifficulty;\n        this._totalWork = totalWork;\n        this._superBlockCounts = superBlockCounts;\n        this._onMainChain = onMainChain;\n        this._mainChainSuccessor = mainChainSuccessor;\n        this._height = head.height;\n    }\n\n    /**\n     * @returns {{_head: SerialBuffer, _totalDifficulty: number, _totalWork: number, _superBlockCounts: Array.<number>, _onMainChain: boolean, _mainChainSuccessor: ?SerialBuffer, _height: number, _pow: SerialBuffer}}\n     */\n    toObj() {\n        Assert.that(this._head.header._pow instanceof Hash, 'Expected cached PoW hash');\n        return {\n            _head: this._head.toLight().serialize(),\n            _totalDifficulty: this._totalDifficulty,\n            _totalWork: this._totalWork,\n            _superBlockCounts: this._superBlockCounts.array,\n            _onMainChain: this._onMainChain,\n            _mainChainSuccessor: this._mainChainSuccessor ? this._mainChainSuccessor.serialize() : null,\n            _height: this._head.height,\n            _pow: this._head.header._pow.serialize()\n        };\n    }\n\n    /**\n     * @param {{_head: Uint8Array, _totalDifficulty: number, _totalWork: number, _superBlockCounts: Array.<number>, _onMainChain: boolean, _mainChainSuccessor: ?Uint8Array, _height: number, _pow: Uint8Array}} obj\n     * @param {string} [hashBase64]\n     * @returns {ChainData}\n     */\n    static fromObj(obj, hashBase64) {\n        if (!obj) return obj;\n        const head = Block.unserialize(new SerialBuffer(obj._head));\n        head.header._pow = Hash.unserialize(new SerialBuffer(obj._pow));\n        head.header._hash = hashBase64 ? Hash.fromBase64(hashBase64) : null;\n        const superBlockCounts = new SuperBlockCounts(obj._superBlockCounts);\n        const successor = obj._mainChainSuccessor ? Hash.unserialize(new SerialBuffer(obj._mainChainSuccessor)) : null;\n        return new ChainData(\n            head,\n            obj._totalDifficulty,\n            obj._totalWork,\n            superBlockCounts,\n            obj._onMainChain,\n            successor\n        );\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<ChainData>}\n     */\n    async nextChainData(block) {\n        Assert.that(this._totalDifficulty > 0);\n\n        const pow = await block.pow();\n        const totalDifficulty = this.totalDifficulty + block.difficulty;\n        const totalWork = this.totalWork + BlockUtils.realDifficulty(pow);\n        const superBlockCounts = this.superBlockCounts.copyAndAdd(BlockUtils.getHashDepth(pow));\n        return new ChainData(block, totalDifficulty, totalWork, superBlockCounts);\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<ChainData>}\n     */\n    async previousChainData(block) {\n        Assert.that(this._totalDifficulty > 0);\n\n        const pow = await this.head.pow();\n        const totalDifficulty = this.totalDifficulty - this.head.difficulty;\n        const totalWork = this.totalWork - BlockUtils.realDifficulty(pow);\n        const superBlockCounts = this.superBlockCounts.copyAndSubtract(BlockUtils.getHashDepth(pow));\n        return new ChainData(block, totalDifficulty, totalWork, superBlockCounts);\n    }\n\n    /** @type {Block} */\n    get head() {\n        return this._head;\n    }\n\n    /** @type {number} */\n    get totalDifficulty() {\n        return this._totalDifficulty;\n    }\n\n    /** @type {number} */\n    get totalWork() {\n        return this._totalWork;\n    }\n\n    /** @type {SuperBlockCounts} */\n    get superBlockCounts() {\n        return this._superBlockCounts;\n    }\n\n    /** @type {boolean} */\n    get onMainChain() {\n        return this._onMainChain;\n    }\n\n    /** @type {boolean} */\n    set onMainChain(onMainChain) {\n        this._onMainChain = onMainChain;\n    }\n\n    /** @type {Hash} */\n    get mainChainSuccessor() {\n        return this._mainChainSuccessor;\n    }\n\n    /** @type {Hash} */\n    set mainChainSuccessor(mainChainSuccessor) {\n        this._mainChainSuccessor = mainChainSuccessor;\n    }\n}\nClass.register(ChainData);\n\nclass SuperBlockCounts {\n    /**\n     * @constructor\n     * @param {Array.<number>} array\n     */\n    constructor(array = []) {\n        this._arr = array;\n    }\n\n    /**\n     * @param {number} depth\n     */\n    add(depth) {\n        Assert.that(NumberUtils.isUint8(depth));\n        for (let i = 0; i <= depth; i++) {\n            this._arr[i] = this.get(i) + 1;\n        }\n    }\n\n    /**\n     * @param {number} depth\n     */\n    subtract(depth) {\n        Assert.that(NumberUtils.isUint8(depth));\n        for (let i = 0; i <= depth; i++) {\n            this._arr[i]--;\n            Assert.that(this._arr[i] >= 0);\n        }\n    }\n\n    /**\n     * @param {number} depth\n     * @returns {SuperBlockCounts}\n     */\n    copyAndAdd(depth) {\n        const copy = new SuperBlockCounts(this._arr.slice());\n        copy.add(depth);\n        return copy;\n    }\n\n    /**\n     * @param {number} depth\n     * @returns {SuperBlockCounts}\n     */\n    copyAndSubtract(depth) {\n        const copy = new SuperBlockCounts(this._arr.slice());\n        copy.subtract(depth);\n        return copy;\n    }\n\n    /**\n     * @param {number} depth\n     * @returns {number}\n     */\n    get(depth) {\n        Assert.that(NumberUtils.isUint8(depth));\n        return this._arr[depth] || 0;\n    }\n\n    /**\n     * @param {number} m\n     * @returns {number}\n     */\n    getCandidateDepth(m) {\n        for (let i = this._arr.length - 1; i >= 0; i--) {\n            if (this._arr[i] >= m) {\n                return i;\n            }\n        }\n        return 0;\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._arr.length;\n    }\n\n    /** @type {Array.<number>} */\n    get array() {\n        return this._arr;\n    }\n}\nClass.register(SuperBlockCounts);\n","class ChainDataStore {\n    /**\n     * @param {JungleDB} jdb\n     */\n    static initPersistent(jdb) {\n        const chainStore = jdb.createObjectStore('ChainData', {\n            codec: new ChainDataStoreCodec(),\n            enableLruCache: ChainDataStore.CHAINDATA_CACHING_ENABLED,\n            lruCacheSize: ChainDataStore.CHAINDATA_CACHE_SIZE\n        });\n        ChainDataStore._createIndexes(chainStore);\n\n        jdb.createObjectStore('Block', {\n            codec: new BlockStoreCodec(),\n            enableLruCache: ChainDataStore.BLOCKS_CACHING_ENABLED,\n            lruCacheSize: ChainDataStore.BLOCKS_CACHE_SIZE,\n            rawLruCacheSize: ChainDataStore.BLOCKS_RAW_CACHE_SIZE\n        });\n    }\n\n    /**\n     * @param {JungleDB} jdb\n     * @returns {ChainDataStore}\n     */\n    static getPersistent(jdb) {\n        const chainStore = jdb.getObjectStore('ChainData');\n        const blockStore = jdb.getObjectStore('Block');\n        return new ChainDataStore(chainStore, blockStore);\n    }\n\n    /**\n     * @returns {ChainDataStore}\n     */\n    static createVolatile() {\n        const chainStore = JDB.JungleDB.createVolatileObjectStore({ codec: new ChainDataStoreCodec() });\n        const blockStore = JDB.JungleDB.createVolatileObjectStore({ codec: new BlockStoreCodec() });\n        ChainDataStore._createIndexes(chainStore);\n        return new ChainDataStore(chainStore, blockStore);\n    }\n\n    /**\n     * @param {IObjectStore} chainStore\n     * @private\n     */\n    static _createIndexes(chainStore) {\n        chainStore.createIndex('height', ['_height'], { lmdbKeyEncoding: JDB.JungleDB.NUMBER_ENCODING, leveldbKeyEncoding: JDB.JungleDB.NUMBER_ENCODING });\n    }\n\n    /**\n     * @param {IObjectStore} chainStore\n     * @param {IObjectStore} blockStore\n     */\n    constructor(chainStore, blockStore) {\n        /** @type {IObjectStore} */\n        this._chainStore = chainStore;\n        /** @type {IObjectStore} */\n        this._blockStore = blockStore;\n    }\n\n    /**\n     * @param {Hash} key\n     * @param {boolean} [includeBody]\n     * @returns {Promise.<?ChainData>}\n     */\n    async getChainData(key, includeBody = false) {\n        /** @type {ChainData} */\n        const chainData = await this._chainStore.get(key.toBase64());\n        if (!chainData || !includeBody) {\n            return chainData;\n        }\n\n        const block = await this._blockStore.get(key.toBase64());\n        if (block && block.isFull()) {\n            chainData.head._body = block.body;\n        }\n\n        return chainData;\n    }\n\n    /**\n     * @param {Hash} key\n     * @param {ChainData} chainData\n     * @param {boolean} [includeBody]\n     * @returns {Promise.<void>}\n     */\n    putChainData(key, chainData, includeBody = true) {\n        if (this._chainStore instanceof JDB.Transaction) {\n            this._chainStore.putSync(key.toBase64(), chainData);\n            if (includeBody && chainData.head.isFull()) {\n                this._blockStore.putSync(key.toBase64(), chainData.head);\n            }\n            return Promise.resolve(true);\n        }\n\n        if (includeBody && chainData.head.isFull()) {\n            const chainTx = this._chainStore.synchronousTransaction();\n            chainTx.putSync(key.toBase64(), chainData);\n            const blockTx = this._blockStore.synchronousTransaction();\n            blockTx.putSync(key.toBase64(), chainData.head);\n            return JDB.JungleDB.commitCombined(chainTx, blockTx);\n        }\n\n        return this._chainStore.put(key.toBase64(), chainData);\n    }\n\n    /**\n     * @param {Hash} key\n     * @param {ChainData} chainData\n     * @param {boolean} [includeBody]\n     * @returns {void}\n     */\n    putChainDataSync(key, chainData, includeBody = true) {\n        Assert.that(this._chainStore instanceof JDB.Transaction);\n        this._chainStore.putSync(key.toBase64(), chainData);\n        if (includeBody && chainData.head.isFull()) {\n            this._blockStore.putSync(key.toBase64(), chainData.head);\n        }\n    }\n\n    /**\n     * @param {Hash} key\n     * @param {boolean} [includeBody]\n     * @returns {?Block}\n     */\n    async getBlock(key, includeBody = false) {\n        if (includeBody) {\n            const block = await this._blockStore.get(key.toBase64());\n            if (block) {\n                return block;\n            }\n        }\n\n        const chainData = await this._chainStore.get(key.toBase64());\n        return chainData ? chainData.head : null;\n    }\n\n    /**\n     * @param {Hash} key\n     * @param {boolean} [includeForks]\n     * @returns {Promise.<?Uint8Array>}\n     */\n    async getRawBlock(key, includeForks = false) {\n        /** @type {ChainData} */\n        const chainData = await this._chainStore.get(key.toBase64());\n        if (!chainData || (!chainData.onMainChain && !includeForks)) {\n            return null;\n        }\n\n        const block = await this._blockStore.get(key.toBase64(), { raw: true });\n        if (block) {\n            return new Uint8Array(block);\n        }\n\n        return null;\n    }\n\n    /**\n     * @param {number} height\n     * @param {boolean} [includeBody]\n     * @returns {Promise.<?ChainData>}\n     */\n    async getChainDataAt(height, includeBody = false) {\n        /** @type {Array.<ChainData>} */\n        const candidates = await this._chainStore.values(JDB.Query.eq('height', height));\n        if (!candidates || !candidates.length) {\n            return undefined;\n        }\n\n        for (const chainData of candidates) {\n            if (chainData.onMainChain) {\n                if (includeBody) {\n                    // eslint-disable-next-line no-await-in-loop\n                    const block = await this._blockStore.get(chainData.head.hash().toBase64());\n                    if (block) {\n                        chainData._head = block;\n                    }\n                }\n                return chainData;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @param {number} height\n     * @param {boolean} [includeBody]\n     * @returns {Promise.<?Block>}\n     */\n    async getBlockAt(height, includeBody = false) {\n        const chainData = await this.getChainDataAt(height, includeBody);\n        return chainData ? chainData.head : null;\n    }\n\n    /**\n     * @param {number} height\n     * @param {boolean} [lower]\n     * @returns {Promise.<?Block>}\n     */\n    async getNearestBlockAt(height, lower = true) {\n        const index = this._chainStore.index('height');\n        /** @type {Array.<ChainData>} */\n        const candidates = lower ?\n            await index.maxValues(JDB.KeyRange.upperBound(height)) :\n            await index.minValues(JDB.KeyRange.lowerBound(height));\n        if (!candidates || !candidates.length) {\n            return undefined;\n        }\n\n        for (const chainData of candidates) {\n            if (chainData.onMainChain) {\n                return chainData.head;\n            }\n        }\n\n        return null;\n    }\n\n    // /**\n    //  * @param {number} startHeight\n    //  * @param {number} [count]\n    //  * @param {boolean} [forward]\n    //  * @returns {Promise.<Array.<Block>>}\n    //  */\n    // async getBlocks(startHeight, count = 500, forward = true) {\n    //     if (count <= 0) {\n    //         return [];\n    //     }\n    //     if (!forward) {\n    //         startHeight = startHeight - count;\n    //     }\n    //     /** @type {Array.<ChainData>} */\n    //     let candidates = await this._chainStore.values(JDB.Query.within('height', startHeight, startHeight + count - 1));\n    //     candidates = candidates\n    //         .filter(chainData => chainData.onMainChain)\n    //         .map(chainData => chainData.head);\n    //     const sortNumber = forward ? ((a, b) => a.height - b.height) : ((a, b) => b.height - a.height);\n    //     candidates.sort(sortNumber);\n    //     return candidates;\n    // }\n\n    /**\n     * @param {Hash} startBlockHash\n     * @param {number} [count]\n     * @param {boolean} [forward]\n     * @returns {Promise.<Array.<Block>>}\n     */\n    getBlocks(startBlockHash, count = 500, forward = true) {\n        if (count <= 0) {\n            return Promise.resolve([]);\n        }\n\n        if (forward) {\n            return this.getBlocksForward(startBlockHash, count);\n        } else {\n            return this.getBlocksBackward(startBlockHash, count);\n        }\n    }\n\n    /**\n     * @param {Hash} startBlockHash\n     * @param {number} count\n     * @returns {Promise.<Array.<Block>>}\n     */\n    async getBlocksForward(startBlockHash, count = 500) {\n        /** @type {ChainData} */\n        let chainData = await this._chainStore.get(startBlockHash.toBase64());\n        if (!chainData) {\n            return [];\n        }\n\n        const blocks = [];\n        while (blocks.length < count && chainData.mainChainSuccessor) {\n            chainData = await this._chainStore.get(chainData.mainChainSuccessor.toBase64());\n            if (!chainData) {\n                return blocks;\n            }\n            blocks.push(chainData.head);\n        }\n        return blocks;\n    }\n\n    /**\n     * @param {Hash} startBlockHash\n     * @param {number} count\n     * @param {boolean} includeBody\n     * @returns {Promise.<Array.<Block>>}\n     */\n    async getBlocksBackward(startBlockHash, count = 500, includeBody = false) {\n        const getBlock = includeBody\n            ? key => this._blockStore.get(key)\n            : key => this._chainStore.get(key).then(data => data.head);\n\n        /** @type {ChainData} */\n        const chainData = await this._chainStore.get(startBlockHash.toBase64());\n        if (!chainData) {\n            return [];\n        }\n\n        /** @type {Block} */\n        let block = chainData.head;\n        const blocks = [];\n        while (blocks.length < count && block.height > 1) {\n            block = await getBlock(block.prevHash.toBase64());\n            if (!block) {\n                return blocks;\n            }\n            blocks.push(block);\n        }\n        return blocks;\n    }\n\n    /**\n    /**\n     * @returns {Promise.<Hash|undefined>}\n     */\n    async getHead() {\n        const key = await this._chainStore.get('main');\n        return key ? Hash.fromBase64(key) : undefined;\n    }\n\n    /**\n     * @param {Hash} key\n     * @returns {Promise.<void>}\n     */\n    setHead(key) {\n        return this._chainStore.put('main', key.toBase64());\n    }\n\n    /**\n     * @param {Hash} key\n     * @returns {void}\n     */\n    setHeadSync(key) {\n        Assert.that(this._chainStore instanceof JDB.SynchronousTransaction);\n        this._chainStore.putSync('main', key.toBase64());\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {ChainDataStore}\n     */\n    transaction(enableWatchdog = true) {\n        const chainTx = this._chainStore.transaction(enableWatchdog);\n        const blockTx = this._blockStore.transaction(enableWatchdog);\n        return new ChainDataStore(chainTx, blockTx);\n    }\n\n    /**\n     * @param {boolean} [enableWatchdog]\n     * @returns {ChainDataStore}\n     */\n    synchronousTransaction(enableWatchdog = true) {\n        const chainTx = this._chainStore.synchronousTransaction(enableWatchdog);\n        const blockTx = this._blockStore.synchronousTransaction(enableWatchdog);\n        return new ChainDataStore(chainTx, blockTx);\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    commit() {\n        if (this._chainStore instanceof JDB.Transaction) {\n            return JDB.JungleDB.commitCombined(this._chainStore, this._blockStore);\n        }\n        return Promise.resolve();\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    abort() {\n        return Promise.all([this._chainStore.abort(), this._blockStore.abort()]);\n    }\n\n    /**\n     * @returns {ChainDataStore}\n     */\n    snapshot() {\n        const chainSnapshot = this._chainStore.snapshot();\n        const blockSnapshot = this._blockStore.snapshot();\n        return new ChainDataStore(chainSnapshot, blockSnapshot);\n    }\n\n    /**\n     * @returns {Promise}\n     */\n    truncate() {\n        if (this._chainStore instanceof JDB.Transaction) {\n            this._chainStore.truncateSync();\n            this._blockStore.truncateSync();\n            return Promise.resolve(true);\n        }\n\n        const chainTx = this._chainStore.transaction();\n        chainTx.truncateSync();\n        const blockTx = this._blockStore.transaction();\n        blockTx.truncateSync();\n        return JDB.JungleDB.commitCombined(chainTx, blockTx);\n    }\n\n    /** @type {Array.<JDB.Transaction>} */\n    get txs() {\n        if (this._chainStore instanceof JDB.Transaction) {\n            return [this._chainStore, this._blockStore];\n        }\n        return [];\n    }\n}\nChainDataStore.CHAINDATA_CACHING_ENABLED = true;\nChainDataStore.CHAINDATA_CACHE_SIZE = 5000;\nChainDataStore.BLOCKS_CACHING_ENABLED = true;\nChainDataStore.BLOCKS_CACHE_SIZE = 0;\nChainDataStore.BLOCKS_RAW_CACHE_SIZE = 500;\nClass.register(ChainDataStore);\n\n/**\n * @implements {ICodec}\n */\nclass ChainDataStoreCodec {\n    /**\n     * @param {*} obj The object to encode before storing it.\n     * @returns {*} Encoded object.\n     */\n    encode(obj) {\n        return typeof obj === 'string' ? obj : obj.toObj();\n    }\n\n    /**\n     * @param {*} obj The object to decode.\n     * @param {string} key The object's primary key.\n     * @returns {*} Decoded object.\n     */\n    decode(obj, key) {\n        return typeof obj === 'string' ? obj : ChainData.fromObj(obj, key);\n    }\n\n    /**\n     * @type {{encode: function(val:*):*, decode: function(val:*):*, buffer: boolean, type: string}|void}\n     */\n    get valueEncoding() {\n        return JDB.JungleDB.JSON_ENCODING;\n    }\n}\n\n/**\n * @implements {ICodec}\n */\nclass BlockStoreCodec {\n    /**\n     * @param {*} obj The object to encode before storing it.\n     * @returns {*} Encoded object.\n     */\n    encode(obj) {\n        return obj.serialize();\n    }\n\n    /**\n     * @param {*} obj The object to decode.\n     * @param {string} key The object's primary key.\n     * @returns {*} Decoded object.\n     */\n    decode(obj, key) {\n        const block = Block.unserialize(new SerialBuffer(obj));\n        block.header._hash = Hash.fromBase64(key);\n        return block;\n    }\n\n    /**\n     * @type {{encode: function(val:*):*, decode: function(val:*):*, buffer: boolean, type: string}|void}\n     */\n    get valueEncoding() {\n        return JDB.JungleDB.BINARY_ENCODING;\n    }\n}\n","class MempoolTransactionSet {\n    /**\n     * @param {Array.<Transaction>} [sortedTransactions]\n     */\n    constructor(sortedTransactions) {\n        /** @type {SortedList.<Transaction>} */\n        this._transactions = new SortedList(sortedTransactions);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {MempoolTransactionSet}\n     */\n    add(transaction) {\n        this._transactions.add(transaction);\n        return this;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {MempoolTransactionSet}\n     */\n    remove(transaction) {\n        this._transactions.remove(transaction);\n        return this;\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {MempoolTransactionSet}\n     */\n    copyAndAdd(transaction) {\n        const transactions = this._transactions.copy();\n        transactions.add(transaction);\n        return new MempoolTransactionSet(transactions.values());\n    }\n\n    /** @type {Array.<Transaction>} */\n    get transactions() {\n        return this._transactions.values();\n    }\n\n    /** @type {Address} */\n    get sender() {\n        return this._transactions.length > 0 ? this._transactions.values()[0].sender : null;\n    }\n\n    /** @type {?Account.Type} */\n    get senderType() {\n        return this._transactions.length > 0 ? this._transactions.values()[0].senderType : undefined;\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._transactions.length;\n    }\n\n    /**\n     * @param {number} feePerByte\n     * @return {number}\n     */\n    numBelowFeePerByte(feePerByte) {\n        return this._transactions.values().filter(t => t.fee / t.serializedSize < feePerByte).length;\n    }\n\n    toString() {\n        return `MempoolTransactionSet{length=${this.length}}`;\n    }\n}\n\nClass.register(MempoolTransactionSet);\n","class Mempool extends Observable {\n    /**\n     * @param {IBlockchain} blockchain\n     * @param {Accounts} accounts\n     */\n    constructor(blockchain, accounts) {\n        super();\n        /** @type {IBlockchain} */\n        this._blockchain = blockchain;\n        /** @type {Accounts} */\n        this._accounts = accounts;\n\n        // Our pool of transactions.\n        /** @type {SortedList.<Transaction>} */\n        this._transactionsByFeePerByte = new SortedList(); // uses Transaction.compare, by fee descending\n        /** @type {HashMap.<Hash, Transaction>} */\n        this._transactionsByHash = new HashMap();\n        /** @type {HashMap.<Address, MempoolTransactionSet>} */\n        this._transactionSetBySender = new HashMap();\n        /** @type {HashMap.<Address, HashSet.<Hash>>} */\n        this._transactionSetByRecipient = new HashMap();\n        /** @type {Synchronizer} */\n        this._synchronizer = new Synchronizer();\n\n        // Listen for changes in the blockchain head to evict transactions that have become invalid.\n        blockchain.on('head-changed', () => this._evictTransactions());\n        blockchain.on('block-reverted', (block) => this._restoreTransactions(block));\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @fires Mempool#transaction-added\n     * @returns {Promise.<Mempool.ReturnCode>}\n     */\n    pushTransaction(transaction) {\n        return this._synchronizer.push(() => this._pushTransaction(transaction));\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @returns {Promise.<Mempool.ReturnCode>}\n     * @private\n     */\n    async _pushTransaction(transaction) {\n        // Check if we already know this transaction.\n        const hash = transaction.hash();\n        if (this._transactionsByHash.contains(hash)) {\n            return Mempool.ReturnCode.KNOWN;\n        }\n\n        const set = this._transactionSetBySender.get(transaction.sender) || new MempoolTransactionSet();\n        // Check limit for free transactions.\n        if (transaction.fee / transaction.serializedSize < Mempool.TRANSACTION_RELAY_FEE_MIN\n            && set.numBelowFeePerByte(Mempool.TRANSACTION_RELAY_FEE_MIN) >= Mempool.FREE_TRANSACTIONS_PER_SENDER_MAX) {\n            return Mempool.ReturnCode.FEE_TOO_LOW;\n        }\n\n        // Intrinsic transaction verification\n        if (!transaction.verify()) {\n            return Mempool.ReturnCode.INVALID;\n        }\n\n        // Retrieve recipient account and test incoming transaction.\n        /** @type {Account} */\n        let recipientAccount;\n        try {\n            recipientAccount = await this._accounts.get(transaction.recipient);\n            recipientAccount.withIncomingTransaction(transaction, this._blockchain.height + 1);\n        } catch (e) {\n            Log.d(Mempool, () => `Rejected transaction from ${transaction.sender} - ${e.message}`);\n            return Mempool.ReturnCode.INVALID;\n        }\n\n        // Retrieve sender account.\n        /** @type {Account} */\n        let senderAccount;\n        try {\n            senderAccount = await this._accounts.get(transaction.sender, transaction.senderType);\n        } catch (e) {\n            Log.d(Mempool, () => `Rejected transaction from ${transaction.sender} - ${e.message}`);\n            return Mempool.ReturnCode.INVALID;\n        }\n\n        // Add new transaction to the sender's pending transaction set. Then re-check all transactions in the set\n        // in fee/byte order against the sender account state. Adding high fee transactions may thus invalidate\n        // low fee transactions in the set.\n        const transactions = [];\n        let tmpAccount = senderAccount;\n        for (const tx of set.copyAndAdd(transaction).transactions) {\n            let error = 'transactions per sender exceeded';\n            try {\n                if (transactions.length < Mempool.TRANSACTIONS_PER_SENDER_MAX) {\n                    tmpAccount = tmpAccount.withOutgoingTransaction(tx, this._blockchain.height + 1, this._blockchain.transactionCache);\n                    transactions.push(tx);\n\n                    // Transaction ok, move to next one.\n                    continue;\n                }\n            } catch (e) {\n                error = e.message;\n            }\n\n            // An error occurred processing this transaction.\n            // If the rejected transaction is the one we're pushing, fail.\n            // Otherwise, evict the rejected transaction from the mempool.\n            if (tx.equals(transaction)) {\n                Log.d(Mempool, () => `Rejected transaction from ${transaction.sender} - ${error}`);\n                return Mempool.ReturnCode.INVALID;\n            } else {\n                // Remove transaction\n                this._removeTransaction(tx);\n            }\n        }\n\n        if (this._transactionsByFeePerByte.length >= Mempool.SIZE_MAX) {\n            this._popLowFeeTransaction();\n        }\n\n        // Transaction is valid, add it to the mempool.\n        this._transactionsByFeePerByte.add(transaction);\n        this._transactionsByHash.put(hash, transaction);\n        this._transactionSetBySender.put(transaction.sender, new MempoolTransactionSet(transactions));\n        /** @type {HashSet.<Hash>} */\n        const byRecipient = this._transactionSetByRecipient.get(transaction.recipient) || new HashSet();\n        byRecipient.add(transaction.hash());\n        this._transactionSetByRecipient.put(transaction.recipient, byRecipient);\n\n        // Tell listeners about the new valid transaction we received.\n        this.fire('transaction-added', transaction);\n\n        return Mempool.ReturnCode.ACCEPTED;\n    }\n\n    /**\n     * @private\n     */\n    _popLowFeeTransaction() {\n        // Remove transaction\n        const transaction = this._transactionsByFeePerByte.pop();\n\n        /** @type {MempoolTransactionSet} */\n        const set = this._transactionSetBySender.get(transaction.sender);\n        set.remove(transaction);\n\n        /** @type {HashSet.<Hash>} */\n        const byRecipient = this._transactionSetByRecipient.get(transaction.recipient);\n        if (byRecipient) {\n            if (byRecipient.length === 1) {\n                this._transactionSetByRecipient.remove(transaction.recipient);\n            } else {\n                byRecipient.remove(transaction.hash());\n            }\n        } else {\n            Log.e(Mempool, `Invalid state: no transactionsByRecipient for ${transaction}`);\n        }\n\n        this._transactionsByHash.remove(transaction.hash());\n    }\n\n    /**\n     * Does *not* remove transaction from transactionsBySender!\n     * @param {Transaction} transaction\n     * @private\n     */\n    _removeTransaction(transaction) {\n        this._transactionsByHash.remove(transaction.hash());\n\n        // TODO: Optimise remove from this._transactionsByMinFee.\n        this._transactionsByFeePerByte.remove(transaction);\n\n        /** @type {HashSet.<Hash>} */\n        const byRecipient = this._transactionSetByRecipient.get(transaction.recipient);\n        if (byRecipient) {\n            if (byRecipient.length === 1) {\n                this._transactionSetByRecipient.remove(transaction.recipient);\n            } else {\n                byRecipient.remove(transaction.hash());\n            }\n        } else {\n            Log.e(Mempool, `Invalid state: no transactionsByRecipient for ${transaction}`);\n        }\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Transaction}\n     */\n    getTransaction(hash) {\n        return this._transactionsByHash.get(hash);\n    }\n\n    /**\n     * @param {number} [maxSize]\n     * @param {number} [minFeePerByte]\n     * @returns {Array.<Transaction>}\n     */\n    *transactionGenerator(maxSize = Infinity, minFeePerByte = 0) {\n        let size = 0;\n        for (const /** @type {Transaction} */ tx of this._transactionsByFeePerByte) {\n            const txSize = tx.serializedSize;\n            if (size + txSize >= maxSize) continue;\n            if (tx.feePerByte < minFeePerByte) break;\n\n            yield tx;\n            size += txSize;\n        }\n    }\n\n    /**\n     * @param {number} [maxSize]\n     * @param {number} [minFeePerByte]\n     * @returns {Array.<Transaction>}\n     */\n    getTransactions(maxSize = Infinity, minFeePerByte = 0) {\n        return Array.from(this.transactionGenerator(maxSize, minFeePerByte));\n    }\n\n    /**\n     * @param {number} maxSize\n     * @returns {Promise.<Array.<Transaction>>}\n     */\n    async getTransactionsForBlock(maxSize) {\n        const transactions = this.getTransactions(maxSize);\n        const prunedAccounts = await this._accounts.gatherToBePrunedAccounts(transactions, this._blockchain.height + 1, this._blockchain.transactionCache);\n        const prunedAccountsSize = prunedAccounts.reduce((sum, acc) => sum + acc.serializedSize, 0);\n\n        let size = prunedAccountsSize + transactions.reduce((sum, tx) => sum + tx.serializedSize, 0);\n        while (size > maxSize) {\n            size -= transactions.pop().serializedSize;\n        }\n\n        transactions.sort((a, b) => a.compareBlockOrder(b));\n        return transactions;\n    }\n\n    /**\n     * @param {Address} address\n     * @return {Array.<Transaction>}\n     */\n    getPendingTransactions(address) {\n        return this.getTransactionsBySender(address);\n    }\n\n    /**\n     * @param {Address} address\n     * @return {Array.<Transaction>}\n     */\n    getTransactionsBySender(address) {\n        /** @type {MempoolTransactionSet} */\n        const set = this._transactionSetBySender.get(address);\n        return set ? set.transactions : [];\n    }\n\n    /**\n     * @param {Address} address\n     * @return {Array.<Transaction>}\n     */\n    getTransactionsByRecipient(address) {\n        /** @type {HashSet.<Hash>} */\n        const set = this._transactionSetByRecipient.get(address);\n        if (!set) {\n            return [];\n        }\n\n        /** @type {Array.<Transaction>} */\n        const transactions = [];\n        for (const hash of set.valueIterator()) {\n            const tx = this._transactionsByHash.get(hash);\n            Assert.that(!!tx);\n            transactions.push(tx);\n        }\n        return transactions;\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     * @param {number} [maxTransactions]\n     * @return {Array.<Transaction>}\n     */\n    getTransactionsByAddresses(addresses, maxTransactions = Infinity) {\n        const transactions = [];\n        for (const address of addresses) {\n            // Fetch transactions by sender first\n            /** @type {Array.<Transaction>} */\n            const bySender = this.getTransactionsBySender(address);\n            for (const tx of bySender) {\n                if (transactions.length >= maxTransactions) return transactions;\n                transactions.push(tx);\n            }\n\n            // Fetch transactions by recipient second\n            /** @type {Array.<Transaction>} */\n            const byRecipient = this.getTransactionsByRecipient(address);\n            for (const tx of byRecipient) {\n                if (transactions.length >= maxTransactions) return transactions;\n                transactions.push(tx);\n            }\n        }\n        return transactions;\n    }\n\n    /**\n     * @param {number} minFeePerByte\n     */\n    evictBelowMinFeePerByte(minFeePerByte) {\n        /** @type {Transaction} */\n        let transaction = this._transactionsByFeePerByte.peekLast();\n        while (transaction && transaction.feePerByte < minFeePerByte) {\n            this._transactionsByFeePerByte.pop();\n\n            this._transactionsByHash.remove(transaction.hash());\n\n            /** @type {MempoolTransactionSet} */\n            const bySender = this._transactionSetBySender.get(transaction.sender);\n            if (bySender.length === 1) {\n                this._transactionSetBySender.remove(transaction.sender);\n            } else {\n                bySender.remove(transaction);\n            }\n            /** @type {HashSet.<Hash>} */\n            const byRecipient = this._transactionSetByRecipient.get(transaction.recipient);\n            if (byRecipient.length === 1) {\n                this._transactionSetByRecipient.remove(transaction.recipient);\n            } else {\n                byRecipient.remove(transaction.hash());\n            }\n\n            transaction = this._transactionsByFeePerByte.peekLast();\n        }\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise}\n     * @private\n     */\n    _restoreTransactions(block) {\n        return this._synchronizer.push(async () => {\n            for (const tx of block.transactions) {\n                await this._pushTransaction(tx);\n            }\n        });\n    }\n\n    /**\n     * @fires Mempool#transactions-ready\n     * @returns {Promise}\n     * @private\n     */\n    _evictTransactions() {\n        return this._synchronizer.push(() => this.__evictTransactions());\n    }\n\n    /**\n     * @fires Mempool#transactions-ready\n     * @returns {Promise}\n     * @private\n     */\n    async __evictTransactions() {\n        // Evict all transactions from the pool that have become invalid due\n        // to changes in the account state (i.e. typically because the were included\n        // in a newly mined block). No need to re-check signatures.\n        for (const sender of this._transactionSetBySender.keys()) {\n            /** @type {MempoolTransactionSet} */\n            const set = this._transactionSetBySender.get(sender);\n\n            try {\n                const senderAccount = await this._accounts.get(set.sender, set.senderType);\n\n                // If a transaction in the set is not valid anymore,\n                // we try to construct a new set based on the heuristic of including\n                // high fee/byte transactions first.\n                const transactions = [];\n                let account = senderAccount;\n                for (const tx of set.transactions) {\n                    try {\n                        const tmpAccount = account.withOutgoingTransaction(tx, this._blockchain.height + 1, this._blockchain.transactionCache);\n\n                        const recipientAccount = await this._accounts.get(tx.recipient);\n                        recipientAccount.withIncomingTransaction(tx, this._blockchain.height + 1);\n\n                        transactions.push(tx);\n                        account = tmpAccount;\n                    } catch (e) {\n                        // Remove transaction\n                        this._removeTransaction(tx);\n                    }\n                }\n                if (transactions.length === 0) {\n                    this._transactionSetBySender.remove(sender);\n                } else {\n                    this._transactionSetBySender.put(sender, new MempoolTransactionSet(transactions));\n                }\n            } catch (e) {\n                // In case of an error, remove all transactions of this set.\n                for (const tx of set.transactions) {\n                    this._removeTransaction(tx);\n                }\n                this._transactionSetBySender.remove(sender);\n            }\n        }\n\n        // Tell listeners that the pool has updated after a blockchain head change.\n        /**\n         * @event Mempool#transactions-ready\n         */\n        this.fire('transactions-ready');\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._transactionsByHash.length;\n    }\n}\n\n/**\n * Fee threshold in sat/byte below which transactions are considered \"free\".\n * @type {number}\n */\nMempool.TRANSACTION_RELAY_FEE_MIN = 1;\n/**\n * Maximum number of transactions per sender.\n * @type {number}\n */\nMempool.TRANSACTIONS_PER_SENDER_MAX = 500;\n/**\n * Maximum number of \"free\" transactions per sender.\n * @type {number}\n */\nMempool.FREE_TRANSACTIONS_PER_SENDER_MAX = 10;\n/**\n * Maximum number of transactions in the mempool.\n * @type {number}\n */\nMempool.SIZE_MAX = 100000;\n\n/** @enum {number} */\nMempool.ReturnCode = {\n    FEE_TOO_LOW: -2,\n    INVALID: -1,\n\n    ACCEPTED: 1,\n    KNOWN: 2\n};\n\nClass.register(Mempool);\n","class InvRequestManager {\n    constructor() {\n        /** @type {HashMap.<InvVector, {current: BaseConsensusAgent, waiting: Set.<BaseConsensusAgent>}>} */\n        this._vectorsToRequest = new HashMap();\n        /** @type {Timers} */\n        this._timers = new Timers();\n    }\n\n    /**\n     * @param {BaseConsensusAgent} agent\n     * @param {InvVector} vector\n     */\n    askToRequestVector(agent, vector) {\n        if (agent.syncing || this._vectorsToRequest.length > InvRequestManager.MAX_INV_MANAGED) {\n            agent.requestVector(vector);\n            return;\n        }\n        if (this._vectorsToRequest.contains(vector)) {\n            const o = this._vectorsToRequest.get(vector);\n            if (o.current.peer.channel.closed) {\n                o.current = null;\n            }\n            if (o.current === null) {\n                o.current = agent;\n                this._request(vector);\n            } else {\n                o.waiting.add(agent);\n            }\n        } else {\n            this._vectorsToRequest.put(vector, {current: agent, waiting: new Set()});\n            this._request(vector);\n        }\n    }\n\n    /**\n     * @param {InvVector} vector\n     * @private\n     */\n    _request(vector) {\n        Assert.that(this._vectorsToRequest.contains(vector));\n        const agent = this._vectorsToRequest.get(vector).current;\n        Assert.that(agent);\n        agent.requestVector(vector);\n        this._timers.resetTimeout(vector.hash, () => this.noteVectorNotReceived(agent, vector), InvRequestManager.MAX_TIME_PER_VECTOR);\n    }\n\n    /**\n     * @param {BaseConsensusAgent} agent\n     * @param {InvVector} vector\n     */\n    noteVectorNotReceived(agent, vector) {\n        this._timers.clearTimeout(vector.hash);\n        if (this._vectorsToRequest.contains(vector)) {\n            const o = this._vectorsToRequest.get(vector);\n            if (o.current !== agent) return;\n            o.current = null;\n            if (o.waiting.size !== 0) {\n                o.current = o.waiting.values().next().value;\n                o.waiting.delete(o.current);\n                this._request(vector);\n            }\n            if (o.current === null) {\n                this._vectorsToRequest.remove(vector);\n            }\n        }\n    }\n\n    noteVectorReceived(vector) {\n        this._timers.clearTimeout(vector.hash);\n        this._vectorsToRequest.remove(vector);\n    }\n}\n\nInvRequestManager.MAX_TIME_PER_VECTOR = 10000;\nInvRequestManager.MAX_INV_MANAGED = 10000;\n\nClass.register(InvRequestManager);\n","/**\n * @abstract\n */\nclass BaseConsensusAgent extends Observable {\n    /**\n     * @param {Time} time\n     * @param {Peer} peer\n     * @param {InvRequestManager} invRequestManager\n     * @param {Subscription} [targetSubscription]\n     */\n    constructor(time, peer, invRequestManager, targetSubscription) {\n        super();\n        /** @type {Time} */\n        this._time = time;\n        /** @type {Peer} */\n        this._peer = peer;\n\n        // Flag indicating that have synced our blockchain with the peer's.\n        /** @type {boolean} */\n        this._synced = false;\n\n        // Set of all objects (InvVectors) that we think the remote peer knows.\n        /** @type {HashSet.<InvVector>} */\n        this._knownObjects = new HashSet();\n        this._knownObjects.add(new InvVector(InvVector.Type.BLOCK, peer.headHash));\n\n        // InvVectors we want to request via getData are collected here and\n        // periodically requested.\n        /** @type {UniqueQueue.<InvVector>} */\n        this._blocksToRequest = new UniqueQueue();\n        /** @type {ThrottledQueue.<InvVector>} */\n        this._txsToRequest = new ThrottledQueue(\n            BaseConsensusAgent.TRANSACTIONS_AT_ONCE + BaseConsensusAgent.FREE_TRANSACTIONS_AT_ONCE,\n            BaseConsensusAgent.TRANSACTIONS_PER_SECOND + BaseConsensusAgent.FREE_TRANSACTIONS_PER_SECOND,\n            1000, BaseConsensusAgent.REQUEST_TRANSACTIONS_WAITING_MAX);\n\n        // Objects that are currently being requested from the peer.\n        /** @type {HashSet.<InvVector>} */\n        this._objectsInFlight = new HashSet();\n\n        // All objects that were requested from the peer but not received yet.\n        /** @type {HashSet.<InvVector>} */\n        this._objectsThatFlew = new HashSet();\n\n        // Objects that are currently being processed by the blockchain/mempool.\n        /** @type {HashSet.<InvVector>} */\n        this._objectsProcessing = new HashSet();\n\n        // A Subscription object specifying which objects should be announced to the peer.\n        // Initially, we don't announce anything to the peer until it tells us otherwise.\n        /** @type {Subscription} */\n        this._remoteSubscription = Subscription.NONE;\n        // Subscribe to all announcements from the peer.\n        /** @type {Subscription} */\n        this._localSubscription = Subscription.NONE;\n        this._lastSubscriptionChange = null;\n        /** @type {Subscription} */\n        this._targetSubscription = targetSubscription || Subscription.ANY;\n\n        // Helper object to keep track of timeouts & intervals.\n        /** @type {Timers} */\n        this._timers = new Timers();\n\n        // Queue of transaction inv vectors waiting to be sent out\n        /** @type {ThrottledQueue.<InvVector>} */\n        this._waitingInvVectors = new ThrottledQueue(\n            BaseConsensusAgent.TRANSACTIONS_AT_ONCE,\n            BaseConsensusAgent.TRANSACTIONS_PER_SECOND,\n            1000, BaseConsensusAgent.REQUEST_TRANSACTIONS_WAITING_MAX);\n        this._timers.setInterval('invVectors', () => this._sendWaitingInvVectors(), BaseConsensusAgent.TRANSACTION_RELAY_INTERVAL);\n\n        // Queue of \"free\" transaction inv vectors waiting to be sent out\n        /** @type {ThrottledQueue.<{serializedSize:number, vector:InvVector}>} */\n        this._waitingFreeInvVectors = new ThrottledQueue(\n            BaseConsensusAgent.FREE_TRANSACTIONS_AT_ONCE,\n            BaseConsensusAgent.FREE_TRANSACTIONS_PER_SECOND,\n            1000, BaseConsensusAgent.REQUEST_TRANSACTIONS_WAITING_MAX);\n        this._timers.setInterval('freeInvVectors', () => this._sendFreeWaitingInvVectors(), BaseConsensusAgent.FREE_TRANSACTION_RELAY_INTERVAL);\n\n        // Helper object to keep track of block proofs we're requesting.\n        this._blockProofRequest = null;\n\n        // Helper object to keep track of transaction proofs we're requesting.\n        this._transactionsProofRequest = null;\n\n        // Helper object to keep track of transaction receipts we're requesting.\n        this._transactionReceiptsRequest = null;\n\n        /** @type {MultiSynchronizer} */\n        this._synchronizer = new MultiSynchronizer();\n\n        /** @type {InvRequestManager} */\n        this._invRequestManager = invRequestManager;\n\n        // Listen to consensus messages from the peer.\n        peer.channel.on('inv', msg => this._onInv(msg));\n        peer.channel.on('block', msg => this._onBlock(msg));\n        peer.channel.on('header', msg => this._onHeader(msg));\n        peer.channel.on('tx', msg => this._onTx(msg));\n        peer.channel.on('not-found', msg => this._onNotFound(msg));\n\n        peer.channel.on('subscribe', msg => this._onSubscribe(msg));\n        peer.channel.on('get-data', msg => this._onGetData(msg));\n        peer.channel.on('get-header', msg => this._onGetHeader(msg));\n\n        peer.channel.on('block-proof', msg => this._onBlockProof(msg));\n        peer.channel.on('transactions-proof', msg => this._onTransactionsProof(msg));\n        peer.channel.on('transaction-receipts', msg => this._onTransactionReceipts(msg));\n\n        peer.channel.on('get-head', msg => this._onGetHead(msg));\n        peer.channel.on('head', msg => this._onHead(msg));\n\n        // Clean up when the peer disconnects.\n        peer.channel.on('close', () => this._onClose());\n\n        this._requestHead();\n    }\n\n    _requestHead() {\n        this._peer.channel.getHead();\n    }\n\n    onHeadUpdated() {\n        this._timers.resetTimeout('get-next-head', () => this._requestHead(), BaseConsensusAgent.HEAD_REQUEST_INTERVAL);\n    }\n\n    /**\n     * @param {GetHeadMessage} msg\n     * @private\n     */\n    _onGetHead(msg) {\n        this._peer.channel.head(this._blockchain.head.header);\n    }\n\n    /**\n     * @param {HeadMessage} msg\n     */\n    _onHead(msg) {\n        this._peer.head = msg.header;\n        this.onHeadUpdated();\n    }\n\n    /**\n     * @param {Subscription} subscription\n     */\n    subscribe(subscription) {\n        this._targetSubscription = subscription;\n        this._subscribe(subscription);\n    }\n\n    _subscribeTarget() {\n        this._subscribe(this._targetSubscription);\n    }\n\n    /**\n     * @param {Subscription} subscription\n     */\n    _subscribe(subscription) {\n        this._localSubscription = subscription;\n        this._lastSubscriptionChange = Date.now();\n        this._peer.channel.subscribe(this._localSubscription);\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {boolean}\n     */\n    relayBlock(block) {\n        // Don't relay block if have not synced with the peer yet.\n        if (!this._synced) {\n            return false;\n        }\n\n        // Only relay block if it matches the peer's subscription.\n        if (!this._remoteSubscription.matchesBlock(block)) {\n            return false;\n        }\n\n        // Create InvVector.\n        const vector = InvVector.fromBlock(block);\n\n        // Don't relay block to this peer if it already knows it.\n        if (this._knownObjects.contains(vector)) {\n            return false;\n        }\n\n        // Relay block to peer.\n        this._peer.channel.inv([vector, ...this._waitingInvVectors.dequeueMulti(BaseInventoryMessage.VECTORS_MAX_COUNT - 1)]);\n\n        // Assume that the peer knows this block now.\n        this._knownObjects.add(vector);\n\n        return true;\n    }\n\n    _sendWaitingInvVectors() {\n        const invVectors = this._waitingInvVectors.dequeueMulti(BaseInventoryMessage.VECTORS_MAX_COUNT);\n        if (invVectors.length > 0) {\n            this._peer.channel.inv(invVectors);\n            Log.v(BaseConsensusAgent, () => `[INV] Sent ${invVectors.length} vectors to ${this._peer.peerAddress}`);\n        }\n    }\n\n    _sendFreeWaitingInvVectors() {\n        const invVectors = [];\n        let size = 0;\n        while (invVectors.length <= BaseInventoryMessage.VECTORS_MAX_COUNT && this._waitingFreeInvVectors.length > 0\n            && size < BaseConsensusAgent.FREE_TRANSACTION_SIZE_PER_INTERVAL) {\n            const {serializedSize, vector} = this._waitingFreeInvVectors.dequeue();\n            invVectors.push(vector);\n            size += serializedSize;\n        }\n        if (invVectors.length > 0) {\n            this._peer.channel.inv(invVectors);\n            Log.v(BaseConsensusAgent, () => `[INV] Sent ${invVectors.length} vectors to ${this._peer.peerAddress}`);\n        }\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @return {boolean}\n     */\n    relayTransaction(transaction) {\n        // Only relay transaction if it matches the peer's subscription.\n        if (!this._remoteSubscription.matchesTransaction(transaction)) {\n            return false;\n        }\n\n        // Create InvVector.\n        const vector = InvVector.fromTransaction(transaction);\n\n        // Don't relay transaction to this peer if it already knows it.\n        if (this._knownObjects.contains(vector)) {\n            return false;\n        }\n\n        // Relay transaction to peer later.\n        const serializedSize = transaction.serializedSize;\n        if (transaction.fee / serializedSize < BaseConsensusAgent.TRANSACTION_RELAY_FEE_MIN) {\n            this._waitingFreeInvVectors.enqueue({serializedSize, vector});\n        } else {\n            this._waitingInvVectors.enqueue(vector);\n        }\n\n        // Assume that the peer knows this transaction now.\n        this._knownObjects.add(vector);\n\n        return true;\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @returns {boolean}\n     */\n    knowsBlock(blockHash) {\n        const vector = new InvVector(InvVector.Type.BLOCK, blockHash);\n        return this._knownObjects.contains(vector);\n    }\n\n    /**\n     * @param {SubscribeMessage} msg\n     * @protected\n     */\n    _onSubscribe(msg) {\n        Log.d(BaseConsensusAgent, `[SUBSCRIBE] ${this._peer.peerAddress} ${msg.subscription}`);\n        this._remoteSubscription = msg.subscription;\n    }\n\n    /**\n     * @param {InvMessage} msg\n     * @returns {Promise.<void>}\n     * @protected\n     */\n    async _onInv(msg) {\n        // Keep track of the objects the peer knows.\n        for (const vector of msg.vectors) {\n            this._knownObjects.add(vector);\n            this._waitingInvVectors.remove(vector);\n            this._waitingFreeInvVectors.remove(vector);\n        }\n\n        // Check which of the advertised objects we know\n        // Request unknown objects, ignore known ones.\n        const unknownBlocks = [];\n        const unknownTxs = [];\n        for (const vector of msg.vectors) {\n            // Ignore objects that we are currently requesting / processing.\n            if (this._objectsInFlight.contains(vector) || this._objectsProcessing.contains(vector)) {\n                continue;\n            }\n\n            // Filter out objects that we are not interested in.\n            if (!this._shouldRequestData(vector)) {\n                continue;\n            }\n\n            switch (vector.type) {\n                case InvVector.Type.BLOCK: {\n                    const block = await this._getBlock(vector.hash, /*includeForks*/ true); // eslint-disable-line no-await-in-loop\n                    if (!block) {\n                        unknownBlocks.push(vector);\n                        this._onNewBlockAnnounced(vector.hash);\n                    } else {\n                        this._onKnownBlockAnnounced(vector.hash, block);\n                    }\n                    break;\n                }\n                case InvVector.Type.TRANSACTION: {\n                    const transaction = await this._getTransaction(vector.hash); // eslint-disable-line no-await-in-loop\n                    if (!transaction) {\n                        unknownTxs.push(vector);\n                        this._onNewTransactionAnnounced(vector.hash);\n                    } else {\n                        this._onKnownTransactionAnnounced(vector.hash, transaction);\n                    }\n                    break;\n                }\n                default:\n                    throw `Invalid inventory type: ${vector.type}`;\n            }\n        }\n\n        Log.v(BaseConsensusAgent, () => `[INV] ${msg.vectors.length} vectors (${unknownBlocks.length} new blocks, ${unknownTxs.length} new txs) received from ${this._peer.peerAddress}`);\n\n        if (unknownBlocks.length > 0 || unknownTxs.length > 0) {\n            for (const vector of unknownBlocks) {\n                this._invRequestManager.askToRequestVector(this, vector);\n            }\n            for (const vector of unknownTxs) {\n                this._invRequestManager.askToRequestVector(this, vector);\n            }\n        } else {\n            this._onNoUnknownObjects();\n        }\n    }\n\n    /**\n     * @param {InvVector} vector\n     */\n    requestVector(...vector) {\n        // Store unknown vectors in objectsToRequest.\n        this._blocksToRequest.enqueueAllNew(vector.filter(v => v.type === InvVector.Type.BLOCK));\n        this._txsToRequest.enqueueAllNew(vector.filter(v => v.type === InvVector.Type.TRANSACTION));\n\n        // Clear the request throttle timeout.\n        this._timers.clearTimeout('inv');\n\n        // If there are enough objects queued up, send out a getData request.\n        if (this._blocksToRequest.length + this._txsToRequest.available >= BaseConsensusAgent.REQUEST_THRESHOLD) {\n            this._requestData();\n        }\n        // Otherwise, wait a short time for more inv messages to arrive, then request.\n        else {\n            this._timers.setTimeout('inv', () => this._requestData(), BaseConsensusAgent.REQUEST_THROTTLE);\n        }\n    }\n\n    /**\n     * @param {InvVector} vector\n     * @returns {boolean}\n     * @protected\n     */\n    _shouldRequestData(vector) {\n        return true;\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {boolean} [includeForks]\n     * @param {boolean} [includeBody]\n     * @returns {Promise.<?Block>}\n     * @protected\n     * @abstract\n     */\n    _getBlock(hash, includeForks = false, includeBody = false) {\n        // MUST be implemented by subclasses.\n        throw new Error('not implemented');\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {boolean} [includeForks]\n     * @returns {Promise.<?Uint8Array>}\n     * @protected\n     * @abstract\n     */\n    _getRawBlock(hash, includeForks = false) {\n        // MUST be implemented by subclasses.\n        throw new Error('not implemented');\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Promise.<?Transaction>}\n     * @protected\n     * @abstract\n     */\n    _getTransaction(hash) {\n        // MUST be implemented by subclasses.\n        throw new Error('not implemented');\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {void}\n     * @protected\n     */\n    _onNewBlockAnnounced(hash) {\n    }\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @returns {void}\n     * @protected\n     */\n    _onKnownBlockAnnounced(hash, block) {\n    }\n    /**\n     * @param {Hash} hash\n     * @returns {void}\n     * @protected\n     */\n    _onNewTransactionAnnounced(hash) {\n    }\n    /**\n     * @param {Hash} hash\n     * @param {Transaction} transaction\n     * @returns {void}\n     * @protected\n     */\n    _onKnownTransactionAnnounced(hash, transaction) {\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     */\n    _requestData() {\n        // Only one request at a time.\n        if (!this._objectsInFlight.isEmpty()) return;\n\n        // Don't do anything if there are no objects queued to request.\n        if (this._blocksToRequest.isEmpty() && !this._txsToRequest.isAvailable()) return;\n\n        // Request queued objects from the peer. Only request up to VECTORS_MAX_COUNT objects at a time.\n        const vectorsMaxCount = BaseInventoryMessage.VECTORS_MAX_COUNT;\n        /** @type {Array.<InvVector>} */\n        let vectors = this._blocksToRequest.dequeueMulti(vectorsMaxCount);\n        if (vectors.length < vectorsMaxCount) {\n            vectors = vectors.concat(this._txsToRequest.dequeueMulti(vectorsMaxCount - vectors.length));\n        }\n\n        // Mark the requested objects as in-flight.\n        this._objectsInFlight.addAll(vectors);\n\n        // Request data from peer.\n        this._doRequestData(vectors);\n\n        // Set timer to detect end of request / missing objects\n        this._timers.setTimeout('getData', () => this._noMoreData(), BaseConsensusAgent.REQUEST_TIMEOUT);\n    }\n\n    /**\n     * @param {Array.<InvVector>} vectors\n     * @returns {void}\n     * @protected\n     */\n    _doRequestData(vectors) {\n        this._peer.channel.getData(vectors);\n    }\n\n    /**\n     * @param {BlockMessage} msg\n     * @return {Promise.<void>}\n     * @protected\n     */\n    async _onBlock(msg) {\n        const hash = msg.block.hash();\n\n        // Check if we have requested this block.\n        const vector = new InvVector(InvVector.Type.BLOCK, hash);\n        if (!this._objectsInFlight.contains(vector) && !this._objectsThatFlew.contains(vector)) {\n            Log.w(BaseConsensusAgent, `Unsolicited block ${hash} received from ${this._peer.peerAddress}, discarding`);\n            return;\n        }\n\n        // Reuse already known (verified) transactions\n        const transactions = msg.block.isFull() ? msg.block.body.transactions : [];\n        const transactionPromises = transactions.map(t => this._getTransaction(t.hash()));\n        for (let i = 0; i < transactions.length; i++) {\n            const transaction = await transactionPromises[i]; // eslint-disable-line no-await-in-loop\n            if (transaction) {\n                transactions[i] = transaction;\n            }\n        }\n\n        if ((!this._peer.head && this._peer.headHash.equals(hash)) || (this._peer.head && this._peer.head.height < msg.block.height)) {\n            this._peer.head = msg.block.header;\n            this.onHeadUpdated();\n        }\n\n        // Mark object as received.\n        this._onObjectReceived(vector);\n\n        // Process block.\n        this._objectsProcessing.add(vector);\n        await this._processBlock(hash, msg.block);\n\n        // Mark object as processed.\n        this._onObjectProcessed(vector);\n\n        this._invRequestManager.noteVectorReceived(InvVector.fromBlock(msg.block));\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @returns {Promise.<void>}\n     * @protected\n     */\n    async _processBlock(hash, block) {\n    }\n\n    /**\n     * @param {HeaderMessage} msg\n     * @return {Promise.<void>}\n     * @protected\n     */\n    async _onHeader(msg) {\n        const hash = msg.header.hash();\n\n        // Check if we have requested this header.\n        const vector = new InvVector(InvVector.Type.BLOCK, hash);\n        if (!this._objectsInFlight.contains(vector) && !this._objectsThatFlew.contains(vector)) {\n            Log.w(BaseConsensusAgent, `Unsolicited header ${hash} received from ${this._peer.peerAddress}, discarding`);\n            return;\n        }\n\n        if ((!this._peer.head && this._peer.headHash.equals(hash)) || (this._peer.head && this._peer.head.height < msg.header.height)) {\n            this._peer.head = msg.header;\n            this.onHeadUpdated();\n        }\n\n        // Mark object as received.\n        this._onObjectReceived(vector);\n\n        // Process header.\n        this._objectsProcessing.add(vector);\n        await this._processHeader(hash, msg.header);\n\n        // Mark object as processed.\n        this._onObjectProcessed(vector);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {BlockHeader} header\n     * @returns {Promise.<void>}\n     * @protected\n     */\n    async _processHeader(hash, header) {\n    }\n\n    /**\n     * @param {TxMessage} msg\n     * @return {Promise}\n     * @protected\n     */\n    async _onTx(msg) {\n        const hash = msg.transaction.hash();\n        //Log.d(BaseConsensusAgent, () => `[TX] Received transaction ${hash} from ${this._peer.peerAddress}`);\n\n        // Check if we have requested this transaction.\n        const vector = new InvVector(InvVector.Type.TRANSACTION, hash);\n        if (!this._objectsInFlight.contains(vector) && !this._objectsThatFlew.contains(vector)) {\n            Log.w(BaseConsensusAgent, `Unsolicited transaction ${hash} received from ${this._peer.peerAddress}, discarding`);\n            return;\n        }\n\n        this._invRequestManager.noteVectorReceived(InvVector.fromTransaction(msg.transaction));\n\n        // Mark object as received.\n        this._onObjectReceived(vector);\n\n        // Process transaction.\n        this._objectsProcessing.add(vector);\n\n        // Check whether we subscribed for this transaction.\n        if (this._localSubscription.matchesTransaction(msg.transaction)) {\n            await this._processTransaction(hash, msg.transaction);\n        } else if (this._lastSubscriptionChange + BaseConsensusAgent.SUBSCRIPTION_CHANGE_GRACE_PERIOD > Date.now()) {\n            this._peer.channel.close(CloseType.RECEIVED_TRANSACTION_NOT_MATCHING_OUR_SUBSCRIPTION, 'received transaction not matching our subscription');\n        }\n\n        // Mark object as processed.\n        this._onObjectProcessed(vector);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Transaction} transaction\n     * @returns {Promise.<void>}\n     * @protected\n     */\n    async _processTransaction(hash, transaction) {\n    }\n\n    /**\n     * @param {NotFoundMessage} msg\n     * @returns {void}\n     * @protected\n     */\n    _onNotFound(msg) {\n        Log.d(BaseConsensusAgent, `[NOTFOUND] ${msg.vectors.length} unknown objects received from ${this._peer.peerAddress}`);\n\n        // Remove unknown objects from in-flight list.\n        for (const vector of msg.vectors) {\n            if (!this._objectsInFlight.contains(vector)) {\n                continue;\n            }\n            this._invRequestManager.noteVectorNotReceived(this, vector);\n\n            // Mark object as received.\n            this._onObjectReceived(vector);\n        }\n    }\n\n    /**\n     * @param {InvVector} vector\n     * @returns {void}\n     * @protected\n     */\n    _onObjectReceived(vector) {\n        if (this._objectsInFlight.isEmpty()) return;\n\n        // Remove the vector from objectsInFlight.\n        this._objectsInFlight.remove(vector);\n\n        // Reset the request timeout if we expect more objects to come.\n        if (!this._objectsInFlight.isEmpty()) {\n            this._timers.resetTimeout('getData', () => this._noMoreData(), BaseConsensusAgent.REQUEST_TIMEOUT);\n        } else {\n            this._noMoreData();\n        }\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     */\n    _noMoreData() {\n        // Cancel the request timeout timer.\n        this._timers.clearTimeout('getData');\n\n        for(const vector of this._objectsInFlight.values()) {\n            this._invRequestManager.noteVectorNotReceived(this, vector);\n        }\n\n        // Reset objects in flight.\n        this._objectsThatFlew.addAll(this._objectsInFlight.values());\n        this._objectsInFlight.clear();\n\n        // If there are more objects to request, request them.\n        if (!this._blocksToRequest.isEmpty() || this._txsToRequest.isAvailable()) {\n            this._requestData();\n        } else {\n            this._onAllObjectsReceived();\n        }\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     */\n    _onNoUnknownObjects() {\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     */\n    _onAllObjectsReceived() {\n    }\n\n    /**\n     * @param {InvVector} vector\n     * @returns {void}\n     * @protected\n     */\n    _onObjectProcessed(vector) {\n        // Remove the vector from objectsProcessing.\n        this._objectsProcessing.remove(vector);\n\n        if (this._objectsProcessing.isEmpty()) {\n            this._onAllObjectsProcessed();\n        }\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     */\n    _onAllObjectsProcessed() {\n    }\n\n    /**\n     * @param {GetDataMessage} msg\n     * @returns {Promise}\n     * @protected\n     */\n    async _onGetData(msg) {\n        // Keep track of the objects the peer knows.\n        for (const vector of msg.vectors) {\n            this._knownObjects.add(vector);\n        }\n\n        // Check which of the requested objects we know.\n        // Send back all known objects.\n        // Send notFound for unknown objects.\n        const unknownObjects = [];\n        for (const vector of msg.vectors) {\n            switch (vector.type) {\n                case InvVector.Type.BLOCK: {\n                    const block = await this._getRawBlock(vector.hash, /*includeForks*/ false); // eslint-disable-line no-await-in-loop\n                    if (block) {\n                        // We have found a requested block, send it back to the sender.\n                        this._peer.channel.rawBlock(block);\n                    } else {\n                        // Requested block is unknown.\n                        unknownObjects.push(vector);\n                    }\n                    break;\n                }\n                case InvVector.Type.TRANSACTION: {\n                    const tx = await this._getTransaction(vector.hash); // eslint-disable-line no-await-in-loop\n                    if (tx) {\n                        // We have found a requested transaction, send it back to the sender.\n                        this._peer.channel.tx(tx);\n                    } else {\n                        // Requested transaction is unknown.\n                        unknownObjects.push(vector);\n                    }\n                    break;\n                }\n                default:\n                    throw `Invalid inventory type: ${vector.type}`;\n            }\n        }\n\n        // Report any unknown objects back to the sender.\n        if (unknownObjects.length) {\n            this._peer.channel.notFound(unknownObjects);\n        }\n    }\n\n    /**\n     * @param {GetHeaderMessage} msg\n     * @returns {Promise}\n     * @protected\n     */\n    async _onGetHeader(msg) {\n        // Keep track of the objects the peer knows.\n        for (const vector of msg.vectors) {\n            this._knownObjects.add(vector);\n        }\n\n        // Check which of the requested objects we know.\n        // Send back all known objects.\n        // Send notFound for unknown objects.\n        const unknownObjects = [];\n        for (const vector of msg.vectors) {\n            switch (vector.type) {\n                case InvVector.Type.BLOCK: {\n                    const block = await this._getBlock(vector.hash); // eslint-disable-line no-await-in-loop\n                    if (block) {\n                        // We have found a requested block, send it back to the sender.\n                        this._peer.channel.header(block.header);\n                    } else {\n                        // Requested block is unknown.\n                        unknownObjects.push(vector);\n                    }\n                    break;\n                }\n                case InvVector.Type.TRANSACTION:\n                default:\n                    throw `Invalid inventory type: ${vector.type}`;\n            }\n        }\n\n        // Report any unknown objects back to the sender.\n        if (unknownObjects.length) {\n            this._peer.channel.notFound(unknownObjects);\n        }\n    }\n\n    /**\n     * @param {Hash} blockHashToProve\n     * @param {Block} knownBlock\n     * @returns {Promise.<Block>}\n     */\n    getBlockProof(blockHashToProve, knownBlock) {\n        return this._synchronizer.push('getBlockProof',\n            this._getBlockProof.bind(this, blockHashToProve, knownBlock));\n    }\n\n    /**\n     * @param {Hash} blockHashToProve\n     * @param {Block} knownBlock\n     * @returns {Promise.<Block>}\n     * @private\n     */\n    _getBlockProof(blockHashToProve, knownBlock) {\n        Assert.that(this._blockProofRequest === null);\n\n        Log.d(BaseConsensusAgent, () => `Requesting BlockProof for ${blockHashToProve} from ${this._peer.peerAddress}`);\n\n        return new Promise((resolve, reject) => {\n            this._blockProofRequest = {\n                blockHashToProve,\n                knownBlock,\n                resolve,\n                reject\n            };\n\n            // Request BlockProof from peer.\n            this._peer.channel.getBlockProof(blockHashToProve, knownBlock.hash());\n\n            this._peer.channel.expectMessage(Message.Type.BLOCK_PROOF, () => {\n                reject(new Error('timeout'));\n            }, BaseConsensusAgent.BLOCK_PROOF_REQUEST_TIMEOUT);\n        });\n    }\n\n    /**\n     * @param {BlockProofMessage} msg\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _onBlockProof(msg) {\n        Log.d(BaseConsensusAgent, () => `[BLOCK-PROOF] Received from ${this._peer.peerAddress}: proof=${msg.proof} (${msg.serializedSize} bytes)`);\n\n        // Check if we have requested a header proof, reject unsolicited ones.\n        if (!this._blockProofRequest) {\n            Log.w(BaseConsensusAgent, `Unsolicited header proof received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n\n        const { blockHashToProve, /** @type {Block} */ knownBlock, resolve, reject } = this._blockProofRequest;\n        this._blockProofRequest = null;\n\n        if (!msg.hasProof() || msg.proof.length === 0) {\n            reject(new Error('Block proof request was rejected'));\n            return;\n        }\n\n        // Check that the tail of the proof corresponds to the requested block.\n        const proof = msg.proof;\n        if (!blockHashToProve.equals(proof.tail.hash())) {\n            Log.w(BaseConsensusAgent, `Received BlockProof with invalid tail block from ${this._peer.peerAddress}`);\n            reject(new Error('Invalid tail block'));\n            return;\n        }\n\n        // Check that the proof links up to our reference block.\n        if (!(await knownBlock.isInterlinkSuccessorOf(proof.head))) {\n            Log.w(BaseConsensusAgent, `Received BlockProof with invalid head block from ${this._peer.peerAddress}`);\n            reject(new Error('Invalid head block'));\n            return;\n        }\n\n        // Verify the proof.\n        if (!(await proof.verify())) {\n            Log.w(BaseConsensusAgent, `Invalid BlockProof received from ${this._peer.peerAddress}`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.INVALID_BLOCK_PROOF, 'Invalid BlockProof');\n            reject(new Error('Invalid BlockProof'));\n            return;\n        }\n\n        // Verify individual blocks.\n        const verificationResults = await Promise.all(proof.blocks.map(block => block.verify(this._time)));\n        if (!verificationResults.every(result => result)) {\n            Log.w(BaseConsensusAgent, `Invalid BlockProof received from ${this._peer.peerAddress}`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.INVALID_BLOCK_PROOF, 'Invalid BlockProof');\n            reject(new Error('Invalid BlockProof'));\n            return;\n        }\n\n        // Return the proven block.\n        resolve(proof.tail);\n    }\n\n    /**\n     * @param {Block} block\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<Array.<Transaction>>}\n     */\n    getTransactionsProof(block, addresses) {\n        return this._synchronizer.push('getTransactionsProof',\n            this._getTransactionsProof.bind(this, block, addresses));\n    }\n\n    /**\n     * @param {Block} block\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<Array.<Transaction>>}\n     * @private\n     */\n    _getTransactionsProof(block, addresses) {\n        Assert.that(this._transactionsProofRequest === null);\n\n        Log.d(BaseConsensusAgent, () => `Requesting TransactionsProof for ${addresses}@${block.height} from ${this._peer.peerAddress}`);\n\n        return new Promise((resolve, reject) => {\n            this._transactionsProofRequest = {\n                addresses,\n                block,\n                resolve,\n                reject,\n            };\n\n            // Request TransactionProof from peer.\n            this._peer.channel.getTransactionsProof(block.hash(), addresses);\n\n            // Drop the peer if it doesn't send the TransactionProof within the timeout.\n            this._peer.channel.expectMessage(Message.Type.TRANSACTIONS_PROOF, () => {\n                this._peer.channel.close(CloseType.GET_TRANSACTIONS_PROOF_TIMEOUT, 'getTransactionsProof timeout');\n                reject(new Error('timeout'));\n            }, BaseConsensusAgent.TRANSACTIONS_PROOF_REQUEST_TIMEOUT);\n        });\n    }\n\n    /**\n     * @param {TransactionsProofMessage} msg\n     * @returns {void}\n     * @private\n     */\n    _onTransactionsProof(msg) {\n        Log.d(BaseConsensusAgent, () => `[TRANSACTIONS-PROOF] Received from ${this._peer.peerAddress}: blockHash=${msg.blockHash}, proof=${msg.proof} (${msg.serializedSize} bytes)`);\n\n        // Check if we have requested a transactions proof, reject unsolicited ones.\n        if (!this._transactionsProofRequest) {\n            Log.w(BaseConsensusAgent, `Unsolicited transactions proof received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n\n        const {/** @type {Block} */ block, resolve, reject} = this._transactionsProofRequest;\n        this._transactionsProofRequest = null;\n\n        if (!msg.hasProof()) {\n            Log.w(BaseConsensusAgent, `TransactionsProof request was rejected by ${this._peer.peerAddress}`);\n            reject(new Error('TransactionsProof request was rejected'));\n            return;\n        }\n\n        // Check that the reference block corresponds to the one we requested.\n        if (!block.hash().equals(msg.blockHash)) {\n            Log.w(BaseConsensusAgent, `Received TransactionsProof for invalid reference block from ${this._peer.peerAddress}`);\n            reject(new Error('Invalid reference block'));\n            return;\n        }\n\n        // Verify the proof.\n        const proof = msg.proof;\n        if (!block.bodyHash.equals(proof.root())) {\n            Log.w(BaseConsensusAgent, `Invalid TransactionsProof received from ${this._peer.peerAddress}`);\n            this._peer.channel.close(CloseType.INVALID_TRANSACTION_PROOF, 'Invalid TransactionsProof');\n            reject(new Error('Invalid TransactionsProof'));\n            return;\n        }\n\n        // TODO Verify that the proof only contains transactions that match the given addresses.\n\n        // Return the retrieved transactions.\n        resolve(proof.transactions);\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise.<Array.<TransactionReceipt>>}\n     */\n    getTransactionReceipts(address) {\n        return this._synchronizer.push('getTransactionReceipts',\n            this._getTransactionReceipts.bind(this, address));\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise.<Array.<TransactionReceipt>>}\n     * @private\n     */\n    _getTransactionReceipts(address) {\n        Assert.that(this._transactionReceiptsRequest === null);\n\n        return new Promise((resolve, reject) => {\n            this._transactionReceiptsRequest = {\n                address,\n                resolve,\n                reject\n            };\n\n            this._peer.channel.getTransactionReceipts(address);\n\n            this._peer.channel.expectMessage(Message.Type.TRANSACTION_RECEIPTS, () => {\n                this._peer.channel.close(CloseType.GET_TRANSACTION_RECEIPTS_TIMEOUT, 'getTransactionReceipts timeout');\n                reject(new Error('timeout'));\n            }, BaseConsensusAgent.TRANSACTION_RECEIPTS_REQUEST_TIMEOUT);\n        });\n    }\n\n    /**\n     * @param {TransactionReceiptsMessage} msg\n     * @returns {void}\n     * @private\n     */\n    _onTransactionReceipts(msg) {\n        Log.d(BaseConsensusAgent, () => `[TRANSACTION-RECEIPTS] Received from ${this._peer.peerAddress}: ${msg.transactionReceipts.length}`);\n\n        // Check if we have requested transaction receipts, reject unsolicited ones.\n        // TODO: How about more than one transactionReceipts message?\n        if (!this._transactionReceiptsRequest) {\n            Log.w(BaseConsensusAgent, `Unsolicited transaction receipts received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n\n        const {resolve} = this._transactionReceiptsRequest;\n        this._transactionReceiptsRequest = null;\n\n        // TODO Verify that the transaction receipts match the given address.\n\n        resolve(msg.transactionReceipts);\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     */\n    _onClose() {\n        this._synchronizer.clear();\n\n        // Clear all timers and intervals when the peer disconnects.\n        this._timers.clearAll();\n        this._txsToRequest.stop();\n        this._waitingInvVectors.stop();\n        this._waitingFreeInvVectors.stop();\n\n        // Notify listeners that the peer has disconnected.\n        this.fire('close', this);\n    }\n\n    /** @type {Peer} */\n    get peer() {\n        return this._peer;\n    }\n\n    /** @type {boolean} */\n    get synced() {\n        return this._synced;\n    }\n\n    /** @type {boolean} */\n    get syncing() {\n        return false;\n    }\n}\n/**\n * Number of InvVectors in invToRequest pool to automatically trigger a get-data request.\n * @type {number}\n */\nBaseConsensusAgent.REQUEST_THRESHOLD = 50;\n/**\n * Time (ms) to wait after the last received inv message before sending get-data.\n * @type {number}\n */\nBaseConsensusAgent.REQUEST_THROTTLE = 500;\n/**\n * Maximum time (ms) to wait after sending out get-data or receiving the last object for this request.\n * @type {number}\n */\nBaseConsensusAgent.REQUEST_TIMEOUT = 1000 * 10;\nBaseConsensusAgent.REQUEST_TRANSACTIONS_WAITING_MAX = 5000;\nBaseConsensusAgent.REQUEST_BLOCKS_WAITING_MAX = 5000;\n/**\n * Maximum time (ms) to wait for block-proof.\n * @type {number}\n */\nBaseConsensusAgent.BLOCK_PROOF_REQUEST_TIMEOUT = 1000 * 10;\n/**\n * Maximum time (ms) to wait for transactions-proof.\n * @type {number}\n */\nBaseConsensusAgent.TRANSACTIONS_PROOF_REQUEST_TIMEOUT = 1000 * 10;\n/**\n * Maximum time (ms) to wait for transactions-receipts.\n * @type {number}\n */\nBaseConsensusAgent.TRANSACTION_RECEIPTS_REQUEST_TIMEOUT = 1000 * 15;\n/**\n * Time interval (ms) to wait between sending out transactions.\n * @type {number}\n */\nBaseConsensusAgent.TRANSACTION_RELAY_INTERVAL = 5000;\nBaseConsensusAgent.TRANSACTIONS_AT_ONCE = 100;\nBaseConsensusAgent.TRANSACTIONS_PER_SECOND = 10;\n/**\n * Time interval (ms) to wait between sending out \"free\" transactions.\n * @type {number}\n */\nBaseConsensusAgent.FREE_TRANSACTION_RELAY_INTERVAL = 6000;\nBaseConsensusAgent.FREE_TRANSACTIONS_AT_ONCE = 10;\nBaseConsensusAgent.FREE_TRANSACTIONS_PER_SECOND = 1;\n/**\n * Soft limit for the total size (bytes) of free transactions per relay interval.\n * @type {number}\n */\nBaseConsensusAgent.FREE_TRANSACTION_SIZE_PER_INTERVAL = 15000; // ~100 legacy transactions\n/**\n * Minimum fee per byte (sat/byte) such that a transaction is not considered free.\n * @type {number}\n */\nBaseConsensusAgent.TRANSACTION_RELAY_FEE_MIN = 1;\n/**\n * Number of ms the peer may send non-matching transactions/blocks after a subscription change.\n * @type {number}\n */\nBaseConsensusAgent.SUBSCRIPTION_CHANGE_GRACE_PERIOD = 1000 * 2;\nBaseConsensusAgent.HEAD_REQUEST_INTERVAL = 100 * 1000; // 100 seconds, give client time to announce new head without request\nClass.register(BaseConsensusAgent);\n","/**\n * @abstract\n */\nclass BaseConsensus extends Observable {\n    /**\n     * @param {BaseChain} blockchain\n     * @param {Observable} mempool\n     * @param {Network} network\n     */\n    constructor(blockchain, mempool, network) {\n        super();\n        /** @type {BaseChain} */\n        this._blockchain = blockchain;\n        /** @type {Network} */\n        this._network = network;\n\n        /** @type {HashMap.<Peer,BaseConsensusAgent>} */\n        this._agents = new HashMap();\n\n        /** @type {Timers} */\n        this._timers = new Timers();\n\n        /** @type {boolean} */\n        this._established = false;\n\n        /** @type {Peer} */\n        this._syncPeer = null;\n\n        /** @type {Subscription} */\n        this._subscription = Subscription.ANY;\n\n        /** @type {InvRequestManager} */\n        this._invRequestManager = new InvRequestManager();\n\n        network.on('peer-joined', peer => this._onPeerJoined(peer));\n        network.on('peer-left', peer => this._onPeerLeft(peer));\n\n        // Notify peers when our blockchain head changes.\n        blockchain.on('head-changed', head => this._onHeadChanged(head));\n\n        // Relay new (verified) transactions to peers.\n        mempool.on('transaction-added', tx => this._onTransactionAdded(tx));\n    }\n\n    /**\n     * @param {Subscription} subscription\n     */\n    subscribe(subscription) {\n        this._subscription = subscription;\n        for (const /** @type {BaseConsensusAgent} */ agent of this._agents.values()) {\n            agent.subscribe(subscription);\n        }\n    }\n\n    /**\n     * @param {Peer} peer\n     * @returns {BaseConsensusAgent}\n     * @protected\n     */\n    _newConsensusAgent(peer) {\n        throw new Error('not implemented');\n    }\n\n    /**\n     * @param {Peer} peer\n     * @returns {BaseConsensusAgent}\n     * @protected\n     */\n    _onPeerJoined(peer) {\n        // Create a ConsensusAgent for each peer that connects.\n        const agent = this._newConsensusAgent(peer);\n        this._agents.put(peer.id, agent);\n\n        // Register agent event listeners.\n        agent.on('close', () => this._onPeerLeft(agent.peer));\n        agent.on('sync', () => this._onPeerSynced(agent.peer));\n        agent.on('out-of-sync', () => this._onPeerOutOfSync(agent.peer));\n\n        // If no more peers connect within the specified timeout, start syncing.\n        this._timers.resetTimeout('sync', this._syncBlockchain.bind(this), BaseConsensus.SYNC_THROTTLE);\n\n        return agent;\n    }\n\n    /**\n     * @param {Peer} peer\n     * @protected\n     */\n    _onPeerLeft(peer) {\n        // Reset syncPeer if it left during the sync.\n        if (peer.equals(this._syncPeer)) {\n            Log.d(BaseConsensus, `Peer ${peer.peerAddress} left during sync`);\n            this._syncPeer = null;\n            this.fire('sync-failed', peer.peerAddress);\n        }\n\n        this._agents.remove(peer.id);\n        this._syncBlockchain();\n    }\n\n    /**\n     * @protected\n     */\n    _syncBlockchain() {\n        const candidates = [];\n        let numSyncedFullNodes = 0;\n        for (const /** @type {BaseConsensusAgent} */ agent of this._agents.valueIterator()) {\n            if (!agent.synced) {\n                candidates.push(agent);\n            } else if (Services.isFullNode(agent.peer.peerAddress.services)) {\n                numSyncedFullNodes++;\n            }\n        }\n\n        // Report consensus-lost if we are synced with less than the minimum number of full nodes or have no connections at all.\n        if (this._established && (numSyncedFullNodes < BaseConsensus.MIN_FULL_NODES || this._agents.length === 0)) {\n            this._established = false;\n            this.fire('lost');\n        }\n\n        // Wait for ongoing sync to finish.\n        if (this._syncPeer) {\n            return;\n        }\n\n        // Choose a random peer which we aren't sync'd with yet.\n        const agent = ArrayUtils.randomElement(candidates);\n        if (!agent) {\n            // We are synced with all connected peers.\n\n            // Report consensus-established if we are connected to the minimum number of full nodes.\n            if (numSyncedFullNodes >= BaseConsensus.MIN_FULL_NODES) {\n                if (!this._established) {\n                    Log.i(BaseConsensus, `Synced with all connected peers (${this._agents.length}), consensus established.`);\n                    Log.d(BaseConsensus, `Blockchain: height=${this._blockchain.height}, headHash=${this._blockchain.headHash}`);\n\n                    // Report consensus-established.\n                    this._established = true;\n                    this.fire('established');\n\n                    // Allow inbound network connections after establishing consensus.\n                    this._network.allowInboundConnections = true;\n                }\n            }\n            // Otherwise, wait until more peer connections are established.\n            else {\n                this.fire('waiting');\n            }\n\n            return;\n        }\n\n        this._syncPeer = agent.peer;\n\n        // Notify listeners when we start syncing and have not established consensus yet.\n        if (!this._established) {\n            this.fire('syncing');\n        }\n\n        Log.v(BaseConsensus, `Syncing blockchain with peer ${agent.peer.peerAddress}`);\n        agent.syncBlockchain().catch(Log.w.tag(BaseConsensusAgent));\n    }\n\n    /**\n     * @param {Peer} peer\n     * @protected\n     */\n    _onPeerSynced(peer) {\n        // Reset syncPeer if we finished syncing with it.\n        if (peer.equals(this._syncPeer)) {\n            Log.v(BaseConsensus, `Finished sync with peer ${peer.peerAddress}`);\n            this._syncPeer = null;\n        }\n        this._syncBlockchain();\n    }\n\n    /**\n     * @param {Peer} peer\n     * @protected\n     */\n    _onPeerOutOfSync(peer) {\n        Log.w(BaseConsensus, `Peer ${peer.peerAddress} out of sync, resyncing`);\n        this._syncBlockchain();\n    }\n\n    /**\n     * @param {Block} head\n     * @protected\n     */\n    _onHeadChanged(head) {\n        // Don't announce head changes if we are not synced yet.\n        if (!this._established) return;\n\n        for (const agent of this._agents.values()) {\n            agent.relayBlock(head);\n        }\n    }\n\n    /**\n     * @param {Transaction} tx\n     * @protected\n     */\n    _onTransactionAdded(tx) {\n        // Don't relay transactions if we are not synced yet.\n        if (!this._established) return;\n\n        for (const agent of this._agents.values()) {\n            agent.relayTransaction(tx);\n        }\n    }\n\n    /**\n     * @param {Hash} blockHashToProve\n     * @param {number} blockHeightToProve\n     * @returns {Promise.<Block>}\n     * @protected\n     */\n    async _requestBlockProof(blockHashToProve, blockHeightToProve) {\n        /** @type {Block} */\n        const knownBlock = await this._blockchain.getNearestBlockAt(blockHeightToProve, /*lower*/ false);\n        if (!knownBlock) {\n            throw new Error('No suitable reference block found for BlockProof');\n        }\n\n        if (blockHashToProve.equals(knownBlock.hash())) {\n            return knownBlock;\n        }\n\n        const agents = this._agents.values().filter(agent =>\n            agent.synced\n            && Services.isFullNode(agent.peer.peerAddress.services)\n        );\n\n        // Try agents first that (we think) know the reference block hash.\n        const knownBlockHash = knownBlock.hash();\n        agents.sort((a, b) =>\n            b.knowsBlock(knownBlockHash) !== a.knowsBlock(knownBlockHash)\n                ? -a.knowsBlock(knownBlockHash) + 0.5\n                : Math.random() - 0.5);\n\n        for (const /** @type {BaseConsensusAgent} */ agent of agents) {\n            try {\n                return await agent.getBlockProof(blockHashToProve, knownBlock); // eslint-disable-line no-await-in-loop\n            } catch (e) {\n                Log.w(BaseConsensus, `Failed to retrieve block proof for ${blockHashToProve}@${blockHeightToProve} from ${agent.peer.peerAddress}: ${e.message || e}`);\n                // Try the next peer.\n            }\n        }\n\n        // No peer supplied the requested account, fail.\n        throw new Error(`Failed to retrieve block proof for ${blockHashToProve}`);\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     * @param {Block} [block]\n     * @returns {Promise.<Array<Transaction>>}\n     * @protected\n     */\n    async _requestTransactionsProof(addresses, block = this._blockchain.head) {\n        if (addresses.length === 0) {\n            return [];\n        }\n\n        const agents = this._agents.values().filter(agent =>\n            agent.synced\n            && !Services.isNanoNode(agent.peer.peerAddress.services)\n        );\n\n        // Try agents first that (we think) know the reference block hash.\n        const blockHash = block.hash();\n        agents.sort((a, b) =>\n            b.knowsBlock(blockHash) !== a.knowsBlock(blockHash)\n                ? -a.knowsBlock(blockHash) + 0.5\n                : Math.random() - 0.5);\n\n        for (const /** @type {BaseConsensusAgent} */ agent of agents) {\n            try {\n                return await agent.getTransactionsProof(block, addresses); // eslint-disable-line no-await-in-loop\n            } catch (e) {\n                Log.w(BaseConsensus, `Failed to retrieve transactions proof for ${addresses} from ${agent.peer.peerAddress}: ${e.message || e}`);\n                // Try the next peer.\n            }\n        }\n\n        // No peer supplied the requested proof, fail.\n        throw new Error(`Failed to retrieve transactions proof for ${addresses}`);\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise.<Array.<TransactionReceipt>>}\n     * @protected\n     */\n    async _requestTransactionReceipts(address) {\n        const agents = this._agents.values().filter(agent =>\n            agent.synced\n            && Services.isFullNode(agent.peer.peerAddress.services)\n        ).sort(() => Math.random() - 0.5);\n\n        for (const /** @type {BaseConsensusAgent} */ agent of agents) {\n            try {\n                return await agent.getTransactionReceipts(address); // eslint-disable-line no-await-in-loop\n            } catch (e) {\n                Log.w(BaseConsensus, `Failed to retrieve transaction receipts for ${address} from ${agent.peer.peerAddress}: ${e.message || e}`);\n                // Try the next peer.\n            }\n        }\n\n        // No peer supplied the requested receipts, fail.\n        throw new Error(`Failed to retrieve transaction receipts for ${address}`);\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise.<Array.<{transaction: Transaction, header: BlockHeader}>>}\n     * @protected\n     */\n    async _requestTransactionHistory(address) {\n        // 1. Get transaction receipts.\n        const receipts = await this._requestTransactionReceipts(address);\n\n        // 2. Request proofs for missing blocks.\n        /** @type {Array.<Promise.<Block>>} */\n        const blockRequests = [];\n        let lastBlockHash = null;\n        for (const receipt of receipts) {\n            if (!receipt.blockHash.equals(lastBlockHash)) {\n                // eslint-disable-next-line no-await-in-loop\n                const block = await this._blockchain.getBlock(receipt.blockHash);\n                if (block) {\n                    blockRequests.push(Promise.resolve(block));\n                } else {\n                    const request = this._requestBlockProof(receipt.blockHash, receipt.blockHeight)\n                        .catch(e => Log.e(BaseConsensus, `Failed to retrieve proof for block ${receipt.blockHash}`\n                            + ` (${e}) - transaction history may be incomplete`));\n                    blockRequests.push(request);\n                }\n\n                lastBlockHash = receipt.blockHash;\n            }\n        }\n        const blocks = await Promise.all(blockRequests);\n\n        // 3. Request transaction proofs.\n        const transactionRequests = [];\n        for (const block of blocks) {\n            if (!block) continue;\n\n            const request = this._requestTransactionsProof([address], block)\n                .then(txs => txs.map(tx => ({ transaction: tx, header: block.header })))\n                .catch(e => Log.e(BaseConsensus, `Failed to retrieve transactions for block ${block.hash()}`\n                    + ` (${e}) - transaction history may be incomplete`));\n            transactionRequests.push(request);\n        }\n\n        const transactions = await Promise.all(transactionRequests);\n        return transactions\n            .reduce((flat, it) => it ? flat.concat(it) : flat, [])\n            .sort((a, b) => a.header.height - b.header.height);\n    }\n\n    /** @type {boolean} */\n    get established() {\n        return this._established;\n    }\n\n    /** @type {Network} */\n    get network() {\n        return this._network;\n    }\n\n    get invRequestManager() {\n        return this._invRequestManager;\n    }\n}\nBaseConsensus.SYNC_THROTTLE = 1500; // ms\nBaseConsensus.MIN_FULL_NODES = 1;\nClass.register(BaseConsensus);\n","/**\n * An anchored, contiguous chain of full blocks.\n */\nclass FullChain extends BaseChain {\n    /**\n     * @param {JungleDB} jdb\n     * @param {Accounts} accounts\n     * @param {Time} time\n     * @param {TransactionStore} [transactionStore]\n     * @returns {Promise.<FullChain>}\n     */\n    static getPersistent(jdb, accounts, time, transactionStore) {\n        const store = ChainDataStore.getPersistent(jdb);\n        const chain = new FullChain(store, accounts, time, transactionStore);\n        return chain._init();\n    }\n\n    /**\n     * @param {Accounts} accounts\n     * @param {Time} time\n     * @param {TransactionStore} [transactionStore]\n     * @returns {Promise.<FullChain>}\n     */\n    static createVolatile(accounts, time, transactionStore) {\n        const store = ChainDataStore.createVolatile();\n        const chain = new FullChain(store, accounts, time, transactionStore);\n        return chain._init();\n    }\n\n    /**\n     * @param {ChainDataStore} store\n     * @param {Accounts} accounts\n     * @param {Time} time\n     * @param {TransactionStore} [transactionStore]\n     * @returns {FullChain}\n     */\n    constructor(store, accounts, time, transactionStore) {\n        super(store);\n        this._accounts = accounts;\n        this._time = time;\n\n        /** @type {HashMap.<Hash,Accounts>} */\n        this._snapshots = new HashMap();\n        /** @type {Array.<Hash>} */\n        this._snapshotOrder = [];\n\n        /** @type {ChainData} */\n        this._mainChain = null;\n\n        /** @type {ChainProof} */\n        this._proof = null;\n\n        /** @type {TransactionCache} */\n        this._transactionCache = new TransactionCache();\n\n        /** @type {TransactionStore} */\n        this._transactionStore = transactionStore;\n\n        /** @type {PrioritySynchronizer} */\n        this._synchronizer = new PrioritySynchronizer(2);\n\n        /** @type {number} */\n        this._blockKnownCount = this._blockInvalidCount = this._blockOrphanCount = this._blockExtendedCount = this._blockRebranchedCount = this._blockForkedCount = 0;\n    }\n\n    /**\n     * @returns {Promise.<FullChain>}\n     * @protected\n     */\n    async _init() {\n        this._headHash = await this._store.getHead();\n        if (this._headHash) {\n            // Check that the correct genesis block is stored.\n            const genesis = await this._store.getChainData(GenesisConfig.GENESIS_HASH);\n            if (!genesis || !genesis.onMainChain) {\n                throw new Error('Invalid genesis block stored. Reset your consensus database.');\n            }\n\n            // Load main chain from store.\n            this._mainChain = await this._store.getChainData(this._headHash, /*includeBody*/ true);\n            Assert.that(!!this._mainChain, 'Failed to load main chain from storage');\n\n            // Check that chain/accounts state is consistent.\n            if (!this._mainChain.head.accountsHash.equals(await this._accounts.hash())) {\n                throw new Error('Corrupted store: Inconsistent chain/accounts state');\n            }\n\n            // Initialize TransactionCache.\n            const blocks = await this._store.getBlocksBackward(this.headHash, this._transactionCache.missingBlocks - 1, /*includeBody*/ true);\n            this._transactionCache.prependBlocks([...blocks.reverse(), this._mainChain.head]);\n        } else {\n            // Initialize chain & accounts with Genesis block.\n            this._mainChain = await ChainData.initial(GenesisConfig.GENESIS_BLOCK);\n            this._headHash = GenesisConfig.GENESIS_HASH;\n\n            const tx = this._store.synchronousTransaction();\n            tx.putChainDataSync(GenesisConfig.GENESIS_HASH, this._mainChain);\n            tx.setHeadSync(GenesisConfig.GENESIS_HASH);\n            await tx.commit();\n\n            await this._accounts.initialize(GenesisConfig.GENESIS_BLOCK, GenesisConfig.GENESIS_ACCOUNTS);\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     */\n    pushBlock(block) {\n        return this._synchronizer.push(/*priority*/ 0,\n            this._pushBlock.bind(this, block));\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     * @protected\n     */\n    async _pushBlock(block) {\n        // Check if we already know this block.\n        const hash = block.hash();\n        const knownBlock = await this._store.getBlock(hash);\n        if (knownBlock) {\n            this._blockKnownCount++;\n            return FullChain.OK_KNOWN;\n        }\n\n        // Check that the given block is a full block (includes block body).\n        if (!block.isFull()) {\n            Log.w(FullChain, 'Rejecting block - body missing');\n            this._blockInvalidCount++;\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check all intrinsic block invariants.\n        if (!(await block.verify(this._time))) {\n            this._blockInvalidCount++;\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check that all known interlink blocks are valid predecessors of the given block.\n        // if (!(await this._verifyInterlink(block))) {\n        //     Log.w(FullChain, 'Rejecting block - interlink verification failed');\n        //     return FullChain.ERR_INVALID;\n        // }\n\n        // Check if the block's immediate predecessor is part of the chain.\n        /** @type {ChainData} */\n        const prevData = await this._store.getChainData(block.prevHash);\n        if (!prevData) {\n            Log.w(FullChain, 'Rejecting block - unknown predecessor');\n            this._blockOrphanCount++;\n            return FullChain.ERR_ORPHAN;\n        }\n\n        // Check that the block is a valid successor of its immediate predecessor.\n        const predecessor = prevData.head;\n        if (!(await block.isImmediateSuccessorOf(predecessor))) {\n            Log.w(FullChain, 'Rejecting block - not a valid immediate successor');\n            this._blockInvalidCount++;\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check that the difficulty is correct.\n        const nextTarget = await this.getNextTarget(predecessor);\n        Assert.that(BlockUtils.isValidTarget(nextTarget), 'Failed to compute next target in FullChain');\n        if (block.nBits !== BlockUtils.targetToCompact(nextTarget)) {\n            Log.w(FullChain, 'Rejecting block - difficulty mismatch');\n            this._blockInvalidCount++;\n            return FullChain.ERR_INVALID;\n        }\n\n        // Block looks good, create ChainData.\n        const chainData = await prevData.nextChainData(block);\n\n        // Check if the block extends our current main chain.\n        if (block.prevHash.equals(this.headHash)) {\n            // Append new block to the main chain.\n            if (!(await this._extend(hash, chainData, prevData))) {\n                this._blockInvalidCount++;\n                return FullChain.ERR_INVALID;\n            }\n            this._blockExtendedCount++;\n            return FullChain.OK_EXTENDED;\n        }\n\n        // Otherwise, check if the new chain is harder than our current main chain.\n        if (chainData.totalDifficulty > this.totalDifficulty) {\n            // A fork has become the hardest chain, rebranch to it.\n            if (!(await this._rebranch(hash, chainData))) {\n                this._blockInvalidCount++;\n                return FullChain.ERR_INVALID;\n            }\n            this._blockRebranchedCount++;\n            return FullChain.OK_REBRANCHED;\n        }\n\n        // Otherwise, we are creating/extending a fork. Store chain data.\n        Log.v(FullChain, `Creating/extending fork with block ${hash}, height=${block.height}, totalDifficulty=${chainData.totalDifficulty}, totalWork=${chainData.totalWork}`);\n        await this._store.putChainData(hash, chainData);\n\n        this._blockForkedCount++;\n        return FullChain.OK_FORKED;\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<boolean>}\n     * @protected\n     */\n    async _verifyInterlink(block) {\n        // Check that all blocks referenced in the interlink of the given block are valid predecessors of that block.\n        for (let i = 0; i < block.interlink.length; i++) {\n            const predecessor = await this._store.getBlock(block.interlink.hashes[i]); // eslint-disable-line no-await-in-loop\n            if (!predecessor || !(await block.isInterlinkSuccessorOf(predecessor))) { // eslint-disable-line no-await-in-loop\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {ChainData} chainData\n     * @param {ChainData} prevData\n     * @returns {Promise.<boolean>}\n     * @fires FullChain#head-changed\n     * @private\n     */\n    async _extend(blockHash, chainData, prevData) {\n        const accountsTx = await this._accounts.transaction();\n        try {\n            await accountsTx.commitBlock(chainData.head, this._transactionCache);\n        } catch (e) {\n            // AccountsHash mismatch. This can happen if someone gives us an invalid block.\n            // TODO error handling\n            Log.w(FullChain, `Rejecting block - failed to commit to AccountsTree: ${e.message || e}`);\n            accountsTx.abort().catch(Log.w.tag(FullChain));\n            return false;\n        }\n\n        chainData.onMainChain = true;\n        prevData.mainChainSuccessor = blockHash;\n\n        const storeTx = await this._store.synchronousTransaction();\n        storeTx.putChainDataSync(blockHash, chainData);\n        storeTx.putChainDataSync(chainData.head.prevHash, prevData, /*includeBody*/ false);\n        storeTx.setHeadSync(blockHash);\n\n        if (this._transactionStore) {\n            const transactionStoreTx = this._transactionStore.transaction();\n            await transactionStoreTx.put(chainData.head);\n            await JDB.JungleDB.commitCombined(...storeTx.txs, accountsTx.tx, transactionStoreTx.tx);\n        } else {\n            await JDB.JungleDB.commitCombined(...storeTx.txs, accountsTx.tx);\n        }\n\n        // New block on main chain, so store a new snapshot.\n        await this._saveSnapshot(blockHash);\n\n        // Update transactions cache.\n        this._transactionCache.pushBlock(chainData.head);\n\n        if (this._shouldExtendChainProof() && this._proof) {\n            // If we want to maintain our proof by extending it and have a cached proof, extend it.\n            this._proof = await this._extendChainProof(this._proof, chainData.head.header);\n        } else {\n            // Otherwise, clear the proof and recompute it the next time it is needed.\n            this._proof = null;\n        }\n\n        // Update head.\n        this._mainChain = chainData;\n        this._headHash = blockHash;\n\n        // Tell listeners that the head of the chain has changed.\n        this.fire('head-changed', this.head, /*rebranching*/ false);\n\n        return true;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     */\n    _shouldExtendChainProof() {\n        return false;\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {ChainData} chainData\n     * @returns {Promise.<boolean>}\n     * @protected\n     */\n    async _rebranch(blockHash, chainData) {\n        Log.v(FullChain, `Rebranching to fork ${blockHash}, height=${chainData.head.height}, totalDifficulty=${chainData.totalDifficulty}, totalWork=${chainData.totalWork}`);\n\n        // Drop all snapshots.\n        for (const hash of this._snapshotOrder) {\n            const snapshot = this._snapshots.get(hash);\n            snapshot.abort(); // We do not need to wait for the abortion as long as it has been triggered.\n        }\n        this._snapshots.clear();\n        this._snapshotOrder = [];\n\n        // Find the common ancestor between our current main chain and the fork chain.\n        // Walk up the fork chain until we find a block that is part of the main chain.\n        // Store the chain along the way.\n        /** @type {Array.<ChainData>} */\n        const forkChain = [];\n        /** @type {Array.<Hash>} */\n        const forkHashes = [];\n\n        /** @type {ChainData} */\n        let curData = chainData;\n        /** @type {Hash} */\n        let curHash = blockHash;\n        while (!curData.onMainChain) {\n            forkChain.push(curData);\n            forkHashes.push(curHash);\n\n            curHash = curData.head.prevHash;\n            // TODO FIXME This can fail in the light client. It might not have the requested block at all or only the light block.\n            curData = await this._store.getChainData(curHash, /*includeBody*/ true); // eslint-disable-line no-await-in-loop\n            Assert.that(!!curData, 'Corrupted store: Failed to find fork predecessor while rebranching');\n        }\n\n        Log.v(FullChain, () => `Found common ancestor ${curHash.toBase64()} ${forkChain.length} blocks up`);\n\n        /** @type {ChainData} */\n        const ancestorData = curData;\n        /** @type {Hash} */\n        const ancestorHash = curHash;\n\n        // Validate all accountsHashes on the fork. Revert the AccountsTree to the common ancestor state first.\n        const accountsTx = await this._accounts.transaction(false);\n        const transactionCacheTx = this._transactionCache.clone();\n        // Also update transactions in index.\n        const transactionStoreTx = this._transactionStore ? this._transactionStore.transaction() : null;\n\n        /** @type {Array.<ChainData>} */\n        const revertChain = [];\n        /** @type {Hash} */\n        let headHash = this._headHash;\n        /** @type {ChainData} */\n        let headData = this._mainChain;\n        while (!headHash.equals(ancestorHash)) {\n            try {\n                // This only works in the light client if we revert less than Policy.TRANSACTION_VALIDITY_WINDOW blocks.\n                await accountsTx.revertBlock(headData.head, transactionCacheTx);\n                transactionCacheTx.revertBlock(headData.head);\n\n                // Also update transactions in index.\n                if (this._transactionStore) {\n                    await transactionStoreTx.remove(headData.head);\n                }\n                revertChain.push(headData);\n            } catch (e) {\n                Log.e(FullChain, 'Failed to revert main chain while rebranching', e);\n                accountsTx.abort().catch(Log.w.tag(FullChain));\n                if (this._transactionStore) {\n                    transactionStoreTx.abort().catch(Log.w.tag(FullChain));\n                }\n                return false;\n            }\n\n            headHash = headData.head.prevHash;\n            headData = await this._store.getChainData(headHash, /*includeBody*/ true);\n            Assert.that(!!headData, 'Corrupted store: Failed to find main chain predecessor while rebranching');\n            Assert.that(headData.head.accountsHash.equals(await accountsTx.hash()), 'Failed to revert main chain - inconsistent state');\n        }\n\n        // Try to fetch missing transactions for the cache.\n        // TODO FIXME The light client might not have all necessary blocks.\n        const numMissingBlocks = transactionCacheTx.missingBlocks;\n        const blocks = await this._store.getBlocksBackward(headHash, numMissingBlocks, /*includeBody*/ true);\n        transactionCacheTx.prependBlocks(blocks.reverse());\n\n        // Try to apply all fork blocks.\n        for (let i = forkChain.length - 1; i >= 0; i--) {\n            try {\n                await accountsTx.commitBlock(forkChain[i].head, transactionCacheTx);\n                transactionCacheTx.pushBlock(forkChain[i].head);\n\n                // Also update transactions in index.\n                if (this._transactionStore) {\n                    await transactionStoreTx.put(forkChain[i].head);\n                }\n            } catch (e) {\n                // A fork block is invalid.\n                // TODO delete invalid block and its successors from store.\n                Log.e(FullChain, 'Failed to apply fork block while rebranching', e);\n                accountsTx.abort().catch(Log.w.tag(FullChain));\n                if (this._transactionStore) {\n                    transactionStoreTx.abort().catch(Log.w.tag(FullChain));\n                }\n                return false;\n            }\n        }\n\n        // Fork looks good.\n        // Unset onMainChain flag / mainChainSuccessor on the current main chain up to (excluding) the common ancestor.\n        /** @type {ChainDataStore} */\n        const chainTx = this._store.synchronousTransaction(false);\n        for (const revertedData of revertChain) {\n            revertedData.onMainChain = false;\n            revertedData.mainChainSuccessor = null;\n            chainTx.putChainDataSync(revertedData.head.hash(), revertedData, /*includeBody*/ false);\n        }\n\n        // Update the mainChainSuccessor of the common ancestor block.\n        ancestorData.mainChainSuccessor = forkHashes[forkHashes.length - 1];\n        chainTx.putChainDataSync(ancestorHash, ancestorData, /*includeBody*/ false);\n\n        // Set onMainChain flag / mainChainSuccessor on the fork.\n        for (let i = forkChain.length - 1; i >= 0; i--) {\n            const forkData = forkChain[i];\n            forkData.onMainChain = true;\n            forkData.mainChainSuccessor = i > 0 ? forkHashes[i - 1] : null;\n            // Include the body of the new block (at position 0).\n            chainTx.putChainDataSync(forkHashes[i], forkData, /*includeBody*/ i === 0);\n        }\n\n        // Update head & commit transactions.\n        chainTx.setHeadSync(blockHash);\n        if (this._transactionStore) {\n            await JDB.JungleDB.commitCombined(...chainTx.txs, accountsTx.tx, transactionStoreTx.tx);\n        } else {\n            await JDB.JungleDB.commitCombined(...chainTx.txs, accountsTx.tx);\n        }\n        this._transactionCache = transactionCacheTx;\n\n        // Reset chain proof. We don't recompute the chain proof here, but do it lazily the next time it is needed.\n        // TODO modify chain proof directly, don't recompute.\n        this._proof = null;\n\n        // Fire block-reverted event for each block reverted during rebranch\n        for (const revertedData of revertChain) {\n            this.fire('block-reverted', revertedData.head);\n        }\n\n        // Fire head-changed event for each fork block.\n        for (let i = forkChain.length - 1; i >= 0; i--) {\n            this._mainChain = forkChain[i];\n            this._headHash = forkHashes[i];\n            this.fire('head-changed', this.head, /*rebranching*/ i > 0);\n        }\n\n        return true;\n    }\n\n    /**\n     *\n     * @param {Hash} startBlockHash\n     * @param {number} count\n     * @param {boolean} forward\n     * @returns {Promise.<Array.<Block>>}\n     */\n    getBlocks(startBlockHash, count = 500, forward = true) {\n        return this._store.getBlocks(startBlockHash, count, forward);\n    }\n\n    /**\n     * @returns {Promise.<ChainProof>}\n     * @override\n     */\n    getChainProof() {\n        return this._synchronizer.push(/*priority*/ 1, async () => {\n            if (!this._proof) {\n                this._proof = await this._getChainProof();\n            }\n            return this._proof;\n        });\n    }\n\n    /**\n     * @param {Block} blockToProve\n     * @param {Block} knownBlock\n     * @returns {Promise.<?BlockChain>}\n     **/\n    getBlockProof(blockToProve, knownBlock) {\n        return this._synchronizer.push(/*priority*/ 1,\n            this._getBlockProof.bind(this, blockToProve, knownBlock));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {string} startPrefix\n     * @returns {Promise.<?AccountsTreeChunk>}\n     */\n    async getAccountsTreeChunk(blockHash, startPrefix) {\n        const snapshot = await this._getSnapshot(blockHash);\n        return snapshot && await snapshot.getAccountsTreeChunk(startPrefix);\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<?AccountsProof>}\n     */\n    async getAccountsProof(blockHash, addresses) {\n        const snapshot = await this._getSnapshot(blockHash);\n        return snapshot && await snapshot.getAccountsProof(addresses);\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<?TransactionsProof>}\n     */\n    async getTransactionsProof(blockHash, addresses) {\n        const block = await this.getBlock(blockHash, /*includeForks*/ false, /*includeBody*/ true);\n        if (!block || !block.isFull()) {\n            return null;\n        }\n\n        const matches = [];\n        const addressesSet = new HashSet();\n        addressesSet.addAll(addresses);\n        for (const transaction of block.transactions) {\n            if (addressesSet.contains(transaction.sender) || addressesSet.contains(transaction.recipient)) {\n                matches.push(transaction);\n            }\n        }\n\n        const proof = MerkleProof.compute(block.body.getMerkleLeafs(), matches);\n        return new TransactionsProof(matches, proof);\n    }\n\n    /**\n     * @param {Address} address\n     * @param {number} [limit]\n     * @returns {Promise.<Array.<TransactionReceipt>>}\n     */\n    async getTransactionReceiptsByAddress(address, limit = null) {\n        if (!this._transactionStore) {\n            throw new Error('Invalid request');\n        }\n\n        const transactionReceipts = [];\n        const entriesBySender = await this._transactionStore.getBySender(address, limit);\n        const entriesByRecipient = await this._transactionStore.getByRecipient(address, limit === null ? null : Math.max(0, limit - entriesBySender.length));\n\n        entriesBySender.forEach(entry => {\n            transactionReceipts.push(new TransactionReceipt(entry.transactionHash, entry.blockHash, entry.blockHeight));\n        });\n\n        entriesByRecipient.forEach(entry => {\n            transactionReceipts.push(new TransactionReceipt(entry.transactionHash, entry.blockHash, entry.blockHeight));\n        });\n\n        return transactionReceipts;\n    }\n\n    /**\n     * @param {Hash} transactionHash\n     * @returns {Promise.<?TransactionStoreEntry>}\n     */\n    async getTransactionInfoByHash(transactionHash) {\n        if (!this._transactionStore) {\n            throw new Error('Invalid request');\n        }\n\n        const txStoreEntry = await this._transactionStore.get(transactionHash);\n        if (!txStoreEntry) {\n            return null;\n        }\n\n        return txStoreEntry;\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @returns {Promise.<?Accounts>}\n     */\n    _getSnapshot(blockHash) {\n        // TODO Does this have to be synchronized with pushBlock() ?\n        return this._synchronizer.push(/*priority*/ 1, async () => {\n            const block = await this.getBlock(blockHash);\n            // Check if blockHash is a block on the main chain within the allowed window.\n            if (!block || this._mainChain.head.height - block.height > Policy.NUM_SNAPSHOTS_MAX) {\n                return null;\n            }\n\n            // Check if there already is a snapshot, otherwise create it.\n            let snapshot = null;\n            if (!this._snapshots.contains(blockHash)) {\n                const tx = await this._accounts.transaction();\n                const transactionsTx = this._transactionCache.clone();\n                let currentHash = this._headHash;\n                // Save all snapshots up to blockHash (and stop when its predecessor would be next).\n                while (!block.prevHash.equals(currentHash)) {\n                    const currentBlock = await this.getBlock(currentHash, /*includeForks*/ false, /*includeBody*/ true);\n\n                    if (!this._snapshots.contains(currentHash)) {\n                        snapshot = await this._accounts.snapshot(tx);\n                        this._snapshots.put(currentHash, snapshot);\n                        this._snapshotOrder.unshift(currentHash);\n                    }\n\n                    await tx.revertBlock(currentBlock, transactionsTx);\n                    transactionsTx.revertBlock(currentBlock);\n                    currentHash = currentBlock.prevHash;\n                }\n                await tx.abort();\n            } else {\n                snapshot = this._snapshots.get(blockHash);\n            }\n\n            Assert.that(block.accountsHash.equals(await snapshot.hash()), 'AccountsHash mismatch for snapshot of block ${blockHash}');\n\n            return snapshot;\n        });\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _saveSnapshot(blockHash) {\n        // Replace oldest snapshot if possible.\n        // This ensures snapshots are only created lazily.\n        if (this._snapshotOrder.length > 0) {\n            const oldestHash = this._snapshotOrder.shift();\n            // If the hash is not reused, remove it.\n            const oldestSnapshot = this._snapshots.get(oldestHash);\n            if (oldestSnapshot) {\n                await oldestSnapshot.abort();\n            } else {\n                Log.e(FullChain, () => `Snapshot with hash ${oldestHash.toBase64()} not found.`);\n            }\n            this._snapshots.remove(oldestHash);\n\n            // Add new snapshot.\n            const snapshot = await this._accounts.snapshot();\n            this._snapshots.put(blockHash, snapshot);\n            this._snapshotOrder.push(blockHash);\n        }\n    }\n\n    /** @type {Block} */\n    get head() {\n        return this._mainChain.head;\n    }\n\n    /** @type {Hash} */\n    get headHash() {\n        return this._headHash;\n    }\n\n    get height() {\n        return this._mainChain.head.height;\n    }\n\n    /** @type {number} */\n    get totalDifficulty() {\n        return this._mainChain.totalDifficulty;\n    }\n\n    /** @type {number} */\n    get totalWork() {\n        return this._mainChain.totalWork;\n    }\n\n    /** @type {Accounts} */\n    // XXX Do we really want to expose this?\n    get accounts() {\n        return this._accounts;\n    }\n\n    /** @type {TransactionCache} */\n    get transactionCache() {\n        return this._transactionCache;\n    }\n\n    /** @type {number} */\n    get blockForkedCount() {\n        return this._blockForkedCount;\n    }\n\n    /** @type {number} */\n    get blockRebranchedCount() {\n        return this._blockRebranchedCount;\n    }\n\n    /** @type {number} */\n    get blockExtendedCount() {\n        return this._blockExtendedCount;\n    }\n\n    /** @type {number} */\n    get blockOrphanCount() {\n        return this._blockOrphanCount;\n    }\n\n    /** @type {number} */\n    get blockInvalidCount() {\n        return this._blockInvalidCount;\n    }\n\n    /** @type {number} */\n    get blockKnownCount() {\n        return this._blockKnownCount;\n    }\n\n    /**\n     * @returns {Promise.<Hash>}\n     */\n    // XXX Do we really want to expose this?\n    accountsHash() {\n        return this._accounts.hash();\n    }\n}\n\nFullChain.ERR_ORPHAN = -2;\nFullChain.ERR_INVALID = -1;\nFullChain.OK_KNOWN = 0;\nFullChain.OK_EXTENDED = 1;\nFullChain.OK_REBRANCHED = 2;\nFullChain.OK_FORKED = 3;\nClass.register(FullChain);\n","class FullConsensusAgent extends BaseConsensusAgent {\n    /**\n     * @param {FullChain} blockchain\n     * @param {Mempool} mempool\n     * @param {Time} time\n     * @param {Peer} peer\n     * @param {InvRequestManager} invRequestManager\n     * @param {Subscription} targetSubscription\n     */\n    constructor(blockchain, mempool, time, peer, invRequestManager, targetSubscription) {\n        super(time, peer, invRequestManager, targetSubscription);\n        /** @type {FullChain} */\n        this._blockchain = blockchain;\n        /** @type {Mempool} */\n        this._mempool = mempool;\n\n        // Flag indicating that we are currently syncing our blockchain with the peer's.\n        /** @type {boolean} */\n        this._syncing = false;\n\n        // The number of blocks that extended our blockchain since the last requestBlocks().\n        /** @type {number} */\n        this._numBlocksExtending = -1;\n        // The number of blocks that forked our blockchain since the last requestBlocks().\n        /** @type {number} */\n        this._numBlocksForking = -1;\n        // The last fork block the peer has sent us.\n        /** @type {Block} */\n        this._forkHead = null;\n\n        // The number of failed blockchain sync attempts.\n        /** @type {number} */\n        this._failedSyncs = 0;\n\n        // The block hash that we want to learn to consider the sync complete.\n        /** @type {Hash} */\n        this._syncTarget = peer.headHash;\n\n        /** @type {RateLimit} */\n        this._chainProofLimit = new RateLimit(FullConsensusAgent.CHAIN_PROOF_RATE_LIMIT);\n        /** @type {RateLimit} */\n        this._accountsProofLimit = new RateLimit(FullConsensusAgent.ACCOUNTS_PROOF_RATE_LIMIT);\n        /** @type {RateLimit} */\n        this._accountsTreeChunkLimit = new RateLimit(FullConsensusAgent.ACCOUNTS_TREE_CHUNK_RATE_LIMIT);\n        /** @type {RateLimit} */\n        this._transactionsProofLimit = new RateLimit(FullConsensusAgent.TRANSACTION_PROOF_RATE_LIMIT);\n        /** @type {RateLimit} */\n        this._transactionReceiptsLimit = new RateLimit(FullConsensusAgent.TRANSACTION_RECEIPTS_RATE_LIMIT);\n        /** @type {RateLimit} */\n        this._blockProofLimit = new RateLimit(FullConsensusAgent.BLOCK_PROOF_RATE_LIMIT);\n\n        // Listen to consensus messages from the peer.\n        peer.channel.on('get-blocks', msg => this._onGetBlocks(msg));\n        peer.channel.on('get-chain-proof', msg => this._onGetChainProof(msg));\n        peer.channel.on('get-accounts-proof', msg => this._onGetAccountsProof(msg));\n        peer.channel.on('get-accounts-tree-chunk', msg => this._onGetAccountsTreeChunk(msg));\n        peer.channel.on('get-transactions-proof', msg => this._onGetTransactionsProof(msg));\n        peer.channel.on('get-transaction-receipts', msg => this._onGetTransactions(msg));\n        peer.channel.on('get-block-proof', msg => this._onGetBlockProof(msg));\n        peer.channel.on('mempool', msg => this._onMempool(msg));\n    }\n\n    async syncBlockchain() {\n        this._syncing = true;\n\n        // We only sync with other full nodes.\n        if (!Services.isFullNode(this._peer.peerAddress.services)) {\n            this._syncFinished();\n            return;\n        }\n\n        // Wait for all objects to arrive.\n        if (!this._objectsInFlight.isEmpty()) {\n            Log.v(FullConsensusAgent, `Waiting for ${this._objectsInFlight.length} objects to arrive ...`);\n            return;\n        }\n\n        // Wait for all objects to be processed.\n        if (!this._objectsProcessing.isEmpty()) {\n            Log.v(FullConsensusAgent, `Waiting for ${this._objectsProcessing.length} objects to be processed ...`);\n            return;\n        }\n\n        // If we know our sync target block, the sync process is finished.\n        const head = await this._blockchain.getBlock(this._syncTarget, /*includeForks*/ true);\n        if (head) {\n            this._syncFinished();\n            return;\n        }\n\n        // If the peer didn't send us any blocks that extended our chain, count it as a failed sync attempt.\n        // This sets a maximum length for forks that the full client will accept:\n        //   FullConsensusAgent.SYNC_ATTEMPTS_MAX * BaseInvectoryMessage.VECTORS_MAX_COUNT\n        if (this._numBlocksExtending === 0 && ++this._failedSyncs >= FullConsensusAgent.SYNC_ATTEMPTS_MAX) {\n            this._peer.channel.close(CloseType.BLOCKCHAIN_SYNC_FAILED, 'blockchain sync failed');\n            return;\n        }\n\n        // We don't know the peer's head block, request blocks from it.\n        this._requestBlocks().catch(Log.w.tag(FullConsensusAgent));\n    }\n\n    _syncFinished() {\n        // Subscribe to all announcements from the peer.\n        this._subscribeTarget();\n\n        // Request the peer's mempool.\n        // XXX Use a random delay here to prevent requests to multiple peers at once.\n        const delay = FullConsensusAgent.MEMPOOL_DELAY_MIN\n            + Math.random() * (FullConsensusAgent.MEMPOOL_DELAY_MAX - FullConsensusAgent.MEMPOOL_DELAY_MIN);\n        setTimeout(() => this._peer.channel.mempool(), delay);\n\n        this._syncing = false;\n        this._synced = true;\n\n        this._numBlocksExtending = 0;\n        this._numBlocksForking = 0;\n        this._forkHead = null;\n        this._failedSyncs = 0;\n\n        this.fire('sync');\n    }\n\n    async _requestBlocks(maxInvSize) {\n        // Only one getBlocks request at a time.\n        if (this._peer.channel.isExpectingMessage(Message.Type.INV)) {\n            return;\n        }\n\n        // Drop the peer if it doesn't start sending InvVectors for its chain within the timeout.\n        // Set timeout early to prevent re-entering the method.\n        this._peer.channel.expectMessage(Message.Type.INV, () => {\n            this._peer.channel.close(CloseType.GET_BLOCKS_TIMEOUT, 'getBlocks timeout');\n        }, BaseConsensusAgent.REQUEST_TIMEOUT);\n\n        // Check if the peer is sending us a fork.\n        const onFork = this._forkHead && this._numBlocksExtending === 0 && this._numBlocksForking > 0;\n\n        /** @type {Array.<Hash>} */\n        let locators;\n        if (onFork) {\n            // Only send the fork head as locator if the peer is sending us a fork.\n            locators = [this._forkHead.hash()];\n        } else {\n            locators = await this._blockchain.getBlockLocators();\n        }\n\n        // Reset block counters.\n        this._numBlocksExtending = 0;\n        this._numBlocksForking = 0;\n\n        // Request blocks from peer.\n        this._peer.channel.getBlocks(locators, maxInvSize);\n    }\n\n    /**\n     * @param {InvMessage} msg\n     * @returns {Promise}\n     * @protected\n     * @override\n     */\n    _onInv(msg) {\n        return super._onInv(msg);\n    }\n\n    /**\n     * @param {InvVector} vector\n     * @returns {boolean}\n     * @protected\n     * @override\n     */\n    _shouldRequestData(vector) {\n        // Ignore block announcements from nano clients as they will ignore our getData requests anyways (they only know headers).\n        return !(Services.isNanoNode(this._peer.peerAddress.services) && vector.type === InvVector.Type.BLOCK);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {boolean} [includeForks]\n     * @param {boolean} [includeBody]\n     * @returns {Promise.<?Block>}\n     * @protected\n     * @override\n     */\n    _getBlock(hash, includeForks = false, includeBody = false) {\n        return this._blockchain.getBlock(hash, includeForks, includeBody);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {boolean} [includeForks]\n     * @returns {Promise.<?Uint8Array>}\n     * @protected\n     * @override\n     */\n    _getRawBlock(hash, includeForks = false) {\n        return this._blockchain.getRawBlock(hash, includeForks);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Promise.<?Transaction>}\n     * @protected\n     * @override\n     */\n    _getTransaction(hash) {\n        return Promise.resolve(this._mempool.getTransaction(hash));\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @returns {void}\n     * @protected\n     * @override\n     */\n    async _onKnownBlockAnnounced(hash, block) {\n        if (!this._syncing) return;\n\n        this._numBlocksForking++;\n        this._forkHead = block;\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     * @override\n     */\n    _onNoUnknownObjects() {\n        // The peer does not have any new inv vectors for us.\n        if (this._syncing) {\n            this.syncBlockchain().catch(Log.w.tag(FullConsensusAgent));\n        }\n    }\n\n    /**\n     * @protected\n     * @override\n     */\n    _onAllObjectsReceived() {\n        // If all objects have been received, request more if we're syncing the blockchain.\n        if (this._syncing) {\n            this.syncBlockchain().catch(Log.w.tag(FullConsensusAgent));\n        }\n    }\n\n    /**\n     * @param {HeaderMessage} msg\n     * @return {Promise.<void>}\n     * @protected\n     * @override\n     */\n    _onHeader(msg) {\n        // Ignore header messages.\n        Log.w(FullConsensusAgent, `Unsolicited header message received from ${this._peer.peerAddress}, discarding`);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @returns {Promise.<void>}\n     * @protected\n     * @override\n     */\n    async _processBlock(hash, block) {\n        // TODO send reject message if we don't like the block\n        const status = await this._blockchain.pushBlock(block);\n        switch (status) {\n            case FullChain.ERR_INVALID:\n                this._peer.channel.close(CloseType.RECEIVED_INVALID_BLOCK, 'received invalid block');\n                break;\n\n            case FullChain.OK_EXTENDED:\n            case FullChain.OK_REBRANCHED:\n                if (this._syncing) this._numBlocksExtending++;\n                break;\n\n            case FullChain.OK_FORKED:\n                if (this._syncing) {\n                    this._numBlocksForking++;\n                    this._forkHead = block;\n                }\n                break;\n\n            case FullChain.ERR_ORPHAN:\n                this._onOrphanBlock(hash, block);\n                break;\n\n            case FullChain.OK_KNOWN:\n                Log.v(FullConsensusAgent, `Received known block ${hash} (height=${block.height}, prevHash=${block.prevHash}) from ${this._peer.peerAddress}`);\n                break;\n        }\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @protected\n     */\n    _onOrphanBlock(hash, block) {\n        // Ignore orphan blocks if we're not synced yet. This shouldn't happen.\n        if (!this._synced) {\n            Log.w(FullConsensusAgent, `Received orphan block ${hash} (height=${block.height}, prevHash=${block.prevHash}) while syncing`);\n            return;\n        }\n\n        // The peer has announced an orphaned block after the initial sync. We're probably out of sync.\n        Log.d(FullConsensusAgent, `Received orphan block ${hash} (height=${block.height}, prevHash=${block.prevHash}) from ${this._peer.peerAddress}`);\n\n        // Disable announcements from the peer once.\n        if (!this._timers.timeoutExists('outOfSync')) {\n            this._subscribe(Subscription.NONE);\n        }\n\n        // Set the orphaned block as the new sync target.\n        this._syncTarget = hash;\n\n        // Wait a short time for:\n        // - our (un-)subscribe message to be sent\n        // - potentially more orphaned blocks to arrive\n        this._timers.resetTimeout('outOfSync', () => this._outOfSync(), FullConsensusAgent.RESYNC_THROTTLE);\n    }\n\n    /**\n     * @private\n     */\n    _outOfSync() {\n        this._timers.clearTimeout('outOfSync');\n\n        this._synced = false;\n\n        this.fire('out-of-sync');\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Transaction} transaction\n     * @returns {Promise.<boolean>}\n     * @protected\n     * @override\n     */\n    async _processTransaction(hash, transaction) {\n        const result = await this._mempool.pushTransaction(transaction);\n        switch (result) {\n            case Mempool.ReturnCode.ACCEPTED:\n                return true;\n            case Mempool.ReturnCode.KNOWN:\n                return false;\n            case Mempool.ReturnCode.FEE_TOO_LOW:\n                this.peer.channel.reject(Message.Type.TX, RejectMessage.Code.REJECT_INSUFFICIENT_FEE,\n                    'Sender has too many free transactions', transaction.hash().serialize());\n                return false;\n            case Mempool.ReturnCode.INVALID:\n                this.peer.channel.reject(Message.Type.TX, RejectMessage.Code.REJECT_INVALID, 'Invalid transaction',\n                    transaction.hash().serialize());\n                return false;\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * @protected\n     * @override\n     */\n    _onAllObjectsProcessed() {\n        // If all objects have been processed, request more if we're syncing the blockchain.\n        if (this._syncing) {\n            this.syncBlockchain().catch(Log.w.tag(FullConsensusAgent));\n        }\n    }\n\n\n    /* Request endpoints */\n\n    /**\n     * @param {GetBlocksMessage} msg\n     * @return {Promise}\n     * @private\n     */\n    async _onGetBlocks(msg) {\n        Log.v(FullConsensusAgent, `[GETBLOCKS] ${msg.locators.length} block locators maxInvSize ${msg.maxInvSize} received from ${this._peer.peerAddress}`);\n\n        // A peer has requested blocks. Check all requested block locator hashes\n        // in the given order and pick the first hash that is found on our main\n        // chain, ignore the rest. If none of the requested hashes is found,\n        // pick the genesis block hash. Send the main chain starting from the\n        // picked hash back to the peer.\n        let startBlock = GenesisConfig.GENESIS_BLOCK;\n        for (const locator of msg.locators) {\n            const block = await this._blockchain.getBlock(locator);\n            if (block) {\n                // We found a block, ignore remaining block locator hashes.\n                startBlock = block;\n                break;\n            }\n        }\n\n        // Collect up to GETBLOCKS_VECTORS_MAX inventory vectors for the blocks starting right\n        // after the identified block on the main chain.\n        const blocks = await this._blockchain.getBlocks(startBlock.hash(),\n            Math.min(msg.maxInvSize, FullConsensusAgent.GETBLOCKS_VECTORS_MAX),\n            msg.direction === GetBlocksMessage.Direction.FORWARD);\n        const vectors = [];\n        for (const block of blocks) {\n            vectors.push(InvVector.fromBlock(block));\n        }\n\n        // Send the vectors back to the requesting peer.\n        this._peer.channel.inv(vectors);\n    }\n\n    /**\n     * @param {GetChainProofMessage} msg\n     * @private\n     */\n    async _onGetChainProof(msg) {\n        if (!this._chainProofLimit.note()) {\n            Log.w(FullConsensusAgent, 'Rejecting GetChainProof message - rate-limit exceeded');\n            this._peer.channel.close(CloseType.RATE_LIMIT_EXCEEDED, 'rate-limit exceeded');\n            return;\n        }\n        const proof = await this._blockchain.getChainProof();\n        this._peer.channel.chainProof(proof);\n    }\n\n    /**\n     * @param {GetBlockProofMessage} msg\n     * @private\n     */\n    async _onGetBlockProof(msg) {\n        if (!this._blockProofLimit.note()) {\n            Log.w(FullConsensusAgent, 'Rejecting GetBlockProof message - rate-limit exceeded');\n            this._peer.channel.blockProof(null);\n            return;\n        }\n        const blockToProve = await this._blockchain.getBlock(msg.blockHashToProve);\n        const knownBlock = await this._blockchain.getBlock(msg.knownBlockHash);\n        if (!blockToProve || !knownBlock) {\n            this._peer.channel.blockProof();\n            return;\n        }\n\n        const proof = await this._blockchain.getBlockProof(blockToProve, knownBlock);\n        this._peer.channel.blockProof(proof);\n    }\n\n    /**\n     * @param {GetAccountsProofMessage} msg\n     * @private\n     */\n    async _onGetAccountsProof(msg) {\n        if (!this._accountsProofLimit.note()) {\n            Log.w(FullConsensusAgent, 'Rejecting GetAccountsProof message - rate-limit exceeded');\n            this._peer.channel.accountsProof(msg.blockHash, null);\n            return;\n        }\n        const proof = await this._blockchain.getAccountsProof(msg.blockHash, msg.addresses);\n        this._peer.channel.accountsProof(msg.blockHash, proof);\n    }\n\n    /**\n     * @param {GetTransactionsProofMessage} msg\n     * @private\n     */\n    async _onGetTransactionsProof(msg) {\n        if (!this._transactionsProofLimit.note()) {\n            Log.w(FullConsensusAgent, 'Rejecting GetTransactionsProof message - rate-limit exceeded');\n            this._peer.channel.transactionsProof(msg.blockHash, null);\n            return;\n        }\n        const proof = await this._blockchain.getTransactionsProof(msg.blockHash, msg.addresses);\n        this._peer.channel.transactionsProof(msg.blockHash, proof);\n    }\n\n    /**\n     * @param {GetAccountsTreeChunkMessage} msg\n     * @private\n     */\n    async _onGetAccountsTreeChunk(msg) {\n        if (!this._accountsTreeChunkLimit.note()) {\n            Log.w(FullConsensusAgent, 'Rejecting GetAccountsTreeChunk message - rate-limit exceeded');\n            this._peer.channel.accountsTreeChunk(msg.blockHash, null);\n            return;\n        }\n        const chunk = await this._blockchain.getAccountsTreeChunk(msg.blockHash, msg.startPrefix);\n        this._peer.channel.accountsTreeChunk(msg.blockHash, chunk);\n    }\n\n    /**\n     * @param {GetTransactionReceiptsMessage} msg\n     * @private\n     */\n    async _onGetTransactions(msg) {\n        if (!this._transactionReceiptsLimit.note()) {\n            Log.w(FullConsensusAgent, 'Rejecting GetTransactionReceipts message - rate-limit exceeded');\n            return;\n        }\n\n        const transactionReceipts = await this._blockchain.getTransactionReceiptsByAddress(msg.address, FullConsensusAgent.TRANSACTION_RECEIPTS_LIMIT);\n\n        // TODO recipients current only support a single transaction-receipts message.\n        for (let i = 0; i < transactionReceipts.length && /* TODO Remove me */ i === 0; i += TransactionReceiptsMessage.RECEIPTS_MAX_COUNT) {\n            const receipts = transactionReceipts.slice(i, i + TransactionReceiptsMessage.RECEIPTS_MAX_COUNT);\n            this._peer.channel.transactionReceipts(receipts);\n        }\n    }\n\n    /**\n     * @param {MempoolMessage} msg\n     * @return {Promise}\n     * @private\n     */\n    async _onMempool(msg) {\n        // Query mempool for transactions\n        let transactions = [];\n        switch (this._remoteSubscription.type) {\n            case Subscription.Type.ADDRESSES:\n                transactions = this._mempool.getTransactionsByAddresses(this._remoteSubscription.addresses, FullConsensusAgent.MEMPOOL_ENTRIES_MAX);\n                break;\n            case Subscription.Type.MIN_FEE:\n                transactions = new LimitIterable(this._mempool.transactionGenerator(/*maxSize*/ undefined, this._remoteSubscription.minFeePerByte), FullConsensusAgent.MEMPOOL_ENTRIES_MAX);\n                break;\n            case Subscription.Type.ANY:\n                transactions = new LimitIterable(this._mempool.transactionGenerator(), FullConsensusAgent.MEMPOOL_ENTRIES_MAX);\n                break;\n        }\n\n        // Send an InvVector for each transaction in the mempool.\n        // Split into multiple Inv messages if the mempool is large.\n        let vectors = [];\n        for (const tx of transactions) {\n            vectors.push(InvVector.fromTransaction(tx));\n\n            if (vectors.length >= BaseInventoryMessage.VECTORS_MAX_COUNT) {\n                this._peer.channel.inv(vectors);\n                vectors = [];\n                await new Promise((resolve) => setTimeout(resolve, FullConsensusAgent.MEMPOOL_THROTTLE));\n            }\n        }\n\n        if (vectors.length > 0) {\n            this._peer.channel.inv(vectors);\n        }\n    }\n\n    /** @type {boolean} */\n    get syncing() {\n        return this._syncing;\n    }\n}\n/**\n * Maximum number of blockchain sync retries before closing the connection.\n * XXX If the peer is on a long fork, it will count as a failed sync attempt\n * if our blockchain doesn't switch to the fork within 500 (max InvVectors returned by getBlocks)\n * blocks.\n * @type {number}\n */\nFullConsensusAgent.SYNC_ATTEMPTS_MAX = 25;\n/**\n * Maximum number of inventory vectors to sent in the response for onGetBlocks.\n * @type {number}\n */\nFullConsensusAgent.GETBLOCKS_VECTORS_MAX = 500;\n/**\n * Time {ms} to wait before triggering a blockchain re-sync with the peer.\n * @type {number}\n */\nFullConsensusAgent.RESYNC_THROTTLE = 1000 * 3; // 3 seconds\n/**\n * Minimum time {ms} to wait before triggering the initial mempool request.\n * @type {number}\n */\nFullConsensusAgent.MEMPOOL_DELAY_MIN = 1000 * 2; // 2 seconds\n/**\n * Maximum time {ms} to wait before triggering the initial mempool request.\n * @type {number}\n */\nFullConsensusAgent.MEMPOOL_DELAY_MAX = 1000 * 20; // 20 seconds\n/**\n * Time {ms} to wait between sending full inv vectors of transactions during Mempool request\n * @type {number}\n */\nFullConsensusAgent.MEMPOOL_THROTTLE = 1000;\n/**\n * Number of transaction vectors to send\n * @type {number}\n */\nFullConsensusAgent.MEMPOOL_ENTRIES_MAX = 10000;\nFullConsensusAgent.CHAIN_PROOF_RATE_LIMIT = 3;\nFullConsensusAgent.ACCOUNTS_PROOF_RATE_LIMIT = 60;\nFullConsensusAgent.ACCOUNTS_TREE_CHUNK_RATE_LIMIT = 120;\nFullConsensusAgent.TRANSACTION_PROOF_RATE_LIMIT = 60;\nFullConsensusAgent.TRANSACTION_RECEIPTS_RATE_LIMIT = 30;\nFullConsensusAgent.TRANSACTION_RECEIPTS_LIMIT = 1000;\nFullConsensusAgent.BLOCK_PROOF_RATE_LIMIT = 60;\nClass.register(FullConsensusAgent);\n","class FullConsensus extends BaseConsensus {\n    /**\n     * @param {FullChain} blockchain\n     * @param {Mempool} mempool\n     * @param {Network} network\n     */\n    constructor(blockchain, mempool, network) {\n        super(blockchain, mempool, network);\n        /** @type {FullChain} */\n        this._blockchain = blockchain;\n        /** @type {Mempool} */\n        this._mempool = mempool;\n    }\n\n    /**\n     * @param {number} minFeePerByte\n     */\n    subscribeMinFeePerByte(minFeePerByte) {\n        this.subscribe(Subscription.fromMinFeePerByte(minFeePerByte));\n        this.mempool.evictBelowMinFeePerByte(minFeePerByte);\n    }\n\n    /**\n     * @type {number} minFeePerByte\n     */\n    get minFeePerByte() {\n        return this._subscription.type === Subscription.Type.MIN_FEE ? this._subscription.minFeePerByte : 0;\n    }\n\n    /**\n     * @param {Peer} peer\n     * @returns {BaseConsensusAgent}\n     * @override\n     */\n    _newConsensusAgent(peer) {\n        return new FullConsensusAgent(this._blockchain, this._mempool, this._network.time, peer, this._invRequestManager, this._subscription);\n    }\n\n    /** @type {FullChain} */\n    get blockchain() {\n        return this._blockchain;\n    }\n\n    /** @type {Mempool} */\n    get mempool() {\n        return this._mempool;\n    }\n}\nClass.register(FullConsensus);\n","/**\n * A LightChain is initialized by using NiPoPoWs instead of the full\n * blockchain history, but after initialization, it behaves as a regular\n * full blockchain.\n */\nclass LightChain extends FullChain {\n    /**\n    * @param {JungleDB} jdb\n    * @param {Accounts} accounts\n    * @param {Time} time\n    * @returns {Promise.<LightChain>}\n    */\n    static getPersistent(jdb, accounts, time) {\n        const store = ChainDataStore.getPersistent(jdb);\n        const chain = new LightChain(store, accounts, time);\n        return chain._init();\n    }\n\n    /**\n     * @param {Accounts} accounts\n     * @param {Time} time\n     * @returns {Promise.<LightChain>}\n     */\n    static createVolatile(accounts, time) {\n        const store = ChainDataStore.createVolatile();\n        const chain = new LightChain(store, accounts, time);\n        return chain._init();\n    }\n\n    /**\n     * @param {ChainDataStore} store\n     * @param {Accounts} accounts\n     * @param {Time} time\n     * @returns {PartialLightChain}\n     */\n    constructor(store, accounts, time) {\n        super(store, accounts, time);\n    }\n\n    /**\n     * @override\n     * @protected\n     */\n    async _init() {\n        // FIXME: this is a workaround as Babel doesn't understand await super().\n        await FullChain.prototype._init.call(this);\n        if (!this._proof) {\n            this._proof = await this._getChainProof();\n        }\n        return this;\n    }\n\n    /**\n     * @return {PartialLightChain}\n     */\n    async partialChain() {\n        const proof = await this.getChainProof();\n        const partialChain = new PartialLightChain(this._store, this._accounts, this._time, proof);\n        partialChain.on('committed', (proof, headHash, mainChain) => {\n            this._proof = proof;\n            this._headHash = headHash;\n            this._mainChain = mainChain;\n            this.fire('head-changed', this.head);\n        });\n        await partialChain._init();\n        return partialChain;\n    }\n\n    /**\n     * @returns {boolean}\n     * @private\n     * @override\n     */\n    _shouldExtendChainProof() {\n        return true;\n    }\n}\nClass.register(LightChain);\n","class LightConsensusAgent extends FullConsensusAgent {\n    /**\n     * @param {LightChain} blockchain\n     * @param {Mempool} mempool\n     * @param {Time} time\n     * @param {Peer} peer\n     * @param {InvRequestManager} invRequestManager\n     * @param {Subscription} targetSubscription\n     */\n    constructor(blockchain, mempool, time, peer, invRequestManager, targetSubscription) {\n        super(blockchain, mempool, time, peer, invRequestManager, targetSubscription);\n        /** @type {LightChain} */\n        this._blockchain = blockchain;\n        /** @type {PartialLightChain} */\n        this._partialChain = null;\n\n        /** @type {boolean} */\n        this._syncing = false;\n\n        // Flag indicating whether we do a full catchup or request a proof.\n        /** @type {boolean} */\n        this._catchup = false;\n\n        // Flag indicating whether we believe to be on the main chain of the client.\n        /** @type {boolean} */\n        this._onMainChain = false;\n\n        /** @type {Array.<Block>} */\n        this._orphanedBlocks = [];\n\n        /** @type {boolean} */\n        this._busy = false;\n\n        // Helper object to keep track of the accounts we're requesting from the peer.\n        this._accountsRequest = null;\n\n        // Flag to track chain proof requests.\n        this._requestedChainProof = false;\n\n        // Number of weak proofs we have received from the peer.\n        this._numWeakProofs = 0;\n\n        // Listen to consensus messages from the peer.\n        peer.channel.on('chain-proof', msg => this._onChainProof(msg));\n        peer.channel.on('accounts-tree-chunk', msg => this._onAccountsTreeChunk(msg));\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     * @override\n     */\n    async syncBlockchain() {\n        // We don't sync with nano nodes.\n        if (Services.isNanoNode(this._peer.peerAddress.services)) {\n            this._syncFinished();\n            return;\n        }\n\n        // Wait for all objects to arrive.\n        if (!this._objectsInFlight.isEmpty()) {\n            Log.v(LightConsensusAgent, `Waiting for ${this._objectsInFlight.length} objects to arrive ...`);\n            return;\n        }\n\n        // Wait for all objects to be processed.\n        if (!this._objectsProcessing.isEmpty()) {\n            Log.v(LightConsensusAgent, `Waiting for ${this._objectsProcessing.length} objects to be processed ...`);\n            return;\n        }\n\n        // Ban peer if the sync failed more often than allowed.\n        if (this._failedSyncs >= LightConsensusAgent.SYNC_ATTEMPTS_MAX) {\n            this._peer.channel.close(CloseType.BLOCKCHAIN_SYNC_FAILED, 'blockchain sync failed');\n            if (this._partialChain) {\n                await this._partialChain.abort();\n                this._partialChain = null;\n            }\n            return;\n        }\n\n        // Check if we know head block.\n        const block = await this._blockchain.getBlock(this._syncTarget, /*includeForks*/ true);\n\n        /*\n         * Three cases:\n         * 1) We know block and are not yet syncing: All is done.\n         * 2) We don't know the block and are not yet syncing: Start syncing.\n         *    and determine sync mode (full catchup or not).\n         * 3) We are syncing. Behave differently based on sync mode.\n         *    Note that we can switch from catchup to proof if we notice that\n         *    we're on a fork and get an INV vector starting from the genesis block.\n         */\n\n        // Case 1: We're up to date.\n        if (block && !this._syncing) {\n            this._syncFinished();\n            return;\n        }\n\n        // Case 2: Check header.\n        if (!block && !this._syncing) {\n            this._syncing = true;\n            this._onMainChain = false;\n\n            let header;\n            try {\n                header = await this.getHeader(this._syncTarget);\n            } catch (e) {\n                this._peer.channel.close(CloseType.DID_NOT_GET_REQUESTED_HEADER, 'Did not get requested header');\n                return;\n            }\n\n            // Check how to sync based on heuristic:\n            this._catchup = header.height >= this._blockchain.height\n                && header.height - this._blockchain.height <= Policy.NUM_BLOCKS_VERIFICATION;\n            Log.d(LightConsensusAgent, `Start syncing, catchup mode: ${this._catchup}`);\n        }\n\n        // Case 3: We are syncing.\n        if (this._syncing && !this._busy) {\n            if (this._catchup) {\n                await FullConsensusAgent.prototype.syncBlockchain.call(this);\n            } else {\n                // Initialize partial chain on first call.\n                if (!this._partialChain) {\n                    await this._initChainProofSync();\n                }\n\n                switch (this._partialChain.state) {\n                    case PartialLightChain.State.PROVE_CHAIN:\n                        this._requestChainProof();\n                        this.fire('sync-chain-proof', this._peer.peerAddress);\n                        break;\n                    case PartialLightChain.State.PROVE_ACCOUNTS_TREE:\n                        this._requestAccountsTree();\n                        this.fire('sync-accounts-tree', this._peer.peerAddress);\n                        break;\n                    case PartialLightChain.State.PROVE_BLOCKS:\n                        this._requestProofBlocks();\n                        this.fire('verify-accounts-tree', this._peer.peerAddress);\n                        break;\n                    case PartialLightChain.State.COMPLETE:\n                        // Commit state on success.\n                        this.fire('sync-finalize', this._peer.peerAddress);\n                        this._busy = true;\n                        await this._partialChain.commit();\n                        await this._applyOrphanedBlocks();\n                        this._syncFinished();\n                        break;\n                    case PartialLightChain.State.ABORTED:\n                        this._peer.channel.close(CloseType.ABORTED_SYNC, 'aborted sync');\n                        break;\n                    case PartialLightChain.State.WEAK_PROOF:\n                        Log.d(LightConsensusAgent, `Not syncing with ${this._peer.peerAddress} - weaker proof`);\n                        this._numWeakProofs++;\n                        if (this._numWeakProofs >= LightConsensusAgent.WEAK_PROOFS_MAX) {\n                            this._peer.channel.close(CloseType.BLOCKCHAIN_SYNC_FAILED, 'too many weak proofs');\n                        } else {\n                            this._syncFinished();\n                        }\n                        break;\n                }\n            }\n        }\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _initChainProofSync() {\n        // Subscribe to all announcements from the peer.\n        this._subscribeTarget();\n\n        this._syncing = true;\n        this._synced = false;\n        this._catchup = false;\n        this._onMainChain = true;\n\n        if (this._partialChain) {\n            await this._partialChain.abort();\n        }\n\n        this._partialChain = await this._blockchain.partialChain();\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _syncFinished() {\n        if (this._partialChain) {\n            this._partialChain = null;\n        }\n\n        this._busy = false;\n        super._syncFinished();\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _applyOrphanedBlocks() {\n        for (const block of this._orphanedBlocks) {\n            const status = await this._blockchain.pushBlock(block);\n            if (status === LightChain.ERR_INVALID) {\n                this._peer.channel.close(CloseType.RECEIVED_INVALID_BLOCK, 'received invalid block');\n                break;\n            }\n        }\n        this._orphanedBlocks = [];\n    }\n\n    // Syncing stages.\n    // Stage 1: Chain proof.\n    /**\n     * @returns {void}\n     * @private\n     */\n    _requestChainProof() {\n        Assert.that(this._partialChain && this._partialChain.state === PartialLightChain.State.PROVE_CHAIN);\n        Assert.that(!this._requestedChainProof);\n        this._busy = true;\n\n        // Request ChainProof from peer.\n        this._peer.channel.getChainProof();\n        this._requestedChainProof = true;\n\n        // Drop the peer if it doesn't send the chain proof within the timeout.\n        // TODO should we ban here instead?\n        this._peer.channel.expectMessage(Message.Type.CHAIN_PROOF, () => {\n            this._peer.channel.close(CloseType.GET_CHAIN_PROOF_TIMEOUT, 'getChainProof timeout');\n        }, LightConsensusAgent.CHAINPROOF_REQUEST_TIMEOUT, LightConsensusAgent.CHAINPROOF_CHUNK_TIMEOUT);\n    }\n\n    /**\n     * @param {ChainProofMessage} msg\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _onChainProof(msg) {\n        Assert.that(this._partialChain && this._partialChain.state === PartialLightChain.State.PROVE_CHAIN);\n        Log.d(LightConsensusAgent, `[CHAIN-PROOF] Received from ${this._peer.peerAddress}: ${msg.proof}`);\n\n        // Check if we have requested an interlink chain, reject unsolicited ones.\n        if (!this._requestedChainProof) {\n            Log.w(LightConsensusAgent, `Unsolicited chain proof received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n        this._requestedChainProof = false;\n\n        if (this._syncing) {\n            this.fire('verify-chain-proof', this._peer.peerAddress);\n        }\n\n        // Push the proof into the LightChain.\n        if (!(await this._partialChain.pushProof(msg.proof))) {\n            Log.w(LightConsensusAgent, `Invalid chain proof received from ${this._peer.peerAddress} - verification failed`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.INVALID_CHAIN_PROOF, 'invalid chain proof');\n            return;\n        }\n\n        // TODO add all blocks from the chain proof to knownObjects.\n        this._busy = false;\n        this.syncBlockchain().catch(Log.w.tag(LightConsensusAgent));\n    }\n\n    // Stage 2: Request AccountsTree.\n    /**\n     * @private\n     */\n    _requestAccountsTree() {\n        Assert.that(this._partialChain && this._partialChain.state === PartialLightChain.State.PROVE_ACCOUNTS_TREE);\n        Assert.that(!this._accountsRequest);\n        this._busy = true;\n\n        const startPrefix = this._partialChain.getMissingAccountsPrefix();\n        const headHash = this._partialChain.headHash;\n        Log.d(LightConsensusAgent, `Requesting AccountsTreeChunk starting at ${startPrefix} from ${this._peer.peerAddress}`);\n\n        this._accountsRequest = {\n            startPrefix: startPrefix,\n            blockHash: headHash\n        };\n\n        // Request AccountsProof from peer.\n        this._peer.channel.getAccountsTreeChunk(headHash, startPrefix);\n\n        // Drop the peer if it doesn't send the accounts proof within the timeout.\n        this._peer.channel.expectMessage(Message.Type.ACCOUNTS_TREE_CHUNK, () => {\n            this._peer.channel.close(CloseType.GET_ACCOUNTS_TREE_CHUNK_TIMEOUT, 'getAccountsTreeChunk timeout');\n        }, LightConsensusAgent.ACCOUNTS_TREE_CHUNK_REQUEST_TIMEOUT);\n    }\n\n    /**\n     * @param {AccountsTreeChunkMessage} msg\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _onAccountsTreeChunk(msg) {\n        Log.d(LightConsensusAgent, `[ACCOUNTS-TREE-CHUNK] Received from ${this._peer.peerAddress}: blockHash=${msg.blockHash}, proof=${msg.chunk}`);\n\n        // Check if we have requested an accounts proof, reject unsolicited ones.\n        if (!this._accountsRequest) {\n            Log.w(LightConsensusAgent, `Unsolicited accounts tree chunk received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n\n        Assert.that(this._partialChain && this._partialChain.state === PartialLightChain.State.PROVE_ACCOUNTS_TREE);\n\n        const startPrefix = this._accountsRequest.startPrefix;\n        const blockHash = this._accountsRequest.blockHash;\n\n        // Reset accountsRequest.\n        this._accountsRequest = null;\n\n        if (!msg.hasChunk()) {\n            // Restart syncing.\n            await this._partialChain.abort();\n            this._partialChain = null;\n            this._busy = false;\n            this._failedSyncs++;\n            return;\n        }\n\n        // Check that we know the reference block.\n        if (!blockHash.equals(msg.blockHash) || msg.chunk.head.prefix <= startPrefix) {\n            Log.w(LightConsensusAgent, `Received AccountsTreeChunk for block != head or wrong start prefix from ${this._peer.peerAddress}`);\n            this._peer.channel.close(CloseType.INVALID_ACCOUNTS_TREE_CHUNK, 'Invalid AccountsTreeChunk');\n            return;\n        }\n\n        // Verify the proof.\n        const chunk = msg.chunk;\n        if (!chunk.verify()) {\n            Log.w(LightConsensusAgent, `Invalid AccountsTreeChunk received from ${this._peer.peerAddress}`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.INVALID_ACCOUNTS_TREE_CHUNK, 'Invalid AccountsTreeChunk');\n            return;\n        }\n\n        // Check that the proof root hash matches the accountsHash in the reference block.\n        const rootHash = chunk.root();\n        const block = await this._partialChain.getBlock(blockHash);\n        if (!block.accountsHash.equals(rootHash)) {\n            Log.w(LightConsensusAgent, `Invalid AccountsTreeChunk (root hash) received from ${this._peer.peerAddress}`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.ACCOUNTS_TREE_CHUNCK_ROOT_HASH_MISMATCH, 'AccountsTreeChunk root hash mismatch');\n            return;\n        }\n\n        // Return the retrieved accounts.\n        const result = await this._partialChain.pushAccountsTreeChunk(chunk);\n\n        // Something went wrong!\n        if (result < 0) {\n            // TODO maybe ban?\n            Log.e(`AccountsTree sync failed with error code ${result} from ${this._peer.peerAddress}`);\n            this._peer.channel.close(CloseType.ACCOUNTS_TREE_CHUNCK_ROOT_HASH_MISMATCH, 'AccountsTreeChunk root hash mismatch');\n        }\n\n        this._busy = false;\n        this.syncBlockchain().catch(Log.w.tag(LightConsensusAgent));\n    }\n\n    // Stage 3: Request proof blocks.\n    /**\n     * @private\n     */\n    _requestProofBlocks() {\n        Assert.that(this._partialChain && this._partialChain.state === PartialLightChain.State.PROVE_BLOCKS);\n\n        // If nothing happend since the last request, increase failed syncs.\n        if (this._lastChainHeight === this._partialChain.proofHeadHeight) {\n            this._failedSyncs++;\n        }\n        this._lastChainHeight = this._partialChain.proofHeadHeight;\n\n        // XXX Only one getBlocks request at a time.\n        if (this._peer.channel.isExpectingMessage(Message.Type.INV)) {\n            Log.e(LightConsensusAgent, 'Duplicate _requestProofBlocks()');\n            return;\n        }\n\n        // Drop the peer if it doesn't start sending InvVectors for its chain within the timeout.\n        this._peer.channel.expectMessage(Message.Type.INV, () => {\n            this._peer.channel.close(CloseType.GET_BLOCKS_TIMEOUT, 'getBlocks timeout');\n        }, BaseConsensusAgent.REQUEST_TIMEOUT);\n\n        // Request the full block for our proof head.\n        const locators = this._partialChain.getBlockLocators();\n        this.requestVector(new InvVector(InvVector.Type.BLOCK, locators[0]));\n\n        // Request blocks from peer.\n        this._peer.channel.getBlocks(locators, this._partialChain.numBlocksNeeded(), false);\n    }\n\n    // Block processing.\n    /**\n     * @returns {Promise.<void>}\n     * @private\n     */\n    _requestBlocks() {\n        // If we are syncing and not yet sure whether our blocks are on the main chain, just sync one block for now.\n        if (this._syncing && !this._onMainChain) {\n            return super._requestBlocks(1);\n        }\n        return super._requestBlocks();\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @returns {Promise.<void>}\n     * @protected\n     * @override\n     */\n    async _processBlock(hash, block) {\n        // If we find that we are on a fork far away from our chain, resync.\n        if (block.height < this._chain.height - Policy.NUM_BLOCKS_VERIFICATION\n            && (!this._partialChain || this._partialChain.state !== PartialLightChain.State.PROVE_BLOCKS)) {\n            this._onMainChain = false;\n            await this._initChainProofSync();\n            this.syncBlockchain().catch(Log.w.tag(LightConsensusAgent));\n            return;\n        } else {\n            this._onMainChain = true;\n        }\n\n        // Put block into blockchain.\n        const status = await this._chain.pushBlock(block);\n\n        switch (status) {\n            case FullChain.ERR_INVALID:\n                this._peer.channel.close(CloseType.RECEIVED_INVALID_BLOCK, 'received invalid block');\n                break;\n\n            case FullChain.OK_EXTENDED:\n            case FullChain.OK_REBRANCHED:\n                if (this._syncing) this._numBlocksExtending++;\n                break;\n\n            case FullChain.OK_FORKED:\n                if (this._syncing) {\n                    this._numBlocksForking++;\n                    this._forkHead = block;\n                }\n                break;\n\n            case LightChain.ERR_ORPHAN:\n                this._onOrphanBlock(hash, block);\n                break;\n        }\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @returns {void}\n     * @protected\n     * @override\n     */\n    async _onKnownBlockAnnounced(hash, block) {\n        if (this._syncing && this._catchup) {\n            // If we find that we are on a fork far away from our chain, resync.\n            if (block.height < this._chain.height - Policy.NUM_BLOCKS_VERIFICATION\n                && (!this._partialChain || this._partialChain.state !== PartialLightChain.State.PROVE_BLOCKS)) {\n                this._onMainChain = false;\n                await this._initChainProofSync();\n                this.syncBlockchain().catch(e => Log.e(LightConsensusAgent, e));\n                return;\n            } else {\n                this._onMainChain = true;\n            }\n\n            FullConsensusAgent.prototype._onKnownBlockAnnounced.call(this, hash, block);\n        }\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Block} block\n     * @private\n     * @override\n     */\n    _onOrphanBlock(hash, block) {\n        if (this._syncing && !this._catchup) {\n            this._orphanedBlocks.push(block);\n        } else {\n            super._onOrphanBlock(hash, block);\n        }\n    }\n\n    // Header processing.\n    /**\n     * @param {Hash} hash\n     * @return {Promise.<BlockHeader>}\n     */\n    getHeader(hash) {\n        Assert.that(!this._headerRequest);\n\n        return new Promise((resolve, reject) => {\n            const vector = new InvVector(InvVector.Type.BLOCK, hash);\n            this._headerRequest = {\n                hash: hash,\n                resolve: resolve,\n                reject: reject\n            };\n\n            this._peer.channel.getHeader([vector]);\n\n            // Drop the peer if it doesn't send the accounts proof within the timeout.\n            this._peer.channel.expectMessage(Message.Type.HEADER, () => {\n                this._headerRequest = null;\n                this._peer.channel.close(CloseType.GET_HEADER_TIMEOUT, 'getHeader timeout');\n                reject(new Error('timeout')); // TODO error handling\n            }, BaseConsensusAgent.REQUEST_TIMEOUT);\n        });\n    }\n\n    /**\n     * @param {HeaderMessage} msg\n     * @return {void}\n     * @protected\n     * @override\n     */\n    _onHeader(msg) {\n        const header = msg.header;\n        const hash = header.hash();\n\n        // Check if we have requested this block.\n        if (!this._headerRequest) {\n            Log.w(NanoConsensusAgent, `Unsolicited header ${hash} received from ${this._peer.peerAddress}, discarding`);\n            // TODO What should happen here? ban? drop connection?\n            return;\n        }\n\n        const requestedHash = this._headerRequest.hash;\n        const resolve = this._headerRequest.resolve;\n        const reject = this._headerRequest.reject;\n\n        // Reset headerRequest.\n        this._headerRequest = null;\n\n        // Check that it is the correct hash.\n        if (!requestedHash.equals(hash)) {\n            Log.w(LightConsensusAgent, `Received wrong header from ${this._peer.peerAddress}`);\n            this._peer.channel.close(CloseType.RECEIVED_WRONG_HEADER, 'Received wrong header');\n            reject(new Error('Received wrong header'));\n            return;\n        }\n\n        resolve(header);\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     * @override\n     */\n    _onClose() {\n        if (this._partialChain) {\n            this._partialChain.abort().catch(Log.w.tag(LightConsensusAgent));\n        }\n\n        super._onClose();\n    }\n\n    /** @type {LightChain} */\n    get _chain() {\n        if (this._syncing && !this._catchup && this._partialChain) {\n            return this._partialChain;\n        }\n        return this._blockchain;\n    }\n\n    /** @type {boolean} */\n    get syncing() {\n        return this._syncing;\n    }\n}\n/**\n * Maximum time (ms) to wait for chain-proof after sending out get-chain-proof before dropping the peer.\n * @type {number}\n */\nLightConsensusAgent.CHAINPROOF_REQUEST_TIMEOUT = 1000 * 45;\n/**\n * Maximum time (ms) to wait for between chain-proof chunks before dropping the peer.\n * @type {number}\n */\nLightConsensusAgent.CHAINPROOF_CHUNK_TIMEOUT = 1000 * 10;\n/**\n * Maximum time (ms) to wait for accounts-tree-chunk after sending out get-accounts-tree-chunk before dropping the peer.\n * @type {number}\n */\nLightConsensusAgent.ACCOUNTS_TREE_CHUNK_REQUEST_TIMEOUT = 1000 * 8;\n/**\n * Maximum number of blockchain sync retries before closing the connection.\n * @type {number}\n */\nLightConsensusAgent.SYNC_ATTEMPTS_MAX = 5;\n/**\n * Maximum number of inventory vectors to sent in the response for onGetBlocks.\n * @type {number}\n */\nLightConsensusAgent.GETBLOCKS_VECTORS_MAX = 500;\n/**\n * Maximum number of weak proofs we allow before closing the connection.\n * @type {number}\n */\nLightConsensusAgent.WEAK_PROOFS_MAX = 3;\n\nClass.register(LightConsensusAgent);\n","class LightConsensus extends BaseConsensus {\n    /**\n     * @param {LightChain} blockchain\n     * @param {Mempool} mempool\n     * @param {Network} network\n     */\n    constructor(blockchain, mempool, network) {\n        super(blockchain, mempool, network);\n        /** @type {LightChain} */\n        this._blockchain = blockchain;\n        /** @type {Mempool} */\n        this._mempool = mempool;\n    }\n\n    /**\n     * @param {Peer} peer\n     * @returns {BaseConsensusAgent}\n     * @override\n     */\n    _newConsensusAgent(peer) {\n        return new LightConsensusAgent(this._blockchain, this._mempool, this._network.time, peer, this._invRequestManager, this._subscription);\n    }\n\n    /**\n     * @param {Peer} peer\n     * @override\n     */\n    _onPeerJoined(peer) {\n        const agent = super._onPeerJoined(peer);\n\n        // Forward sync events.\n        this.bubble(agent, 'sync-chain-proof', 'verify-chain-proof', 'sync-accounts-tree', 'verify-accounts-tree', 'sync-finalize');\n\n        return agent;\n    }\n\n    /** @type {LightChain} */\n    get blockchain() {\n        return this._blockchain;\n    }\n\n    /** @type {Mempool} */\n    get mempool() {\n        return this._mempool;\n    }\n}\nClass.register(LightConsensus);\n","class PartialLightChain extends LightChain {\n    /**\n     * @param {ChainDataStore} store\n     * @param {Accounts} accounts\n     * @param {Time} time\n     * @param {ChainProof} proof\n     * @returns {PartialLightChain}\n     */\n    constructor(store, accounts, time, proof) {\n        const tx = store.transaction(false);\n        super(tx, accounts, time);\n\n        /** @type {ChainProof} */\n        this._proof = proof;\n\n        /** @type {PartialLightChain.State} */\n        this._state = PartialLightChain.State.PROVE_CHAIN;\n        /** @type {PartialAccountsTree} */\n        this._partialTree = null;\n        /** @type {Accounts} */\n        this._accountsTx = null;\n        /** @type {ChainData} */\n        this._proofHead = null;\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @returns {Promise.<boolean>}\n     */\n    pushProof(proof) {\n        // Synchronize with .pushBlock()\n        return this._synchronizer.push(/*priority*/ 0,\n            this._pushProof.bind(this, proof));\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @returns {Promise.<boolean>}\n     * @private\n     */\n    async _pushProof(proof) {\n        const toDo = [];\n        for (let i = 0; i < proof.prefix.length; ++i) {\n            const block = proof.prefix.blocks[i];\n            const hash = block.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (!knownBlock && !block.header._pow) {\n                toDo.push(block.header);\n            }\n        }\n        for (let i = 0; i < proof.suffix.length; ++i) {\n            const header = proof.suffix.headers[i];\n            const hash = header.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (!knownBlock && !header._pow) {\n                toDo.push(header);\n            }\n        }\n        await BaseChain.manyPow(toDo);\n\n        // Verify all prefix blocks that we don't know yet.\n        for (let i = 0; i < proof.prefix.length; i++) {\n            const block = proof.prefix.blocks[i];\n            const hash = block.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (knownBlock) {\n                proof.prefix.blocks[i] = knownBlock.toLight();\n            } else if (!(await block.verify(this._time))) {\n                Log.w(PartialLightChain, 'Rejecting proof - prefix contains invalid block');\n                return false;\n            }\n        }\n\n        // Verify all suffix headers that we don't know yet.\n        for (let i = 0; i < proof.suffix.length; i++) {\n            const header = proof.suffix.headers[i];\n            const hash = header.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (knownBlock) {\n                proof.suffix.headers[i] = knownBlock.header;\n            } else if (!(await header.verifyProofOfWork())) {\n                Log.w(PartialLightChain, 'Rejecting proof - suffix contains invalid header');\n                return false;\n            }\n        }\n\n        // Check that the proof is valid.\n        if (!(await proof.verify())) {\n            Log.w(PartialLightChain, 'Rejecting proof - verification failed');\n            return false;\n        }\n\n        // Check that the suffix is long enough.\n        if (proof.suffix.length !== Policy.K && proof.suffix.length !== proof.head.height - 1) {\n            Log.w(PartialLightChain, 'Rejecting proof - invalid suffix length');\n            return false;\n        }\n\n        // Check that the dense suffix of the prefix is long enough.\n        // The paper doesn't require this, we however need a sufficiently long dense suffix\n        // to be able to verify block difficulties.\n        const denseSuffix = proof.prefix.denseSuffix();\n        if (denseSuffix.length < Policy.M && proof.prefix.length > 0 && proof.prefix.head.height >= Policy.M) {\n            Log.w(NanoChain, 'Rejecting proof - dense suffix too short');\n            return false;\n        }\n\n        // Compute and verify interlinks for the suffix.\n        const suffixBlocks = [];\n        let head = proof.prefix.head;\n        for (const header of proof.suffix.headers) {\n            const interlink = await head.getNextInterlink(header.target, header.version);\n            const interlinkHash = interlink.hash();\n            if (!header.interlinkHash.equals(interlinkHash)) {\n                Log.w(PartialLightChain, 'Rejecting proof - invalid interlink hash in proof suffix');\n                return false;\n            }\n\n            head = new Block(header, interlink);\n            suffixBlocks.push(head);\n        }\n\n        // If the given proof is better than our current proof, adopt the given proof as the new best proof.\n        const currentProof = this._proof || await this._getChainProof();\n        if (await BaseChain.isBetterProof(proof, currentProof, Policy.M)) {\n            await this._acceptProof(proof, suffixBlocks);\n        } else {\n            await this.abort();\n            this._state = PartialLightChain.State.WEAK_PROOF;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @param {Array.<Block>} suffix\n     * @returns {Promise.<void>}\n     * @protected\n     */\n    async _acceptProof(proof, suffix) {\n        // If the proof prefix head is not part of our current dense chain suffix, reset store and start over.\n        // TODO use a store transaction here?\n        const head = proof.prefix.head;\n        const headHash = head.hash();\n        const headData = await this._store.getChainData(headHash);\n        if (!headData || headData.totalDifficulty <= 0) {\n            // Delete our current chain.\n            await this._store.truncate();\n\n            /** @type {Array.<Block>} */\n            const denseSuffix = proof.prefix.denseSuffix();\n\n            // Put all other prefix blocks in the store as well (so they can be retrieved via getBlock()/getBlockAt()),\n            // but don't allow blocks to be appended to them by setting totalDifficulty = -1;\n            let superBlockCounts = new SuperBlockCounts();\n            for (let i = 0; i < proof.prefix.length - denseSuffix.length; i++) {\n                const block = proof.prefix.blocks[i];\n                const hash = block.hash();\n                const depth = BlockUtils.getHashDepth(await block.pow());\n                superBlockCounts = superBlockCounts.copyAndAdd(depth);\n\n                const data = new ChainData(block, /*totalDifficulty*/ -1, /*totalWork*/ -1, superBlockCounts, true);\n                await this._store.putChainData(hash, data);\n            }\n\n            // Set the tail end of the dense suffix of the prefix as the new chain head.\n            const tailEnd = denseSuffix[0];\n            this._headHash = tailEnd.hash();\n            this._mainChain = await ChainData.initial(tailEnd, superBlockCounts);\n            await this._store.putChainData(this._headHash, this._mainChain);\n\n            // Only in the dense suffix of the prefix we can calculate the difficulties.\n            for (let i = 1; i < denseSuffix.length; i++) {\n                const block = denseSuffix[i];\n                const result = await this._pushLightBlock(block); // eslint-disable-line no-await-in-loop\n                Assert.that(result >= 0);\n            }\n        }\n\n        // Push all suffix blocks.\n        for (const block of suffix) {\n            const result = await this._pushLightBlock(block); // eslint-disable-line no-await-in-loop\n            Assert.that(result >= 0);\n        }\n\n        this._state = PartialLightChain.State.PROVE_ACCOUNTS_TREE;\n        this._partialTree = await this._accounts.partialAccountsTree();\n        this._proofHead = this._mainChain;\n        await this._store.setHead(this.headHash);\n\n        this._proof = proof;\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushLightBlock(block) {\n        // Check if we already know this header/block.\n        const hash = block.hash();\n        const knownBlock = await this._store.getBlock(hash);\n        if (knownBlock) {\n            return NanoChain.OK_KNOWN;\n        }\n\n        // Retrieve the immediate predecessor.\n        /** @type {ChainData} */\n        const prevData = await this._store.getChainData(block.prevHash);\n        if (!prevData || prevData.totalDifficulty <= 0) {\n            return NanoChain.ERR_ORPHAN;\n        }\n\n        return this._pushBlockInternal(block, hash, prevData);\n    }\n\n    /**\n     * @param {Block} block\n     * @param {Hash} blockHash\n     * @param {ChainData} prevData\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushBlockInternal(block, blockHash, prevData) {\n        // Block looks good, create ChainData.\n        const chainData = await prevData.nextChainData(block);\n\n        // Check if the block extends our current main chain.\n        if (block.prevHash.equals(this.headHash)) {\n            // Append new block to the main chain.\n            chainData.onMainChain = true;\n            prevData.mainChainSuccessor = blockHash;\n\n            await this._store.putChainData(blockHash, chainData);\n            await this._store.putChainData(block.prevHash, prevData, /*includeBody*/ false);\n\n            // Update head.\n            this._mainChain = chainData;\n            this._headHash = blockHash;\n\n            // Append new block to chain proof.\n            if (this._proof) {\n                const proofHeadHash = this._proof.head.hash();\n                if (block.prevHash.equals(proofHeadHash)) {\n                    this._proof = await this._extendChainProof(this._proof, block.header);\n                }\n            }\n\n            // Tell listeners that the head of the chain has changed.\n            this.fire('head-changed', this.head, /*rebranching*/ false);\n\n            return NanoChain.OK_EXTENDED;\n        }\n\n        // Otherwise, check if the new chain is harder than our current main chain.\n        if (chainData.totalDifficulty > this._mainChain.totalDifficulty) {\n            // A fork has become the hardest chain, rebranch to it.\n            await this._rebranch(blockHash, chainData);\n\n            return NanoChain.OK_REBRANCHED;\n        }\n\n        // Otherwise, we are creating/extending a fork. Store chain data.\n        Log.v(NanoChain, `Creating/extending fork with block ${blockHash}, height=${block.height}, totalDifficulty=${chainData.totalDifficulty}, totalWork=${chainData.totalWork}`);\n        await this._store.putChainData(blockHash, chainData);\n\n        return NanoChain.OK_FORKED;\n    }\n\n    /**\n     * @override\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     */\n    _pushBlock(block) {\n        // Queue new blocks while syncing.\n        if (this._state === PartialLightChain.State.PROVE_BLOCKS) {\n            const blockHash = block.hash();\n            if (this._proofHead.head.prevHash.equals(blockHash)) {\n                return this._pushBlockBackwards(block);\n            } else if (this._proofHead.head.hash().equals(blockHash)) {\n                return this._pushHeadBlock(block);\n            }\n        }\n\n        return FullChain.ERR_ORPHAN;\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushHeadBlock(block) {\n        // Check if we already know this block.\n        const hash = block.hash();\n\n        // Check that the given block is a full block (includes block body).\n        if (!block.isFull()) {\n            Log.w(PartialLightChain, 'Rejecting block - body missing');\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check all intrinsic block invariants.\n        if (!(await block.verify(this._time))) {\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check that all known interlink blocks are valid predecessors of the given block.\n        if (!(await this._verifyInterlink(block))) {\n            Log.w(PartialLightChain, 'Rejecting block - interlink verification failed');\n            return FullChain.ERR_INVALID;\n        }\n\n        // We know that the current proof head is the successor.\n        // Check that the block is a valid predecessor of its immediate successor.\n        const prevData = await this._store.getChainData(block.prevHash);\n        if (!prevData) {\n            Log.w(PartialLightChain, 'Rejecting block - unknown predecessor');\n            return FullChain.ERR_ORPHAN;\n        }\n\n        // Check that the block is a valid successor of its immediate predecessor.\n        const predecessor = prevData.head;\n        if (!(await block.isImmediateSuccessorOf(predecessor))) {\n            Log.w(PartialLightChain, 'Rejecting block - not a valid immediate successor');\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check that the difficulty is correct.\n        const nextTarget = await this.getNextTarget(predecessor);\n        if (BlockUtils.isValidTarget(nextTarget)) {\n            if (block.nBits !== BlockUtils.targetToCompact(nextTarget)) {\n                Log.w(PartialLightChain, 'Rejecting block - difficulty mismatch');\n                return FullChain.ERR_INVALID;\n            }\n        } else {\n            Log.w(PartialLightChain, 'Skipping difficulty verification - not enough blocks available');\n        }\n\n        // Block looks good, create ChainData.\n        const chainData = await prevData.nextChainData(block);\n\n        // Prepend new block to the main chain.\n        if (!(await this._prepend(hash, chainData))) {\n            return FullChain.ERR_INVALID;\n        }\n\n        this._mainChain = chainData;\n        this._proofHead = chainData; // So now it is a full block.\n        this._headHash = hash;\n\n        // Check whether we're complete.\n        if (!this.needsMoreBlocks()) {\n            await this._complete();\n        }\n\n        return FullChain.OK_EXTENDED;\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushBlockBackwards(block) {\n        // Check if we already know this block.\n        const hash = block.hash();\n\n        // Check that the given block is a full block (includes block body).\n        if (!block.isFull()) {\n            Log.w(PartialLightChain, 'Rejecting block - body missing');\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check all intrinsic block invariants.\n        if (!(await block.verify(this._time))) {\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check that all known interlink blocks are valid predecessors of the given block.\n        if (!(await this._verifyInterlink(block))) {\n            Log.w(PartialLightChain, 'Rejecting block - interlink verification failed');\n            return FullChain.ERR_INVALID;\n        }\n\n        // We know that the current proof head is the successor.\n        // Check that the block is a valid predecessor of its immediate successor.\n        if (!(await this._proofHead.head.isImmediateSuccessorOf(block))) {\n            Log.w(PartialLightChain, 'Rejecting block - not a valid immediate predecessor');\n            return FullChain.ERR_INVALID;\n        }\n\n        // Check that the difficulty is correct.\n        const nextTarget = await this.getNextTarget(block);\n        if (BlockUtils.isValidTarget(nextTarget)) {\n            if (this._proofHead.head.nBits !== BlockUtils.targetToCompact(nextTarget)) {\n                Log.w(PartialLightChain, 'Rejecting block - difficulty mismatch');\n                return FullChain.ERR_INVALID;\n            }\n        } else {\n            Log.w(NanoChain, 'Skipping difficulty verification - not enough blocks available');\n        }\n\n        // Block looks good, create ChainData.\n        const chainData = await this._proofHead.previousChainData(block);\n\n        // Prepend new block to the main chain.\n        if (!(await this._prepend(hash, chainData))) {\n            return FullChain.ERR_INVALID;\n        }\n\n        return FullChain.OK_EXTENDED;\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {ChainData} chainData\n     * @returns {Promise.<boolean>}\n     * @private\n     */\n    async _prepend(blockHash, chainData) {\n        try {\n            const transactionCache = new TransactionCache();\n            await this._accountsTx.revertBlock(chainData.head, transactionCache);\n        } catch (e) {\n            // AccountsHash mismatch. This can happen if someone gives us an invalid block.\n            // TODO error handling\n            Log.w(PartialLightChain, `Rejecting block - failed to commit to AccountsTree: ${e.message || e}`);\n            return false;\n        }\n\n        chainData.onMainChain = true;\n        chainData.mainChainSuccessor = this._proofHead.head.hash();\n        await this._store.putChainData(blockHash, chainData);\n\n        this._proofHead = chainData;\n\n        // Check whether we're complete.\n        if (!this.needsMoreBlocks()) {\n            await this._complete();\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {AccountsTreeChunk} chunk\n     * @returns {Promise.<PartialAccountsTree.Status>}\n     */\n    async pushAccountsTreeChunk(chunk) {\n        if (this._state !== PartialLightChain.State.PROVE_ACCOUNTS_TREE) {\n            return PartialAccountsTree.Status.ERR_INCORRECT_PROOF;\n        }\n\n        const result = await this._partialTree.pushChunk(chunk);\n\n        // If we're done, prepare next phase.\n        if (result === PartialAccountsTree.Status.OK_COMPLETE) {\n            this._state = PartialLightChain.State.PROVE_BLOCKS;\n            this._accountsTx = new Accounts(this._partialTree.transaction(false));\n        }\n\n        return result;\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _complete() {\n        this._state = PartialLightChain.State.COMPLETE;\n        if (this._accountsTx) {\n            await this._accountsTx.abort();\n            this._accountsTx = null;\n        }\n\n        const currentProof = this._proof || await this._getChainProof();\n        this.fire('complete', currentProof, this._headHash, this._mainChain);\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    async commit() {\n        if (this._accountsTx) {\n            await this._accountsTx.abort();\n        }\n\n        const result = await JDB.JungleDB.commitCombined(...this._store.txs, this._partialTree.tx);\n        this._partialTree = null;\n\n        const currentProof = this._proof || await this._getChainProof();\n        this.fire('committed', currentProof, this._headHash, this._mainChain);\n\n        return result;\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     */\n    async abort() {\n        this._state = PartialLightChain.State.ABORTED;\n        if (this._accountsTx) {\n            await this._accountsTx.abort();\n        }\n        if (this._partialTree) {\n            await this._partialTree.abort();\n        }\n        await this._store.abort();\n        this.fire('aborted');\n    }\n\n    /**\n     * @returns {string}\n     */\n    getMissingAccountsPrefix() {\n        if (this._partialTree) {\n            return this._partialTree.missingPrefix;\n        }\n        return '';\n    }\n\n    /**\n     * @returns {Array.<Hash>}\n     */\n    getBlockLocators() {\n        return this._proofHead ? [this._proofHead.head.hash()] : [this.headHash];\n    }\n\n    /**\n     * @returns {number}\n     */\n    numBlocksNeeded() {\n        if (!this._proofHead) {\n            return Policy.NUM_BLOCKS_VERIFICATION;\n        }\n        let numBlocks = Policy.NUM_BLOCKS_VERIFICATION - (this.height - this._proofHead.head.height + 1);\n        // If we begin syncing, we need one block additionally.\n        if (!this._proofHead.head.isFull()) {\n            numBlocks++;\n        }\n        return numBlocks;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    needsMoreBlocks() {\n        return this.numBlocksNeeded() > 0;\n    }\n\n    /** @type {PartialLightChain.State} */\n    get state() {\n        return this._state;\n    }\n\n    /** @type {number} */\n    get proofHeadHeight() {\n        return this._proofHead.head.height;\n    }\n}\n/**\n * @enum {number}\n */\nPartialLightChain.State = {\n    WEAK_PROOF: -2,\n    ABORTED: -1,\n    PROVE_CHAIN: 0,\n    PROVE_ACCOUNTS_TREE: 1,\n    PROVE_BLOCKS: 2,\n    COMPLETE: 3\n};\nClass.register(PartialLightChain);\n","class NanoChain extends BaseChain {\n    /**\n     * @param {Time} time\n     * @returns {Promise.<NanoChain>}\n     */\n    constructor(time) {\n        super(ChainDataStore.createVolatile());\n\n        /** @type {Time} */\n        this._time = time;\n\n        /** @type {ChainProof} */\n        this._proof = new ChainProof(new BlockChain([GenesisConfig.GENESIS_BLOCK.toLight()]), new HeaderChain([]));\n\n        /** @type {Hash} */\n        this._headHash = GenesisConfig.GENESIS_HASH;\n\n        /** @type {PrioritySynchronizer} */\n        this._synchronizer = new PrioritySynchronizer(2);\n\n        return this._init();\n    }\n\n    async _init() {\n        this._mainChain = await ChainData.initial(GenesisConfig.GENESIS_BLOCK);\n        await this._store.putChainData(GenesisConfig.GENESIS_HASH, this._mainChain);\n\n        return this;\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @returns {Promise.<boolean>}\n     */\n    pushProof(proof) {\n        return this._synchronizer.push(/*priority*/ 0,\n            this._pushProof.bind(this, proof));\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @returns {Promise.<boolean>}\n     * @private\n     */\n    async _pushProof(proof) {\n        const toDo = [];\n        for (let i = 0; i < proof.prefix.length; ++i) {\n            const block = proof.prefix.blocks[i];\n            const hash = block.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (!knownBlock && !block.header._pow) {\n                toDo.push(block.header);\n            }\n        }\n        for (let i = 0; i < proof.suffix.length; ++i) {\n            const header = proof.suffix.headers[i];\n            const hash = header.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (!knownBlock && !header._pow) {\n                toDo.push(header);\n            }\n        }\n        await BaseChain.manyPow(toDo);\n\n        // Verify all prefix blocks that we don't know yet.\n        for (let i = 0; i < proof.prefix.length; i++) {\n            const block = proof.prefix.blocks[i];\n            const hash = block.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (knownBlock) {\n                proof.prefix.blocks[i] = knownBlock.toLight();\n            } else if (!(await block.verify(this._time))) {\n                Log.w(NanoChain, 'Rejecting proof - prefix contains invalid block');\n                return false;\n            }\n        }\n\n        // Verify all suffix headers that we don't know yet.\n        for (let i = 0; i < proof.suffix.length; i++) {\n            const header = proof.suffix.headers[i];\n            const hash = header.hash();\n            const knownBlock = await this._store.getBlock(hash);\n            if (knownBlock) {\n                proof.suffix.headers[i] = knownBlock.header;\n            } else if (!(await header.verifyProofOfWork())) {\n                Log.w(NanoChain, 'Rejecting proof - suffix contains invalid header');\n                return false;\n            }\n        }\n\n        // Check that the proof is valid.\n        if (!(await proof.verify())) {\n            Log.w(NanoChain, 'Rejecting proof - verification failed');\n            return false;\n        }\n\n        // Check that the suffix is long enough.\n        if (proof.suffix.length !== Policy.K && proof.suffix.length !== proof.head.height - 1) {\n            Log.w(NanoChain, 'Rejecting proof - invalid suffix length');\n            return false;\n        }\n\n        // Check that the dense suffix of the prefix is long enough.\n        // The paper doesn't require this, we however need a sufficiently long dense suffix\n        // to be able to verify block difficulties.\n        const denseSuffix = proof.prefix.denseSuffix();\n        if (denseSuffix.length < Policy.M && proof.prefix.length > 0 && proof.prefix.head.height >= Policy.M) {\n            Log.w(NanoChain, 'Rejecting proof - dense suffix too short');\n            return false;\n        }\n\n        // Compute and verify interlinks for the suffix.\n        const suffixBlocks = [];\n        let head = proof.prefix.head;\n        for (const header of proof.suffix.headers) {\n            const interlink = await head.getNextInterlink(header.target, header.version);\n            const interlinkHash = interlink.hash();\n            if (!header.interlinkHash.equals(interlinkHash)) {\n                Log.w(NanoChain, 'Rejecting proof - invalid interlink hash in proof suffix');\n                return false;\n            }\n\n            head = new Block(header, interlink);\n            suffixBlocks.push(head);\n        }\n\n        // If the given proof is better than our current proof, adopt the given proof as the new best proof.\n        const currentProof = this._proof || await this._getChainProof();\n        if (await BaseChain.isBetterProof(proof, currentProof, Policy.M)) {\n            await this._acceptProof(proof, suffixBlocks);\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @param {Array.<Block>} suffix\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _acceptProof(proof, suffix) {\n        this._proof = proof;\n\n        // If the proof prefix head is not part of our current dense chain suffix, reset store and start over.\n        // TODO use a store transaction here?\n        const head = proof.prefix.head;\n        const headHash = head.hash();\n        const headData = await this._store.getChainData(headHash);\n        if (!headData || headData.totalDifficulty <= 0) {\n            // Delete our current chain.\n            await this._store.truncate();\n\n            /** @type {Array.<Block>} */\n            const denseSuffix = proof.prefix.denseSuffix();\n\n            // Store all prefix blocks so they can be retrieved via getBlock()/getBlockAt()),\n            // but don't allow blocks to be appended to them by setting totalDifficulty = -1;\n            let superBlockCounts = new SuperBlockCounts();\n            for (let i = 0; i < proof.prefix.length - denseSuffix.length; i++) {\n                const block = proof.prefix.blocks[i];\n                const hash = block.hash();\n                const depth = BlockUtils.getHashDepth(await block.pow());\n                superBlockCounts = superBlockCounts.copyAndAdd(depth);\n\n                const data = new ChainData(block, /*totalDifficulty*/ -1, /*totalWork*/ -1, superBlockCounts, true);\n                await this._store.putChainData(hash, data);\n            }\n\n            // Set the tail end of the dense suffix of the prefix as the new chain head.\n            const tailEnd = denseSuffix[0];\n            this._headHash = tailEnd.hash();\n            this._mainChain = await ChainData.initial(tailEnd, superBlockCounts);\n            await this._store.putChainData(this._headHash, this._mainChain);\n\n            // Only in the dense suffix of the prefix we can calculate the difficulties.\n            for (let i = 1; i < denseSuffix.length; i++) {\n                const block = denseSuffix[i];\n                const result = await this._pushBlock(block); // eslint-disable-line no-await-in-loop\n                Assert.that(result >= 0);\n            }\n        }\n\n        // Push all suffix blocks.\n        for (const block of suffix) {\n            const result = await this._pushBlock(block); // eslint-disable-line no-await-in-loop\n            Assert.that(result >= 0);\n        }\n    }\n\n    /**\n     * @param {Block} block\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushBlock(block) {\n        // Check if we already know this header/block.\n        const hash = await block.hash();\n        const knownBlock = await this._store.getBlock(hash);\n        if (knownBlock) {\n            return NanoChain.OK_KNOWN;\n        }\n\n        // Retrieve the immediate predecessor.\n        /** @type {ChainData} */\n        const prevData = await this._store.getChainData(block.prevHash);\n        if (!prevData || prevData.totalDifficulty <= 0) {\n            return NanoChain.ERR_ORPHAN;\n        }\n\n        return this._pushBlockInternal(block, hash, prevData);\n    }\n\n    /**\n     * @param {BlockHeader} header\n     * @returns {Promise.<number>}\n     */\n    pushHeader(header) {\n        // Synchronize with .pushProof()\n        return this._synchronizer.push(/*priority*/ 0,\n            this._pushHeader.bind(this, header));\n    }\n\n    /**\n     * @param {BlockHeader} header\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushHeader(header) {\n        // Check if we already know this header/block.\n        const hash = header.hash();\n        const knownBlock = await this._store.getBlock(hash);\n        if (knownBlock) {\n            return NanoChain.OK_KNOWN;\n        }\n\n        // Verify proof of work.\n        if (!(await header.verifyProofOfWork())) {\n            Log.w(NanoChain, 'Rejecting header - PoW verification failed');\n            return NanoChain.ERR_INVALID;\n        }\n\n        // Retrieve the immediate predecessor.\n        /** @type {ChainData} */\n        const prevData = await this._store.getChainData(header.prevHash);\n        if (!prevData || prevData.totalDifficulty <= 0) {\n            Log.w(NanoChain, 'Rejecting header - unknown predecessor');\n            return NanoChain.ERR_ORPHAN;\n        }\n\n        // Check that the block is valid successor to its predecessor.\n        /** @type {Block} */\n        const predecessor = prevData.head;\n        if (!header.isImmediateSuccessorOf(predecessor.header)) {\n            Log.w(NanoChain, 'Rejecting header - not a valid successor');\n            return NanoChain.ERR_INVALID;\n        }\n\n        // Check that the difficulty is correct (if we can compute the next target)\n        const nextTarget = await this.getNextTarget(predecessor);\n        if (BlockUtils.isValidTarget(nextTarget)) {\n            if (header.nBits !== BlockUtils.targetToCompact(nextTarget)) {\n                Log.w(NanoChain, 'Rejecting header - difficulty mismatch');\n                return NanoChain.ERR_INVALID;\n            }\n        } else {\n            Log.w(NanoChain, 'Skipping difficulty verification - not enough blocks available');\n        }\n\n        // Compute and verify interlink.\n        const interlink = await predecessor.getNextInterlink(header.target, header.version);\n        const interlinkHash = interlink.hash();\n        if (!interlinkHash.equals(header.interlinkHash)) {\n            Log.w(NanoChain, 'Rejecting header - interlink verification failed');\n            return NanoChain.ERR_INVALID;\n        }\n\n        const block = new Block(header, interlink);\n        return this._pushBlockInternal(block, hash, prevData);\n    }\n\n    /**\n     * @param {Block} block\n     * @param {Hash} blockHash\n     * @param {ChainData} prevData\n     * @returns {Promise.<number>}\n     * @private\n     */\n    async _pushBlockInternal(block, blockHash, prevData) {\n        // Block looks good, create ChainData.\n        const chainData = await prevData.nextChainData(block);\n\n        // Check if the block extends our current main chain.\n        if (block.prevHash.equals(this.headHash)) {\n            // Append new block to the main chain.\n            chainData.onMainChain = true;\n            prevData.mainChainSuccessor = blockHash;\n\n            const storeTx = this._store.synchronousTransaction();\n            storeTx.putChainDataSync(blockHash, chainData);\n            storeTx.putChainDataSync(block.prevHash, prevData);\n            await storeTx.commit();\n\n            // Update head.\n            this._mainChain = chainData;\n            this._headHash = blockHash;\n\n            // Append new block to chain proof.\n            if (this._proof) {\n                const proofHeadHash = this._proof.head.hash();\n                if (block.prevHash.equals(proofHeadHash)) {\n                    this._proof = await this._extendChainProof(this._proof, block.header);\n                }\n            }\n\n            // Tell listeners that the head of the chain has changed.\n            this.fire('head-changed', this.head, /*rebranching*/ false);\n\n            return NanoChain.OK_EXTENDED;\n        }\n\n        // Otherwise, check if the new chain is harder than our current main chain.\n        if (chainData.totalDifficulty > this._mainChain.totalDifficulty) {\n            // A fork has become the hardest chain, rebranch to it.\n            await this._rebranch(blockHash, chainData);\n\n            return NanoChain.OK_REBRANCHED;\n        }\n\n        // Otherwise, we are creating/extending a fork. Store chain data.\n        Log.v(NanoChain, `Creating/extending fork with block ${blockHash}, height=${block.height}, totalDifficulty=${chainData.totalDifficulty}, totalWork=${chainData.totalWork}`);\n        await this._store.putChainData(blockHash, chainData);\n\n        return NanoChain.OK_FORKED;\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {ChainData} chainData\n     * @returns {Promise}\n     * @private\n     */\n    async _rebranch(blockHash, chainData) {\n        Log.v(NanoChain, `Rebranching to fork ${blockHash}, height=${chainData.head.height}, totalDifficulty=${chainData.totalDifficulty}, totalWork=${chainData.totalWork}`);\n\n        // Find the common ancestor between our current main chain and the fork chain.\n        // Walk up the fork chain until we find a block that is part of the main chain.\n        // Store the chain along the way.\n        const forkChain = [];\n        const forkHashes = [];\n\n        let curData = chainData;\n        let curHash = blockHash;\n        while (!curData.onMainChain) {\n            forkChain.push(curData);\n            forkHashes.push(curHash);\n\n            curHash = curData.head.prevHash;\n            curData = await this._store.getChainData(curHash); // eslint-disable-line no-await-in-loop\n            Assert.that(!!curData, 'Failed to find fork predecessor while rebranching');\n        }\n\n        Log.v(NanoChain, () => `Found common ancestor ${curHash.toBase64()} ${forkChain.length} blocks up`);\n\n        /** @type {ChainData} */\n        const ancestorData = curData;\n        /** @type {Hash} */\n        const ancestorHash = curHash;\n\n        /** @type {ChainDataStore} */\n        const chainTx = this._store.synchronousTransaction(false);\n        /** @type {Array.<ChainData>} */\n        const revertChain = [];\n        /** @type {Hash} */\n        let headHash = this._headHash;\n        /** @type {ChainData} */\n        let headData = this._mainChain;\n\n        // Unset onMainChain flag / mainChainSuccessor on the current main chain up to (excluding) the common ancestor.\n        while (!headHash.equals(ancestorHash)) {\n            headData.onMainChain = false;\n            headData.mainChainSuccessor = null;\n            chainTx.putChainDataSync(headHash, headData);\n            revertChain.push(headData);\n\n            headHash = headData.head.prevHash;\n            headData = await this._store.getChainData(headHash);\n            Assert.that(!!headData, 'Failed to find main chain predecessor while rebranching');\n        }\n\n        // Update the mainChainSuccessor of the common ancestor block.\n        ancestorData.mainChainSuccessor = forkHashes[forkHashes.length - 1];\n        chainTx.putChainDataSync(ancestorHash, ancestorData);\n\n        // Set onMainChain flag / mainChainSuccessor on the fork.\n        for (let i = forkChain.length - 1; i >= 0; i--) {\n            const forkData = forkChain[i];\n            forkData.onMainChain = true;\n            forkData.mainChainSuccessor = i > 0 ? forkHashes[i - 1] : null;\n            chainTx.putChainDataSync(forkHashes[i], forkData);\n        }\n\n        await chainTx.commit();\n\n        // Reset chain proof. We don't recompute the chain proof here, but do it lazily the next time it is needed.\n        // TODO modify chain proof directly, don't recompute.\n        this._proof = null;\n\n        // Fire block-reverted event for each block reverted during rebranch\n        for (const revertedData of revertChain) {\n            this.fire('block-reverted', revertedData.head);\n        }\n\n        // Fire head-changed event for each fork block.\n        for (let i = forkChain.length - 1; i >= 0; i--) {\n            this._mainChain = forkChain[i];\n            this._headHash = forkHashes[i];\n            this.fire('head-changed', this.head, /*rebranching*/ i > 0);\n        }\n    }\n\n    /**\n     * @returns {Promise.<ChainProof>}\n     * @override\n     */\n    getChainProof() {\n        return this._synchronizer.push(/*priority*/ 1, async () => {\n            if (!this._proof) {\n                this._proof = await this._getChainProof();\n            }\n            return this._proof;\n        });\n    }\n\n    /** @type {Block} */\n    get head() {\n        return this._mainChain.head;\n    }\n\n    /** @type {Hash} */\n    get headHash() {\n        return this._headHash;\n    }\n\n    /** @type {number} */\n    get height() {\n        return this._mainChain.head.height;\n    }\n}\nNanoChain.ERR_ORPHAN = -2;\nNanoChain.ERR_INVALID = -1;\nNanoChain.OK_KNOWN = 0;\nNanoChain.OK_EXTENDED = 1;\nNanoChain.OK_REBRANCHED = 2;\nNanoChain.OK_FORKED = 3;\nClass.register(NanoChain);\n","class NanoConsensusAgent extends BaseConsensusAgent {\n    /**\n     * @param {NanoChain} blockchain\n     * @param {NanoMempool} mempool\n     * @param {Time} time\n     * @param {Peer} peer\n     * @param {InvRequestManager} invRequestManager\n     * @param {Subscription} targetSubscription\n     */\n    constructor(blockchain, mempool, time, peer, invRequestManager, targetSubscription) {\n        super(time, peer, invRequestManager, targetSubscription);\n        /** @type {NanoChain} */\n        this._blockchain = blockchain;\n        /** @type {NanoMempool} */\n        this._mempool = mempool;\n\n        // Flag indicating that we are currently syncing our blockchain with the peer's.\n        /** @type {boolean} */\n        this._syncing = false;\n\n        /** @type {Array.<BlockHeader>} */\n        this._orphanedBlocks = [];\n\n        // Helper object to keep track of the accounts we're requesting from the peer.\n        this._accountsRequest = null;\n\n        // Flag to track chain proof requests.\n        this._requestedChainProof = false;\n\n        // Listen to consensus messages from the peer.\n        peer.channel.on('chain-proof', msg => this._onChainProof(msg));\n        peer.channel.on('accounts-proof', msg => this._onAccountsProof(msg));\n\n        peer.channel.on('get-chain-proof', msg => this._onGetChainProof(msg));\n\n        // Subscribe to all announcements from the peer.\n        this._subscribeTarget();\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     */\n    async syncBlockchain() {\n        this._syncing = true;\n\n        const headBlock = await this._blockchain.getBlock(this._peer.headHash);\n        if (!headBlock) {\n            this._requestChainProof();\n            this.fire('sync-chain-proof', this._peer.peerAddress);\n        } else {\n            this._syncFinished();\n        }\n    }\n\n    requestMempool() {\n        // Request the peer's mempool.\n        // XXX Use a random delay here to prevent requests to multiple peers at once.\n        const delay = NanoConsensusAgent.MEMPOOL_DELAY_MIN\n            + Math.random() * (NanoConsensusAgent.MEMPOOL_DELAY_MAX - NanoConsensusAgent.MEMPOOL_DELAY_MIN);\n        setTimeout(() => this._peer.channel.mempool(), delay);\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _syncFinished() {\n        this._syncing = false;\n        this._synced = true;\n\n        this.requestMempool();\n\n        this.fire('sync');\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _requestChainProof() {\n        // Only one chain proof request at a time.\n        if (this._requestedChainProof) {\n            return;\n        }\n\n        // Request ChainProof from peer.\n        this._peer.channel.getChainProof();\n        this._requestedChainProof = true;\n\n        // Drop the peer if it doesn't send the chain proof within the timeout.\n        this._peer.channel.expectMessage(Message.Type.CHAIN_PROOF, () => {\n            this._peer.channel.close(CloseType.GET_CHAIN_PROOF_TIMEOUT, 'getChainProof timeout');\n        }, NanoConsensusAgent.CHAINPROOF_REQUEST_TIMEOUT, NanoConsensusAgent.CHAINPROOF_CHUNK_TIMEOUT);\n    }\n\n    /**\n     * @param {ChainProofMessage} msg\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _onChainProof(msg) {\n        Log.d(NanoConsensusAgent, `[CHAIN-PROOF] Received from ${this._peer.peerAddress}: ${msg.proof}`);\n\n        // Check if we have requested a chain proof, reject unsolicited ones.\n        // FIXME\n        if (!this._requestedChainProof) {\n            Log.w(NanoConsensusAgent, `Unsolicited chain proof received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n        this._requestedChainProof = false;\n\n        if (this._syncing) {\n            this.fire('verify-chain-proof', this._peer.peerAddress);\n        }\n\n        // Push the proof into the NanoChain.\n        if (!(await this._blockchain.pushProof(msg.proof))) {\n            Log.w(NanoConsensusAgent, `Invalid chain proof received from ${this._peer.peerAddress} - verification failed`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.INVALID_CHAIN_PROOF, 'invalid chain proof');\n            return;\n        }\n\n        // TODO add all blocks from the chain proof to knownObjects.\n\n        // Apply any orphaned blocks we received while waiting for the chain proof.\n        await this._applyOrphanedBlocks();\n\n        if (this._syncing) {\n            this._syncFinished();\n        }\n    }\n\n    /**\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _applyOrphanedBlocks() {\n        for (const header of this._orphanedBlocks) {\n            const status = await this._blockchain.pushHeader(header);\n            if (status === NanoChain.ERR_INVALID) {\n                this._peer.channel.close(CloseType.RECEIVED_INVALID_BLOCK, 'received invalid block');\n                break;\n            }\n        }\n        this._orphanedBlocks = [];\n    }\n\n    /**\n     * @param {Array.<InvVector>} vectors\n     * @returns {void}\n     * @protected\n     * @override\n     */\n    _doRequestData(vectors) {\n        /** @type {Array.<InvVector>} */\n        const blocks = [];\n        /** @type {Array.<InvVector>} */\n        const transactions = [];\n        for (const vector of vectors) {\n            if (vector.type === InvVector.Type.BLOCK) {\n                blocks.push(vector);\n            } else {\n                transactions.push(vector);\n            }\n        }\n\n        // Request headers and transactions from peer.\n        this._peer.channel.getHeader(blocks);\n        this._peer.channel.getData(transactions);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {boolean} [includeForks]\n     * @returns {Promise.<?Block>}\n     * @protected\n     * @override\n     */\n    _getBlock(hash, includeForks = false) {\n        return this._blockchain.getBlock(hash, includeForks);\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Promise.<?Transaction>}\n     * @protected\n     * @override\n     */\n    _getTransaction(hash) {\n        return Promise.resolve(this._mempool.getTransaction(hash));\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {BlockHeader} header\n     * @returns {Promise.<void>}\n     * @protected\n     * @override\n     */\n    async _processHeader(hash, header) {\n        // TODO send reject message if we don't like the block\n        const status = await this._blockchain.pushHeader(header);\n        if (status === NanoChain.ERR_INVALID) {\n            this._peer.channel.close(CloseType.RECEIVED_INVALID_HEADER, 'received invalid header');\n        }\n        // Re-sync with this peer if it starts sending orphan blocks after the initial sync.\n        else if (status === NanoChain.ERR_ORPHAN) {\n            this._orphanedBlocks.push(header);\n            if (this._synced) {\n                this._requestChainProof();\n            }\n        }\n    }\n\n    /**\n     * @param {Hash} hash\n     * @param {Transaction} transaction\n     * @returns {Promise.<void>}\n     * @protected\n     * @override\n     */\n    _processTransaction(hash, transaction) {\n        return this._mempool.pushTransaction(transaction);\n    }\n\n    /**\n     * @param {GetChainProofMessage} msg\n     * @private\n     */\n    async _onGetChainProof(msg) {\n        const proof = await this._blockchain.getChainProof();\n        if (proof) {\n            this._peer.channel.chainProof(proof);\n        }\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<Array.<Account>>}\n     */\n    getAccounts(blockHash, addresses) {\n        return this._synchronizer.push('getAccounts',\n            this._getAccounts.bind(this, blockHash, addresses));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @returns {Promise.<Array<Account>>}\n     * @private\n     */\n    _getAccounts(blockHash, addresses) {\n        Assert.that(this._accountsRequest === null);\n\n        Log.d(NanoConsensusAgent, `Requesting AccountsProof for ${addresses} from ${this._peer.peerAddress}`);\n\n        return new Promise((resolve, reject) => {\n            this._accountsRequest = {\n                addresses: addresses,\n                blockHash: blockHash,\n                resolve: resolve,\n                reject: reject\n            };\n\n            // Request AccountsProof from peer.\n            this._peer.channel.getAccountsProof(blockHash, addresses);\n\n            // Drop the peer if it doesn't send the accounts proof within the timeout.\n            this._peer.channel.expectMessage(Message.Type.ACCOUNTS_PROOF, () => {\n                this._peer.channel.close(CloseType.GET_ACCOUNTS_PROOF_TIMEOUT, 'getAccountsProof timeout');\n                reject(new Error('timeout')); // TODO error handling\n            }, NanoConsensusAgent.ACCOUNTSPROOF_REQUEST_TIMEOUT);\n        });\n    }\n\n    /**\n     * @param {AccountsProofMessage} msg\n     * @returns {Promise.<void>}\n     * @private\n     */\n    async _onAccountsProof(msg) {\n        Log.d(NanoConsensusAgent, `[ACCOUNTS-PROOF] Received from ${this._peer.peerAddress}: blockHash=${msg.blockHash}, proof=${msg.proof} (${msg.serializedSize} bytes)`);\n\n        // Check if we have requested an accounts proof, reject unsolicited ones.\n        if (!this._accountsRequest) {\n            Log.w(NanoConsensusAgent, `Unsolicited accounts proof received from ${this._peer.peerAddress}`);\n            // TODO close/ban?\n            return;\n        }\n\n        const addresses = this._accountsRequest.addresses;\n        const blockHash = this._accountsRequest.blockHash;\n        const resolve = this._accountsRequest.resolve;\n        const reject = this._accountsRequest.reject;\n\n        // Reset accountsRequest.\n        this._accountsRequest = null;\n\n        if (!msg.hasProof()) {\n            reject(new Error('Accounts request was rejected'));\n            return;\n        }\n\n        // Check that the reference block corresponds to the one we requested.\n        if (!blockHash.equals(msg.blockHash)) {\n            Log.w(NanoConsensusAgent, `Received AccountsProof for invalid reference block from ${this._peer.peerAddress}`);\n            reject(new Error('Invalid reference block'));\n            return;\n        }\n\n        // Verify the proof.\n        const proof = msg.proof;\n        if (!proof.verify()) {\n            Log.w(NanoConsensusAgent, `Invalid AccountsProof received from ${this._peer.peerAddress}`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.INVALID_ACCOUNTS_PROOF, 'Invalid AccountsProof');\n            reject(new Error('Invalid AccountsProof'));\n            return;\n        }\n\n        // Check that the proof root hash matches the accountsHash in the reference block.\n        const rootHash = proof.root();\n        const block = await this._blockchain.getBlock(blockHash);\n        if (!block.accountsHash.equals(rootHash)) {\n            Log.w(NanoConsensusAgent, `Invalid AccountsProof (root hash) received from ${this._peer.peerAddress}`);\n            // TODO ban instead?\n            this._peer.channel.close(CloseType.ACCOUNTS_PROOF_ROOT_HASH_MISMATCH, 'AccountsProof root hash mismatch');\n            reject(new Error('AccountsProof root hash mismatch'));\n            return;\n        }\n\n        // Check that all requested accounts are part of this proof.\n        // XXX return a map address -> account instead?\n        const accounts = [];\n        for (const address of addresses) {\n            try {\n                const account = proof.getAccount(address);\n                accounts.push(account);\n            } catch (e) {\n                Log.w(NanoConsensusAgent, `Incomplete AccountsProof received from ${this._peer.peerAddress}`);\n                // TODO ban instead?\n                this._peer.channel.close(CloseType.INCOMPLETE_ACCOUNTS_PROOF, 'Incomplete AccountsProof');\n                reject(new Error('Incomplete AccountsProof'));\n                return;\n            }\n        }\n\n        // Return the retrieved accounts.\n        resolve(accounts);\n    }\n\n    /**\n     * @returns {void}\n     * @protected\n     * @override\n     */\n    _onClose() {\n        // Clear the synchronizer queue.\n        this._synchronizer.clear();\n        super._onClose();\n    }\n\n    /** @type {boolean} */\n    get syncing() {\n        return this._syncing;\n    }\n}\n/**\n * Maximum time (ms) to wait for chain-proof after sending out get-chain-proof before dropping the peer.\n * @type {number}\n */\nNanoConsensusAgent.CHAINPROOF_REQUEST_TIMEOUT = 1000 * 45;\n/**\n * Maximum time (ms) to wait for between chain-proof chunks before dropping the peer.\n * @type {number}\n */\nNanoConsensusAgent.CHAINPROOF_CHUNK_TIMEOUT = 1000 * 10;\n/**\n * Maximum time (ms) to wait for accounts-proof after sending out get-accounts-proof before dropping the peer.\n * @type {number}\n */\nNanoConsensusAgent.ACCOUNTSPROOF_REQUEST_TIMEOUT = 1000 * 5;\n/**\n * Minimum time {ms} to wait before triggering the initial mempool request.\n * @type {number}\n */\nNanoConsensusAgent.MEMPOOL_DELAY_MIN = 1000 * 2; // 2 seconds\n/**\n * Maximum time {ms} to wait before triggering the initial mempool request.\n * @type {number}\n */\nNanoConsensusAgent.MEMPOOL_DELAY_MAX = 1000 * 20; // 20 seconds\nClass.register(NanoConsensusAgent);\n","class NanoConsensus extends BaseConsensus {\n    /**\n     * @param {NanoChain} blockchain\n     * @param {NanoMempool} mempool\n     * @param {Network} network\n     */\n    constructor(blockchain, mempool, network) {\n        super(blockchain, mempool, network);\n        /** @type {NanoChain} */\n        this._blockchain = blockchain;\n        /** @type {NanoMempool} */\n        this._mempool = mempool;\n\n        /** @type {Subscription} */\n        this._subscription = Subscription.BLOCKS_ONLY;\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     */\n    subscribeAccounts(addresses) {\n        this.subscribe(Subscription.fromAddresses(addresses));\n        this._mempool.evictExceptAddresses(addresses);\n        for (const /** @type {NanoConsensusAgent} */ agent of this._agents.valueIterator()) {\n            agent.requestMempool();\n        }\n    }\n\n    /**\n     * @param {Peer} peer\n     * @returns {BaseConsensusAgent}\n     * @override\n     */\n    _newConsensusAgent(peer) {\n        return new NanoConsensusAgent(this._blockchain, this._mempool, this._network.time, peer, this._invRequestManager, this._subscription);\n    }\n\n    /**\n     * @param {Peer} peer\n     * @override\n     */\n    _onPeerJoined(peer) {\n        const agent = super._onPeerJoined(peer);\n\n        // Forward sync events.\n        this.bubble(agent, 'sync-chain-proof', 'verify-chain-proof');\n\n        return agent;\n    }\n\n    /**\n     * @param {Block} head\n     * @override\n     */\n    async _onHeadChanged(head) {\n        if (!this._established) return;\n\n        // Update mempool.\n        try {\n            const includedTransactions = await this._requestTransactionsProof(this._subscription.addresses, head);\n            this._mempool.changeHead(head, includedTransactions);\n        } catch (e) {\n            Log.e(NanoConsensus, `Failed to retrieve transaction proof to update mempool: ${e.message || e}`);\n        }\n\n        // Relay block *after* requesting the TransactionsProof. Otherwise, we might\n        // send the request to a peer (first) that has not adopted the new block yet.\n        super._onHeadChanged(head);\n    }\n\n    /**\n     * @param {Transaction} tx\n     * @protected\n     */\n    _onTransactionAdded(tx) {\n        // Don't relay transactions added to the mempool.\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Hash} [blockHash]\n     * @returns {Promise.<Account>}\n     */\n    async getAccount(address, blockHash = null) {\n        return (await this.getAccounts([address], blockHash))[0];\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     * @param {Hash} [blockHash]\n     * @returns {Promise.<Array<Account>>}\n     */\n    async getAccounts(addresses, blockHash) {\n        blockHash = blockHash ? blockHash : this._blockchain.headHash;\n        const agents = this._agents.values().filter(agent =>\n            agent.synced\n            && agent.knowsBlock(blockHash)\n            && !Services.isNanoNode(agent.peer.peerAddress.services)\n        );\n\n        for (const /** @type {NanoConsensusAgent} */ agent of agents) {\n            try {\n                return await agent.getAccounts(blockHash, addresses); // eslint-disable-line no-await-in-loop\n            } catch (e) {\n                Log.w(NanoConsensus, `Failed to retrieve accounts ${addresses} from ${agent.peer.peerAddress}: ${e}`);\n                // Try the next peer.\n            }\n        }\n\n        // No peer supplied the requested account, fail.\n        throw new Error(`Failed to retrieve accounts ${addresses}`);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @returns {Promise.<void>}\n     */\n    async relayTransaction(transaction) {\n        // Fail if we are not connected to at least one full/light node.\n        if (!this._agents.values().some(agent => !Services.isNanoNode(agent.peer.peerAddress.services))) {\n            throw new Error('Failed to relay transaction - only nano nodes connected');\n        }\n\n        // Store transaction in mempool.\n        if (!(await this._mempool.pushTransaction(transaction))) {\n            throw new Error('Failed to relay transaction - mempool rejected transaction');\n        }\n\n        // Relay transaction to all connected peers.\n        let relayed = false;\n        for (const agent of this._agents.values()) {\n            relayed = agent.relayTransaction(transaction) || relayed;\n        }\n\n        // Fail if the transaction was not relayed.\n        if (!relayed) {\n            throw new Error('Failed to relay transaction - no agent relayed transaction');\n        }\n    }\n\n    /** @type {NanoChain} */\n    get blockchain() {\n        return this._blockchain;\n    }\n\n    /** @type {NanoMempool} */\n    get mempool() {\n        return this._mempool;\n    }\n}\nClass.register(NanoConsensus);\n","class NanoMempool extends Observable {\n    /**\n     * @param {IBlockchain} blockchain\n     */\n    constructor(blockchain) {\n        super();\n\n        /** @type {IBlockchain} */\n        this._blockchain = blockchain;\n\n        // Our pool of transactions.\n        /** @type {HashMap.<Hash, Transaction>} */\n        this._transactionsByHash = new HashMap();\n        /** @type {HashMap.<Address, MempoolTransactionSet>} */\n        this._transactionSetByAddress = new HashMap();\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @fires Mempool#transaction-added\n     * @returns {Promise.<boolean>}\n     */\n    async pushTransaction(transaction) {\n        // Check if we already know this transaction.\n        const hash = transaction.hash();\n        if (this._transactionsByHash.contains(hash)) {\n            Log.v(Mempool, () => `Ignoring known transaction ${hash.toBase64()}`);\n            return false;\n        }\n\n        // Check validity based on startHeight.\n        if (this._blockchain.height >= transaction.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n            Log.v(Mempool, () => `Ignoring expired transaction ${hash.toBase64()}`);\n            return false;\n        }\n\n        // Verify transaction.\n        if (!transaction.verify()) {\n            return false;\n        }\n\n        // Transaction is valid, add it to the mempool.\n        this._transactionsByHash.put(hash, transaction);\n        const set = this._transactionSetByAddress.get(transaction.sender) || new MempoolTransactionSet();\n        set.add(transaction);\n        this._transactionSetByAddress.put(transaction.sender, set);\n\n        // Tell listeners about the new transaction we received.\n        this.fire('transaction-added', transaction);\n\n        return true;\n    }\n\n    /**\n     * @param {Hash} hash\n     * @returns {Transaction}\n     */\n    getTransaction(hash) {\n        return this._transactionsByHash.get(hash);\n    }\n\n    /**\n     * @param {number} maxCount\n     * @returns {Array.<Transaction>}\n     */\n    getTransactions(maxCount = 5000) {\n        return this._transactionsByHash.values().sort((a, b) => a.compare(b)).slice(0, maxCount);\n    }\n\n    /**\n     * @param {Address} address\n     * @return {Array.<Transaction>}\n     */\n    getPendingTransactions(address) {\n        const set = this._transactionSetByAddress.get(address);\n        return set ? set.transactions : [];\n    }\n\n    /**\n     * @param {Block} block\n     * @param {Array.<Transaction>} transactions\n     */\n    changeHead(block, transactions) {\n        this._evictTransactions(block.header, transactions);\n    }\n\n    /**\n     * @param {Array.<Address>} addresses\n     */\n    evictExceptAddresses(addresses) {\n        const addressSet = new HashSet();\n        addressSet.addAll(addresses);\n        for (const /** @type {Transaction} */ tx of this._transactionsByHash.values()) {\n            if (!addressSet.contains(tx.sender) && !addressSet.contains(tx.recipient)) {\n                this._transactionsByHash.remove(tx.hash());\n\n                /** @type {MempoolTransactionSet} */\n                const set = this._transactionSetByAddress.get(tx.sender);\n                set.remove(tx);\n\n                if (set.length === 0) {\n                    this._transactionSetByAddress.remove(tx.sender);\n                }\n            }\n        }\n    }\n\n    /**\n     * @param {BlockHeader} blockHeader\n     * @param {Array.<Transaction>} transactions\n     * @private\n     */\n    _evictTransactions(blockHeader, transactions) {\n        // Remove expired transactions.\n        for (const /** @type {Transaction} */ tx of this._transactionsByHash.values()) {\n            const txHash = tx.hash();\n            if (blockHeader.height >= tx.validityStartHeight + Policy.TRANSACTION_VALIDITY_WINDOW) {\n                this._transactionsByHash.remove(txHash);\n\n                /** @type {MempoolTransactionSet} */\n                const set = this._transactionSetByAddress.get(tx.sender);\n                set.remove(tx);\n\n                if (set.length === 0) {\n                    this._transactionSetByAddress.remove(tx.sender);\n                }\n\n                this.fire('transaction-expired', tx);\n            }\n        }\n\n        // Remove mined transactions.\n        for (const /** @type {Transaction} */ tx of transactions) {\n            const txHash = tx.hash();\n            if (this._transactionsByHash.contains(txHash)) {\n                this._transactionsByHash.remove(txHash);\n\n                /** @type {MempoolTransactionSet} */\n                const set = this._transactionSetByAddress.get(tx.sender);\n                set.remove(tx);\n\n                if (set.length === 0) {\n                    this._transactionSetByAddress.remove(tx.sender);\n                }\n\n                this.fire('transaction-mined', tx, blockHeader);\n            }\n        }\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._transactionsByHash.length;\n    }\n}\nClass.register(NanoMempool);\n","class ConsensusDB extends JDB.JungleDB {\n    /**\n     * @param {string} [dbPrefix]\n     * @returns {Promise.<ConsensusDB>}\n     */\n    static async getFull(dbPrefix = '') {\n        if (!ConsensusDB._instance) {\n            ConsensusDB._instance = await new ConsensusDB(`${dbPrefix}full-consensus`);\n        }\n        return ConsensusDB._instance;\n    }\n\n    /**\n     * @param {string} dbPrefix\n     * @returns {Promise.<ConsensusDB>}\n     */\n    static async getLight(dbPrefix = '') {\n        if (!ConsensusDB._instance) {\n            ConsensusDB._instance = await new ConsensusDB(`${dbPrefix}light-consensus`);\n        }\n        return ConsensusDB._instance;\n    }\n\n    /**\n     * @param {string} dbName\n     * @returns {Promise.<ConsensusDB>}\n     */\n    constructor(dbName) {\n        // Start with 500MB and resize at least 1GB at a time.\n        super(dbName, ConsensusDB.VERSION, {\n            maxDbSize: ConsensusDB.INITIAL_DB_SIZE,\n            autoResize: true,\n            minResize: ConsensusDB.MIN_RESIZE\n        });\n        return this._init();\n    }\n\n    /**\n     * @returns {Promise.<ConsensusDB>}\n     * @private\n     */\n    async _init() {\n        // Initialize object stores.\n        AccountsTreeStore.initPersistent(this);\n        ChainDataStore.initPersistent(this);\n        TransactionStore.initPersistent(this);\n\n        // Establish connection to database.\n        await this.connect();\n\n        return this;\n    }\n}\nConsensusDB._instance = null;\nConsensusDB.VERSION = 4;\nConsensusDB.INITIAL_DB_SIZE = 1024*1024*500; // 500 MB initially\nConsensusDB.MIN_RESIZE = 1 << 30; // 1 GB\nClass.register(ConsensusDB);\n","class Consensus {\n    /**\n     * @param {NetworkConfig} [netconfig]\n     * @return {Promise.<FullConsensus>}\n     */\n    static async full(netconfig = NetworkConfig.getDefault()) {\n        netconfig.services = new Services(Services.FULL, Services.FULL);\n        await netconfig.initPersistent();\n\n        /** @type {Time} */\n        const time = new Time();\n        /** @type {ConsensusDB} */\n        const db = await ConsensusDB.getFull(`${GenesisConfig.NETWORK_NAME}-`);\n        /** @type {Accounts} */\n        const accounts = await Accounts.getPersistent(db);\n        /** @type {TransactionStore} */\n        const transactionStore = await TransactionStore.getPersistent(db);\n        /** @type {FullChain} */\n        const blockchain = await FullChain.getPersistent(db, accounts, time, transactionStore);\n        /** @type {Mempool} */\n        const mempool = new Mempool(blockchain, accounts);\n        /** @type {Network} */\n        const network = new Network(blockchain, netconfig, time);\n\n        return new FullConsensus(blockchain, mempool, network);\n    }\n\n    /**\n     * @param {NetworkConfig} [netconfig]\n     * @return {Promise.<LightConsensus>}\n     */\n    static async light(netconfig = NetworkConfig.getDefault()) {\n        netconfig.services = new Services(Services.LIGHT, Services.LIGHT | Services.FULL);\n        await netconfig.initPersistent();\n\n        /** @type {Time} */\n        const time = new Time();\n        /** @type {ConsensusDB} */\n        const db = await ConsensusDB.getLight(`${GenesisConfig.NETWORK_NAME}-`);\n        /** @type {Accounts} */\n        const accounts = await Accounts.getPersistent(db);\n        /** @type {LightChain} */\n        const blockchain = await LightChain.getPersistent(db, accounts, time);\n        /** @type {Mempool} */\n        const mempool = new Mempool(blockchain, accounts);\n        /** @type {Network} */\n        const network = new Network(blockchain, netconfig, time);\n\n        return new LightConsensus(blockchain, mempool, network);\n    }\n\n    /**\n     * @param {NetworkConfig} [netconfig]\n     * @return {Promise.<NanoConsensus>}\n     */\n    static async nano(netconfig = NetworkConfig.getDefault()) {\n        netconfig.services = new Services(Services.NANO, Services.NANO | Services.LIGHT | Services.FULL);\n        await netconfig.initPersistent();\n\n        /** @type {Time} */\n        const time = new Time();\n        /** @type {NanoChain} */\n        const blockchain = await new NanoChain(time);\n        /** @type {NanoMempool} */\n        const mempool = new NanoMempool(blockchain);\n        /** @type {Network} */\n        const network = new Network(blockchain, netconfig, time);\n\n        return new NanoConsensus(blockchain, mempool, network);\n    }\n\n    /**\n     * @param {NetworkConfig} [netconfig]\n     * @return {Promise.<FullConsensus>}\n     */\n    static async volatileFull(netconfig = NetworkConfig.getDefault()) {\n        netconfig.services = new Services(Services.FULL, Services.FULL);\n        await netconfig.initVolatile();\n\n        /** @type {Time} */\n        const time = new Time();\n        /** @type {Accounts} */\n        const accounts = await Accounts.createVolatile();\n        /** @type {TransactionStore} */\n        const transactionStore = await TransactionStore.createVolatile();\n        /** @type {FullChain} */\n        const blockchain = await FullChain.createVolatile(accounts, time, transactionStore);\n        /** @type {Mempool} */\n        const mempool = new Mempool(blockchain, accounts);\n        /** @type {Network} */\n        const network = new Network(blockchain, netconfig, time);\n\n        return new FullConsensus(blockchain, mempool, network);\n    }\n\n    /**\n     * @param {NetworkConfig} [netconfig]\n     * @return {Promise.<LightConsensus>}\n     */\n    static async volatileLight(netconfig = NetworkConfig.getDefault()) {\n        netconfig.services = new Services(Services.LIGHT, Services.LIGHT | Services.FULL);\n        await netconfig.initVolatile();\n\n        /** @type {Time} */\n        const time = new Time();\n        /** @type {Accounts} */\n        const accounts = await Accounts.createVolatile();\n        /** @type {LightChain} */\n        const blockchain = await LightChain.createVolatile(accounts, time);\n        /** @type {Mempool} */\n        const mempool = new Mempool(blockchain, accounts);\n        /** @type {Network} */\n        const network = new Network(blockchain, netconfig, time);\n\n        return new LightConsensus(blockchain, mempool, network);\n    }\n\n    /**\n     * @param {NetworkConfig} [netconfig]\n     * @return {Promise.<NanoConsensus>}\n     */\n    static async volatileNano(netconfig = NetworkConfig.getDefault()) {\n        netconfig.services = new Services(Services.NANO, Services.NANO | Services.LIGHT | Services.FULL);\n        await netconfig.initVolatile();\n\n        /** @type {Time} */\n        const time = new Time();\n        /** @type {NanoChain} */\n        const blockchain = await new NanoChain(time);\n        /** @type {NanoMempool} */\n        const mempool = new NanoMempool(blockchain);\n        /** @type {Network} */\n        const network = new Network(blockchain, netconfig, time);\n\n        return new NanoConsensus(blockchain, mempool, network);\n    }\n}\n\nClass.register(Consensus);\n","class Protocol {\n}\nProtocol.DUMB = 0;\nProtocol.WS = 1;\nProtocol.RTC = 2;\nClass.register(Protocol);\n","class Message {\n    /**\n     * Create a new Message instance. This is usually not called directly but by subclasses.\n     * @param {Message.Type} type Message type\n     */\n    constructor(type) {\n        if (!NumberUtils.isUint64(type)) throw new Error('Malformed type');\n        /** @type {Message.Type} */\n        this._type = type;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {Message.Type}\n     */\n    static peekType(buf) {\n        // Store current read position.\n        const pos = buf.readPos;\n\n        // Set read position past the magic to the beginning of the type string.\n        buf.readPos = 4;\n\n        // Read the type.\n        const type = buf.readVarUint();\n\n        // Reset the read position to original.\n        buf.readPos = pos;\n\n        return /** @type {Message.Type} */ type;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {number}\n     */\n    static peekLength(buf) {\n        // Store current read position.\n        const pos = buf.readPos;\n\n        // Set read position past the magic to the beginning of the type string.\n        buf.readPos = 4;\n\n        // Read the type and ignore it.\n        buf.readVarUint();\n        // Read the length.\n        const length = buf.readUint32();\n\n        // Reset the read position to original.\n        buf.readPos = pos;\n\n        return length;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {Message}\n     */\n    static unserialize(buf) {\n        // XXX Direct buffer manipulation currently requires this.\n        Assert.that(buf.readPos === 0, 'Message.unserialize() requires buf.readPos == 0');\n\n        const magic = buf.readUint32();\n        const type = buf.readVarUint();\n        buf.readUint32(); // length is ignored\n        const checksum = buf.readUint32();\n\n        // Validate magic.\n        if (magic !== Message.MAGIC) throw 'Malformed magic';\n\n        // Validate checksum.\n        Message._writeChecksum(type, buf, 0);\n        const calculatedChecksum = CRC32.compute(buf);\n        if (checksum !== calculatedChecksum) throw new Error('Invalid checksum');\n\n        return new Message(type);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        // XXX Direct buffer manipulation currently requires this.\n        Assert.that(buf.writePos === 0, 'Message.serialize() requires buf.writePos == 0');\n\n        buf.writeUint32(Message.MAGIC);\n        buf.writeVarUint(this._type);\n        buf.writeUint32(this.serializedSize);\n        buf.writeUint32(0); // written later by _setChecksum()\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*magic*/ 4\n            + /*type*/ SerialBuffer.varUintSize(this._type)\n            + /*length*/ 4\n            + /*checksum*/ 4;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {void}\n     * @protected\n     */\n    _setChecksum(buf) {\n        const checksum = CRC32.compute(buf);\n        Message._writeChecksum(this._type, buf, checksum);\n    }\n\n    /**\n     * @param {Message.Type} type\n     * @param {SerialBuffer} buf\n     * @param {number} value\n     * @returns {void}\n     * @private\n     */\n    static _writeChecksum(type, buf, value) {\n        // Store current write position.\n        const pos = buf.writePos;\n\n        // Set write position past the magic, type, and length fields to the\n        // beginning of the checksum value.\n        buf.writePos = /*magic*/ 4\n            + /*type*/ SerialBuffer.varUintSize(type)\n            + /*length*/ 4;\n\n        // Write the checksum value.\n        buf.writeUint32(value);\n\n        // Reset the write position to original.\n        buf.writePos = pos;\n    }\n\n    /** @type {Message.Type} */\n    get type() {\n        return this._type;\n    }\n\n    /** @returns {string} */\n    toString() {\n        return `Message{type=${this.type}, size=${this.serializedSize}}`;\n    }\n}\nMessage.MAGIC = 0x42042042;\n/**\n * Enum for message types.\n * @enum {number}\n */\nMessage.Type = {\n    VERSION:    0,\n    INV:        1,\n    GET_DATA:   2,\n    GET_HEADER: 3,\n    NOT_FOUND:  4,\n    GET_BLOCKS: 5,\n    BLOCK:      6,\n    HEADER:     7,\n    TX:         8,\n    MEMPOOL:    9,\n    REJECT:     10,\n    SUBSCRIBE:  11,\n\n    ADDR:       20,\n    GET_ADDR:   21,\n    PING:       22,\n    PONG:       23,\n\n    SIGNAL:     30,\n\n    GET_CHAIN_PROOF:            40,\n    CHAIN_PROOF:                41,\n    GET_ACCOUNTS_PROOF:         42,\n    ACCOUNTS_PROOF:             43,\n    GET_ACCOUNTS_TREE_CHUNK:    44,\n    ACCOUNTS_TREE_CHUNK:        45,\n    GET_TRANSACTIONS_PROOF:     47,\n    TRANSACTIONS_PROOF:         48,\n    GET_TRANSACTION_RECEIPTS:   49,\n    TRANSACTION_RECEIPTS:       50,\n    GET_BLOCK_PROOF:            51,\n    BLOCK_PROOF:                52,\n\n    GET_HEAD:   60,\n    HEAD:       61,\n\n    VERACK:   90\n};\nClass.register(Message);\n","class AddrMessage extends Message {\n    /**\n     * @param {Array.<PeerAddress>} addresses\n     */\n    constructor(addresses) {\n        super(Message.Type.ADDR);\n        if (!addresses || !NumberUtils.isUint16(addresses.length)\n            || addresses.some(it => !(it instanceof PeerAddress))) throw 'Malformed addresses';\n        this._addresses = addresses;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {AddrMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const addresses = [];\n        for (let i = 0; i < count; ++i) {\n            addresses.push(PeerAddress.unserialize(buf));\n        }\n        return new AddrMessage(addresses);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint16(this._addresses.length);\n        for (const addr of this._addresses) {\n            addr.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let size = super.serializedSize\n            + /*count*/ 2;\n        for (const addr of this._addresses) {\n            size += addr.serializedSize;\n        }\n        return size;\n    }\n\n    /** @type {Array.<PeerAddress>} */\n    get addresses() {\n        return this._addresses;\n    }\n\n    toString() {\n        return `AddrMessage{size=${this._addresses.length}}`;\n    }\n}\nClass.register(AddrMessage);\n","class BlockMessage extends Message {\n    /**\n     * @param {Block} block\n     */\n    constructor(block) {\n        super(Message.Type.BLOCK);\n        // TODO Bitcoin block messages start with a block version\n        /** @type {Block} */\n        this._block = block;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {BlockMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const block = Block.unserialize(buf);\n        return new BlockMessage(block);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._block.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._block.serializedSize;\n    }\n\n    /** @type {Block} */\n    get block() {\n        return this._block;\n    }\n\n    toString() {\n        return `BlockMessage{height=${this._block.height}, hash=${this._block.hash()}}`;\n    }\n}\nClass.register(BlockMessage);\n","class RawBlockMessage extends Message {\n    /**\n     * @param {Uint8Array} block\n     */\n    constructor(block) {\n        super(Message.Type.BLOCK);\n        /** @type {Uint8Array} */\n        this._block = block;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.write(this._block);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /*\n        unserialize is not implemented,\n        because this message will serialize\n        to a BlockMessage\n     */\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._block.length;\n    }\n\n    /** @type {Block} */\n    get block() {\n        return Block.unserialize(new SerialBuffer(this._block));\n    }\n}\nClass.register(RawBlockMessage);\n","class GetAddrMessage extends Message {\n    /**\n     * @param {number} protocolMask\n     * @param {number} serviceMask\n     */\n    constructor(protocolMask, serviceMask) {\n        super(Message.Type.GET_ADDR);\n        if (!NumberUtils.isUint8(protocolMask)) throw 'Malformed protocolMask';\n        if (!NumberUtils.isUint32(serviceMask)) throw 'Malformed serviceMask';\n        this._protocolMask = protocolMask;\n        this._serviceMask = serviceMask;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {GetAddrMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const protocolMask = buf.readUint8();\n        const serviceMask = buf.readUint32();\n        return new GetAddrMessage(protocolMask, serviceMask);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint8(this._protocolMask);\n        buf.writeUint32(this._serviceMask);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*protocolMask*/ 1\n            + /*serviceMask*/ 4;\n    }\n\n    /** @type {number} */\n    get protocolMask() {\n        return this._protocolMask;\n    }\n\n    /** @type {number} */\n    get serviceMask() {\n        return this._serviceMask;\n    }\n\n    toString() {\n        return `GetAddrMessage{protocol=${this._protocolMask}, services=${this._serviceMask}}`;\n    }\n}\nClass.register(GetAddrMessage);\n","class GetBlocksMessage extends Message {\n    /**\n     * @param {Array.<Hash>} locators\n     * @param {number} maxInvSize\n     * @param {GetBlocksMessage.Direction} direction\n     */\n    constructor(locators, maxInvSize=BaseInventoryMessage.VECTORS_MAX_COUNT, direction=GetBlocksMessage.Direction.FORWARD) {\n        super(Message.Type.GET_BLOCKS);\n        if (!locators || !NumberUtils.isUint16(locators.length)\n            || locators.some(it => !Hash.isHash(it))) throw 'Malformed locators';\n        if (!NumberUtils.isUint16(maxInvSize)) throw 'Malformed maxInvSize';\n        if (!NumberUtils.isUint8(direction)) throw 'Malformed direction';\n        /** @type {Array.<Hash>} */\n        this._locators = locators;\n        this._maxInvSize = maxInvSize;\n        this._direction = direction;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {GetBlocksMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const locators = [];\n        for (let i = 0; i < count; i++) {\n            locators.push(Hash.unserialize(buf));\n        }\n        const maxInvSize = buf.readUint16();\n        const direction = buf.readUint8();\n        return new GetBlocksMessage(locators, maxInvSize, direction);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint16(this._locators.length);\n        for (const locator of this._locators) {\n            locator.serialize(buf);\n        }\n        buf.writeUint16(this._maxInvSize);\n        buf.writeUint8(this._direction);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let size = super.serializedSize\n            + /*count*/ 2\n            + /*direction*/ 1\n            + /*maxInvSize*/ 2;\n        for (const locator of this._locators) {\n            size += locator.serializedSize;\n        }\n        return size;\n    }\n\n    /** @type {Array.<Hash>} */\n    get locators() {\n        return this._locators;\n    }\n\n    /** @type {GetBlocksMessage.Direction} */\n    get direction() {\n        return this._direction;\n    }\n\n    /** @type {number} */\n    get maxInvSize() {\n        return this._maxInvSize;\n    }\n\n    toString() {\n        return `GetBlocksMessage{direction=${this._direction === GetBlocksMessage.Direction.FORWARD ? 'forward' : 'backward'}, maxInvSize=${this._maxInvSize}}`;\n    }\n}\n/**\n * @enum {number}\n */\nGetBlocksMessage.Direction = {\n    FORWARD: 0x1,\n    BACKWARD: 0x2\n};\nClass.register(GetBlocksMessage);\n","class HeaderMessage extends Message {\n    /**\n     * @param {BlockHeader} header\n     */\n    constructor(header) {\n        super(Message.Type.HEADER);\n        /** @type {BlockHeader} */\n        this._header = header;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {HeaderMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const header = BlockHeader.unserialize(buf);\n        return new HeaderMessage(header);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._header.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._header.serializedSize;\n    }\n\n    /** @type {BlockHeader} */\n    get header() {\n        return this._header;\n    }\n\n    toString() {\n        return `HeaderMessage{height=${this._header.height}, hash=${this._header.hash()}}`;\n    }\n}\nClass.register(HeaderMessage);\n","class InvVector {\n    /**\n     * @param {Block} block\n     * @returns {InvVector}\n     */\n    static fromBlock(block) {\n        const hash = block.hash();\n        return new InvVector(InvVector.Type.BLOCK, hash);\n    }\n\n    /**\n     * @param {BlockHeader} header\n     * @returns {InvVector}\n     */\n    static fromHeader(header) {\n        const hash = header.hash();\n        return new InvVector(InvVector.Type.BLOCK, hash);\n    }\n\n    /**\n     * @param {Transaction} tx\n     * @returns {InvVector}\n     */\n    static fromTransaction(tx) {\n        const hash = tx.hash();\n        return new InvVector(InvVector.Type.TRANSACTION, hash);\n    }\n\n    /**\n     * @param {InvVector.Type} type\n     * @param {Hash} hash\n     */\n    constructor(type, hash) {\n        // TODO validate type\n        if (!Hash.isHash(hash)) throw 'Malformed hash';\n        /** @type {InvVector.Type} */\n        this._type = type;\n        /** @type {Hash} */\n        this._hash = hash;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {InvVector}\n     */\n    static unserialize(buf) {\n        const type = InvVector.Type.unserialize(buf);\n        const hash = Hash.unserialize(buf);\n        return new InvVector(type, hash);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint32(this._type);\n        this._hash.serialize(buf);\n        return buf;\n    }\n\n    /**\n     * @param {InvVector} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof InvVector\n            && this._type === o.type\n            && this._hash.equals(o.hash);\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return `${this._type}|${this._hash.toBase64()}`;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `InvVector{type=${this._type}, hash=${this._hash}}`;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*invType*/ 4\n            + this._hash.serializedSize;\n    }\n\n    /** @type {InvVector.Type} */\n    get type() {\n        return this._type;\n    }\n\n    /** @type {Hash} */\n    get hash() {\n        return this._hash;\n    }\n}\n/**\n * @enum {number}\n */\nInvVector.Type = {\n    ERROR: 0,\n    TRANSACTION: 1,\n    BLOCK: 2,\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {InvVector.Type}\n     */\n    unserialize: function (buf) {\n        return /** @type {InvVector.Type} */ (buf.readUint32());\n    }\n};\nClass.register(InvVector);\n\nclass BaseInventoryMessage extends Message {\n    /**\n     * @param {Message.Type} type\n     * @param {Array.<InvVector>} vectors\n     */\n    constructor(type, vectors) {\n        super(type);\n        if (!vectors || !NumberUtils.isUint16(vectors.length)\n            || vectors.some(it => !(it instanceof InvVector))\n            || vectors.length > BaseInventoryMessage.VECTORS_MAX_COUNT) throw 'Malformed vectors';\n        /** @type {Array.<InvVector>} */\n        this._vectors = vectors;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint16(this._vectors.length);\n        for (const vector of this._vectors) {\n            vector.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let size = super.serializedSize\n            + /*count*/ 2;\n        for (const vector of this._vectors) {\n            size += vector.serializedSize;\n        }\n        return size;\n    }\n\n    /** @type {Array.<InvVector>} */\n    get vectors() {\n        return this._vectors;\n    }\n\n    // noinspection JSCheckFunctionSignatures\n    toString(subtype = 'InventoryMessage') {\n        return `${subtype}{transactions=${this._vectors.filter(vector => vector.type === InvVector.Type.TRANSACTION).length}, blocks=${this._vectors.filter(vector => vector.type === InvVector.Type.BLOCK).length}}`;\n    }\n}\nBaseInventoryMessage.VECTORS_MAX_COUNT = 1000;\nClass.register(BaseInventoryMessage);\n\nclass InvMessage extends BaseInventoryMessage {\n    /**\n     * @param {Array.<InvVector>} vectors\n     */\n    constructor(vectors) {\n        super(Message.Type.INV, vectors);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {InvMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const vectors = [];\n        for (let i = 0; i < count; ++i) {\n            vectors.push(InvVector.unserialize(buf));\n        }\n        return new InvMessage(vectors);\n    }\n\n    toString() {\n        return super.toString('InvMessage');\n    }\n}\nClass.register(InvMessage);\n\nclass GetDataMessage extends BaseInventoryMessage {\n    /**\n     * @param {Array.<InvVector>} vectors\n     */\n    constructor(vectors) {\n        super(Message.Type.GET_DATA, vectors);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetDataMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const vectors = [];\n        for (let i = 0; i < count; ++i) {\n            vectors.push(InvVector.unserialize(buf));\n        }\n        return new GetDataMessage(vectors);\n    }\n\n    toString() {\n        return super.toString('GetDataMessage');\n    }\n}\nClass.register(GetDataMessage);\n\nclass GetHeaderMessage extends BaseInventoryMessage {\n    /**\n     * @param {Array.<InvVector>} vectors\n     */\n    constructor(vectors) {\n        super(Message.Type.GET_HEADER, vectors);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetHeaderMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const vectors = [];\n        for (let i = 0; i < count; ++i) {\n            vectors.push(InvVector.unserialize(buf));\n        }\n        return new GetHeaderMessage(vectors);\n    }\n\n    toString() {\n        return super.toString('GetHeaderMessage');\n    }\n}\nClass.register(GetHeaderMessage);\n\nclass NotFoundMessage extends BaseInventoryMessage {\n    /**\n     * @param {Array.<InvVector>} vectors\n     */\n    constructor(vectors) {\n        super(Message.Type.NOT_FOUND, vectors);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {NotFoundMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const vectors = [];\n        for (let i = 0; i < count; ++i) {\n            vectors.push(InvVector.unserialize(buf));\n        }\n        return new NotFoundMessage(vectors);\n    }\n\n    toString() {\n        return super.toString('NotFoundMessage');\n    }\n}\nClass.register(NotFoundMessage);\n","class MempoolMessage extends Message {\n    constructor() {\n        super(Message.Type.MEMPOOL);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {MempoolMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        return new MempoolMessage();\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize;\n    }\n\n    toString() {\n        return 'MempoolMessage{}';\n    }\n}\nClass.register(MempoolMessage);\n","class PingMessage extends Message {\n    /**\n     * @param {number} nonce\n     */\n    constructor(nonce) {\n        super(Message.Type.PING);\n        if (!NumberUtils.isUint32(nonce)) throw 'Malformed nonce';\n        /** @type {number} */\n        this._nonce = nonce;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {PingMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const nonce = buf.readUint32();\n        return new PingMessage(nonce);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint32(this._nonce);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*nonce*/ 4;\n    }\n\n    /** @type {number} */\n    get nonce() {\n        return this._nonce;\n    }\n\n    toString() {\n        return `PingMessage{nonce=${this._nonce}}`;\n    }\n}\nClass.register(PingMessage);\n","class PongMessage extends Message {\n    /**\n     * @param {number} nonce\n     */\n    constructor(nonce) {\n        super(Message.Type.PONG);\n        if (!NumberUtils.isUint32(nonce)) throw 'Malformed nonce';\n\n        this._nonce = nonce;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {PongMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const nonce = buf.readUint32();\n        return new PongMessage(nonce);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint32(this._nonce);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*nonce*/ 4;\n    }\n\n    /** @type {number} */\n    get nonce() {\n        return this._nonce;\n    }\n\n    toString() {\n        return `PongMessage{nonce=${this._nonce}}`;\n    }\n}\nClass.register(PongMessage);\n","class RejectMessage extends Message {\n    /**\n     * @param {Message.Type} messageType\n     * @param {RejectMessage.Code} code\n     * @param {string} reason\n     * @param {Uint8Array} [extraData]\n     */\n    constructor(messageType, code, reason, extraData=new Uint8Array(0)) {\n        super(Message.Type.REJECT);\n        if (!NumberUtils.isUint64(messageType)) throw new Error('Malformed type');\n        if (!NumberUtils.isUint8(code)) throw new Error('Malformed code');\n        if (StringUtils.isMultibyte(reason) || reason.length > 255) throw new Error('Malformed reason');\n        if (!(extraData instanceof Uint8Array) || !NumberUtils.isUint16(extraData.byteLength)) throw new Error('Malformed extraData');\n\n        /** @type {Message.Type} */\n        this._messageType = messageType;\n        /** @type {RejectMessage.Code} */\n        this._code = code;\n        /** @type {string} */\n        this._reason = reason;\n        /** @type {Uint8Array} */\n        this._extraData = extraData;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {RejectMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const messageType = /** @type {Message.Type} */ buf.readVarUint();\n        const code = /** @type {RejectMessage.Code} */ buf.readUint8();\n        const reason = buf.readVarLengthString();\n        const length = buf.readUint16();\n        const extraData = buf.read(length);\n        return new RejectMessage(messageType, code, reason, extraData);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeVarUint(this._messageType);\n        buf.writeUint8(this._code);\n        buf.writeVarLengthString(this._reason);\n        buf.writeUint16(this._extraData.byteLength);\n        buf.write(this._extraData);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + SerialBuffer.varUintSize(this._messageType)\n            + /*code*/ 1\n            + SerialBuffer.varLengthStringSize(this._reason)\n            + /*extraDataLength*/ 2\n            + this._extraData.byteLength;\n    }\n\n    /** @type {Message.Type} */\n    get messageType() {\n        return this._messageType;\n    }\n\n    /** @type {RejectMessage.Code} */\n    get code() {\n        return this._code;\n    }\n\n    /** @type {string} */\n    get reason() {\n        return this._reason;\n    }\n\n    /** @type {Uint8Array} */\n    get extraData() {\n        return this._extraData;\n    }\n\n    toString() {\n        return `RejectMessage{type=${this._messageType}, code=${this._code}, reason=${this._reason}}`;\n    }\n}\n/**\n * @enum {number}\n */\nRejectMessage.Code = {\n    REJECT_MALFORMED: 0x01,\n    REJECT_INVALID: 0x10,\n    REJECT_OBSOLETE: 0x11,\n    REJECT_DOUBLE: 0x12,\n    REJECT_DUST: 0x41,\n    REJECT_INSUFFICIENT_FEE: 0x42\n};\nClass.register(RejectMessage);\n","class SignalMessage extends Message {\n    /**\n     * @param {PeerId} senderId\n     * @param {PeerId} recipientId\n     * @param {number} nonce\n     * @param {number} ttl\n     * @param {SignalMessage.Flags|number} flags\n     * @param {Uint8Array} [payload]\n     * @param {PublicKey} [senderPubKey]\n     * @param {Signature} [signature]\n     */\n    constructor(senderId, recipientId, nonce, ttl, flags = 0, payload = new Uint8Array(0), senderPubKey, signature) {\n        super(Message.Type.SIGNAL);\n        if (!(senderId instanceof PeerId)) throw 'Malformed senderId';\n        if (!(recipientId instanceof PeerId)) throw 'Malformed recipientId';\n        if (!NumberUtils.isUint32(nonce)) throw 'Malformed nonce';\n        if (!NumberUtils.isUint8(ttl)) throw 'Malformed ttl';\n        if (!NumberUtils.isUint8(flags)) throw 'Malformed flags';\n        if (!(payload instanceof Uint8Array) || !NumberUtils.isUint16(payload.byteLength)) throw 'Malformed payload';\n        const hasPayload = payload.byteLength > 0;\n        if (hasPayload && !(signature instanceof Signature)) throw 'Malformed signature';\n        if (hasPayload && !(senderPubKey instanceof PublicKey)) throw 'Malformed public key';\n\n        // Note that the signature is NOT verified here.\n        // Callers must explicitly invoke verifySignature() to check it.\n\n        /** @type {PeerId} */\n        this._senderId = senderId;\n        /** @type {PeerId} */\n        this._recipientId = recipientId;\n        /** @type {number} */\n        this._nonce = nonce;\n        /** @type {number} */\n        this._ttl = ttl;\n        /** @type {SignalMessage.Flags|number} */\n        this._flags = flags;\n        /** @type {Uint8Array} */\n        this._payload = payload;\n        /** @type {PublicKey} */\n        this._senderPubKey = hasPayload ? senderPubKey : undefined;\n        /** @type {Signature} */\n        this._signature = hasPayload ? signature : undefined;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {SignalMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const senderId = PeerId.unserialize(buf);\n        const recipientId = PeerId.unserialize(buf);\n        const nonce = buf.readUint32();\n        const ttl = buf.readUint8();\n        const flags = buf.readUint8();\n        const length = buf.readUint16();\n        const payload = buf.read(length);\n        const senderPubKey = length > 0 ? PublicKey.unserialize(buf) : undefined;\n        const signature = length > 0 ? Signature.unserialize(buf) : undefined;\n        return new SignalMessage(senderId, recipientId, nonce, ttl, flags, payload, senderPubKey, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._senderId.serialize(buf);\n        this._recipientId.serialize(buf);\n        buf.writeUint32(this._nonce);\n        buf.writeUint8(this._ttl);\n        buf.writeUint8(this._flags);\n        buf.writeUint16(this._payload.byteLength);\n        buf.write(this._payload);\n        if (this._payload.byteLength > 0) {\n            this._senderPubKey.serialize(buf);\n            this._signature.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*senderId*/ this._senderId.serializedSize\n            + /*recipientId*/ this._recipientId.serializedSize\n            + /*nonce*/ 4\n            + /*ttl*/ 1\n            + /*flags*/ 1\n            + /*payloadLength*/ 2\n            + this._payload.byteLength\n            + (this._payload.byteLength > 0 ? this._senderPubKey.serializedSize : 0)\n            + (this._payload.byteLength > 0 ? this._signature.serializedSize : 0);\n    }\n\n    /**\n     * @return {boolean}\n     */\n    verifySignature() {\n        if (!this._signature) {\n            return false;\n        }\n\n        return this._signature.verify(this._senderPubKey, this._payload)\n            && this._senderId.equals(this._senderPubKey.toPeerId());\n    }\n\n    /** @type {PeerId} */\n    get senderId() {\n        return this._senderId;\n    }\n\n    /** @type {PeerId} */\n    get recipientId() {\n        return this._recipientId;\n    }\n\n    /** @type {number} */\n    get nonce() {\n        return this._nonce;\n    }\n\n    /** @type {number} */\n    get ttl() {\n        return this._ttl;\n    }\n\n    /** @type {SignalMessage.Flags|number} */\n    get flags() {\n        return this._flags;\n    }\n\n    /** @type {Uint8Array} */\n    get payload() {\n        return this._payload;\n    }\n\n    /** @type {Signature} */\n    get signature() {\n        return this._signature;\n    }\n\n    /** @type {PublicKey} */\n    get senderPubKey() {\n        return this._senderPubKey;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    hasPayload() {\n        return this._payload.byteLength > 0;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isUnroutable() {\n        return (this._flags & SignalMessage.Flag.UNROUTABLE) !== 0;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isTtlExceeded() {\n        return (this._flags & SignalMessage.Flag.TTL_EXCEEDED) !== 0;\n    }\n\n    toString() {\n        return `SignalMessage{sender=${this._senderId}, recipient=${this._recipientId}, nonce=${this._nonce}, ttl=${this._ttl}, flags=${this._flags}}`;\n    }\n}\n/**\n * @enum {number}\n */\nSignalMessage.Flag = {\n    UNROUTABLE: 0x1,\n    TTL_EXCEEDED: 0x2\n};\nClass.register(SignalMessage);\n","class SubscribeMessage extends Message {\n    constructor(subscription) {\n        super(Message.Type.SUBSCRIBE);\n        this._subscription = subscription;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {SubscribeMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const subscription = Subscription.unserialize(buf);\n        return new SubscribeMessage(subscription);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._subscription.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._subscription.serializedSize;\n    }\n\n    /** @type {Subscription} */\n    get subscription() {\n        return this._subscription;\n    }\n\n    toString() {\n        return `SubscribeMessage{${this._subscription}}`;\n    }\n}\nClass.register(SubscribeMessage);\n","class TxMessage extends Message {\n    /**\n     * @param {Transaction} transaction\n     * @param {?AccountsProof} [accountsProof]\n     */\n    constructor(transaction, accountsProof) {\n        super(Message.Type.TX);\n        /** @type {Transaction} */\n        this._transaction = transaction;\n        /** @type {AccountsProof} */\n        this._accountsProof = accountsProof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {TxMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const transaction = Transaction.unserialize(buf);\n        const hasAccountsProof = buf.readUint8();\n        if (hasAccountsProof === 1) {\n            const accountsProof = AccountsProof.unserialize(buf);\n            return new TxMessage(transaction, accountsProof);\n        }\n        return new TxMessage(transaction);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._transaction.serialize(buf);\n        buf.writeUint8(this._accountsProof ? 1 : 0);\n        if (this._accountsProof) {\n            this._accountsProof.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        let size = super.serializedSize\n            + this._transaction.serializedSize\n            + /*hasAccountsProof*/ 1;\n        if (this._accountsProof) {\n            size += this._accountsProof.serializedSize;\n        }\n        return size;\n    }\n\n    /** @type {Transaction} */\n    get transaction() {\n        return this._transaction;\n    }\n\n    /** @type {boolean} */\n    get hasAccountsProof() {\n        return !!this._accountsProof;\n    }\n\n    /** @type {AccountsProof} */\n    get accountsProof() {\n        return this._accountsProof;\n    }\n\n    toString() {\n        return `TxMessage{hash=${this._transaction.hash()}}`;\n    }\n}\nClass.register(TxMessage);\n","class VersionMessage extends Message {\n    /**\n     * @param {number} version\n     * @param {PeerAddress} peerAddress\n     * @param {Hash} genesisHash\n     * @param {Hash} headHash\n     * @param {Uint8Array} challengeNonce\n     */\n    constructor(version, peerAddress, genesisHash, headHash, challengeNonce) {\n        super(Message.Type.VERSION);\n        if (!NumberUtils.isUint32(version)) throw new Error('Malformed version');\n        if (!(peerAddress instanceof PeerAddress)) throw new Error('Malformed peerAddress');\n        if (!Hash.isHash(genesisHash)) throw new Error('Malformed genesisHash');\n        if (!Hash.isHash(headHash)) throw new Error('Malformed headHash');\n        if (!(challengeNonce instanceof Uint8Array) || challengeNonce.byteLength !== 32) throw new Error('Malformed challenge nonce');\n\n        /** @type {number} */\n        this._version = version;\n        /** @type {PeerAddress} */\n        this._peerAddress = peerAddress;\n        /** @type {Hash} */\n        this._genesisHash = genesisHash;\n        /** @type {Hash} */\n        this._headHash = headHash;\n        /** @type {Uint8Array} */\n        this._challengeNonce = challengeNonce;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {VersionMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const version = buf.readUint32();\n        const peerAddress = PeerAddress.unserialize(buf);\n        const genesisHash = Hash.unserialize(buf);\n        const headHash = Hash.unserialize(buf);\n        const challengeNonce = buf.read(VersionMessage.CHALLENGE_SIZE);\n        return new VersionMessage(version, peerAddress, genesisHash, headHash, challengeNonce);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint32(this._version);\n        this._peerAddress.serialize(buf);\n        this._genesisHash.serialize(buf);\n        this._headHash.serialize(buf);\n        buf.write(this._challengeNonce);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*version*/ 4\n            + this._peerAddress.serializedSize\n            + this._genesisHash.serializedSize\n            + this._headHash.serializedSize\n            + VersionMessage.CHALLENGE_SIZE;\n    }\n\n    /** @type {number} */\n    get version() {\n        return this._version;\n    }\n\n    /** @type {PeerAddress} */\n    get peerAddress() {\n        return this._peerAddress;\n    }\n\n    /** @type {Hash} */\n    get genesisHash() {\n        return this._genesisHash;\n    }\n\n    /** @type {Hash} */\n    get headHash() {\n        return this._headHash;\n    }\n\n    /** @type {Uint8Array} */\n    get challengeNonce() {\n        return this._challengeNonce;\n    }\n\n    toString() {\n        return `VersionMessage{version=${this._version}, peer=${this._peerAddress}, genesis=${this._genesisHash}, head=${this._headHash}}`;\n    }\n}\n\nVersionMessage.CHALLENGE_SIZE = 32;\nClass.register(VersionMessage);\n","class VerAckMessage extends Message {\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Signature} signature\n     */\n    constructor(publicKey, signature) {\n        super(Message.Type.VERACK);\n        /** @type {PublicKey} */\n        this._publicKey = publicKey;\n        /** @type {Signature} */\n        this._signature = signature;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {VerAckMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const publicKey = PublicKey.unserialize(buf);\n        const signature = Signature.unserialize(buf);\n        return new VerAckMessage(publicKey, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this.publicKey.serialize(buf);\n        this.signature.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._publicKey.serializedSize\n            + this._signature.serializedSize;\n    }\n\n    /** @type {PublicKey} */\n    get publicKey() {\n        return this._publicKey;\n    }\n\n    /** @type {Signature} */\n    get signature() {\n        return this._signature;\n    }\n\n    toString() {\n        return 'VerAckMessage{}';\n    }\n}\nClass.register(VerAckMessage);\n","class AccountsProofMessage extends Message {\n    /**\n     * @param {Hash} blockHash\n     * @param {AccountsProof} [accountsProof]\n     */\n    constructor(blockHash, accountsProof=null) {\n        super(Message.Type.ACCOUNTS_PROOF);\n        if (!(blockHash instanceof Hash)) throw new Error('Malformed blockHash');\n        if (accountsProof && !(accountsProof instanceof AccountsProof)) throw new Error('Malformed proof');\n        /** @type {Hash} */\n        this._blockHash = blockHash;\n        /** @type {AccountsProof} */\n        this._accountsProof = accountsProof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {AccountsProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const hasProof = buf.readUint8();\n        let accountsProof = null;\n        if (hasProof !== 0) {\n            accountsProof = AccountsProof.unserialize(buf);\n        }\n        return new AccountsProofMessage(blockHash, accountsProof);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeUint8(this.hasProof() ? 1 : 0);\n        if (this.hasProof()) {\n            this._accountsProof.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*success bit*/ 1\n            + this._blockHash.serializedSize\n            + (this.hasProof() ? this._accountsProof.serializedSize : 0);\n    }\n\n    /**\n     * @return {boolean}\n     */\n    hasProof() {\n        return !!this._accountsProof;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n\n    /** @type {AccountsProof} */\n    get proof() {\n        return this._accountsProof;\n    }\n}\nClass.register(AccountsProofMessage);\n","class GetAccountsProofMessage extends Message {\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     */\n    constructor(blockHash, addresses) {\n        super(Message.Type.GET_ACCOUNTS_PROOF);\n        if (!blockHash || !(blockHash instanceof Hash)) throw new Error('Malformed block hash');\n        if (!addresses || !NumberUtils.isUint16(addresses.length)\n            || addresses.length < 1\n            || addresses.some(it => !(it instanceof Address))) throw new Error('Malformed addresses');\n        this._blockHash = blockHash;\n        /** @type {Array.<Address>} */\n        this._addresses = addresses;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetAccountsProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const count = buf.readUint16();\n        const addresses = [];\n        for (let i = 0; i < count; i++) {\n            addresses.push(Address.unserialize(buf));\n        }\n        return new GetAccountsProofMessage(blockHash, addresses);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeUint16(this._addresses.length);\n        for (const address of this._addresses) {\n            address.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._blockHash.serializedSize\n            + /*count*/ 2\n            + this._addresses.reduce((sum, address) => sum + address.serializedSize, 0);\n    }\n\n    /** @type {Array.<Address>} */\n    get addresses() {\n        return this._addresses;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n}\nClass.register(GetAccountsProofMessage);\n","class ChainProofMessage extends Message {\n    /**\n     * @param {ChainProof} proof\n     */\n    constructor(proof) {\n        super(Message.Type.CHAIN_PROOF);\n        if (!(proof instanceof ChainProof)) throw 'Malformed chainProof';\n\n        /** @type {ChainProof} */\n        this._proof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {ChainProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const proof = ChainProof.unserialize(buf);\n        return new ChainProofMessage(proof);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._proof.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._proof.serializedSize;\n    }\n\n    /** @type {ChainProof} */\n    get proof() {\n        return this._proof;\n    }\n}\nClass.register(ChainProofMessage);\n","class GetChainProofMessage extends Message {\n    constructor() {\n        super(Message.Type.GET_CHAIN_PROOF);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetChainProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        return new GetChainProofMessage();\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize;\n    }\n}\nClass.register(GetChainProofMessage);\n","class AccountsTreeChunkMessage extends Message {\n    /**\n     * @param {Hash} blockHash\n     * @param {AccountsTreeChunk} [accountsTreeChunk]\n     */\n    constructor(blockHash, accountsTreeChunk=null) {\n        super(Message.Type.ACCOUNTS_TREE_CHUNK);\n        if (!(blockHash instanceof Hash)) throw 'Malformed blockHash';\n        if (accountsTreeChunk && !(accountsTreeChunk instanceof AccountsTreeChunk)) throw 'Malformed chunk';\n        /** @type {Hash} */\n        this._blockHash = blockHash;\n        /** @type {AccountsTreeChunk} */\n        this._accountsTreeChunk = accountsTreeChunk;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {AccountsTreeChunkMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const hasChunk = buf.readUint8();\n        let accountsTreeChunk = null;\n        if (hasChunk !== 0) {\n            accountsTreeChunk = AccountsTreeChunk.unserialize(buf);\n        }\n        return new AccountsTreeChunkMessage(blockHash, accountsTreeChunk);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeUint8(this.hasChunk() ? 1 : 0);\n        if (this.hasChunk()) {\n            this._accountsTreeChunk.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*success bit*/ 1\n            + this._blockHash.serializedSize\n            + (this.hasChunk() ? this._accountsTreeChunk.serializedSize : 0);\n    }\n\n    /**\n     * @return {boolean}\n     */\n    hasChunk() {\n        return !!this._accountsTreeChunk;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n\n    /** @type {AccountsTreeChunk} */\n    get chunk() {\n        return this._accountsTreeChunk;\n    }\n}\nClass.register(AccountsTreeChunkMessage);\n","class GetAccountsTreeChunkMessage extends Message {\n    /**\n     * @param {Hash} blockHash\n     * @param {string} startPrefix\n     */\n    constructor(blockHash, startPrefix) {\n        super(Message.Type.GET_ACCOUNTS_TREE_CHUNK);\n        if (!blockHash || !(blockHash instanceof Hash)) throw 'Malformed block hash';\n        if (StringUtils.isMultibyte(startPrefix)\n            || !NumberUtils.isUint8(startPrefix.length)) throw 'Malformed start prefix';\n        /** @type {Hash} */\n        this._blockHash = blockHash;\n        this._startPrefix = startPrefix;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetAccountsTreeChunkMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const startPrefix = buf.readVarLengthString();\n        return new GetAccountsTreeChunkMessage(blockHash, startPrefix);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeVarLengthString(this._startPrefix);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._blockHash.serializedSize\n            + SerialBuffer.varLengthStringSize(this._startPrefix);\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n\n    /** @type {string} */\n    get startPrefix() {\n        return this._startPrefix;\n    }\n}\nClass.register(GetAccountsTreeChunkMessage);\n","class TransactionsProofMessage extends Message {\n    /**\n     * @param {Hash} blockHash\n     * @param {TransactionsProof} [proof]\n     */\n    constructor(blockHash, proof=null) {\n        super(Message.Type.TRANSACTIONS_PROOF);\n        if (!(blockHash instanceof Hash)) throw new Error('Malformed blockHash');\n        if (proof && !(proof instanceof TransactionsProof)) throw new Error('Malformed proof');\n        /** @type {Hash} */\n        this._blockHash = blockHash;\n        /** @type {TransactionsProof} */\n        this._proof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {TransactionsProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const hasProof = buf.readUint8();\n        let proof = null;\n        if (hasProof !== 0) {\n            proof = TransactionsProof.unserialize(buf);\n        }\n        return new TransactionsProofMessage(blockHash, proof);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeUint8(this.hasProof() ? 1 : 0);\n        if (this.hasProof()) {\n            this._proof.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*success bit*/ 1\n            + this._blockHash.serializedSize\n            + (this.hasProof() ? this._proof.serializedSize : 0);\n    }\n\n    /**\n     * @return {boolean}\n     */\n    hasProof() {\n        return !!this._proof;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n\n    /** @type {TransactionsProof} */\n    get proof() {\n        return this._proof;\n    }\n}\nClass.register(TransactionsProofMessage);\n","class GetTransactionsProofMessage extends Message {\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     */\n    constructor(blockHash, addresses) {\n        super(Message.Type.GET_TRANSACTIONS_PROOF);\n        if (!blockHash || !(blockHash instanceof Hash)) throw new Error('Malformed block hash');\n        if (!addresses || !NumberUtils.isUint16(addresses.length)\n            || addresses.some(it => !(it instanceof Address))) throw new Error('Malformed addresses');\n        this._blockHash = blockHash;\n        /** @type {Array.<Address>} */\n        this._addresses = addresses;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetTransactionsProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHash = Hash.unserialize(buf);\n        const count = buf.readUint16();\n        const addresses = [];\n        for (let i = 0; i < count; i++) {\n            addresses.push(Address.unserialize(buf));\n        }\n        return new GetTransactionsProofMessage(blockHash, addresses);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHash.serialize(buf);\n        buf.writeUint16(this._addresses.length);\n        for (const address of this._addresses) {\n            address.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._blockHash.serializedSize\n            + /*count*/ 2\n            + this._addresses.reduce((sum, address) => sum + address.serializedSize, 0);\n    }\n\n    /** @type {Array.<Address>} */\n    get addresses() {\n        return this._addresses;\n    }\n\n    /** @type {Hash} */\n    get blockHash() {\n        return this._blockHash;\n    }\n}\nClass.register(GetTransactionsProofMessage);\n","class GetTransactionReceiptsMessage extends Message {\n    /**\n     * @param {Address} address\n     */\n    constructor(address) {\n        super(Message.Type.GET_TRANSACTION_RECEIPTS);\n        if (!(address instanceof Address)) throw new Error('Malformed address');\n        /** @type {Address} */\n        this._address = address;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {GetTransactionReceiptsMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const address = Address.unserialize(buf);\n        return new GetTransactionReceiptsMessage(address);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._address.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._address.serializedSize;\n    }\n\n    /** @type {Address} */\n    get address() {\n        return this._address;\n    }\n}\nClass.register(GetTransactionReceiptsMessage);\n","class TransactionReceiptsMessage extends Message {\n    /**\n     * @param {Array.<TransactionReceipt>} transactionReceipts\n     */\n    constructor(transactionReceipts) {\n        super(Message.Type.TRANSACTION_RECEIPTS);\n        if (!Array.isArray(transactionReceipts) || !NumberUtils.isUint16(transactionReceipts.length)\n            || transactionReceipts.some(it => !(it instanceof TransactionReceipt))\n            || transactionReceipts.length > TransactionReceiptsMessage.RECEIPTS_MAX_COUNT) throw new Error('Malformed transactionReceipts');\n        /** @type {Array.<TransactionReceipt>} */\n        this._transactionReceipts = transactionReceipts;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {TransactionReceiptsMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const count = buf.readUint16();\n        const transactionReceipts = [];\n        for (let i = 0; i < count; ++i) {\n            transactionReceipts.push(TransactionReceipt.unserialize(buf));\n        }\n        return new TransactionReceiptsMessage(transactionReceipts);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeUint16(this._transactionReceipts.length);\n        for (const receipt of this._transactionReceipts) {\n            receipt.serialize(buf);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*count*/ 2\n            + this._transactionReceipts.reduce((sum, receipt) => sum + receipt.serializedSize, 0);\n    }\n\n    /** @type {Array.<TransactionReceipt>} */\n    get transactionReceipts() {\n        return this._transactionReceipts;\n    }\n}\nClass.register(TransactionReceiptsMessage);\nTransactionReceiptsMessage.RECEIPTS_MAX_COUNT = 500;\n","class GetBlockProofMessage extends Message {\n    /**\n     * @param {Hash} blockHashToProve\n     * @param {Hash} knownBlockHash\n     */\n    constructor(blockHashToProve, knownBlockHash) {\n        super(Message.Type.GET_BLOCK_PROOF);\n        if (!(blockHashToProve instanceof Hash)) throw new Error('Malformed blockHashToProve');\n        if (!(knownBlockHash instanceof Hash)) throw new Error('Malformed knownBlockHash');\n        /** @type {Hash} */\n        this._blockHashToProve = blockHashToProve;\n        /** @type {Hash} */\n        this._knownBlockHash = knownBlockHash;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {GetBlockProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const blockHashToProve = Hash.unserialize(buf);\n        const knownBlockHash = Hash.unserialize(buf);\n        return new GetBlockProofMessage(blockHashToProve, knownBlockHash);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._blockHashToProve.serialize(buf);\n        this._knownBlockHash.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._blockHashToProve.serializedSize\n            + this._knownBlockHash.serializedSize;\n    }\n\n    /** @type {Hash} */\n    get blockHashToProve() {\n        return this._blockHashToProve;\n    }\n\n    /** @type {Hash} */\n    get knownBlockHash() {\n        return this._knownBlockHash;\n    }\n}\nClass.register(GetBlockProofMessage);\n","class BlockProofMessage extends Message {\n    /**\n     * @param {BlockChain} [proof]\n     */\n    constructor(proof) {\n        super(Message.Type.BLOCK_PROOF);\n        if (proof && !(proof instanceof BlockChain)) throw new Error('Malformed proof');\n        /** @type {BlockChain} */\n        this._proof = proof;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {BlockProofMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const hasProof = buf.readUint8() === 1;\n        if (hasProof) {\n            const proof = BlockChain.unserialize(buf);\n            return new BlockProofMessage(proof);\n        }\n        return new BlockProofMessage();\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        if (this._proof) {\n            buf.writeUint8(1);\n            this._proof.serialize(buf);\n        } else {\n            buf.writeUint8(0);\n        }\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + /*found*/ 1\n            + (this._proof ? this._proof.serializedSize : 0);\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    hasProof() {\n        return !!this._proof;\n    }\n\n    /** @type {BlockChain} */\n    get proof() {\n        return this._proof;\n    }\n}\nClass.register(BlockProofMessage);\n","class GetHeadMessage extends Message {\n    constructor() {\n        super(Message.Type.GET_HEAD);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {GetHeadMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        return new GetHeadMessage();\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    toString() {\n        return 'GetHeadMessage{}';\n    }\n}\nClass.register(GetHeadMessage);\n","class HeadMessage extends Message {\n    /**\n     * @param {BlockHeader} header\n     */\n    constructor(header) {\n        super(Message.Type.HEAD);\n        /** @type {BlockHeader} */\n        this._header = header;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {HeadMessage}\n     */\n    static unserialize(buf) {\n        Message.unserialize(buf);\n        const header = BlockHeader.unserialize(buf);\n        return new HeadMessage(header);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        this._header.serialize(buf);\n        super._setChecksum(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + this._header.serializedSize;\n    }\n\n    /** @type {BlockHeader} */\n    get header() {\n        return this._header;\n    }\n\n    toString() {\n        return `HeadMessage{height=${this._header.height}, hash=${this._header.hash()}}`;\n    }\n}\nClass.register(HeadMessage);\n","class MessageFactory {\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {Message.Type}\n     */\n    static peekType(buf) {\n        return Message.peekType(buf);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {Message}\n     */\n    static parse(buf) {\n        const type = Message.peekType(buf);\n        const clazz = MessageFactory.CLASSES[type];\n        if (!clazz || !clazz.unserialize) throw new Error(`Invalid message type: ${type}`);\n        return clazz.unserialize(buf);\n    }\n}\n/**\n * @dict \n * @type {object}\n */\nMessageFactory.CLASSES = {};\nMessageFactory.CLASSES[Message.Type.VERSION] = VersionMessage;\nMessageFactory.CLASSES[Message.Type.INV] = InvMessage;\nMessageFactory.CLASSES[Message.Type.GET_DATA] = GetDataMessage;\nMessageFactory.CLASSES[Message.Type.GET_HEADER] = GetHeaderMessage;\nMessageFactory.CLASSES[Message.Type.NOT_FOUND] = NotFoundMessage;\nMessageFactory.CLASSES[Message.Type.BLOCK] = BlockMessage;\nMessageFactory.CLASSES[Message.Type.HEADER] = HeaderMessage;\nMessageFactory.CLASSES[Message.Type.TX] = TxMessage;\nMessageFactory.CLASSES[Message.Type.GET_BLOCKS] = GetBlocksMessage;\nMessageFactory.CLASSES[Message.Type.MEMPOOL] = MempoolMessage;\nMessageFactory.CLASSES[Message.Type.REJECT] = RejectMessage;\nMessageFactory.CLASSES[Message.Type.SUBSCRIBE] = SubscribeMessage;\nMessageFactory.CLASSES[Message.Type.ADDR] = AddrMessage;\nMessageFactory.CLASSES[Message.Type.GET_ADDR] = GetAddrMessage;\nMessageFactory.CLASSES[Message.Type.PING] = PingMessage;\nMessageFactory.CLASSES[Message.Type.PONG] = PongMessage;\nMessageFactory.CLASSES[Message.Type.SIGNAL] = SignalMessage;\nMessageFactory.CLASSES[Message.Type.GET_CHAIN_PROOF] = GetChainProofMessage;\nMessageFactory.CLASSES[Message.Type.CHAIN_PROOF] = ChainProofMessage;\nMessageFactory.CLASSES[Message.Type.GET_ACCOUNTS_PROOF] = GetAccountsProofMessage;\nMessageFactory.CLASSES[Message.Type.ACCOUNTS_PROOF] = AccountsProofMessage;\nMessageFactory.CLASSES[Message.Type.GET_ACCOUNTS_TREE_CHUNK] = GetAccountsTreeChunkMessage;\nMessageFactory.CLASSES[Message.Type.ACCOUNTS_TREE_CHUNK] = AccountsTreeChunkMessage;\nMessageFactory.CLASSES[Message.Type.GET_TRANSACTIONS_PROOF] = GetTransactionsProofMessage;\nMessageFactory.CLASSES[Message.Type.TRANSACTIONS_PROOF] = TransactionsProofMessage;\nMessageFactory.CLASSES[Message.Type.GET_TRANSACTION_RECEIPTS] = GetTransactionReceiptsMessage;\nMessageFactory.CLASSES[Message.Type.TRANSACTION_RECEIPTS] = TransactionReceiptsMessage;\nMessageFactory.CLASSES[Message.Type.GET_BLOCK_PROOF] = GetBlockProofMessage;\nMessageFactory.CLASSES[Message.Type.BLOCK_PROOF] = BlockProofMessage;\nMessageFactory.CLASSES[Message.Type.GET_HEAD] = GetHeadMessage;\nMessageFactory.CLASSES[Message.Type.HEAD] = HeadMessage;\nMessageFactory.CLASSES[Message.Type.VERACK] = VerAckMessage;\nClass.register(MessageFactory);\n","class WebRtcConnector extends Observable {\n    /**\n     * @constructor\n     * @param {NetworkConfig} networkConfig\n     */\n    constructor(networkConfig) {\n        super();\n\n        /** @type {NetworkConfig} */\n        this._networkConfig = networkConfig;\n\n        /** @type {HashMap.<PeerId,PeerConnector>} */\n        this._connectors = new HashMap();\n\n        /** @type {Timers} */\n        this._timers = new Timers();\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @param {PeerChannel} signalChannel\n     * @returns {boolean}\n     */\n    connect(peerAddress, signalChannel) {\n        if (peerAddress.protocol !== Protocol.RTC) throw 'Malformed peerAddress';\n\n        const peerId = peerAddress.peerId;\n        if (this._connectors.contains(peerId)) {\n            return false;\n        }\n\n        const connector = new OutboundPeerConnector(this._networkConfig, peerAddress, signalChannel);\n        connector.on('connection', conn => this._onConnection(conn, peerId));\n        this._connectors.put(peerId, connector);\n\n        this._timers.setTimeout(`connect_${peerId}`, () => {\n            this._connectors.remove(peerId);\n            this._timers.clearTimeout(`connect_${peerId}`);\n\n            connector.rtcConnection.close();\n\n            this.fire('error', peerAddress, 'timeout');\n        }, WebRtcConnector.CONNECT_TIMEOUT);\n\n        return true;\n    }\n\n    isValidSignal(msg) {\n        return this._connectors.contains(msg.senderId) && this._connectors.get(msg.senderId).nonce === msg.nonce;\n    }\n\n    onSignal(channel, msg) {\n        // Check if we received an unroutable/ttl exceeded response from one of the signaling peers.\n        if (msg.isUnroutable() || msg.isTtlExceeded()) {\n            // Clear the timeout early if we initiated the connection.\n            if (this.isValidSignal(msg) && this._connectors.get(msg.senderId) instanceof OutboundPeerConnector) {\n                const connector = this._connectors.get(msg.senderId);\n                const peerAddress = connector.peerAddress;\n\n                this._connectors.remove(msg.senderId);\n                this._timers.clearTimeout(`connect_${msg.senderId}`);\n\n                connector.rtcConnection.close();\n\n                // XXX Reason needs to be adapted when more flags are added.\n                const reason = msg.isUnroutable() ? 'unroutable' : 'ttl exceeded';\n                this.fire('error', peerAddress, reason);\n            }\n\n            return;\n        }\n\n        let payload;\n        try {\n            payload = JSON.parse(BufferUtils.toAscii(msg.payload));\n        } catch (e) {\n            Log.e(WebRtcConnector, `Failed to parse signal payload from ${msg.senderId}`);\n            return;\n        }\n\n        if (!payload) {\n            Log.d(WebRtcConnector, `Discarding signal from ${msg.senderId} - empty payload`);\n            return;\n        }\n\n        if (payload.type === 'offer') {\n            // Check if we have received an offer on an ongoing connection.\n            // This can happen if two peers initiate connections to one another\n            // simultaneously. Resolve this by having the peer with the higher\n            // peerId discard the offer while the one with the lower peerId\n            // accepts it.\n            /** @type {PeerConnector} */\n            let connector = this._connectors.get(msg.senderId);\n            if (connector) {\n                if (msg.recipientId.compare(msg.senderId) > 0) {\n                    // Discard the offer.\n                    Log.d(WebRtcConnector, `Simultaneous connection, discarding offer from ${msg.senderId} (<${msg.recipientId})`);\n                    return;\n                } else if (connector instanceof InboundPeerConnector) {\n                    // We have already seen an offer from this peer. Forward it to the existing connector.\n                    Log.w(WebRtcConnector, `Duplicate offer received from ${msg.senderId}`);\n                    connector.onSignal(payload);\n                    return;\n                } else {\n                    // We are going to accept the offer. Clear the connect timeout\n                    // from our previous outbound connection attempt to this peer.\n                    Log.d(WebRtcConnector, `Simultaneous connection, accepting offer from ${msg.senderId} (>${msg.recipientId})`);\n                    this._timers.clearTimeout(`connect_${msg.senderId}`);\n\n                    // Abort the outbound connection attempt.\n                    connector.rtcConnection.close();\n\n                    // Let listeners know that the connection attempt was aborted.\n                    this.fire('error', connector.peerAddress, 'simultaneous inbound connection');\n                }\n            }\n\n            // Accept the offer.\n            connector = new InboundPeerConnector(this._networkConfig, channel, msg.senderId, payload);\n            connector.on('connection', conn => this._onConnection(conn, msg.senderId));\n            this._connectors.put(msg.senderId, connector);\n\n            this._timers.setTimeout(`connect_${msg.senderId}`, () => {\n                this._timers.clearTimeout(`connect_${msg.senderId}`);\n                this._connectors.remove(msg.senderId);\n            }, WebRtcConnector.CONNECT_TIMEOUT);\n        }\n\n        // If we are already establishing a connection with the sender of this\n        // signal, forward it to the corresponding connector.\n        else if (this._connectors.contains(msg.senderId)) {\n            this._connectors.get(msg.senderId).onSignal(payload);\n        }\n\n        // If none of the above conditions is met, the signal is invalid and we discard it.\n    }\n\n    _onConnection(conn, peerId) {\n        // Clear the connect timeout.\n        this._timers.clearTimeout(`connect_${peerId}`);\n\n        // Clean up when this connection closes.\n        conn.on('close', () => this._onClose(peerId));\n\n        // Tell listeners about the new connection.\n        this.fire('connection', conn);\n    }\n\n    _onClose(peerId) {\n        this._connectors.remove(peerId);\n        this._timers.clearTimeout(`connect_${peerId}`);\n    }\n}\nWebRtcConnector.CONNECT_TIMEOUT = 8000; // ms\nClass.register(WebRtcConnector);\n\nclass PeerConnector extends Observable {\n    /**\n     * @param {NetworkConfig} networkConfig\n     * @param {PeerChannel} signalChannel\n     * @param {PeerId} peerId\n     * @param {PeerAddress} peerAddress\n     */\n    constructor(networkConfig, signalChannel, peerId, peerAddress) {\n        super();\n        /** @type {NetworkConfig} */\n        this._networkConfig = networkConfig;\n        /** @type {PeerChannel} */\n        this._signalChannel = signalChannel;\n        /** @type {PeerId} */\n        this._peerId = peerId;\n        /** @type {PeerAddress} */\n        this._peerAddress = peerAddress; // null for inbound connections\n\n        /** @type {number} */\n        this._nonce = NumberUtils.randomUint32();\n\n        /** @type {RTCPeerConnection} */\n        this._rtcConnection = WebRtcFactory.newPeerConnection(this._networkConfig.rtcConfig);\n        this._rtcConnection.onicecandidate = e => this._onIceCandidate(e);\n\n        this._lastIceCandidate = null;\n        this._iceCandidateQueue = [];\n    }\n\n    onSignal(signal) {\n        if (signal.sdp) {\n            this._rtcConnection.setRemoteDescription(WebRtcFactory.newSessionDescription(signal))\n                .then(() => {\n                    if (signal.type === 'offer') {\n                        this._rtcConnection.createAnswer()\n                            .then(description => this._onDescription(description))\n                            .catch(Log.e.tag(PeerConnector));\n                    }\n\n                    this._handleCandidateQueue().catch(Log.w.tag(PeerConnector));\n                })\n                .catch(Log.e.tag(PeerConnector));\n        } else if (signal.candidate) {\n            this._addIceCandidate(signal).catch(Log.w.tag(PeerConnector));\n        }\n    }\n\n    /**\n     * @param {*} signal\n     * @returns {Promise}\n     * @private\n     */\n    _addIceCandidate(signal) {\n        this._lastIceCandidate = WebRtcFactory.newIceCandidate(signal);\n\n        // Do not try to add ICE candidates before the remote description is set.\n        if (!this._rtcConnection.remoteDescription || !this._rtcConnection.remoteDescription.type) {\n            this._iceCandidateQueue.push(signal);\n            return Promise.resolve();\n        }\n\n        return this._rtcConnection.addIceCandidate(this._lastIceCandidate)\n            .catch(Log.e.tag(PeerConnector));\n    }\n\n    async _handleCandidateQueue() {\n        // Handle ICE candidates if they already arrived.\n        for (const candidate of this._iceCandidateQueue) {\n            await this._addIceCandidate(candidate);\n        }\n        this._iceCandidateQueue = [];\n    }\n\n    _signal(signal) {\n        const payload = BufferUtils.fromAscii(JSON.stringify(signal));\n        const keyPair = this._networkConfig.keyPair;\n        const peerId = this._networkConfig.peerId;\n        this._signalChannel.signal(\n            peerId,\n            this._peerId,\n            this._nonce,\n            Network.SIGNAL_TTL_INITIAL,\n            0, /*flags*/\n            payload,\n            keyPair.publicKey,\n            Signature.create(keyPair.privateKey, keyPair.publicKey, payload)\n        );\n    }\n\n    _onIceCandidate(event) {\n        if (event.candidate !== null) {\n            this._signal(event.candidate);\n        }\n    }\n\n    _onDescription(description) {\n        this._rtcConnection.setLocalDescription(description)\n            .then(() => this._signal(this._rtcConnection.localDescription))\n            .catch(Log.e.tag(PeerConnector));\n    }\n\n    _onDataChannel(event) {\n        const channel = new WebRtcDataChannel(event.channel || event.target);\n\n        // Make sure to close the corresponding RTCPeerConnection when the RTCDataChannel is closed\n        channel.on('close', () => this._rtcConnection.close());\n\n        // There is no API to get the remote IP address. As a crude heuristic, we parse the IP address\n        // from the last ICE candidate seen before the connection was established.\n        // TODO Can we improve this?\n        let netAddress = null;\n        if (this._lastIceCandidate) {\n            try {\n                netAddress = WebRtcUtils.candidateToNetAddress(this._lastIceCandidate);\n            } catch (e) {\n                Log.w(PeerConnector, `Failed to parse IP from ICE candidate: ${this._lastIceCandidate}`);\n            }\n        } else {\n            // XXX Why does this happen?\n            Log.w(PeerConnector, 'No ICE candidate seen for inbound connection');\n        }\n\n        const conn = new NetworkConnection(channel, Protocol.RTC, netAddress, this._peerAddress);\n        this.fire('connection', conn);\n    }\n\n    get nonce() {\n        return this._nonce;\n    }\n\n    get peerAddress() {\n        return this._peerAddress;\n    }\n\n    get rtcConnection() {\n        return this._rtcConnection;\n    }\n}\nClass.register(PeerConnector);\n\nclass OutboundPeerConnector extends PeerConnector {\n    constructor(webRtcConfig, peerAddress, signalChannel) {\n        super(webRtcConfig, signalChannel, peerAddress.peerId, peerAddress);\n        this._peerAddress = peerAddress;\n\n        // Create offer.\n        const channel = this._rtcConnection.createDataChannel('data-channel');\n        channel.binaryType = 'arraybuffer';\n        channel.onopen = e => this._onDataChannel(e);\n        this._rtcConnection.createOffer()\n            .then(description => this._onDescription(description))\n            .catch(Log.e.tag(OutboundPeerConnector));\n    }\n}\nClass.register(OutboundPeerConnector);\n\nclass InboundPeerConnector extends PeerConnector {\n    constructor(webRtcConfig, signalChannel, peerId, offer) {\n        super(webRtcConfig, signalChannel, peerId, null);\n        this._rtcConnection.ondatachannel = event => {\n            event.channel.onopen = e => this._onDataChannel(e);\n        };\n        this.onSignal(offer);\n    }\n}\nClass.register(InboundPeerConnector);\n","class WebRtcDataChannel extends DataChannel {\n    /**\n     * @param {RTCDataChannel} nativeChannel\n     */\n    constructor(nativeChannel) {\n        super();\n        // We expect WebRtc data channels to be ordered.\n        Assert.that(nativeChannel.ordered, 'WebRtc data channel not ordered');\n        /** @type {RTCDataChannel} */\n        this._channel = nativeChannel;\n\n        this._channel.onmessage = msg => this._onMessage(msg.data || msg);\n        this._channel.onclose = () => this._onClose();\n        this._channel.onerror = e => this.fire('error', e, this);\n    }\n\n    /**\n     * @param {ArrayBuffer} msg\n     * @protected\n     * @override\n     */\n    _onMessage(msg) {\n        // FIXME It seems that Firefox still sometimes receives blobs instead of ArrayBuffers on RTC connections.\n        // FIXME FileReader is async and may RE-ORDER MESSAGES!\n        if (msg instanceof Blob) {\n            const reader = new FileReader();\n            reader.onloadend = () => super._onMessage(reader.result);\n            reader.readAsArrayBuffer(msg);\n        } else {\n            super._onMessage(msg);\n        }\n    }\n    /**\n     * @override\n     */\n    sendChunk(msg) {\n        this._channel.send(msg);\n    }\n\n    /**\n     * @override\n     */\n    close() {\n        this._channel.close();\n    }\n\n    /**\n     * @override\n     */\n    get readyState() {\n        return DataChannel.ReadyState.fromString(this._channel.readyState);\n    }\n}\n\nClass.register(WebRtcDataChannel);\n","class WebRtcUtils {\n    static candidateToNetAddress(candidate) {\n        // TODO XXX Ad-hoc parsing of candidates - Improve!\n        const parts = candidate.candidate.split(' ');\n        if (parts.length < 6) {\n            return null;\n        }\n        // XXX The IP obtained from the ice candidate is not really reliable.\n        // But for the time being, we treat it as such as it only affects browser clients,\n        // which cannot obtain a more reliable form of net addresses.\n        return NetAddress.fromIP(parts[4], true);\n    }\n}\nClass.register(WebRtcUtils);\n","class WebSocketConnector extends Observable {\n    /**\n     * @constructor\n     * @param {NetworkConfig} networkConfig\n     * @listens WebSocketServer#connection\n     */\n    constructor(networkConfig) {\n        super();\n        this._networkConfig = networkConfig;\n\n        if (networkConfig.peerAddress.protocol === Protocol.WS) {\n            this._wss = WebSocketFactory.newWebSocketServer(networkConfig);\n            this._wss.on('connection', ws => this._onConnection(ws));\n\n            Log.d(WebSocketConnector, `WebSocketConnector listening on port ${networkConfig.peerAddress.port}`);\n        }\n\n        /** @type {HashMap.<PeerAddress, WebSocket>} */\n        this._sockets = new HashMap();\n\n        /** @type {Timers} */\n        this._timers = new Timers();\n    }\n\n    /**\n     * @fires WebSocketConnector#connection\n     * @fires WebSocketConnector#error\n     * @param {PeerAddress} peerAddress\n     * @returns {boolean}\n     */\n    connect(peerAddress) {\n        if (peerAddress.protocol !== Protocol.WS) throw 'Malformed peerAddress';\n\n        const timeoutKey = `connect_${peerAddress}`;\n        if (this._timers.timeoutExists(timeoutKey)) {\n            Log.w(WebSocketConnector, `Already connecting to ${peerAddress}`);\n            return false;\n        }\n\n        const ws = WebSocketFactory.newWebSocket(`wss://${peerAddress.host}:${peerAddress.port}`, {\n            handshakeTimeout: WebSocketConnector.CONNECT_TIMEOUT\n        }, this._networkConfig);\n        ws.binaryType = 'arraybuffer';\n        ws.onopen = () => {\n            this._timers.clearTimeout(timeoutKey);\n            this._sockets.remove(peerAddress);\n\n            // Don't fire error events after the connection has been established.\n            ws.onerror = () => {};\n\n            // There is no way to determine the remote IP in the browser ... thanks for nothing, WebSocket API.\n            const netAddress = (ws._socket && ws._socket.remoteAddress) ? NetAddress.fromIP(ws._socket.remoteAddress, true) : null;\n            const conn = new NetworkConnection(new WebSocketDataChannel(ws), Protocol.WS, netAddress, peerAddress);\n            this.fire('connection', conn);\n        };\n        ws.onerror = e => {\n            this._timers.clearTimeout(timeoutKey);\n            this._sockets.remove(peerAddress);\n\n            /**\n             * Tell listeners that an error has ocurred.\n             * @event WebSocketConnector#error\n             */\n            this.fire('error', peerAddress, e);\n        };\n\n        this._sockets.put(peerAddress, ws);\n\n        this._timers.setTimeout(timeoutKey, () => {\n            this._timers.clearTimeout(timeoutKey);\n            this._sockets.remove(peerAddress);\n\n            // We don't want to fire the error event again if the websocket\n            // connect fails at a later time.\n            ws.onerror = () => {};\n\n            // If the connection succeeds after we have fired the error event,\n            // close it.\n            ws.onopen = () => {\n                Log.d(WebSocketConnector, () => `Connection to ${peerAddress} succeeded after timeout - closing it`);\n                ws.close();\n            };\n\n            /**\n             * Tell listeners that a timeout error has occurred.\n             * @event WebSocketConnector#error\n             */\n            this.fire('error', peerAddress, 'timeout');\n        }, WebSocketConnector.CONNECT_TIMEOUT);\n\n        return true;\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @fires WebSocketConnector#error\n     * @returns {void}\n     */\n    abort(peerAddress) {\n        const ws = this._sockets.get(peerAddress);\n        if (!ws) {\n            return;\n        }\n\n        this._timers.clearTimeout(`connect_${peerAddress}`);\n        this._sockets.remove(peerAddress);\n\n        ws.onerror = () => {};\n        ws.onopen = () => {\n            Log.d(WebSocketConnector, () => `Connection to ${peerAddress} succeeded after aborting - closing it`);\n            ws.close();\n        };\n        ws.close();\n\n        /**\n         * Tell listeners that the connection attempt has been aborted.\n         * @event WebSocketConnector#error\n         */\n        this.fire('error', peerAddress, 'aborted');\n    }\n\n    /**\n     * @fires WebSocketConnector#connection\n     * @param {WebSocket} ws\n     * @returns {void}\n     */\n    _onConnection(ws) {\n        const netAddress = NetAddress.fromIP(ws._socket.remoteAddress, true);\n        const conn = new NetworkConnection(new WebSocketDataChannel(ws), Protocol.WS, netAddress, /*peerAddress*/ null);\n\n        /**\n        * Tell listeners that an initial connection to a peer has been established.\n        * @event WebSocketConnector#connection\n        */\n        this.fire('connection', conn);\n    }\n}\nWebSocketConnector.CONNECT_TIMEOUT = 1000 * 5; // 5 seconds\nClass.register(WebSocketConnector);\n","class WebSocketDataChannel extends DataChannel {\n    /**\n     * @param {WebSocket} ws\n     */\n    constructor(ws) {\n        super();\n        /** @type {WebSocket} */\n        this._ws = ws;\n        this._ws.onmessage = msg => this._onMessage(msg.data || msg);\n        this._ws.onclose = () => this._onClose();\n        this._ws.onerror = e => this.fire('error', e);\n    }\n\n    /**\n     * @override\n     */\n    close() {\n        this._ws.close();\n    }\n\n    /**\n     * @override\n     * @param {Uint8Array} msg\n     */\n    sendChunk(msg) {\n        this._ws.send(msg);\n    }\n\n    /**\n     * @override\n     * @type {DataChannel.ReadyState}\n     */\n    get readyState() {\n        return /** @type {DataChannel.ReadyState} */ this._ws.readyState;\n    }\n}\n\nClass.register(WebSocketDataChannel);\n","class NetAddress {\n    /**\n     * @param {string} ip\n     * @param {boolean} reliable\n     * @return {NetAddress}\n     */\n    static fromIP(ip, reliable = false) {\n        const saneIp = NetUtils.ipToBytes(ip);\n        const type = NetUtils.isIPv4Address(saneIp) ? NetAddress.Type.IPv4 : NetAddress.Type.IPv6;\n        return new NetAddress(type, saneIp, reliable);\n    }\n\n    /**\n     * @param {NetAddress.Type} type\n     * @param {Uint8Array} ipArray\n     * @param {boolean} reliable\n     */\n    constructor(type, ipArray = null, reliable = false) {\n        switch (type) {\n            case NetAddress.Type.IPv4:\n                if (!(ipArray instanceof Uint8Array) || ipArray.length !== NetUtils.IPv4_LENGTH) throw new Error('Malformed ip');\n                break;\n            case NetAddress.Type.IPv6:\n                if (!(ipArray instanceof Uint8Array) || ipArray.length !== NetUtils.IPv6_LENGTH) throw new Error('Malformed ip');\n                break;\n            case NetAddress.Type.UNKNOWN:\n            case NetAddress.Type.UNSPECIFIED:\n                ipArray = null;\n                break;\n            default:\n                throw new Error('Malformed type');\n        }\n\n        /** @type {NetAddress.Type} */\n        this._type = type;\n        /** @type {Uint8Array} */\n        this._ip = ipArray;\n        /** @type {boolean} */\n        this._reliable = reliable;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @return {NetAddress}\n     */\n    static unserialize(buf) {\n        const type = /** @type {NetAddress.Type} */ buf.readUint8();\n\n        let ipArray = null;\n        switch (type) {\n            case NetAddress.Type.IPv4:\n                ipArray = buf.read(NetUtils.IPv4_LENGTH);\n                break;\n            case NetAddress.Type.IPv6:\n                ipArray = buf.read(NetUtils.IPv6_LENGTH);\n                break;\n        }\n\n        return new NetAddress(type, ipArray);\n    }\n\n    /**\n     * @param {?SerialBuffer} [buf]\n     * @return {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._type);\n        if (this._ip) {\n            buf.write(this._ip);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*type*/ 1\n            + (this._ip ? this._ip.length : 0);\n    }\n\n    /**\n     * @param {NetAddress} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof NetAddress\n            && this._type === o._type\n            && BufferUtils.equals(this._ip, o.ip);\n    }\n\n    hashCode() {\n        return this.toString();\n    }\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        if (this._type === NetAddress.Type.UNKNOWN) return '<unknown>';\n        if (this._type === NetAddress.Type.UNSPECIFIED) return '';\n        return NetUtils.bytesToIp(this._ip);\n    }\n\n    /** @type {Uint8Array} */\n    get ip() {\n        return this._ip;\n    }\n\n    /** @type {NetAddress.Type} */\n    get type() {\n        return this._type;\n    }\n\n    /** @type {boolean} */\n    get reliable() {\n        return this._reliable;\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isPseudo() {\n        return !this._ip;\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isPrivate() {\n        return this.isPseudo() || NetUtils.isPrivateIP(this._ip);\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isIPv6() {\n        return this._ip && NetUtils.isIPv6Address(this._ip);\n    }\n\n    /**\n     * @return {boolean}\n     */\n    isIPv4() {\n        return this._ip && NetUtils.isIPv4Address(this._ip);\n    }\n\n    /**\n     * @param {number} bitCount\n     * @return {NetAddress}\n     */\n    subnet(bitCount) {\n        const ip = this._ip ? NetUtils.ipToSubnet(this._ip, bitCount) : null;\n        return new NetAddress(this._type, ip, this._reliable);\n    }\n}\n/** @enum {number} */\nNetAddress.Type = {\n    IPv4: 0,\n    IPv6: 1,\n    UNSPECIFIED: 2,\n    UNKNOWN: 3\n};\nNetAddress.UNSPECIFIED = new NetAddress(NetAddress.Type.UNSPECIFIED);\nNetAddress.UNKNOWN = new NetAddress(NetAddress.Type.UNKNOWN);\nClass.register(NetAddress);\n","class PeerId extends Serializable {\n    /**\n     * @param {PeerId} o\n     * @returns {PeerId}\n     */\n    static copy(o) {\n        if (!o) return o;\n        const obj = new Uint8Array(o._obj);\n        return new PeerId(obj);\n    }\n\n    constructor(arg) {\n        super();\n        if (!(arg instanceof Uint8Array)) throw new Error('Primitive: Invalid type');\n        if (arg.length !== PeerId.SERIALIZED_SIZE) throw new Error('Primitive: Invalid length');\n        this._obj = arg;\n    }\n\n    /**\n     * Create Address object from binary form.\n     * @param {SerialBuffer} buf Buffer to read from.\n     * @return {PeerId} Newly created Account object.\n     */\n    static unserialize(buf) {\n        return new PeerId(buf.read(PeerId.SERIALIZED_SIZE));\n    }\n\n    /**\n     * Serialize this Address object into binary form.\n     * @param {?SerialBuffer} [buf] Buffer to write to.\n     * @return {SerialBuffer} Buffer from `buf` or newly generated one.\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.write(this._obj);\n        return buf;\n    }\n\n    subarray(begin, end) {\n        return this._obj.subarray(begin, end);\n    }\n\n    /**\n     * @type {number}\n     */\n    get serializedSize() {\n        return PeerId.SERIALIZED_SIZE;\n    }\n\n    /**\n     * @param {Serializable} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PeerId\n            && super.equals(o);\n    }\n\n    /**\n     * @returns {string}\n     * @override\n     */\n    toString() {\n        return this.toHex();\n    }\n\n    /**\n     * @param {string} base64\n     * @return {PeerId}\n     */\n    static fromBase64(base64) {\n        return new PeerId(BufferUtils.fromBase64(base64));\n    }\n\n    /**\n     * @param {string} hex\n     * @return {PeerId}\n     */\n    static fromHex(hex) {\n        return new PeerId(BufferUtils.fromHex(hex));\n    }\n}\n\nPeerId.SERIALIZED_SIZE = 16;\nClass.register(PeerId);\n","class PeerAddress {\n    /**\n     * @param {number} protocol\n     * @param {number} services\n     * @param {number} timestamp\n     * @param {NetAddress} netAddress\n     * @param {PublicKey} publicKey\n     * @param {number} distance\n     * @param {Signature} [signature]\n     */\n    constructor(protocol, services, timestamp, netAddress, publicKey, distance, signature) {\n        if (!NumberUtils.isUint8(distance)) throw new Error('Malformed distance');\n        if (publicKey !== null && !(publicKey instanceof PublicKey)) throw new Error('Malformed publicKey');\n\n        /** @type {number} */\n        this._protocol = protocol;\n        /** @type {number} */\n        this._services = services;\n        /** @type {number} */\n        this._timestamp = timestamp;\n        /** @type {NetAddress} */\n        this._netAddress = netAddress || NetAddress.UNSPECIFIED;\n        /** @type {PublicKey} */\n        this._publicKey = publicKey;\n        /** @type {number} */\n        this._distance = distance;\n        /** @type {?Signature} */\n        this._signature = signature;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {PeerAddress}\n     */\n    static unserialize(buf) {\n        const protocol = buf.readUint8();\n        switch (protocol) {\n            case Protocol.WS:\n                return WsPeerAddress.unserialize(buf);\n\n            case Protocol.RTC:\n                return RtcPeerAddress.unserialize(buf);\n\n            case Protocol.DUMB:\n                return DumbPeerAddress.unserialize(buf);\n\n            default:\n                throw `Malformed PeerAddress protocol ${protocol}`;\n        }\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        if (!this._publicKey) throw new Error('PeerAddress without publicKey may not be serialized.');\n        if (!this._signature) throw new Error('PeerAddress without signature may not be serialized.');\n\n        buf = buf || new SerialBuffer(this.serializedSize);\n        buf.writeUint8(this._protocol);\n        buf.writeUint32(this._services);\n        buf.writeUint64(this._timestamp);\n\n        // Never serialize private netAddresses.\n        if (this._netAddress.isPrivate()) {\n            NetAddress.UNSPECIFIED.serialize(buf);\n        } else {\n            this._netAddress.serialize(buf);\n        }\n\n        this._publicKey.serialize(buf);\n        buf.writeUint8(this._distance);\n        this._signature.serialize(buf);\n\n        return buf;\n    }\n\n    serializeContent(buf) {\n        buf = buf || new SerialBuffer(this.serializedContentSize);\n\n        buf.writeUint8(this._protocol);\n        buf.writeUint32(this._services);\n        buf.writeUint64(this._timestamp);\n\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return /*protocol*/ 1\n            + /*services*/ 4\n            + /*timestamp*/ 8\n            + this._netAddress.serializedSize\n            + this._publicKey.serializedSize\n            + /*distance*/ 1\n            + this._signature.serializedSize;\n    }\n\n    /** @type {number} */\n    get serializedContentSize() {\n        return /*protocol*/ 1\n            + /*services*/ 4\n            + /*timestamp*/ 8;\n    }\n\n    /**\n     * @param {PeerAddress|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        // We consider peer addresses to be equal if the public key or peer id is not known on one of them:\n        // Peers from the network always contain a peer id and public key, peers without peer id or public key\n        // are always set by the user.\n        return o instanceof PeerAddress\n            && this.protocol === o.protocol\n            && (!this.publicKey || !o.publicKey || this.publicKey.equals(o.publicKey))\n            && (!this.peerId || !o.peerId || this.peerId.equals(o.peerId))\n            /* services is ignored */\n            /* timestamp is ignored */\n            /* netAddress is ignored */\n            /* distance is ignored */;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    verifySignature() {\n        if (this._signatureVerified === undefined) {\n            this._signatureVerified = this.signature.verify(this.publicKey, this.serializeContent());\n        }\n        return this._signatureVerified;\n    }\n\n    /** @type {number} */\n    get protocol() {\n        return this._protocol;\n    }\n\n    /** @type {number} */\n    get services() {\n        return this._services;\n    }\n\n    /** @type {number} */\n    get timestamp() {\n        return this._timestamp;\n    }\n\n    /** @type {NetAddress} */\n    get netAddress() {\n        return this._netAddress.isPseudo() ? null : this._netAddress;\n    }\n\n    /** @type {NetAddress} */\n    set netAddress(value) {\n        this._netAddress = value || NetAddress.UNSPECIFIED;\n    }\n\n    /** @type {PublicKey} */\n    get publicKey() {\n        return this._publicKey;\n    }\n\n    /** @type {PeerId} */\n    get peerId() {\n        return this._publicKey ? this._publicKey.toPeerId() : null;\n    }\n\n    /** @type {number} */\n    get distance() {\n        return this._distance;\n    }\n\n    /** @type {Signature} */\n    get signature() {\n        return this._signature;\n    }\n\n    /** @type {Signature} */\n    set signature(signature) {\n        // Never change the signature of a remote address.\n        if (this._distance !== 0) {\n            return;\n        }\n\n        this._signature = signature;\n        this._signatureVerified = undefined;\n    }\n\n    // Changed when passed on to other peers.\n    /** @type {number} */\n    set distance(value) {\n        this._distance = value;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isSeed() {\n        return this._timestamp === 0;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    exceedsAge() {\n        // Seed addresses are never too old.\n        if (this.isSeed()) {\n            return false;\n        }\n\n        const age = Date.now() - this.timestamp;\n        switch (this.protocol) {\n            case Protocol.WS:\n                return age > PeerAddressBook.MAX_AGE_WEBSOCKET;\n\n            case Protocol.RTC:\n                return age > PeerAddressBook.MAX_AGE_WEBRTC;\n\n            case Protocol.DUMB:\n                return age > PeerAddressBook.MAX_AGE_DUMB;\n        }\n        return false;\n    }\n\n}\n\nClass.register(PeerAddress);\n\nclass WsPeerAddress extends PeerAddress {\n    /**\n     * @param {string} host\n     * @param {number} port\n     * @param {string} [publicKeyHex]\n     * @returns {WsPeerAddress}\n     */\n    static seed(host, port, publicKeyHex) {\n        const publicKey = publicKeyHex ? new PublicKey(BufferUtils.fromHex(publicKeyHex)) : null;\n        return new WsPeerAddress(Services.FULL, /*timestamp*/ 0, NetAddress.UNSPECIFIED, publicKey, 0, host, port);\n    }\n\n    /**\n     * @param {number} services\n     * @param {number} timestamp\n     * @param {NetAddress} netAddress\n     * @param {PublicKey} publicKey\n     * @param {number} distance\n     * @param {string} host\n     * @param {number} port\n     * @param {Signature} [signature]\n     */\n    constructor(services, timestamp, netAddress, publicKey, distance, host, port, signature) {\n        super(Protocol.WS, services, timestamp, netAddress, publicKey, distance, signature);\n        if (!host) throw new Error('Malformed host');\n        if (!NumberUtils.isUint16(port)) throw new Error('Malformed port');\n        this._host = host;\n        this._port = port;\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {WsPeerAddress}\n     */\n    static unserialize(buf) {\n        const services = buf.readUint32();\n        const timestamp = buf.readUint64();\n        const netAddress = NetAddress.unserialize(buf);\n        const publicKey = PublicKey.unserialize(buf);\n        const distance = buf.readUint8();\n        const signature = Signature.unserialize(buf);\n        const host = buf.readVarLengthString();\n        const port = buf.readUint16();\n        return new WsPeerAddress(services, timestamp, netAddress, publicKey, distance, host, port, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        buf.writeVarLengthString(this._host);\n        buf.writeUint16(this._port);\n        return buf;\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serializeContent(buf) {\n        buf = buf || new SerialBuffer(this.serializedContentSize);\n        super.serializeContent(buf);\n        buf.writeVarLengthString(this._host);\n        buf.writeUint16(this._port);\n        return buf;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    globallyReachable() {\n        return NetUtils.hostGloballyReachable(this.host);\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize\n            + SerialBuffer.varLengthStringSize(this._host)\n            + /*port*/ 2;\n    }\n\n    /** @type {number} */\n    get serializedContentSize() {\n        return super.serializedContentSize\n            + SerialBuffer.varLengthStringSize(this._host)\n            + /*port*/ 2;\n    }\n\n    /**\n     * @override\n     * @param {PeerAddress|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return super.equals(o)\n            && o instanceof WsPeerAddress\n            && ((!!this.peerId && !!o.peerId) || (this._host === o.host && this._port === o.port));\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this.peerId\n            ? `wss:///${this.peerId}`\n            : `wss://${this._host}:${this._port}/`;\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `wss://${this._host}:${this._port}/${this.peerId ? this.peerId : ''}`;\n    }\n\n    /**\n     * @returns {WsPeerAddress}\n     */\n    withoutId() {\n        return new WsPeerAddress(this.services, this.timestamp, this.netAddress, null, this.distance, this.host, this.port);\n    }\n\n    /** @type {string} */\n    get host() {\n        return this._host;\n    }\n\n    /** @type {number} */\n    get port() {\n        return this._port;\n    }\n}\n\nClass.register(WsPeerAddress);\n\nclass RtcPeerAddress extends PeerAddress {\n    /**\n     * @param {number} services\n     * @param {number} timestamp\n     * @param {NetAddress} netAddress\n     * @param {PublicKey} publicKey\n     * @param {number} distance\n     * @param {Signature} [signature]\n     */\n    constructor(services, timestamp, netAddress, publicKey, distance, signature) {\n        super(Protocol.RTC, services, timestamp, netAddress, publicKey, distance, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {RtcPeerAddress}\n     */\n    static unserialize(buf) {\n        const services = buf.readUint32();\n        const timestamp = buf.readUint64();\n        const netAddress = NetAddress.unserialize(buf);\n        const publicKey = PublicKey.unserialize(buf);\n        const distance = buf.readUint8();\n        const signature = Signature.unserialize(buf);\n        return new RtcPeerAddress(services, timestamp, netAddress, publicKey, distance, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize;\n    }\n\n    /**\n     * @override\n     * @param {PeerAddress|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return super.equals(o)\n            && o instanceof RtcPeerAddress;\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this.toString();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `rtc:///${this.peerId}`;\n    }\n}\n\nClass.register(RtcPeerAddress);\n\nclass DumbPeerAddress extends PeerAddress {\n    /**\n     * @param {number} services\n     * @param {number} timestamp\n     * @param {NetAddress} netAddress\n     * @param {PublicKey} publicKey\n     * @param {number} distance\n     * @param {Signature} [signature]\n     */\n    constructor(services, timestamp, netAddress, publicKey, distance, signature) {\n        super(Protocol.DUMB, services, timestamp, netAddress, publicKey, distance, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} buf\n     * @returns {DumbPeerAddress}\n     */\n    static unserialize(buf) {\n        const services = buf.readUint32();\n        const timestamp = buf.readUint64();\n        const netAddress = NetAddress.unserialize(buf);\n        const publicKey = PublicKey.unserialize(buf);\n        const distance = buf.readUint8();\n        const signature = Signature.unserialize(buf);\n        return new DumbPeerAddress(services, timestamp, netAddress, publicKey, distance, signature);\n    }\n\n    /**\n     * @param {SerialBuffer} [buf]\n     * @returns {SerialBuffer}\n     */\n    serialize(buf) {\n        buf = buf || new SerialBuffer(this.serializedSize);\n        super.serialize(buf);\n        return buf;\n    }\n\n    /** @type {number} */\n    get serializedSize() {\n        return super.serializedSize;\n    }\n\n    /**\n     * @override\n     * @param {PeerAddress} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return super.equals(o)\n            && o instanceof DumbPeerAddress;\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this.toString();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `dumb:///${this.peerId}`;\n    }\n}\n\nClass.register(DumbPeerAddress);\n","class PeerAddressState {\n    /**\n     * @param {PeerAddress} peerAddress\n     */\n    constructor(peerAddress) {\n        /** @type {PeerAddress} */\n        this.peerAddress = peerAddress;\n\n        /** @type {number} */\n        this.state = PeerAddressState.NEW;\n        /** @type {number} */\n        this.lastConnected = -1;\n        /** @type {number} */\n        this.bannedUntil = -1;\n        /** @type {number} */\n        this.banBackoff = PeerAddressBook.INITIAL_FAILED_BACKOFF;\n\n        /** @type {SignalRouter} */\n        this._signalRouter = new SignalRouter(peerAddress);\n\n        /** @type {number} */\n        this._failedAttempts = 0;\n\n        /**\n         * Map from closeType to number of occurrences\n         * @type {Map.<number,number>}\n         * @private\n         */\n        this._closeTypes = new Map();\n\n        /**\n         * @type {HashSet.<NetAddress>}\n         * @private\n         */\n        this._addedBy = new HashSet();\n    }\n\n    /** @type {SignalRouter} */\n    get signalRouter() {\n        return this._signalRouter;\n    }\n\n    /** @type {number} */\n    get maxFailedAttempts() {\n        switch (this.peerAddress.protocol) {\n            case Protocol.RTC:\n                return PeerAddressBook.MAX_FAILED_ATTEMPTS_RTC;\n            case Protocol.WS:\n                return PeerAddressBook.MAX_FAILED_ATTEMPTS_WS;\n            default:\n                return 0;\n        }\n    }\n\n    /** @type {number} */\n    get failedAttempts() {\n        if (this._signalRouter.bestRoute) {\n            return this._signalRouter.bestRoute.failedAttempts;\n        } else {\n            return this._failedAttempts;\n        }\n    }\n\n    /** @type {number} */\n    set failedAttempts(value) {\n        if (this._signalRouter.bestRoute) {\n            this._signalRouter.bestRoute.failedAttempts = value;\n            this._signalRouter.updateBestRoute(); // scores may have changed\n        } else {\n            this._failedAttempts = value;\n        }\n    }\n\n    /**\n     * @param {number} type\n     */\n    close(type) {\n        if (!type) return;\n\n        if (this._closeTypes.has(type)) {\n            this._closeTypes.set(type, this._closeTypes.get(type) + 1);\n        } else {\n            this._closeTypes.set(type, 1);\n        }\n\n        if (this.state === PeerAddressState.BANNED) {\n            return;\n        }\n\n        if (CloseType.isBanningType(type)) {\n            this.state = PeerAddressState.BANNED;\n        } else if (CloseType.isFailingType(type)) {\n            this.state = PeerAddressState.FAILED;\n        } else {\n            this.state = PeerAddressState.TRIED;\n        }\n    }\n\n    /**\n     * @param {PeerAddressState|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof PeerAddressState\n            && this.peerAddress.equals(o.peerAddress);\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this.peerAddress.hashCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `PeerAddressState{peerAddress=${this.peerAddress}, state=${this.state}, `\n            + `lastConnected=${this.lastConnected}, failedAttempts=${this.failedAttempts}, `\n            + `bannedUntil=${this.bannedUntil}}`;\n    }\n\n    /** @type {HashSet.<NetAddress>} */\n    get addedBy() {\n        return this._addedBy;\n    }\n}\nPeerAddressState.NEW = 1;\nPeerAddressState.ESTABLISHED = 2;\nPeerAddressState.TRIED = 3;\nPeerAddressState.FAILED = 4;\nPeerAddressState.BANNED = 5;\nClass.register(PeerAddressState);\n\nclass SignalRouter {\n    /**\n     * @constructor\n     * @param {PeerAddress} peerAddress\n     */\n    constructor(peerAddress) {\n        /** @type {PeerAddress} */\n        this.peerAddress = peerAddress;\n\n        /** @type {SignalRoute} */\n        this._bestRoute = null;\n        /** @type {HashSet.<SignalRoute>} */\n        this._routes = new HashSet();\n    }\n\n    /** @type {SignalRoute} */\n    get bestRoute() {\n        return this._bestRoute;\n    }\n\n    /**\n     * @param {PeerChannel} signalChannel\n     * @param {number} distance\n     * @param {number} timestamp\n     * @returns {boolean} whether we have a new best route\n     */\n    addRoute(signalChannel, distance, timestamp) {\n        const oldRoute = this._routes.get(signalChannel);\n        const newRoute = new SignalRoute(signalChannel, distance, timestamp);\n\n        if (oldRoute) {\n            // Do not reset failed attempts.\n            newRoute.failedAttempts = oldRoute.failedAttempts;\n        }\n        this._routes.add(newRoute);\n\n        if (!this._bestRoute || newRoute.score > this._bestRoute.score\n            || (newRoute.score === this._bestRoute.score && timestamp > this._bestRoute.timestamp)) {\n\n            this._bestRoute = newRoute;\n            this.peerAddress.distance = this._bestRoute.distance;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @returns {void}\n     */\n    deleteBestRoute() {\n        if (this._bestRoute) {\n            this.deleteRoute(this._bestRoute.signalChannel);\n        }\n    }\n\n    /**\n     * @param {PeerChannel} signalChannel\n     * @returns {void}\n     */\n    deleteRoute(signalChannel) {\n        this._routes.remove(signalChannel); // maps to same hashCode\n        if (this._bestRoute && this._bestRoute.signalChannel.equals(signalChannel)) {\n            this.updateBestRoute();\n        }\n    }\n\n    /**\n     * @returns {void}\n     */\n    deleteAllRoutes() {\n        this._bestRoute = null;\n        this._routes = new HashSet();\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    hasRoute() {\n        return this._routes.length > 0;\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    updateBestRoute() {\n        let bestRoute = null;\n        // Choose the route with minimal distance and maximal timestamp.\n        for (const route of this._routes.values()) {\n            if (bestRoute === null || route.score > bestRoute.score\n                || (route.score === bestRoute.score && route.timestamp > bestRoute.timestamp)) {\n\n                bestRoute = route;\n            }\n        }\n        this._bestRoute = bestRoute;\n        if (this._bestRoute) {\n            this.peerAddress.distance = this._bestRoute.distance;\n        } else {\n            this.peerAddress.distance = PeerAddressBook.MAX_DISTANCE + 1;\n        }\n    }\n\n    /**\n     * @param {PeerAddressState|*} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof PeerAddressState\n            && this.peerAddress.equals(o.peerAddress);\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this.peerAddress.hashCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `PeerAddressState{peerAddress=${this.peerAddress}, state=${this.state}, `\n            + `lastConnected=${this.lastConnected}, failedAttempts=${this.failedAttempts}, `\n            + `bannedUntil=${this.bannedUntil}}`;\n    }\n}\nClass.register(SignalRouter);\n\nclass SignalRoute {\n    /**\n     * @param {PeerChannel} signalChannel\n     * @param {number} distance\n     * @param {number} timestamp\n     */\n    constructor(signalChannel, distance, timestamp) {\n        this.failedAttempts = 0;\n        this.timestamp = timestamp;\n        this._signalChannel = signalChannel;\n        this._distance = distance;\n    }\n\n    /** @type {PeerChannel} */\n    get signalChannel() {\n        return this._signalChannel;\n    }\n\n    /** @type {number} */\n    get distance() {\n        return this._distance;\n    }\n\n    /** @type {number} */\n    get score() {\n        return ((PeerAddressBook.MAX_DISTANCE - this._distance) / 2) * (1 - (this.failedAttempts / PeerAddressBook.MAX_FAILED_ATTEMPTS_RTC));\n    }\n\n    /**\n     * @param {SignalRoute} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof SignalRoute\n            && this._signalChannel.equals(o._signalChannel);\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this._signalChannel.hashCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `SignalRoute{signalChannel=${this._signalChannel}, distance=${this._distance}, timestamp=${this.timestamp}, failedAttempts=${this.failedAttempts}}`;\n    }\n}\nClass.register(SignalRoute);\n","class PeerAddressBook extends Observable {\n    /**\n     * @constructor\n     * @param {NetworkConfig} netconfig\n     */\n    constructor(netconfig) {\n        super();\n\n        /**\n         * @type {NetworkConfig}\n         * @private\n         */\n        this._networkConfig = netconfig;\n\n        /**\n         * Set of PeerAddressStates of all peerAddresses we know.\n         * @type {HashSet.<PeerAddressState>}\n         * @private\n         */\n        this._store = new HashSet();\n\n        /**\n         * Map from peerIds to RTC peerAddresses.\n         * @type {HashMap.<PeerId,PeerAddressState>}\n         * @private\n         */\n        this._stateByPeerId = new HashMap();\n\n        /**\n         * @type {HashMap.<NetAddress,Set.<PeerAddressState>>}\n         * @private\n         */\n        this._statesByNetAddress = new HashMap();\n\n        // Init seed peers.\n        this.add(/*channel*/ null, GenesisConfig.SEED_PEERS);\n\n        // Setup housekeeping interval.\n        setInterval(() => this._housekeeping(), PeerAddressBook.HOUSEKEEPING_INTERVAL);\n    }\n\n    /**\n     * @returns {Array.<PeerAddressState>}\n     */\n    values() {\n        return this._store.values();\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {?PeerAddressState}\n     * @private\n     */\n    _get(peerAddress) {\n        if (peerAddress instanceof WsPeerAddress) {\n            const localPeerAddress = this._store.get(peerAddress.withoutId());\n            if (localPeerAddress) return localPeerAddress;\n        }\n        return this._store.get(peerAddress);\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {?PeerAddressState}\n     */\n    getState(peerAddress) {\n        return this._get(peerAddress);\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {PeerAddress|null}\n     */\n    get(peerAddress) {\n        /** @type {PeerAddressState} */\n        const peerAddressState = this._get(peerAddress);\n        return peerAddressState ? peerAddressState.peerAddress : null;\n    }\n\n    /**\n     * @param {PeerId} peerId\n     * @returns {PeerAddress|null}\n     */\n    getByPeerId(peerId) {\n        /** @type {PeerAddressState} */\n        const peerAddressState = this._stateByPeerId.get(peerId);\n        return peerAddressState ? peerAddressState.peerAddress : null;\n    }\n\n    /**\n     * @param {PeerId} peerId\n     * @returns {PeerChannel}\n     */\n    getChannelByPeerId(peerId) {\n        const peerAddressState = this._stateByPeerId.get(peerId);\n        if (peerAddressState && peerAddressState.signalRouter.bestRoute) {\n            return peerAddressState.signalRouter.bestRoute.signalChannel;\n        }\n        return null;\n    }\n\n    /**\n     * @param {number} protocolMask\n     * @param {number} serviceMask\n     * @param {number} maxAddresses\n     * @returns {Array.<PeerAddress>}\n     */\n    query(protocolMask, serviceMask, maxAddresses = 1000) {\n        const addressStates = this._store.values();\n        const numAddresses = addressStates.length;\n\n        // Pick a random start index.\n        const index = Math.floor(Math.random() * numAddresses);\n\n        // XXX inefficient linear scan\n        const now = Date.now();\n        const addresses = [];\n        for (let i = 0; i < numAddresses; i++) {\n            const idx = (index + i) % numAddresses;\n            const peerAddressState = addressStates[idx];\n\n            // Never return banned or failed addresses.\n            if (peerAddressState.state === PeerAddressState.BANNED\n                    || peerAddressState.state === PeerAddressState.FAILED) {\n                continue;\n            }\n\n            // Never return seed peers.\n            const address = peerAddressState.peerAddress;\n            if (address.isSeed()) {\n                continue;\n            }\n\n            // Only return addresses matching the protocol mask.\n            if ((address.protocol & protocolMask) === 0) {\n                continue;\n            }\n\n            // Only return addresses matching the service mask.\n            if ((address.services & serviceMask) === 0) {\n                continue;\n            }\n\n            // Update timestamp for connected peers.\n            if (peerAddressState.state === PeerAddressState.ESTABLISHED) {\n                // Also update timestamp for RTC connections\n                if (peerAddressState.signalRouter.bestRoute) {\n                    peerAddressState.signalRouter.bestRoute.timestamp = now;\n                }\n            }\n\n            // Never return addresses that are too old.\n            if (address.exceedsAge()) {\n                continue;\n            }\n\n            // Return this address.\n            addresses.push(address);\n\n            // Stop if we have collected maxAddresses.\n            if (addresses.length >= maxAddresses) {\n                break;\n            }\n        }\n        return addresses;\n    }\n\n    /**\n     * @param {PeerChannel} channel\n     * @param {PeerAddress|Array.<PeerAddress>} arg\n     * @fires PeerAddressBook#added\n     */\n    add(channel, arg) {\n        const peerAddresses = Array.isArray(arg) ? arg : [arg];\n        const newAddresses = [];\n\n        for (const addr of peerAddresses) {\n            if (this._add(channel, addr)) {\n                newAddresses.push(addr);\n            }\n        }\n\n        // Tell listeners that we learned new addresses.\n        if (newAddresses.length) {\n            this.fire('added', newAddresses, this);\n        }\n    }\n\n    /**\n     * @param {PeerChannel} channel\n     * @param {PeerAddress|RtcPeerAddress} peerAddress\n     * @returns {boolean}\n     * @private\n     */\n    _add(channel, peerAddress) {\n        // Max book size reached\n        if (this._store.length >= PeerAddressBook.MAX_SIZE) {\n            return false;\n        }\n\n        // Ignore our own address.\n        if (this._networkConfig.peerAddress.equals(peerAddress)) {\n            return false;\n        }\n\n        // Ignore address if it is too old.\n        // Special case: allow seed addresses (timestamp == 0) via null channel.\n        if (channel && peerAddress.exceedsAge()) {\n            Log.d(PeerAddressBook, `Ignoring address ${peerAddress} - too old (${new Date(peerAddress.timestamp)})`);\n            return false;\n        }\n\n        // Ignore address if its timestamp is too far in the future.\n        if (peerAddress.timestamp > Date.now() + PeerAddressBook.MAX_TIMESTAMP_DRIFT) {\n            Log.d(PeerAddressBook, `Ignoring addresses ${peerAddress} - timestamp in the future`);\n            return false;\n        }\n\n        // Increment distance values of RTC addresses.\n        if (peerAddress.protocol === Protocol.RTC) {\n            peerAddress.distance++;\n\n            // Ignore address if it exceeds max distance.\n            if (peerAddress.distance > PeerAddressBook.MAX_DISTANCE) {\n                Log.d(PeerAddressBook, `Ignoring address ${peerAddress} - max distance exceeded`);\n                // Drop any route to this peer over the current channel. This may prevent loops.\n                const peerAddressState = this._get(peerAddress);\n                if (peerAddressState) {\n                    peerAddressState.signalRouter.deleteRoute(channel);\n                }\n                return false;\n            }\n        }\n\n        // Get the (reliable) netAddress of the peer that sent us this address.\n        const netAddress = channel && channel.netAddress && channel.netAddress.reliable ? channel.netAddress : null;\n\n        // Check if we already know this address.\n        let peerAddressState = this._get(peerAddress);\n        let knownAddress = null;\n        let changed = false;\n        if (peerAddressState) {\n            knownAddress = peerAddressState.peerAddress;\n\n            // Ignore address if it is banned.\n            if (peerAddressState.state === PeerAddressState.BANNED) {\n                return false;\n            }\n\n            // Never update seed peers.\n            if (knownAddress.isSeed()) {\n                return false;\n            }\n\n            // Never erase NetAddresses and never overwrite reliable addresses.\n            if (knownAddress.netAddress && (!peerAddress.netAddress || knownAddress.netAddress.reliable)) {\n                peerAddress.netAddress = knownAddress.netAddress;\n            }\n        } else {\n            // If we know the IP address of the sender, check that we don't exceed the maximum number of addresses per IP.\n            if (netAddress) {\n                const states = this._statesByNetAddress.get(netAddress);\n                if (states && states.size >= PeerAddressBook.MAX_SIZE_PER_IP) {\n                    Log.d(PeerAddressBook, `Ignoring address ${peerAddress} - max count per IP ${netAddress} reached`);\n                    return false;\n                }\n            }\n\n            // Add new peerAddressState.\n            peerAddressState = new PeerAddressState(peerAddress);\n            this._store.add(peerAddressState);\n            if (peerAddress.peerId) {\n                // Index by peerId.\n                this._stateByPeerId.put(peerAddress.peerId, peerAddressState);\n            }\n            changed = true;\n        }\n\n        // Update address if we do not know this address or it has a more recent timestamp.\n        if (!knownAddress || knownAddress.timestamp < peerAddress.timestamp) {\n            peerAddressState.peerAddress = peerAddress;\n            changed = true;\n        }\n\n        // Add route.\n        if (peerAddress.protocol === Protocol.RTC) {\n            changed = peerAddressState.signalRouter.addRoute(channel, peerAddress.distance, peerAddress.timestamp) || changed;\n        }\n\n        // Track which IP address send us this address.\n        if (netAddress) {\n            peerAddressState.addedBy.add(channel.netAddress);\n\n            let states = this._statesByNetAddress.get(channel.netAddress);\n            if (!states) {\n                states = new Set();\n                this._statesByNetAddress.put(channel.netAddress, states);\n            }\n            states.add(peerAddressState);\n        }\n\n        return changed;\n    }\n\n    /**\n     * Called when a connection to this peerAddress has been established.\n     * The connection might have been initiated by the other peer, so address\n     * may not be known previously.\n     * If it is already known, it has been updated by a previous version message.\n     * @param {PeerChannel} channel\n     * @param {PeerAddress|RtcPeerAddress} peerAddress\n     * @returns {void}\n     */\n    established(channel, peerAddress) {\n        let peerAddressState = this._get(peerAddress);\n        \n        if (!peerAddressState) {\n            peerAddressState = new PeerAddressState(peerAddress);\n\n            this._store.add(peerAddressState);\n        }\n\n        if (peerAddress.peerId) {\n            this._stateByPeerId.put(peerAddress.peerId, peerAddressState);\n        }\n\n        peerAddressState.state = PeerAddressState.ESTABLISHED;\n        peerAddressState.lastConnected = Date.now();\n        peerAddressState.failedAttempts = 0;\n        peerAddressState.bannedUntil = -1;\n        peerAddressState.banBackoff = PeerAddressBook.INITIAL_FAILED_BACKOFF;\n\n        if (!peerAddressState.peerAddress.isSeed()) {\n            peerAddressState.peerAddress = peerAddress;\n        }\n\n        // Add route.\n        if (peerAddress.protocol === Protocol.RTC) {\n            peerAddressState.signalRouter.addRoute(channel, peerAddress.distance, peerAddress.timestamp);\n        }\n    }\n\n    /**\n     * Called when a connection to this peerAddress is closed.\n     * @param {PeerChannel} channel\n     * @param {PeerAddress} peerAddress\n     * @param {number|null} type\n     * @returns {void}\n     */\n    close(channel, peerAddress, type = null) {\n        const peerAddressState = this._get(peerAddress);\n        if (!peerAddressState) {\n            return;\n        }\n\n        // register the type of disconnection\n        peerAddressState.close(type);\n\n        // Delete all addresses that were signalable over the disconnected peer.\n        if (channel) {\n            this._removeBySignalChannel(channel);\n        }\n\n        if (CloseType.isBanningType(type)){\n            this._ban(peerAddress);\n        }\n        else if (CloseType.isFailingType(type)) {\n            peerAddressState.failedAttempts++;\n\n            if (peerAddressState.failedAttempts >= peerAddressState.maxFailedAttempts) {\n                // Remove address only if we have tried the maximum number of backoffs.\n                if (peerAddressState.banBackoff >= PeerAddressBook.MAX_FAILED_BACKOFF) {\n                    this._remove(peerAddress);\n                } else {\n                    peerAddressState.bannedUntil = Date.now() + peerAddressState.banBackoff;\n                    peerAddressState.banBackoff = Math.min(PeerAddressBook.MAX_FAILED_BACKOFF, peerAddressState.banBackoff * 2);\n                }\n            }\n        }\n\n        // Immediately delete dumb addresses, since we cannot connect to those anyway.\n        if (peerAddress.protocol === Protocol.DUMB) {\n            this._remove(peerAddress);\n        }\n    }\n\n    /**\n     * Called when a message has been returned as unroutable.\n     * @param {PeerChannel} channel\n     * @param {PeerAddress} peerAddress\n     * @returns {void}\n     */\n    unroutable(channel, peerAddress) {\n        if (!peerAddress) {\n            return;\n        }\n\n        const peerAddressState = this._get(peerAddress);\n        if (!peerAddressState) {\n            return;\n        }\n\n        if (!peerAddressState.signalRouter.bestRoute || !peerAddressState.signalRouter.bestRoute.signalChannel.equals(channel)) {\n            Log.w(PeerAddressBook, `Got unroutable for ${peerAddress} on a channel other than the best route.`);\n            return;\n        }\n\n        peerAddressState.signalRouter.deleteBestRoute();\n        if (!peerAddressState.signalRouter.hasRoute()) {\n            this._remove(peerAddressState.peerAddress);\n        }\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @param {number} [duration] in milliseconds\n     * @returns {void}\n     * @private\n     */\n    _ban(peerAddress, duration = PeerAddressBook.DEFAULT_BAN_TIME) {\n        let peerAddressState = this._get(peerAddress);\n        if (!peerAddressState) {\n            peerAddressState = new PeerAddressState(peerAddress);\n            this._store.add(peerAddressState);\n        }\n\n        peerAddressState.state = PeerAddressState.BANNED;\n        peerAddressState.bannedUntil = Date.now() + duration;\n\n        // Drop all routes to this peer.\n        peerAddressState.signalRouter.deleteAllRoutes();\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {boolean}\n     */\n    isBanned(peerAddress) {\n        const peerAddressState = this._get(peerAddress);\n        return peerAddressState\n            && peerAddressState.state === PeerAddressState.BANNED\n            // XXX Never consider seed peers to be banned. This allows us to use\n            // the banning mechanism to prevent seed peers from being picked when\n            // they are down, but still allows recovering seed peers' inbound\n            // connections to succeed.\n            && !peerAddressState.peerAddress.isSeed();\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {void}\n     * @private\n     */\n    _remove(peerAddress) {\n        const peerAddressState = this._get(peerAddress);\n        if (!peerAddressState) {\n            return;\n        }\n\n        // Never delete seed addresses, ban them instead for a couple of minutes.\n        if (peerAddressState.peerAddress.isSeed()) {\n            this._ban(peerAddress, peerAddressState.banBackoff);\n            return;\n        }\n\n        // Delete from peerId index.\n        if (peerAddress.peerId) {\n            this._stateByPeerId.remove(peerAddress.peerId);\n        }\n\n        // Delete from netAddress index.\n        for (const netAddress of peerAddressState.addedBy) {\n            const states = this._statesByNetAddress.get(netAddress);\n            if (states) {\n                states.delete(peerAddressState);\n                if (states.size === 0) {\n                    this._statesByNetAddress.remove(netAddress);\n                }\n            }\n        }\n\n        // Don't delete bans.\n        if (peerAddressState.state === PeerAddressState.BANNED) {\n            return;\n        }\n\n        // Delete the address.\n        this._store.remove(peerAddress);\n    }\n\n    /**\n     * Delete all RTC-only routes that are signalable over the given peer.\n     * @param {PeerChannel} channel\n     * @returns {void}\n     * @private\n     */\n    _removeBySignalChannel(channel) {\n        // XXX inefficient linear scan\n        for (const peerAddressState of this._store.values()) {\n            if (peerAddressState.peerAddress.protocol === Protocol.RTC) {\n                peerAddressState.signalRouter.deleteRoute(channel);\n                if (!peerAddressState.signalRouter.hasRoute()) {\n                    this._remove(peerAddressState.peerAddress);\n                }\n            }\n        }\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _housekeeping() {\n        const now = Date.now();\n        const unbannedAddresses = [];\n\n        for (/** @type {PeerAddressState} */ const peerAddressState of this._store.values()) {\n            const addr = peerAddressState.peerAddress;\n\n            switch (peerAddressState.state) {\n                case PeerAddressState.NEW:\n                case PeerAddressState.TRIED:\n                case PeerAddressState.FAILED:\n                    // Delete all new peer addresses that are older than MAX_AGE.\n                    if (addr.exceedsAge()) {\n                        this._remove(addr);\n                        continue;\n                    }\n\n                    // Reset failed attempts after bannedUntil has expired.\n                    if (peerAddressState.state === PeerAddressState.FAILED\n                        && peerAddressState.failedAttempts >= peerAddressState.maxFailedAttempts\n                        && peerAddressState.bannedUntil > 0 && peerAddressState.bannedUntil <= now) {\n\n                        peerAddressState.bannedUntil = -1;\n                        peerAddressState.failedAttempts = 0;\n                        unbannedAddresses.push(addr);\n                    }\n\n                    break;\n\n                case PeerAddressState.BANNED:\n                    if (peerAddressState.bannedUntil <= now) {\n                        // Don't remove seed addresses, unban them.\n                        if (addr.isSeed()) {\n                            // Restore banned seed addresses to the NEW state.\n                            peerAddressState.state = PeerAddressState.NEW;\n                            peerAddressState.failedAttempts = 0;\n                            peerAddressState.bannedUntil = -1;\n                            unbannedAddresses.push(addr);\n                        } else {\n                            // Delete expires bans.\n                            this._store.remove(addr);\n                        }\n                    }\n                    break;\n\n                case PeerAddressState.ESTABLISHED:\n                    // Also update timestamp for RTC connections\n                    if (peerAddressState.signalRouter.bestRoute) {\n                        peerAddressState.signalRouter.bestRoute.timestamp = now;\n                    }\n                    break;\n\n                default:\n                    // TODO What about peers who are stuck connecting? Can this happen?\n                    // Do nothing for CONNECTING peers.\n            }\n        }\n\n        if (unbannedAddresses.length) {\n            this.fire('added', unbannedAddresses, this);\n        }\n    }\n\n    /** @type {number} */\n    get knownAddressesCount() {\n        return this._store.length;\n    }\n}\nPeerAddressBook.MAX_AGE_WEBSOCKET = 1000 * 60 * 30; // 30 minutes\nPeerAddressBook.MAX_AGE_WEBRTC = 1000 * 60 * 10; // 10 minutes\nPeerAddressBook.MAX_AGE_DUMB = 1000 * 60; // 1 minute\nPeerAddressBook.MAX_DISTANCE = 4;\nPeerAddressBook.MAX_FAILED_ATTEMPTS_WS = 3;\nPeerAddressBook.MAX_FAILED_ATTEMPTS_RTC = 2;\nPeerAddressBook.MAX_TIMESTAMP_DRIFT = 1000 * 60 * 10; // 10 minutes\nPeerAddressBook.HOUSEKEEPING_INTERVAL = 1000 * 60; // 1 minute\nPeerAddressBook.DEFAULT_BAN_TIME = 1000 * 60 * 10; // 10 minutes\nPeerAddressBook.INITIAL_FAILED_BACKOFF = 1000 * 30; // 30 seconds\nPeerAddressBook.MAX_FAILED_BACKOFF = 1000 * 60 * 10; // 10 minutes\nPeerAddressBook.MAX_SIZE = PlatformUtils.isBrowser() ? 15000 : 100000;\nPeerAddressBook.MAX_SIZE_PER_IP = 250;\nClass.register(PeerAddressBook);\n","class GenesisConfig {\n    static main() {\n        // TODO\n        GenesisConfig.init(GenesisConfig.CONFIGS['bounty']);\n    }\n\n    static test() {\n        // TODO\n        GenesisConfig.init(GenesisConfig.CONFIGS['bounty']);\n    }\n\n    static dev() {\n        GenesisConfig.init(GenesisConfig.CONFIGS['dev']);\n    }\n\n    static bounty() {\n        GenesisConfig.init(GenesisConfig.CONFIGS['bounty']);\n    }\n\n    /**\n     * @param {{NETWORK_ID:number,NETWORK_NAME:string,GENESIS_BLOCK:Block,GENESIS_ACCOUNTS:string,SEED_PEERS:Array.<PeerAddress>}} config\n     */\n    static init(config) {\n        if (GenesisConfig._config) throw new Error('GenesisConfig already initialized');\n        if (!config.NETWORK_ID) throw new Error('Config is missing network id');\n        if (!config.NETWORK_NAME) throw new Error('Config is missing database prefix');\n        if (!config.GENESIS_BLOCK) throw new Error('Config is missing genesis block');\n        if (!config.GENESIS_ACCOUNTS) throw new Error('Config is missing genesis accounts');\n        if (!config.SEED_PEERS) throw new Error('Config is missing seed peers');\n\n        GenesisConfig._config = config;\n    }\n\n    /**\n     * @type {number}\n     */\n    static get NETWORK_ID() {\n        if (!GenesisConfig._config) throw new Error('GenesisConfig not initialized');\n        return GenesisConfig._config.NETWORK_ID;\n    }\n\n    /**\n     * @type {string}\n     */\n    static get NETWORK_NAME() {\n        if (!GenesisConfig._config) throw new Error('GenesisConfig not initialized');\n        return GenesisConfig._config.NETWORK_NAME;\n    }\n\n    /**\n     * @type {Block}\n     */\n    static get GENESIS_BLOCK() {\n        if (!GenesisConfig._config) throw new Error('GenesisConfig not initialized');\n        return GenesisConfig._config.GENESIS_BLOCK;\n    }\n\n    /**\n     * @type {Hash}\n     */\n    static get GENESIS_HASH() {\n        if (!GenesisConfig._config) throw new Error('GenesisConfig not initialized');\n        if (!GenesisConfig._config.GENESIS_HASH) {\n            GenesisConfig._config.GENESIS_HASH = GenesisConfig._config.GENESIS_BLOCK.hash();\n        }\n        return GenesisConfig._config.GENESIS_HASH;\n    }\n\n    /**\n     * @type {string}\n     */\n    static get GENESIS_ACCOUNTS() {\n        if (!GenesisConfig._config) throw new Error('GenesisConfig not initialized');\n        return GenesisConfig._config.GENESIS_ACCOUNTS;\n    }\n\n    /**\n     * @type {Array.<PeerAddress>}\n     */\n    static get SEED_PEERS() {\n        if (!GenesisConfig._config) throw new Error('GenesisConfig not initialized');\n        return GenesisConfig._config.SEED_PEERS;\n    }\n}\nClass.register(GenesisConfig);\n\nGenesisConfig.CONFIGS = {\n    // TODO 'main': { }\n    // TODO 'test': { }\n\n    'dev': {\n        NETWORK_ID: 2,\n        NETWORK_NAME: 'dev',\n        SEED_PEERS: [\n            WsPeerAddress.seed('dev.nimiq-network.com', 8080, 'e65e39616662f2c16d62dc08915e5a1d104619db8c2b9cf9b389f96c8dce9837')\n        ],\n        GENESIS_BLOCK: new Block(\n            new BlockHeader(\n                new Hash(null),\n                new Hash(null),\n                Hash.fromBase64('JvMr9c9l2m8HWNdFAGTEastKH+aDZvln9EopXelhVIg='),\n                Hash.fromBase64('1t/Zm91tN0p178+ePcxyR5bPxvC6jFLskqiidFFO3wY='),\n                BlockUtils.difficultyToCompact(1),\n                1,\n                1522338300,\n                12432,\n                BlockHeader.Version.V1),\n            new BlockInterlink([], new Hash(null)),\n            new BlockBody(Address.fromBase64('AAAAAAAAAAAAAAAAAAAAAAAAAAA='), [], BufferUtils.fromBase64('RGV2TmV0'))\n        ),\n        GENESIS_ACCOUNTS:\n            'AGTHyaGKKYtMW9zm81Nw2UYCIWr2bQAAAAOO9hgWyh/5Ezv+1Ldw9Oid2zwaY+LjRXAjAQAAAdpxepGo' +\n            'TVTy25Dj9WOZXg1SAyoCtCmEkgYAAAABAAAWgAAAAdpxepGoAAAB2nF6kagxFAXrnWawCibXmNIocpEN' +\n            'bY2M4QAAAACPgR32bdaFsm6G5Bg4H96UDFtJMFclfA8rAQAAA+Z8YTcn7eJ7xhfBV9k79a2bDLpb0SWE' +\n            'gSIAAAABAAALQAAAAKZqEDPcAAAD5nxhNyfiENwK3NNQGB6fxKS62kvoApoe4gEAAAKLbf59cM8P40JX' +\n            'yIKzSkr749mOqp5n1/ruAAAAAQAAC0AAAABsklUU6AAAAott/n1wZs9N9eWbNeUSLDy5qbhe6CW7Q94B' +\n            'AAADLsSIL0WLcA6Nt5Ji+Pu2j2p4wJgN8lpIVwAAAAEAABaAAAADLsSIL0UAAAMuxIgvRXGosRRWBkji' +\n            'IyWOFAzp3WZYGhQvAAAAAN+ByO6LKclRKAD8iueyAPGY/ZnTIbM5CbUBAAAAMXEUVZ+h9Kb5BH+lzQTK' +\n            'HdVMiFfmRsJBWAAAAAEAAAtAAAAACD2DY5sAAAAxcRRVn+hB476I0A6qQDjCSzzvumwsQHf9AQAAA03B' +\n            '6LO6vHPfpZtbnDWtPlN7WlO0l+aw1KIAAAABAAALQAAAAIz1psifAAADTcHos7qSQrji3cQRvdhZEyJa' +\n            'a9OF/pUTGwEAAAEJawwO04GTmnyPT2hcnepKTWwqUe3rBlVwAAAAAQAAC0AAAAAsPIICeQAAAQlrDA7T' +\n            'Kd6Wv+nDz7vTAMDCu39sALbKiawBAAABJAr6aFtkUf/rcih9aUVHVigY+8UIy2/+QQAAAAEAAAtAAAAA' +\n            'MKx/EWUAAAEkCvpoW4oaIYhRvV3BULo9azzYYyKeeCxrAQAAA03cDnJSDjUiPbhnHIY/7aooMW/Y0Epe' +\n            'T58AAAABAAAWgAAAA03cDnJSAAADTdwOclKFF7HkvjRHt0g5nwPzP59X9Uge9wEAAAGGEgl7kg2aSBjn' +\n            '4A5Od5+0Lh5sBpm6dar7AAAAAQAAFoAAAAGGEgl7kgAAAYYSCXuSk87IwlS6e4YT+koCY6/lL28D3sYB' +\n            'AAACjIEYqGyFuGHIpbQDcibbuM8kkiHguhEKAwAAAAEAABaAAAACjIEYqGwAAAKMgRiobCUh+XSo0plb' +\n            '6NrVoCXHLwt7XzNZAAAAA1fLvw67icCbQBBXoglPtPMRkeln1StoiSYAAAACFc2B9ywrb3evyXkRn2lI' +\n            'r99+cUgwAipdwwEAAAPxDMrFsmKBEu04Bg6LEqHvrJj2ewKnZ3qmAAAAAQAAFoAAAAPxDMrFsgAAA/EM' +\n            'ysWyc3iG9qZDzL/uCLJEdhmwKaAHgIMBAAACPUMNm/Uu1vSoi1gBseNjIp1mp154Sw79UAAAAAEAABaA' +\n            'AAACPUMNm/UAAAI9Qw2b9YcCc88Iyrx0NUbMZOK3rJdc/ggmAQAAAnsptOZZhrhJa+5Z89rK+wkxjzUt' +\n            'hAHVfDoAAAABAAAWgAAAAnsptOZZAAACeym05lkhopvGoZgAsJ38XeT+KI6VFZ6HVQEAAAKZNR0cZ3N/' +\n            'V/VlAJ1g1vBkidPGJBfIBQZcAAAAAQAAC0AAAABu3i+EvAAAApk1HRxnwWGEqi7rwr6bZ9df8Uhr5cG3' +\n            'nAUAAAAB+ett5xJRyHYmu80aIhgssCKeD9KYKNlI+gEAAAHcmaAZJKAMxD+5u1O+u5ALn65VT4HGDIxw' +\n            'AAAAAQAAC0AAAABPbvAEMQAAAdyZoBkkTOyyimPzT9JghHBHVSBRqHTY6qMBAAABMiMv3v3Fqy0Rq/yO' +\n            'BHu3RlPy/l121QrKAwAAAAEAABaAAAABMiMv3v0AAAEyIy/e/TyTgfm1ATlfv11vqgZ2mGgLp5I3AAAA' +\n            'BB6+ivcGqPmcXVPR6jFzANQ/oHcfYAbWLCAAAAACEUzY24RQtw7fskPYnAuOCrVYvYWjy/Sq2QEAAAA1' +\n            'ejIu8T103OAjQ6dOO7R1qdl9voiJTyMzAAAAAQAAC0AAAAAI6bMH0wAAADV6Mi7xMF78LO+AmQt47Q2F' +\n            '8lJOtFmP+8sBAAADIrN3lvTLTPW10LenULSqINB8dhRMCjZoqgAAAAEAAAtAAAAAhciT7n4AAAMis3eW' +\n            '9PfpWIeCkAqinftTYf+jyT/iAxE2AAAAACtXQrrG1ENyC6MF0IZJhxjw1atz1xqHhPwBAAAAvi3c14rV' +\n            'Vkylvnz2LXDSnAd0Ap9o6EcHkwAAAAEAAAtAAAAAH7JPeUIAAAC+LdzXityvfksBfLlWNu3IzdEXOAKK' +\n            'juLqAAAAAWKGyagmDA2tPlgh/4bnCAHEUTy6X43XlxYAAAABpZApuaLoMq3LP2zjV1NWvIyyZ9WXhbjK' +\n            'rgAAAAOSnw31GpWdLCHuiuqqRiU+c6/7QpNNu415AQAAA/PO43ur9pEsqZCx+ctQ0uLZPiPcQtZ4AtoA' +\n            'AAABAAALQAAAAKiiez9IAAAD887je6ty7kyqfDlYpexa6zO61+OPc7PemgEAAAFVhN0jTzdIVM9Xza9g' +\n            'EHJEU/NTXLDe1iXFAAAAAQAAC0AAAAA463owjgAAAVWE3SNP895JOb/wZK4ieF/UWFZvxGiH5yMAAAAB' +\n            'WtMtyhV1iFBda1GZC0OkOSwt9AADUTkavAEAAAGLTWokGsi+QGXG5VciJh0XKhgY2Ffw3nFhAAAAAQAA' +\n            'C0AAAABB4jxbWgAAAYtNaiQaxyj4UkPRXmdB4RUJOmY0/+DGi2sAAAABmtptM00N3PW8TiZSDGq75w65' +\n            'ENAqIvV17gEAAAPVauIkr0eeRNW8s9uvLImxBON8OZc+nrJLAAAAAQAAC0AAAACjkdBbcwAAA9Vq4iSv' +\n            'LMTqFpsInyV7LXX07AVlLB4LwK8AAAACVOJQdF94lWhUD0pOtwPsSpOcOfVM4c3lYAEAAAJZhQlPED5v' +\n            'd70C9VJcR9E0/6kVRjND3chpAAAAAQAAC0AAAABkQNbigwAAAlmFCU8Q5+bT5k92M+EdyU87fjVCIOHg' +\n            'JvQBAAABLAh445G4HY/gCBp8Ww86DjZzqu2656S1WwAAAAEAABaAAAABLAh445EAAAEsCHjjkfGu/x1G' +\n            'ALyflu5s6H/RjA0uF2FJAQAAAfUQ1yISxqLt9R+tekR4gPOI6gjm8GCCewkAAAABAAAWgAAAAfUQ1yIS' +\n            'AAAB9RDXIhLmoPJPmFOfClWZtRtz8SIHZV+RYgEAAAGb6NZw6ik9LhWvYkCsjo753C4xml4yhuLkAAAA' +\n            'AQAAFoAAAAGb6NZw6gAAAZvo1nDq0lWfSarsXeQhGik+Wy00hFQPYNIBAAAC4wlfg1nMx6ncdUeIXQp/' +\n            'MHyEH0Q1GZoNiAAAAAEAAAtAAAAAeyw6leUAAALjCV+DWRJzvcMi6fQ+RMgH4p3thxoZkT3KAQAAAplo' +\n            'xifaQHmEokpWgPZUy2JkLz0fIsjxIz4AAAABAAALQAAAAG7my7FPAAACmWjGJ9ojMPo7C9y8Ib/ncXPh' +\n            'wUC60bh5vwAAAACNnQv2v4inBpnu2xVZInd7VAlMXKKdYgukAQAAApBN6CyLt+TdIz09e58DxUKFW4PK' +\n            '6+lckmcAAAABAAALQAAAAG1iUVzCAAACkE3oLIs/W2vCON/csGZ+BrXXzOfPf3+nwgAAAABdcEFzteZa' +\n            'aSm87wyRZwS2rvearhLJb0wSAQAAA5l3BvfWMZXszk+sOGOzYCH6Scso0530ACEAAAABAAAWgAAAA5l3' +\n            'BvfWAAADmXcG99Yn1+CSxVm0b9VEmdXSPU9MLZ6euQEAAACc7CZPBZWabWnc3dRvBQIYMyDgLCyx2AtM' +\n            'AAAAAQAAC0AAAAAaJ1u31wAAAJzsJk8FMsv+RNrEAeMhkxQQ7swlQm/MWcsBAAAEFqz9ZzfxBC8ZD/h5' +\n            'XbP5/TW158EyNFjtDwAAAAEAAAtAAAAArnIqO98AAAQWrP1nN9WW44AbwcH3rC9B0LDZEGH/6LGWAAAA' +\n            'A0/mTvNyq+e4MxN7UI6LWMDrHl4bIjVbRqkBAAAADwRE4OfGbkb1M4LvJTsug5Guwv4UipUglQAAAAEA' +\n            'AAtAAAAAAoC2JXwAAAAPBETg5xXn4XxmjRL8H7qyrMKtPOQ68d9gAQAAA+kpJjZRO8ds5r5Z15bsaAvU' +\n            'z1Hi+igym+wAAAABAAALQAAAAKbcMQkOAAAD6SkmNlFtNRkkOze3mxqbEGn8LmugDYG9AAEAAAIeKgo/' +\n            '6Q3VK9Fh4+5mvtU/qnCGKcL5eZe6AAAAAQAAC0AAAABaXFcKpwAAAh4qCj/pVkOr82XeobTRYSqMwBit' +\n            '+DK26L0AAAADExdE1KGweTGwMNtOUr0mkTMuJZPdUx/lFgEAAAIYnmRDO5Us7NZLbPKbfSqFz9Qcz12x' +\n            'p7EIAAAAAQAAC0AAAABZb7tgigAAAhieZEM7QJBbpsW5TySU3AOaRq0w6StqDbkBAAAAQYtUtY+neTkG' +\n            'p0FX3yBWlI9VfXL9rY2T0AAAAAEAABaAAAAAQYtUtY8AAABBi1S1j6CfjxyppAST/5j+yNsnpZ4mb+LM' +\n            'AQAAAwd7a4MeZabvmCauqJUxc/dnJt9Qdbu0C+sAAAABAAALQAAAAIE/PJXbAAADB3trgx6XwCRFCATy' +\n            '6PT5xzl/tTynPq+pVwEAAAP3RVI223cMsae0V7OPJkgsuqVbHiDuSfwpAAAAAQAAFoAAAAP3RVI22wAA' +\n            'A/dFUjbbqciNZ2beiMn+kVcprmWvCo0qNNYAAAAAp/x8AiuP0gOSmGXc+PyW+ma3l4h07YsKpAEAAAKh' +\n            'uMUSlEiZItBpeLfj6hIFvBR6t0/1Zyh2AAAAAQAAFoAAAAKhuMUSlAAAAqG4xRKUMbR0l40dlxXJiTEF' +\n            'uHD29zmRDB8BAAAC0qDOUYnujJP0QRa7dQ2AJ0h1cIE0IkEehgAAAAEAABaAAAAC0qDOUYkAAALSoM5R' +\n            'iepA5phgkMYQo9vghvEMs6W2EXiXAQAAAsKfyTSX6ZAOU+orXNxOz0wdBuAqVHbOiV0AAAABAAAWgAAA' +\n            'AsKfyTSXAAACwp/JNJcBVoZ5gIarGpvmG5G4a1OXW3821QEAAANETmvLWBcBCeyCAd6ZLaV8GnQ8Da54' +\n            'gAyrAAAAAQAAFoAAAANETmvLWAAAA0ROa8tY+JrQTn9k06PB7If9N0CfYchk/C0BAAACrhSVuS2ezk3S' +\n            'ZrOTLlI6dWuGTC76mwagfAAAAAEAAAtAAAAAcljDnt0AAAKuFJW5LYlQAlhiQPsfkWnHfepiRbygaVcw' +\n            'AQAAAbh/Gb8NJqE45Cy7l+FzX6ekgF3R/5Mtr+4AAAABAAAWgAAAAbh/Gb8NAAABuH8Zvw0P094GHr/6' +\n            'AsV1AwxF7c61Qq2RSAAAAAJQwqsff2pLw8MLHSdj/TYI/vua9S1qFloyAQAAAZMy1gvR0p1S/3oRAOZ8' +\n            'nDanLv73M3Fv150AAAABAAAWgAAAAZMy1gvRAAABkzLWC9F4DlJe82PbL79kI4++HW6Glhr8OAEAAAAc' +\n            'Kk11+SFNxI4R9S/ebQHQO2V5jHpCMS1hAAAAAQAAC0AAAAAEsbeTqgAAABwqTXX5sSvBMuNoUTbS19Um' +\n            'etiaDp8t/vsBAAABkaKnSL2M6hWXx8/DUkVUtGxAV3Xd9gtcfAAAAAEAABaAAAABkaKnSL0AAAGRoqdI' +\n            'vTi9K8WL24O90wK1LIuwvNvkRR9iAQAAAQ5MDkLw77e4PHxSapULV3EHaCWnRV0ELfQAAAABAAAWgAAA' +\n            'AQ5MDkLwAAABDkwOQvB45gZiCw5zStBMXeShepM6iLltkgAAAAHfl0LN8u7wC1h8uhyRIY5s1I1gZPfF' +\n            '1qn+AAAAA8xCKTupigAMUEItvNB1XfJi5d20TA4oijkBAAABheDAya/Vr7/+aeXTjjrLIAY/8G9+ps7j' +\n            'DAAAAAEAAAtAAAAAQPrKzEgAAAGF4MDJrySGgRI77yf0Ksrs7U5YU1v43lFrAAAAAkrmY2OrF77xscYd' +\n            'oQqK/Kr8Sc5nR/w91goBAAADoIlPx03C0gM7wMgvzaUglns4BJzvq8fWUQAAAAEAABaAAAADoIlPx00A' +\n            'AAOgiU/HTR059QJNJ6egySnjQ5ssU/g987fwAQAAAOSjwgS4txd+4xsScIOZ2jJ8gm6PFGb4IPcAAAAB' +\n            'AAALQAAAACYbSwDKAAAA5KPCBLgEEiPQ5L80JKvaQkZUqVTQVFocRQEAAAAgrZivoOKiOJFwOp94dsp2' +\n            'dceiRnJRp2BDAAAAAQAAC0AAAAAFckQdRgAAACCtmK+gCouuvquET79GQpJvlDjxodZmWlIBAAADdflm' +\n            'IVtOxwzhUy9DP2U/1dg443ziW+44fAAAAAEAAAtAAAAAk6mRBZAAAAN1+WYhW7W78iEqRWPDm9L0+nV1' +\n            'sgxvC7aAAAAAAnjT5GbwylWQC2KwtxExw7D10y49vKcooJ0AAAADf6VG1QRSW6oEqsV40bK3bkmqzoXd' +\n            'ot6i4gEAAAEy6r22pwWExn95sjo6xoCdI0e/eYKD/GftAAAAAQAAFoAAAAEy6r22pwAAATLqvbanD5Iv' +\n            '+2lMo8wGu38cLQnhQWGpZEoBAAAB3Wk4Pnb/keSDfMbiKmBGXEB/R75Sm81yZQAAAAEAABaAAAAB3Wk4' +\n            'PnYAAAHdaTg+dlD3NG/nQX9YueouG07G0GevJx2cAQAAASDQ25ZqoHTmauLeC1uxbbJc9puYK7ibUGQA' +\n            'AAABAAAWgAAAASDQ25ZqAAABINDblmrDxe/R9ACThqXry6xBd28gwzmBbAAAAAA3JtwFy7gOad2nnAuf' +\n            '4c9a2JDr8h65bBqxAQAAApIfgNiYaB9nad26DD093xiYPxcQq2fLUB0AAAABAAALQAAAAG2v6s7EAAAC' +\n            'kh+A2JhP0wpVAIQo7aaYGJz1q+BQ/JvaAQEAAAELaF0K71KfkeqRPM7T8QipPJ8FVXyve5YUAAAAAQAA' +\n            'FoAAAAELaF0K7wAAAQtoXQrvJ/jj56GUsaHxN9mDMXP5RsX08l8AAAADE1QMtlVNL/Tr3lfTfZGZ4SRd' +\n            '7Ko1EbsleAEAAAKN3l0bwt3bQiKYf+QXt0o8YjRC4DeZwDgRAAAAAQAAC0AAAABs+mTZ9gAAAo3eXRvC' +\n            'VJEHZ0qy+F1pvTVulg0P1CdMCToAAAACfGL6o0cNbRO/RL5C/tljM1b4X9GibgKJhgEAAAPEPtTYFS70' +\n            'hIR9vGG5Bss2KK0fyL/Q7ZfwAAAAAQAAFoAAAAPEPtTYFQAAA8Q+1NgVjxMxbNwbSqmxFnDEgA2J2Io6' +\n            'Q14AAAAB0Fl8OgAV2mEYfjb3jRucPYtRg9szNOY5LAEAAADjj9fBEDJIdjKxmX0e1aiPEla5rtes80Lh' +\n            'AAAAAQAAC0AAAAAl7U6gLgAAAOOP18EQBkYuU4gvkHTrVpgVrymqlmeIV3cBAAAA2NjC3v910c484H8c' +\n            'iZmr9lYIo66SCeFyQwAAAAEAAAtAAAAAJCQgeoAAAADY2MLe/1PF67K3QcuQJ+m4P7tOiIrVmdFhAQAA' +\n            'AukCHDJUZrnHmLoVULR6r8HDBaygNH/gNE8AAAABAAAWgAAAAukCHDJUAAAC6QIcMlS4diPveIAR8ciq' +\n            'f6WfLVCvxGQ1MQAAAAJlQHbfixmoGC8hAefMDjnblFS989zLCxhKAQAAA+519/AhViOdiXDAAdtc5/ue' +\n            'TM0syon8VYoAAAABAAAWgAAAA+519/AhAAAD7nX38CH0clyiOijE/jV+sOwm6ZB5i5GvYQEAAAGy/GNM' +\n            'TQyzah076TeqMT+jyMJhGgese8vbAAAAAQAAC0AAAABIf2XiDQAAAbL8Y0xNr/JNzMvTszgQcqMcDBEz' +\n            'tfKONfgAAAARpIlShW0='\n    },\n\n    'bounty': {\n        NETWORK_ID: 3,\n        NETWORK_NAME: 'bounty',\n        SEED_PEERS: [\n            WsPeerAddress.seed('bug-bounty1.nimiq-network.com', 8080, '7e825872ee12a71bda50cba9f230c760c84ee50eef0a3e435467e8d5307c0b4e'),\n            WsPeerAddress.seed('bug-bounty2.nimiq-network.com', 8080, 'ea876175c8b693c0db38b7c17d66e9c510020fceb4634f04e281af30438f8787'),\n            WsPeerAddress.seed('bug-bounty3.nimiq-network.com', 8080, '5c0d5d801e85ebd42f25a45b2cb7f3b39b9ce14002d4662f5ed0cd79ce25165a')\n        ],\n        GENESIS_BLOCK: new Block(\n            new BlockHeader(\n                new Hash(null),\n                new Hash(null),\n                Hash.fromBase64('nPcJa/7i0KYsiPQ8FPOgvLYgpP3m05UMwPfIPJAdAvI='),\n                Hash.fromBase64('sXZsIZDV40vD7NDdrnSk2tOsPMKKit/vH0xvz1RXmQo='),\n                BlockUtils.difficultyToCompact(1),\n                1,\n                1522338300,\n                67058,\n                BlockHeader.Version.V1),\n            new BlockInterlink([], new Hash(null)),\n            new BlockBody(Address.fromBase64('AAAAAAAAAAAAAAAAAAAAAAAAAAA='), [], BufferUtils.fromBase64('Qm91bnR5TmV0'))\n        ),\n        GENESIS_ACCOUNTS:\n            'AGROsO8mYpEUdwzEGQ0O6vnlpVKChwEAAAPgjSSR4LB4qqj8ygd5C6xKRfXafhN7T5fmAAAAAQAAC0AA' +\n            'AAClbNttpgAAA+CNJJHgvj7dWIwWkgYczXTXDMe9WDwe7PIAAAABuvV0Xzr7uF1SMm0j0okevxuwhMCF' +\n            'RbOerwEAAAAzj75naNS5u7vg6bLNCTc+tc++nDMzSMxcAAAAAQAAFoAAAAAzj75naAAAADOPvmdoLCur' +\n            'wI3RXio3O082uOONNCaOL5EAAAAArvAV+ORfFg1aBKGWGk19uDxpWkV+fiIkWwEAAAJR5PbT4MvZdtuH' +\n            'jLiimcdnhbNI6TKH2m4GAAAAAQAAC0AAAABi+354pgAAAlHk9tPgpgOUfVePZWnuO69XlvZf8BzHjTsA' +\n            'AAACuA/6/UZ+myPLTv0rQR48yVjdYBj+xnx0gQEAAAH38jLPmHhUCPYh7IdSdeq5grLJ7N3/9k7oAAAA' +\n            'AQAAC0AAAABT/bMimgAAAffyMs+YTpbsTx+qRTynShhe/OncI3F8UJUBAAACY7QNrF0kaFoknkqcBjWI' +\n            'NhgkiICcLaGFqQAAAAEAABaAAAACY7QNrF0AAAJjtA2sXYy5yceBWd2UZHzOlLJ8bJT3XnkiAQAAAet+' +\n            'mSFo/V6xEWOKhdqqy8rbsGtb0IpSTjsAAAABAAAWgAAAAet+mSFoAAAB636ZIWisTPQqBlMhdavdoB1d' +\n            'Jg4hNeIzSQAAAAM9NgN2R9lbltBpK4dHZ0tyJFuWFqFXycS6AQAAABDdCzYOg7v1ZL/YGtYz6n/pqZ7k' +\n            'BscS9EAAAAABAAALQAAAAALPgd5YAAAAEN0LNg4jeClst35OziQr18E8ongjqdUwkAAAAACSi46KoSGZ' +\n            'ZZgRFEG1UmNVvuGnXlr/p8tLAAAAAo2Y+VdN6KsTS3g0BfG/5A2WO23wvPTR1wQBAAAABjp3o4OXWcPN' +\n            'eS7zgUtJ1ZtdWMlPrUCjQQAAAAEAABaAAAAABjp3o4MAAAAGOnejg0HbqTyPwzbBbmZKac+AJldb1K8S' +\n            'AQAAA2xCJZEUiCvMiRHOWl0TPvfiopaGoWuy/1MAAAABAAAWgAAAA2xCJZEUAAADbEIlkRSW5uOyFaGB' +\n            'eE9iLFclv4dkn0b8hAEAAAAaof6tJK4CoBvPyIm5zYNslaFa0I0DAXdNAAAAAQAAC0AAAAAEcFUc3AAA' +\n            'ABqh/q0k7md7N7SMnce8u1qZ7zza/iG1Tn4AAAAC2fbY76DyEhIrSQASeAudDPtSCBr5cZuxUwEAAADk' +\n            '0kARBJH5qFOo09UHXzNlMp6yjMHoBVicAAAAAQAAFoAAAADk0kARBAAAAOTSQBEEBGm9ERoB+XwvUDmC' +\n            'og0GIMYSA/0BAAACzQJNz/Z6A5yDJeNdyNSW1L+irfZN+NpYRQAAAAEAABaAAAACzQJNz/YAAALNAk3P' +\n            '9grte35IRZZFznMf1gpDH0fsbgh6AAAAANIlCqNKBUnIybVhKsuJHiMrgaeH+72CipcAAAAArp3v7lub' +\n            'ymFcF+x8X6sQer1ayMp1jrlWiwEAAAQQfjLXJ7IS3Zq3na6MsYcufha2Tm5gvr2xAAAAAQAAFoAAAAQQ' +\n            'fjLXJwAABBB+Mtcn5XPFpovekv8bgRGTV2LSeiZleJUAAAACXoxQT4M7+VL2b5FDeiL8Y1dHlO1boy19' +\n            '6AEAAAOcBs1QJwsPNgV1uujn9YRrWXf23JR0QKsvAAAAAQAAC0AAAACaASI4BwAAA5wGzVAnhdNFqitT' +\n            '85qR1j+u1sme41jJRfkAAAAC6ttvlJrkUQTtZt4IVpXGMPPbiOARbrgajgAAAAHVpCh2w6PvV+HiS5PL' +\n            '5s4wdjHd6qKO6i8PAAAAA2qxFnjjJl5FHtoCQxEJfO0uyXaCj9MG+OkBAAADFiD2hCtcPDqv69GPrUF7' +\n            'J1ufmM68/Ru99gAAAAEAAAtAAAAAg7ApFggAAAMWIPaEK5BnIwlb6NRmmDQzimYNOTKOVNPjAAAAAY1F' +\n            'x02zSd3uF8Vj4S/TaoBuM///DSp0gSwAAAADZ5wnyoHktQhKTfw0OpLTgiwg53rMarO+LQEAAAJflxqP' +\n            'fHUakyXzvQFuqMGCr6xa8pbx1MG2AAAAAQAAFoAAAAJflxqPfAAAAl+XGo98TtdEztipo0zyipnMocYl' +\n            'e2VSHzsAAAAB8OIqY4ZJ40Xz0UiBI4UHWjeUanUuMMH5qwEAAAIKm7AwSvDbPaXscFKMfNoshmPOuji4' +\n            'FyTgAAAAAQAAFoAAAAIKm7AwSgAAAgqbsDBKluoH0jINLWuByiQ+CAG3gMo+8JgAAAAA1uRP/GEF1BOx' +\n            '7I2paX5fa/wEkQDcMJcCTQEAAAH5Z+cQz7kBi6Rgajd3MHk58AA3NwBGMyJiAAAAAQAAC0AAAABUO/vY' +\n            'IwAAAfln5xDP/3+ug/4aXTjAo5YwpNMt+nZ+lB0AAAAC4xiGzk8p0EDsMgk7BZ2Lp/Ipqs/8QkvT6wEA' +\n            'AAGe+TeyjXZtAVYZPw0/Wm+gH1sTuonDC+zdAAAAAQAAFoAAAAGe+TeyjQAAAZ75N7KNxcAvQyI0dTnE' +\n            'OU4b5XGOOLIXrOYBAAADvPpJRzblSEO08l6xF6oGQvBQPB7VBBg0cwAAAAEAAAtAAAAAn38MNokAAAO8' +\n            '+klHNocR7UAAXunjaoZ8raL1kqQqMhaBAQAAA8avedwClf/LVcuz9RkrElWM+SyAjp8k+1sAAAABAAAL' +\n            'QAAAAKEdPvoBAAADxq953ALOttlrLzsnbOrQj8LjeGNjY8MCmAEAAAEeregRRXA2d50cqQgJcXF4rsQ1' +\n            'Iy0wCdkPAAAAAQAAC0AAAAAvx6atjAAAAR6t6BFF5pw0DA0RHO6/7cAqKwohgusbMJ4BAAABnR1KdPep' +\n            'yuvGAvBWqAB0Mij3qHXgmM3pQgAAAAEAABaAAAABnR1KdPcAAAGdHUp092IPe5Uo8L6bEBfIcBszCCaU' +\n            '3ZCFAQAAAlApip6i7sSV9Xf/cZOWcSnR3lvQ6qnjYiEAAAABAAALQAAAAGKxlxpxAAACUCmKnqLHZ87+' +\n            '742b7VCY+mdcXgUivnErUQEAAAJc6SBPCXsPV1cyJmrWJbyix0y0MGvNdAxnAAAAAQAAC0AAAABk0YVi' +\n            'ggAAAlzpIE8JJhdSTzJWBddPXWISNCnXKQbdSOEAAAAAshscJDuUrLmff96PmMXSHjv6iLnuakcuEQEA' +\n            'AAF3oHpkI8BjHIpOQcNWshd7j/h9mICI5myBAAAAAQAAC0AAAAA+mr8QsQAAAXegemQjbgkIzm9ttUga' +\n            'Xm481y+qKRjSeqwBAAAB7DzablqAf2gbs+/9SYhcADbIRJbS7G3c+QAAAAEAABaAAAAB7DzabloAAAHs' +\n            'PNpuWtJEhwUaSZ9Tg+yvkFZ242oTVaxrAQAAA8zovmmlJrUqvQ9XKD75Ql3t/wHtYw/hqi4AAAABAAAL' +\n            'QAAAAKImymbxAAADzOi+aaUscN6LWAC41YIiEiyUFT4nl8DbwwEAAAJrqfvqURra+7HArgPHeoZuZGfB' +\n            'nZxo4oZcAAAAAQAAC0AAAABnRv9RuQAAAmup++pRZ77cbnKDpVQw4BL39bEWeOSwHw0AAAACC47Ibf40' +\n            'xdAvwpS6spKJEDfGUOP0dfLvNgEAAADExu0Of/wIe/ktutHQJVsqBotvETusEBk8AAAAAQAAFoAAAADE' +\n            'xu0OfwAAAMTG7Q5/npgGH2YQ5O69Zb8InpcJ+3Xb3hMAAAABGivkj2P3t+w3wcJlDbqHHLeZjaGprCzm' +\n            'FwAAAAFfg6V+9IxjkTpCkTZ2heqwjjcQb3GjCEZTAQAAAZIMcUVqJ0k1ifmmNQt79Rs1dX0L2Mq+MloA' +\n            'AAABAAAWgAAAAZIMcUVqAAABkgxxRWp9VLAV2l/GjEWTAZzpxeDaUsxNkgEAAAN2uVrw4g9W2DDeukSz' +\n            'TyLxYqm5KFcw72fJAAAAAQAAFoAAAAN2uVrw4gAAA3a5WvDii7RScEJSU1x6ZmCL5M3F50xRHfQAAAAC' +\n            '+CK5BiiMrHZJ7TrhEFQ8n0YRfoLMUczX2QAAAAJNvBcYruLQJ2TltxpinmOSf13f+cXn3J3jAAAAA5w4' +\n            'C/BjVTkfE0Phx+Rb2fsm3J8RI3wFwTsBAAAAC+MMUH8dzPNaHQGQKnjqTKs7aWbbdH7dEwAAAAEAAAtA' +\n            'AAAAAfssuBYAAAAL4wxQf4FwpwRoMuHItz9YGBRc6x1o3amtAQAAACwQMTvDUlbrOHxQG5guU3iG0q9/' +\n            '+CrDFXMAAAABAAALQAAAAAdYCDShAAAALBAxO8MhD4gQOrLQfWJGyCsI5ZUmVdh8pQAAAADdRRBrv3G4' +\n            'F2Tq3ImF+xUVZz2gqjVpGdAaAQAAAZYf2OJvN1smnhwcM8c/aZznmfFtvxDRU9gAAAABAAAWgAAAAZYf' +\n            '2OJvAAABlh/Y4m8eR91nBeBI9qdg1mlPf8ZIzFLPmQEAAAI3vx7Pa5ty9e+2jB6gL+lO95IuG4TdDN1v' +\n            'AAAAAQAAFoAAAAI3vx7PawAAAje/Hs9rgCRUm9RKMk+J4Mqy1pCGgnExdFcAAAAAUWefBW7kQ4xPetD+' +\n            '/je2JzS83YLr60juHAEAAAGA5ARRy0KuCQ/K40H+qr7fyuDRlNACqSihAAAAAQAAC0AAAABAJgC4TQAA' +\n            'AYDkBFHLlRXf6DznkAPPYQG5bSgjCxCB6WIBAAAB0PAwzsvj1VjB3iefUVXm0uENgye1iH8GWgAAAAEA' +\n            'ABaAAAAB0PAwzssAAAHQ8DDOy2SmQ0XvARmN17wy1azFVYOFl8LmAAAAAuymvWJbap1uaBnvqo22bGoC' +\n            'cg9XRK1olasAAAAA/lMYYTxyjHLVR/Pxkp4el+dp5sGYw2CyNwAAAANzjeaeP6Vn5Qo6zPTuJbEby9W8' +\n            'yGOUlpj0AAAAAGJvsBrGU9LXiImw0pNsAfYsGPpChDfzxqUAAAACnha01XkWHT3K98ZVf4qFZ+eVZk69' +\n            'HXgTZAAAAADG+hJMiXbLXYotByvgurHAZkCIfeoD4j/GAQAAAnwS195BXMR4RF6S2HEut98KOu46WyAn' +\n            'MgUAAAABAAAWgAAAAnwS195BAAACfBLX3kGB7YYZXaVHVYpvlS5pPB0rTmAdhgEAAAOw7V2WAkTXOeZB' +\n            'hAQ3gO4hKDzaPoI/obIIAAAAAQAAFoAAAAOw7V2WAgAAA7DtXZYCexCLXdJmUo3et6zTrM4JHLAHvHcB' +\n            'AAAAo52G7qeniYMBQPn2IGmF4SyZvtqO5T3j8QAAAAEAAAtAAAAAG0Tr0nIAAACjnYbup/82u4K2pI3Z' +\n            'h8SrLR0y1SaJZ5l2AQAAAM0wkaKTtJYt5lBGk9KdUOfTPfmHPMJYvIwAAAABAAAWgAAAAM0wkaKTAAAA' +\n            'zTCRopP8K2cAplRi+V/cwUxuZsSR4QZlJQEAAAFrnAUfbjFv4oFVJrnxAqoTAfT+ir0cddG8AAAAAQAA' +\n            'C0AAAAA8mgDakwAAAWucBR9uS6QEmO4u5Y4uSMXTZDH8ysKkgeUAAAABJql00I3a+i/3sQxVGNO8jvSH' +\n            'NvKIDDwpCAAAAAG5PG0zfZL63kNtVx8yC/1rU/YJ+beMCq/MAQAAAfyrrlYeV08n7pDCSKBTHhoQtuof' +\n            'LbLc5vIAAAABAAAWgAAAAfyrrlYeAAAB/KuuVh6t32k0jFALkuXmJTd3CVbsSVqr9gAAAAJGVwd4qfoE' +\n            '4hQZ0AIEtzoGqvhfroylPD7hAAAAATCkdqWwldyF7Ow6kOLADIO7fufoY/2MCtwBAAADn+uup3jSsj0K' +\n            '3MSzvXONYK4E0E+ydYu0MQAAAAEAABaAAAADn+uup3gAAAOf666neJlIQtZB2w+EQBPHLR9hU4c7Pc8p' +\n            'AQAAAHrMSxVGaFi1A/Bg67LMchAQLHHATlbxJ1oAAAABAAALQAAAABR3YdjhAAAAesxLFUaL9KQCAqp4' +\n            'Q5SOagEaGjf7lDpynQAAAABBumWs5OROJv8K/JWHN97QVURIoPj96+bXAQAAAzOvVCYV6OmPb3ZVZhDT' +\n            'huOTXPAGcUPCMUAAAAABAAAWgAAAAzOvVCYVAAADM69UJhWOjYkDOqh2GLtyhACzalkqt6i5GAAAAABk' +\n            'HOEzHn2NueFUN/i1nufAJm5Ac7Whv/IvAQAAAnaJFcF5fLjdbjLqfgEZqSxvEzn1UcW6XekAAAABAAAL' +\n            'QAAAAGkW2PWVAAACdokVwXmQSClXUuSIAuzoqKB4jFwZAJuMdgEAAAHsD0/gGtLI0Rhf68pXNo8w6tke' +\n            'Dbl7/leEAAAAAQAAFoAAAAHsD0/gGgAAAewPT+AaCOUy0dRimkU3sK1J9IqLyEwVekoBAAAD1asYkCaI' +\n            'LiY2H+HviJLKv8bvJpZp3yEU5AAAAAEAAAtAAAAAo5yEGAcAAAPVqxiQJviZYUNe7PwjCxRRwmdn2qbL' +\n            'ShqZAQAAAj7b2zm/blSYRSUbnvVCJTGqqdqvIGdeXlIAAAABAAAWgAAAAj7b2zm/AAACPtvbOb9X+fT7' +\n            '4TMZImyXLXIuIgWFUyD5uAEAAAIPegL2Y5UScwJ9ZTWVekf09n4XUKQhwkvjAAAAAQAAC0AAAABX6asp' +\n            'EQAAAg96AvZjv7BLmwd9zQiXxIRalCtzU+r8G3wBAAAEBj9a7W52WYLujJxZpIibUJZrq7ka4SDDEQAA' +\n            'AAEAABaAAAAEBj9a7W4AAAQGP1rtbvPLOoPC9Vea1GXBedP3t7MHPoMsAQAAAgBURMd+ePmpTRjQCgCi' +\n            '5pVFGkD2qs/bOPIAAAABAAAWgAAAAgBURMd+AAACAFREx35sf7kDiNf4hPKBPARdgY4/AAtsaAEAAAEI' +\n            'I2jMolR1W14pluv9x/6myqzxn3ZUEenzAAAAAQAAFoAAAAEII2jMogAAAQgjaMyiEIZJWfKO8Y1GoDU9' +\n            'rEsVumVGFgEAAAABDnO2+5f7Yo9xYe4kL5omlRWQaOFVp1fkRwEAAABQ82mtvY9XMFguE8guQcqN7PcZ' +\n            'aP59u73nAAAAAQAAFoAAAABQ82mtvQAAAFDzaa29HbkxrjlvrxypwVCKBXGLscWZxBsBAAACbbcPl4DZ' +\n            'q3f07ciGYXAPXG+EQbptqwEXgAAAAAEAAAtAAAAAZ56CmUAAAAJttw+XgKh3+qgc1B4nsn6iKBWKH8/1' +\n            'k3DaAQAAAygH/3wfau3GDF2ltpK1zQVT/YbUHG1O6BUAAAABAAAWgAAAAygH/3wfAAADKAf/fB8SWgnh' +\n            'KY7eEBq1dn7EdblSHhwwiAEAAAMiqJ4ySyyTQbUeHOhqhls8J6pSa9FOTdORAAAAAQAAC0AAAACFxsUI' +\n            'YgAAAyKonjJL13wA6mHCW2/OQD28IMlARXIpkYABAAAiUPS1kYdh8z8IT9HgqMC1auELaAZIShQtEgAA' +\n            'AAEAAAtAAAAFuCjI7ZcAACJQ9LWRhw=='\n    }\n};\n","class CloseType {\n    /**\n     * @param {number} closeType\n     * @return {boolean}\n     */\n    static isBanningType(closeType){\n        return closeType >= 100 && closeType < 200;\n    }\n\n    /**\n     * @param {number} closeType\n     * @return {boolean}\n     */\n    static isFailingType(closeType){\n        return closeType >= 200;\n    }\n}\n\n// Regular Close Types\n\nCloseType.GET_BLOCKS_TIMEOUT = 1;\nCloseType.GET_CHAIN_PROOF_TIMEOUT = 2;\nCloseType.GET_ACCOUNTS_TREE_CHUNK_TIMEOUT = 3;\nCloseType.GET_HEADER_TIMEOUT = 4;\nCloseType.INVALID_ACCOUNTS_TREE_CHUNK = 5;\nCloseType.ACCOUNTS_TREE_CHUNCK_ROOT_HASH_MISMATCH = 6;\nCloseType.INVALID_CHAIN_PROOF = 7;\nCloseType.RECEIVED_WRONG_HEADER = 8;\nCloseType.DID_NOT_GET_REQUESTED_HEADER = 9;\n\nCloseType.GET_ACCOUNTS_PROOF_TIMEOUT = 11;\nCloseType.GET_TRANSACTIONS_PROOF_TIMEOUT = 12;\nCloseType.GET_TRANSACTION_RECEIPTS_TIMEOUT = 13;\nCloseType.INVALID_ACCOUNTS_PROOF = 14;\nCloseType.ACCOUNTS_PROOF_ROOT_HASH_MISMATCH = 15;\nCloseType.INCOMPLETE_ACCOUNTS_PROOF = 16;\nCloseType.INVALID_BLOCK = 17;\nCloseType.INVALID_CHAIN_PROOF = 18;\nCloseType.INVALID_TRANSACTION_PROOF = 19;\nCloseType.INVALID_BLOCK_PROOF = 20;\n\nCloseType.SENDING_PING_MESSAGE_FAILED = 22;\nCloseType.SENDING_OF_VERSION_MESSAGE_FAILED = 23;\n\nCloseType.SIMULTANEOUS_CONNECTION = 29;\nCloseType.DUPLICATE_CONNECTION = 30;\nCloseType.PEER_IS_BANNED = 31;\nCloseType.MANUAL_NETWORK_DISCONNECT = 33;\nCloseType.MANUAL_WEBSOCKET_DISCONNECT = 34;\nCloseType.MAX_PEER_COUNT_REACHED = 35;\n\nCloseType.PEER_CONNECTION_RECYCLED = 36;\nCloseType.PEER_CONNECTION_RECYCLED_INBOUND_EXCHANGE = 37;\nCloseType.INBOUND_CONNECTIONS_BLOCKED = 38;\n\nCloseType.MANUAL_PEER_DISCONNECT = 90;\n\n// Ban Close Types\n\nCloseType.RECEIVED_INVALID_BLOCK = 100;\nCloseType.BLOCKCHAIN_SYNC_FAILED = 101;\nCloseType.RECEIVED_INVALID_HEADER = 102;\nCloseType.RECEIVED_TRANSACTION_NOT_MATCHING_OUR_SUBSCRIPTION = 103;\nCloseType.ADDR_MESSAGE_TOO_LARGE = 104;\nCloseType.INVALID_ADDR = 105;\nCloseType.ADDR_NOT_GLOBALLY_REACHABLE = 106;\nCloseType.INVALID_SIGNAL_TTL = 107;\nCloseType.INVALID_SIGNATURE = 108;\nCloseType.RECEIVED_BLOCK_NOT_MATCHING_OUR_SUBSCRIPTION = 109;\n\nCloseType.INCOMPATIBLE_VERSION = 110;\nCloseType.DIFFERENT_GENESIS_BLOCK = 111;\nCloseType.INVALID_PEER_ADDRESS_IN_VERSION_MESSAGE = 112;\nCloseType.UNEXPECTED_PEER_ADDRESS_IN_VERSION_MESSAGE = 113;\nCloseType.INVALID_PUBLIC_KEY_IN_VERACK_MESSAGE = 114;\nCloseType.INVALID_SIGNATURE_IN_VERACK_MESSAGE = 115;\nCloseType.BANNED_IP = 116;\n\nCloseType.RATE_LIMIT_EXCEEDED = 120;\n\nCloseType.MANUAL_PEER_BAN = 190;\n\n// Fail Close Types\n\nCloseType.CLOSED_BY_REMOTE = 200;\nCloseType.PING_TIMEOUT = 201;\nCloseType.CONNECTION_FAILED = 202;\nCloseType.NETWORK_ERROR = 203;\nCloseType.VERSION_TIMEOUT = 204;\nCloseType.VERACK_TIMEOUT = 205;\nCloseType.ABORTED_SYNC = 206;\nCloseType.FAILED_TO_PARSE_MESSAGE_TYPE = 207;\nCloseType.CONNECTION_LIMIT_PER_IP = 208;\nCloseType.CHANNEL_CLOSING = 209;\n\nCloseType.MANUAL_PEER_FAIL = 290;\n\nClass.register(CloseType);\n","class NetworkConnection extends Observable {\n    /**\n     * @param {DataChannel} channel\n     * @param {number} protocol\n     * @param {NetAddress} netAddress\n     * @param {PeerAddress} peerAddress\n     */\n    constructor(channel, protocol, netAddress, peerAddress) {\n        super();\n        /** @type {DataChannel} */\n        this._channel = channel;\n\n        /** @type {number} */\n        this._protocol = protocol;\n        /** @type {NetAddress} */\n        this._netAddress = netAddress;\n        /** @type {PeerAddress} */\n        this._peerAddress = peerAddress;\n\n        /** @type {number} */\n        this._bytesSent = 0;\n        /** @type {number} */\n        this._bytesReceived = 0;\n\n        /** @type {boolean} */\n        this._inbound = !peerAddress;\n\n        /** @type {boolean} */\n        this._closed = false;\n\n        /** @type {*} */\n        this._lastError = null;\n\n        // Unique id for this connection.\n        /** @type {number} */\n        this._id = NetworkConnection._instanceCount++;\n\n        this._channel.on('message', msg => this._onMessage(msg));\n        this._channel.on('close', () => this._onClose(CloseType.CLOSED_BY_REMOTE, 'Closed by remote'));\n        this._channel.on('error', e => this._onError(e));\n    }\n\n    /**\n     * @param {Uint8Array} msg\n     * @private\n     */\n    _onMessage(msg) {\n        // Don't emit messages if this channel is closed.\n        if (this._closed) {\n            return;\n        }\n\n        this._bytesReceived += msg.byteLength || msg.length;\n        this.fire('message', msg, this);\n    }\n\n    /**\n     * @param {*} e\n     * @private\n     */\n    _onError(e) {\n        this._lastError = e;\n        this.fire('error', e, this);\n    }\n\n    /**\n     * @param {number} [type]\n     * @param {string} [reason]\n     * @private\n     */\n    _onClose(type, reason) {\n        // Don't fire close event again when already closed.\n        if (this._closed) {\n            return;\n        }\n\n        // Mark this connection as closed.\n        this._closed = true;\n\n        // Propagate last network error.\n        if (type === CloseType.CLOSED_BY_REMOTE && this._lastError) {\n            type = CloseType.NETWORK_ERROR;\n            reason = this._lastError;\n        }\n\n        // Tell listeners that this connection has closed.\n        this.fire('close', type, reason, this);\n    }\n\n    /**\n     * @param {number} [type]\n     * @param {string} [reason]\n     * @private\n     */\n    _close(type, reason) {\n        // Don't wait for the native close event to fire.\n        this._onClose(type, reason);\n\n        // Close the native channel.\n        this._channel.close();\n    }\n\n    /**\n     * @return {boolean}\n     * @private\n     */\n    _isChannelOpen() {\n        return this._channel.readyState === DataChannel.ReadyState.OPEN;\n    }\n\n    /**\n     * @return {boolean}\n     * @private\n     */\n    _isChannelClosing() {\n        return this._channel.readyState === DataChannel.ReadyState.CLOSING;\n    }\n\n    /**\n     * @return {boolean}\n     * @private\n     */\n    _isChannelClosed() {\n        return this._channel.readyState === DataChannel.ReadyState.CLOSED;\n    }\n\n    /**\n     * @param {Uint8Array} msg\n     * @return {boolean}\n     */\n    send(msg) {\n        const logAddress = this._peerAddress || this._netAddress;\n        if (this._closed) {\n            return false;\n        }\n\n        // Fire close event (early) if channel is closing/closed.\n        if (this._isChannelClosing() || this._isChannelClosed()) {\n            Log.w(NetworkConnection, `Not sending data to ${logAddress} - channel closing/closed (${this._channel.readyState})`);\n            this._onClose(CloseType.CHANNEL_CLOSING, 'channel closing');\n            return false;\n        }\n\n        // Don't attempt to send if channel is not (yet) open.\n        if (!this._isChannelOpen()) {\n            Log.w(NetworkConnection, `Not sending data to ${logAddress} - channel not open (${this._channel.readyState})`);\n            return false;\n        }\n\n        try {\n            this._channel.send(msg);\n            this._bytesSent += msg.byteLength || msg.length;\n            return true;\n        } catch (e) {\n            Log.e(NetworkConnection, `Failed to send data to ${logAddress}: ${e.message || e}`);\n            return false;\n        }\n    }\n\n    /**\n     * @param {Message.Type|Array.<Message.Type>} types\n     * @param {function()} timeoutCallback\n     * @param {number} [msgTimeout]\n     * @param {number} [chunkTimeout]\n     */\n    expectMessage(types, timeoutCallback, msgTimeout, chunkTimeout) {\n        this._channel.expectMessage(types, timeoutCallback, msgTimeout, chunkTimeout);\n    }\n\n    /**\n     * @param {Message.Type} type\n     * @returns {boolean}\n     */\n    isExpectingMessage(type) {\n        return this._channel.isExpectingMessage(type);\n    }\n\n    /**\n     * @param {Message.Type} type\n     * @param {boolean} success\n     */\n    confirmExpectedMessage(type, success) {\n        this._channel.confirmExpectedMessage(type, success);\n    }\n\n    /**\n     * @param {number} [type]\n     * @param {string} [reason]\n     */\n    close(type, reason) {\n        if (!this._closed) {\n            const connType = this._inbound ? 'inbound' : 'outbound';\n            Log.d(NetworkConnection, `Closing ${connType} connection #${this._id} ${this._peerAddress || this._netAddress}` + (reason ? ` - ${reason}` : '') + ` (${type})`);\n        }\n        this._close(type, reason);\n    }\n\n    /**\n     * @param {NetworkConnection} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof NetworkConnection\n            && this._id === o.id;\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this._id.toString();\n    }\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return `NetworkConnection{id=${this._id}, protocol=${this._protocol}, peerAddress=${this._peerAddress}, netAddress=${this._netAddress}}`;\n    }\n\n    /** @type {number} */\n    get id() {\n        return this._id;\n    }\n\n    /** @type {number} */\n    get protocol() {\n        return this._protocol;\n    }\n\n    /** @type {PeerAddress} */\n    get peerAddress() {\n        return this._peerAddress;\n    }\n\n    /** @type {PeerAddress} */\n    set peerAddress(value) {\n        this._peerAddress = value;\n    }\n\n    /** @type {NetAddress} */\n    get netAddress() {\n        return this._netAddress;\n    }\n\n    /** @type {NetAddress} */\n    set netAddress(value) {\n        this._netAddress = value;\n    }\n\n    /** @type {number} */\n    get bytesSent() {\n        return this._bytesSent;\n    }\n\n    /** @type {number} */\n    get bytesReceived() {\n        return this._bytesReceived;\n    }\n\n    /** @type {boolean} */\n    get inbound() {\n        return this._inbound;\n    }\n\n    /** @type {boolean} */\n    get outbound() {\n        return !this._inbound;\n    }\n\n    /** @type {boolean} */\n    get closed() {\n        return this._closed;\n    }\n\n    /** @type {number} */\n    get lastMessageReceivedAt() {\n        return this._channel.lastMessageReceivedAt;\n    }\n}\n// Used to generate unique NetworkConnection ids.\nNetworkConnection._instanceCount = 0;\nClass.register(NetworkConnection);\n","class PeerChannel extends Observable {\n    /**\n     * @listens NetworkConnection#message\n     * @param {NetworkConnection} connection\n     */\n    constructor(connection) {\n        super();\n        this._conn = connection;\n        this._conn.on('message', msg => this._onMessage(msg));\n\n        // Forward specified events on the connection to listeners of this Observable.\n        this.bubble(this._conn, 'close', 'error');\n    }\n\n    /**\n     * @param {Uint8Array} rawMsg\n     * @private\n     */\n    async _onMessage(rawMsg) {\n        const start = Date.now();\n        let msg = null, type = null;\n\n        try {\n            const buf = new SerialBuffer(rawMsg);\n            type = MessageFactory.peekType(buf);\n            msg = MessageFactory.parse(buf);\n        } catch(e) {\n            Log.w(PeerChannel, `Failed to parse '${PeerChannel.Event[type]}' message from ${this.peerAddress || this.netAddress}`, e.message || e);\n\n            // Confirm that message arrived but could not be parsed successfully.\n            this._conn.confirmExpectedMessage(type, false);\n\n            // From the Bitcoin Reference:\n            //  \"Be careful of reject message feedback loops where two peers\n            //   each dont understand each others reject messages and so keep\n            //   sending them back and forth forever.\"\n\n            // If the message does not make sense at a whole or we fear to get into a reject loop,\n            // we ban the peer instead.\n            if (type === null || type === Message.Type.REJECT) {\n                this.close(CloseType.FAILED_TO_PARSE_MESSAGE_TYPE, 'Failed to parse message type');\n                return;\n            }\n\n            // Otherwise inform other node and ignore message.\n            this.reject(type, RejectMessage.Code.REJECT_MALFORMED, e.message || e);\n            return;\n        }\n\n        if (!msg) return;\n\n        // Confirm that message was successfully parsed.\n        this._conn.confirmExpectedMessage(type, true);\n\n        try {\n            await this.fire(PeerChannel.Event[msg.type], msg, this);\n            this.fire('message-log', msg, this, Date.now() - start);\n        } catch (e) {\n            Log.w(PeerChannel, `Error while processing '${PeerChannel.Event[msg.type]}' message from ${this.peerAddress || this.netAddress}: ${e}`);\n        }\n    }\n\n    /**\n     * @param {Message.Type|Array.<Message.Type>} types\n     * @param {function()} timeoutCallback\n     * @param {number} [msgTimeout]\n     * @param {number} [chunkTimeout]\n     */\n    expectMessage(types, timeoutCallback, msgTimeout, chunkTimeout) {\n        this._conn.expectMessage(types, timeoutCallback, msgTimeout, chunkTimeout);\n    }\n\n    /**\n     * @param {Message.Type} type\n     * @returns {boolean}\n     */\n    isExpectingMessage(type) {\n        return this._conn.isExpectingMessage(type);\n    }\n\n    /**\n     * @param {Message} msg\n     * @return {boolean}\n     * @private\n     */\n    _send(msg) {\n        return this._conn.send(msg.serialize());\n    }\n\n    /**\n     * @param {number} [type]\n     * @param {string} [reason]\n     */\n    close(type, reason) {\n        this._conn.close(type, reason);\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @param {Hash} headHash\n     * @param {Uint8Array} challengeNonce\n     * @return {boolean}\n     */\n    version(peerAddress, headHash, challengeNonce) {\n        return this._send(new VersionMessage(Version.CODE, peerAddress, GenesisConfig.GENESIS_HASH, headHash, challengeNonce));\n    }\n\n    /**\n     * @param {PublicKey} publicKey\n     * @param {Signature} signature\n     * @returns {boolean}\n     */\n    verack(publicKey, signature) {\n        return this._send(new VerAckMessage(publicKey, signature));\n    }\n\n    /**\n     * @param {Array.<InvVector>} vectors\n     * @return {boolean}\n     */\n    inv(vectors) {\n        return this._send(new InvMessage(vectors));\n    }\n\n    /**\n     * @param {Array.<InvVector>} vectors\n     * @return {boolean}\n     */\n    notFound(vectors) {\n        return this._send(new NotFoundMessage(vectors));\n    }\n\n    /**\n     * @param {Array.<InvVector>} vectors\n     * @return {boolean}\n     */\n    getData(vectors) {\n        return this._send(new GetDataMessage(vectors));\n    }\n\n    /**\n     * @param {Array.<InvVector>} vectors\n     * @return {boolean}\n     */\n    getHeader(vectors) {\n        return this._send(new GetHeaderMessage(vectors));\n    }\n\n    /**\n     * @param {Block} block\n     * @return {boolean}\n     */\n    block(block) {\n        return this._send(new BlockMessage(block));\n    }\n\n    /**\n     * @param {Uint8Array} block\n     * @return {boolean}\n     */\n    rawBlock(block) {\n        return this._send(new RawBlockMessage(block));\n    }\n\n    /**\n     * @param {BlockHeader} header\n     * @return {boolean}\n     */\n    header(header) {\n        return this._send(new HeaderMessage(header));\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {?AccountsProof} [accountsProof]\n     * @return {boolean}\n     */\n    tx(transaction, accountsProof) {\n        return this._send(new TxMessage(transaction, accountsProof));\n    }\n\n    /**\n     * @param {Array.<Hash>} locators\n     * @param {number} maxInvSize\n     * @param {boolean} [ascending]\n     * @return {boolean}\n     */\n    getBlocks(locators, maxInvSize=BaseInventoryMessage.VECTORS_MAX_COUNT, ascending=true) {\n        return this._send(new GetBlocksMessage(locators, maxInvSize, ascending ? GetBlocksMessage.Direction.FORWARD : GetBlocksMessage.Direction.BACKWARD));\n    }\n\n    /**\n     * @return {boolean}\n     */\n    mempool() {\n        return this._send(new MempoolMessage());\n    }\n\n    /**\n     * @param {Message.Type} messageType\n     * @param {RejectMessage.Code} code\n     * @param {string} reason\n     * @param {Uint8Array} [extraData]\n     * @return {boolean}\n     */\n    reject(messageType, code, reason, extraData) {\n        return this._send(new RejectMessage(messageType, code, reason, extraData));\n    }\n\n    /**\n     * @param {Subscription} subscription\n     * @returns {boolean}\n     */\n    subscribe(subscription) {\n        return this._send(new SubscribeMessage(subscription));\n    }\n\n    /**\n     * @param {Array.<PeerAddress>} addresses\n     * @return {boolean}\n     */\n    addr(addresses) {\n        return this._send(new AddrMessage(addresses));\n    }\n\n    /**\n     * @param {number} protocolMask\n     * @param {number} serviceMask\n     * @return {boolean}\n     */\n    getAddr(protocolMask, serviceMask) {\n        return this._send(new GetAddrMessage(protocolMask, serviceMask));\n    }\n\n    /**\n     * @param {number} nonce\n     * @return {boolean}\n     */\n    ping(nonce) {\n        return this._send(new PingMessage(nonce));\n    }\n\n    /**\n     * @param {number} nonce\n     * @return {boolean}\n     */\n    pong(nonce) {\n        return this._send(new PongMessage(nonce));\n    }\n\n    /**\n     * @param {PeerId} senderId\n     * @param {PeerId} recipientId\n     * @param {number} nonce\n     * @param {number} ttl\n     * @param {SignalMessage.Flags|number} flags\n     * @param {Uint8Array} [payload]\n     * @param {PublicKey} [senderPubKey]\n     * @param {Signature} [signature]\n     * @return {boolean}\n     */\n    signal(senderId, recipientId, nonce, ttl, flags, payload, senderPubKey, signature) {\n        return this._send(new SignalMessage(senderId, recipientId, nonce, ttl, flags, payload, senderPubKey, signature));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @return {boolean}\n     */\n    getAccountsProof(blockHash, addresses) {\n        return this._send(new GetAccountsProofMessage(blockHash, addresses));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {AccountsProof} [proof]\n     * @return {boolean}\n     */\n    accountsProof(blockHash, proof) {\n        return this._send(new AccountsProofMessage(blockHash, proof));\n    }\n\n    /**\n     * @return {boolean}\n     */\n    getChainProof() {\n        return this._send(new GetChainProofMessage());\n    }\n\n    /**\n     * @param {ChainProof} proof\n     * @return {boolean}\n     */\n    chainProof(proof) {\n        return this._send(new ChainProofMessage(proof));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {string} startPrefix\n     * @return {boolean}\n     */\n    getAccountsTreeChunk(blockHash, startPrefix) {\n        return this._send(new GetAccountsTreeChunkMessage(blockHash, startPrefix));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {AccountsTreeChunk} [chunk]\n     * @return {boolean}\n     */\n    accountsTreeChunk(blockHash, chunk) {\n        return this._send(new AccountsTreeChunkMessage(blockHash, chunk));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {Array.<Address>} addresses\n     * @return {boolean}\n     */\n    getTransactionsProof(blockHash, addresses) {\n        return this._send(new GetTransactionsProofMessage(blockHash, addresses));\n    }\n\n    /**\n     * @param {Hash} blockHash\n     * @param {TransactionsProof} [proof]\n     * @return {boolean}\n     */\n    transactionsProof(blockHash, proof) {\n        return this._send(new TransactionsProofMessage(blockHash, proof));\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {boolean}\n     */\n    getTransactionReceipts(address) {\n        return this._send(new GetTransactionReceiptsMessage(address));\n    }\n\n    /**\n     * @param {Array.<TransactionReceipt>} transactionReceipts\n     * @returns {boolean}\n     */\n    transactionReceipts(transactionReceipts) {\n        return this._send(new TransactionReceiptsMessage(transactionReceipts));\n    }\n\n    /**\n     * @param {Hash} blockHashToProve\n     * @param {Hash} knownBlockHash\n     * @returns {boolean}\n     */\n    getBlockProof(blockHashToProve, knownBlockHash) {\n        return this._send(new GetBlockProofMessage(blockHashToProve, knownBlockHash));\n    }\n\n    /**\n     * @param {BlockChain} [proof]\n     * @returns {boolean}\n     */\n    blockProof(proof) {\n        return this._send(new BlockProofMessage(proof));\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    getHead() {\n        return this._send(new GetHeadMessage());\n    }\n\n    /**\n     * @param {BlockHeader} header\n     * @returns {boolean}\n     */\n    head(header) {\n        return this._send(new HeadMessage(header));\n    }\n\n    /**\n     * @param {PeerChannel} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof PeerChannel\n            && this._conn.equals(o.connection);\n    }\n\n    /**\n     * @returns {string}\n     */\n    hashCode() {\n        return this._conn.hashCode();\n    }\n\n    /**\n     * @return {string}\n     */\n    toString() {\n        return `PeerChannel{conn=${this._conn}}`;\n    }\n\n    /** @type {NetworkConnection} */\n    get connection() {\n        return this._conn;\n    }\n\n    /** @type {number} */\n    get id() {\n        return this._conn.id;\n    }\n\n    /** @type {number} */\n    get protocol() {\n        return this._conn.protocol;\n    }\n\n    /** @type {PeerAddress} */\n    get peerAddress() {\n        return this._conn.peerAddress;\n    }\n\n    /** @type {PeerAddress} */\n    set peerAddress(value) {\n        this._conn.peerAddress = value;\n    }\n\n    /** @type {NetAddress} */\n    get netAddress() {\n        return this._conn.netAddress;\n    }\n\n    /** @type {NetAddress} */\n    set netAddress(value) {\n        this._conn.netAddress = value;\n    }\n\n    /** @type {boolean} */\n    get closed() {\n        return this._conn.closed;\n    }\n\n    /** @type {number} */\n    get lastMessageReceivedAt() {\n        return this._conn.lastMessageReceivedAt;\n    }\n}\nClass.register(PeerChannel);\n\nPeerChannel.Event = {};\nPeerChannel.Event[Message.Type.VERSION] = 'version';\nPeerChannel.Event[Message.Type.INV] = 'inv';\nPeerChannel.Event[Message.Type.GET_DATA] = 'get-data';\nPeerChannel.Event[Message.Type.GET_HEADER] = 'get-header';\nPeerChannel.Event[Message.Type.NOT_FOUND] = 'not-found';\nPeerChannel.Event[Message.Type.GET_BLOCKS] = 'get-blocks';\nPeerChannel.Event[Message.Type.BLOCK] = 'block';\nPeerChannel.Event[Message.Type.HEADER] = 'header';\nPeerChannel.Event[Message.Type.TX] = 'tx';\nPeerChannel.Event[Message.Type.MEMPOOL] = 'mempool';\nPeerChannel.Event[Message.Type.REJECT] = 'reject';\nPeerChannel.Event[Message.Type.SUBSCRIBE] = 'subscribe';\nPeerChannel.Event[Message.Type.ADDR] = 'addr';\nPeerChannel.Event[Message.Type.GET_ADDR] = 'get-addr';\nPeerChannel.Event[Message.Type.PING] = 'ping';\nPeerChannel.Event[Message.Type.PONG] = 'pong';\nPeerChannel.Event[Message.Type.SIGNAL] = 'signal';\nPeerChannel.Event[Message.Type.GET_CHAIN_PROOF] = 'get-chain-proof';\nPeerChannel.Event[Message.Type.CHAIN_PROOF] = 'chain-proof';\nPeerChannel.Event[Message.Type.GET_ACCOUNTS_PROOF] = 'get-accounts-proof';\nPeerChannel.Event[Message.Type.ACCOUNTS_PROOF] = 'accounts-proof';\nPeerChannel.Event[Message.Type.GET_ACCOUNTS_TREE_CHUNK] = 'get-accounts-tree-chunk';\nPeerChannel.Event[Message.Type.ACCOUNTS_TREE_CHUNK] = 'accounts-tree-chunk';\nPeerChannel.Event[Message.Type.GET_TRANSACTIONS_PROOF] = 'get-transactions-proof';\nPeerChannel.Event[Message.Type.TRANSACTIONS_PROOF] = 'transactions-proof';\nPeerChannel.Event[Message.Type.GET_TRANSACTION_RECEIPTS] = 'get-transaction-receipts';\nPeerChannel.Event[Message.Type.TRANSACTION_RECEIPTS] = 'transaction-receipts';\nPeerChannel.Event[Message.Type.GET_BLOCK_PROOF] = 'get-block-proof';\nPeerChannel.Event[Message.Type.BLOCK_PROOF] = 'block-proof';\nPeerChannel.Event[Message.Type.GET_HEAD] = 'get-head';\nPeerChannel.Event[Message.Type.HEAD] = 'head';\nPeerChannel.Event[Message.Type.VERACK] = 'verack';\n","class NetworkAgent extends Observable {\n    /**\n     * @param {IBlockchain} blockchain\n     * @param {PeerAddressBook} addresses\n     * @param {NetworkConfig} networkConfig\n     * @param {PeerChannel} channel\n     *\n     * @listens PeerChannel#version\n     * @listens PeerChannel#verack\n     * @listens PeerChannel#addr\n     * @listens PeerChannel#getAddr\n     * @listens PeerChannel#ping\n     * @listens PeerChannel#pong\n     * @listens PeerChannel#close\n     */\n    constructor(blockchain, addresses, networkConfig, channel) {\n        super();\n        /** @type {IBlockchain} */\n        this._blockchain = blockchain;\n        /** @type {PeerAddressBook} */\n        this._addresses = addresses;\n        /** @type {NetworkConfig} */\n        this._networkConfig = networkConfig;\n        /** @type {PeerChannel} */\n        this._channel = channel;\n\n        /**\n         * The peer object we create after the handshake completes.\n         * @type {Peer}\n         * @private\n         */\n        this._peer = null;\n\n        /**\n         * All peerAddresses that we think the remote peer knows.\n         * @type {HashSet.<PeerAddress>}\n         * @private\n         */\n        this._knownAddresses = new HashSet();\n\n        /**\n         * Helper object to keep track of timeouts & intervals.\n         * @type {Timers}\n         * @private\n         */\n        this._timers = new Timers();\n\n        /**\n         * True if we have received the peer's version message.\n         * @type {boolean}\n         * @private\n         */\n        this._versionReceived = false;\n\n        /**\n         * True if we have received the peer's verack message.\n         * @type {boolean}\n         * @private\n         */\n        this._verackReceived = false;\n\n        /**\n         * True if we have successfully sent our version message.\n         * @type {boolean}\n         * @private\n         */\n        this._versionSent = false;\n\n        /**\n         * True if we have successfully sent our verack message.\n         * @type {boolean}\n         * @private\n         */\n        this._verackSent = false;\n\n        /**\n         * Number of times we have tried to send out the version message.\n         * @type {number}\n         * @private\n         */\n        this._versionAttempts = 0;\n\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this._peerAddressVerified = false;\n\n        /**\n         * @type {Uint8Array}\n         * @private\n         */\n        this._peerChallengeNonce = null;\n\n        /**\n         * @type {Map.<number, number>}\n         * @private\n         */\n        this._pingTimes = new Map();\n\n        /** @type {Uint8Array} */\n        this._challengeNonce = new Uint8Array(VersionMessage.CHALLENGE_SIZE);\n        CryptoWorker.lib.getRandomValues(this._challengeNonce);\n\n        /** @type {ThrottledQueue} */\n        this._addrQueue = new ThrottledQueue(\n            NetworkAgent.MAX_ADDR_RELAY_PER_MESSAGE,\n            NetworkAgent.MAX_ADDR_RELAY_PER_MESSAGE,\n            NetworkAgent.ADDR_QUEUE_INTERVAL,\n            NetworkAgent.ADDR_RATE_LIMIT,\n            () => this._relayNow());\n\n        this._addrLimit = new RateLimit(NetworkAgent.ADDR_RATE_LIMIT);\n\n        // Listen to network/control messages from the peer.\n        channel.on('version', msg => this._onVersion(msg));\n        channel.on('verack', msg => this._onVerAck(msg));\n        channel.on('addr', msg => this._onAddr(msg));\n        channel.on('get-addr', msg => this._onGetAddr(msg));\n        channel.on('ping', msg => this._onPing(msg));\n        channel.on('pong', msg => this._onPong(msg));\n\n        // Clean up when the peer disconnects.\n        channel.on('close', () => this._onClose());\n    }\n\n    /**\n     * @param {Array.<PeerAddress|RtcPeerAddress>} addresses\n     */\n    relayAddresses(addresses) {\n        // Don't relay if the handshake hasn't finished yet.\n        if (!this._verackReceived || !this._versionSent) {\n            return;\n        }\n\n        for (const address of addresses) {\n            this._addrQueue.enqueue(address);\n        }\n    }\n\n    _relayNow() {\n        const addresses = this._addrQueue.dequeueMulti(NetworkAgent.MAX_ADDR_RELAY_PER_MESSAGE);\n        if (addresses.length === 0) return;\n\n        // Only relay addresses that the peer doesn't know yet or that have improved.\n        // If the address the peer knows is older than RELAY_THROTTLE, relay the address again.\n        const filteredAddresses = addresses.filter(addr => {\n            // Exclude RTC addresses that are already at MAX_DISTANCE.\n            if (addr.protocol === Protocol.RTC && addr.distance >= PeerAddressBook.MAX_DISTANCE) {\n                return false;\n            }\n\n            // Exclude DumbPeerAddresses.\n            if (addr.protocol === Protocol.DUMB) {\n                return false;\n            }\n\n            const knownAddress = this._knownAddresses.get(addr);\n            return !addr.isSeed() // Never relay seed addresses.\n                && (!knownAddress // New address.\n                    || (addr.protocol === Protocol.RTC && knownAddress.distance > addr.distance) // Better distance.\n                    || knownAddress.timestamp < Date.now() - NetworkAgent.RELAY_THROTTLE); // Relay throttle.\n        });\n\n        if (filteredAddresses.length) {\n            this._channel.addr(filteredAddresses);\n\n            // We assume that the peer knows these addresses now.\n            for (const address of filteredAddresses) {\n                this._knownAddresses.add(address);\n            }\n        }\n    }\n\n\n    /* Handshake */\n\n    handshake() {\n        if (this._versionSent) {\n            // Version already sent, no need to handshake again.\n            return;\n        }\n\n        // Kick off the handshake by telling the peer our version, network address & blockchain head hash.\n        // Firefox sends the data-channel-open event too early, so sending the version message might fail.\n        // Try again in this case.\n        if (!this._channel.version(this._networkConfig.peerAddress, this._blockchain.headHash, this._challengeNonce)) {\n            this._versionAttempts++;\n            if (this._versionAttempts >= NetworkAgent.VERSION_ATTEMPTS_MAX || this._channel.closed) {\n                this._channel.close(CloseType.SENDING_OF_VERSION_MESSAGE_FAILED, 'sending of version message failed');\n                return;\n            }\n\n            setTimeout(this.handshake.bind(this), NetworkAgent.VERSION_RETRY_DELAY);\n            return;\n        }\n\n        this._versionSent = true;\n\n        // Drop the peer if it doesn't send us a version message.\n        // Only do this if we haven't received the peer's version message already.\n        if (!this._versionReceived) {\n            // TODO Should we ban instead?\n            this._timers.setTimeout('version', () => {\n                this._timers.clearTimeout('version');\n                this._channel.close(CloseType.VERSION_TIMEOUT, 'version timeout');\n            }, NetworkAgent.HANDSHAKE_TIMEOUT);\n        } else if (this._peerAddressVerified) {\n            this._sendVerAck();\n        }\n\n        this._timers.setTimeout('verack', () => {\n            this._timers.clearTimeout('verack');\n            this._channel.close(CloseType.VERACK_TIMEOUT, 'verack timeout');\n        }, NetworkAgent.HANDSHAKE_TIMEOUT * 2);\n    }\n\n    /**\n     * @param {VersionMessage} msg\n     * @private\n     */\n    _onVersion(msg) {\n        Log.d(NetworkAgent, () => `[VERSION] ${msg.peerAddress} ${msg.headHash.toBase64()}`);\n\n        const now = Date.now();\n\n        // Make sure this is a valid message in our current state.\n        if (!this._canAcceptMessage(msg)) {\n            return;\n        }\n\n        // Ignore duplicate version messages.\n        if (this._versionReceived) {\n            Log.d(NetworkAgent, () => `Ignoring duplicate version message from ${this._channel.peerAddress}`);\n            return;\n        }\n\n        // Clear the version timeout.\n        this._timers.clearTimeout('version');\n\n        // Check if the peer is running a compatible version.\n        if (!Version.isCompatible(msg.version)) {\n            this._channel.reject(Message.Type.VERSION, RejectMessage.Code.REJECT_OBSOLETE, `incompatible version (ours=${Version.CODE}, theirs=${msg.version})`);\n            this._channel.close(CloseType.INCOMPATIBLE_VERSION, `incompatible version (ours=${Version.CODE}, theirs=${msg.version})`);\n            return;\n        }\n\n        // Check if the peer is working on the same genesis block.\n        if (!GenesisConfig.GENESIS_HASH.equals(msg.genesisHash)) {\n            this._channel.close(CloseType.DIFFERENT_GENESIS_BLOCK, `different genesis block (${msg.genesisHash})`);\n            return;\n        }\n\n        // Check that the given peerAddress is correctly signed.\n        if (!msg.peerAddress.verifySignature()) {\n            this._channel.close(CloseType.INVALID_PEER_ADDRESS_IN_VERSION_MESSAGE, 'invalid peerAddress in version message');\n            return;\n        }\n\n        // TODO check services?\n\n        // Check that the given peerAddress matches the one we expect.\n        // In case of inbound WebSocket connections, this is the first time we\n        // see the remote peer's peerAddress.\n        const peerAddress = msg.peerAddress;\n        if (this._channel.peerAddress) {\n            if (!this._channel.peerAddress.equals(peerAddress)) {\n                this._channel.close(CloseType.UNEXPECTED_PEER_ADDRESS_IN_VERSION_MESSAGE, 'unexpected peerAddress in version message');\n                return;\n            }\n            this._peerAddressVerified = true;\n        }\n\n        // The client might not send its netAddress. Set it from our address database if we have it.\n        if (!peerAddress.netAddress) {\n            /** @type {PeerAddress} */\n            const storedAddress = this._addresses.get(peerAddress);\n            if (storedAddress && storedAddress.netAddress) {\n                peerAddress.netAddress = storedAddress.netAddress;\n            }\n        }\n\n        // Set/update the channel's peer address.\n        this._channel.peerAddress = peerAddress;\n\n        // Create peer object. Since the initial version message received from the\n        // peer contains their local timestamp, we can use it to calculate their\n        // offset to our local timestamp and store it for later (last argument).\n        this._peer = new Peer(\n            this._channel,\n            msg.version,\n            msg.headHash,\n            peerAddress.timestamp - now\n        );\n\n        this._peerChallengeNonce = msg.challengeNonce;\n        this._versionReceived = true;\n\n        // Tell listeners that we received this peer's version information.\n        // Listeners registered to this event might close the connection to this peer.\n        this.fire('version', this._peer, this);\n\n        // Abort handshake if the connection was closed.\n        if (this._channel.closed) {\n            return;\n        }\n\n        if (!this._versionSent) {\n            this.handshake();\n            return;\n        }\n\n        if (this._peerAddressVerified) {\n            this._sendVerAck();\n        }\n\n        if (this._verackReceived) {\n            this._finishHandshake();\n        }\n    }\n\n    _sendVerAck() {\n        Assert.that(this._peerAddressVerified);\n\n        const data = BufferUtils.concatTypedArrays(this._channel.peerAddress.peerId.serialize(), this._peerChallengeNonce);\n        const signature = Signature.create(this._networkConfig.keyPair.privateKey, this._networkConfig.keyPair.publicKey, data);\n        this._channel.verack(this._networkConfig.keyPair.publicKey, signature);\n\n        this._verackSent = true;\n    }\n\n    /**\n     * @param {VerAckMessage} msg\n     * @private\n     */\n    _onVerAck(msg) {\n        Log.d(NetworkAgent, () => `[VERACK] from ${this._channel.peerAddress}`);\n\n        // Make sure this is a valid message in our current state.\n        if (!this._canAcceptMessage(msg)) {\n            return;\n        }\n\n        // Ignore duplicate verack messages.\n        if (this._verackReceived) {\n            Log.d(NetworkAgent, () => `Ignoring duplicate verack message from ${this._channel.peerAddress}`);\n            return;\n        }\n\n        // Clear the verack timeout.\n        this._timers.clearTimeout('verack');\n\n        // Verify public key\n        if (!msg.publicKey.toPeerId().equals(this._channel.peerAddress.peerId)) {\n            this._channel.close(CloseType.INVALID_PUBLIC_KEY_IN_VERACK_MESSAGE, 'Invalid public key in verack message');\n            return;\n        }\n\n        // Verify signature\n        const data = BufferUtils.concatTypedArrays(this._networkConfig.peerAddress.peerId.serialize(), this._challengeNonce);\n        if (!msg.signature.verify(msg.publicKey, data)) {\n            this._channel.close(CloseType.INVALID_SIGNATURE_IN_VERACK_MESSAGE, 'Invalid signature in verack message');\n            return;\n        }\n\n        if (!this._peerAddressVerified) {\n            this._peerAddressVerified = true;\n            this._sendVerAck();\n        }\n\n        // Remember that the peer has sent us this address.\n        this._knownAddresses.add(this._channel.peerAddress);\n\n        this._verackReceived = true;\n\n        if (this._verackSent) {\n            this._finishHandshake();\n        }\n    }\n\n    _finishHandshake() {\n        // Setup regular connectivity check.\n        // TODO randomize interval?\n        this._timers.setInterval('connectivity',\n            () => this._checkConnectivity(),\n            NetworkAgent.CONNECTIVITY_CHECK_INTERVAL);\n\n        // Regularly announce our address.\n        this._timers.setInterval('announce-addr',\n            () => this._channel.addr([this._networkConfig.peerAddress]),\n            NetworkAgent.ANNOUNCE_ADDR_INTERVAL);\n\n        // Tell listeners that the handshake with this peer succeeded.\n        this.fire('handshake', this._peer, this);\n\n        // Request new network addresses from the peer.\n        this._requestAddresses();\n    }\n\n\n    /* Addresses */\n\n    _requestAddresses() {\n        // Request addresses from peer.\n        this._channel.getAddr(this._networkConfig.protocolMask, this._networkConfig.services.accepted);\n\n        // We don't use a timeout here. The peer will not respond with an addr message if\n        // it doesn't have any new addresses.\n    }\n\n    /**\n     * @param {AddrMessage} msg\n     * @private\n     */\n    async _onAddr(msg) {\n        // Make sure this is a valid message in our current state.\n        if (!this._canAcceptMessage(msg)) {\n            return;\n        }\n\n        // Reject messages that contain more than 1000 addresses, ban peer (bitcoin).\n        if (msg.addresses.length > NetworkAgent.MAX_ADDR_PER_MESSAGE) {\n            Log.w(NetworkAgent, 'Rejecting addr message - too many addresses');\n            this._channel.close(CloseType.ADDR_MESSAGE_TOO_LARGE, 'addr message too large');\n            return;\n        }\n\n        if (!this._addrLimit.note(msg.addresses.length)) {\n            Log.w(NetworkAgent, 'Rejecting addr message - rate-limit exceeded');\n            this._channel.close(CloseType.RATE_LIMIT_EXCEEDED, 'rate-limit exceeded');\n            return;\n        }\n\n        // Check the addresses the peer send us.\n        for (const addr of msg.addresses) {\n            if (!addr.verifySignature()) {\n                this._channel.close(CloseType.INVALID_ADDR, 'invalid addr');\n                return;\n            }\n\n            if (addr.protocol === Protocol.WS && !addr.globallyReachable()) {\n                this._channel.close(CloseType.ADDR_NOT_GLOBALLY_REACHABLE, 'addr not globally reachable');\n                return;\n            }\n\n            this._knownAddresses.add(addr);\n        }\n\n        // Put the new addresses in the address pool.\n        this._addresses.add(this._channel, msg.addresses);\n\n        // Tell listeners that we have received new addresses.\n        this.fire('addr', msg.addresses, this);\n    }\n\n    /**\n     * @private\n     * @param {GetAddrMessage} msg\n     * @return {void}\n     */\n    _onGetAddr(msg) {\n        // Make sure this is a valid message in our current state.\n        if (!this._canAcceptMessage(msg)) {\n            return;\n        }\n\n        // Find addresses that match the given serviceMask.\n        const addresses = this._addresses.query(msg.protocolMask, msg.serviceMask, NetworkAgent.MAX_ADDR_PER_MESSAGE);\n\n        const filteredAddresses = addresses.filter(addr => {\n            // Exclude RTC addresses that are already at MAX_DISTANCE.\n            if (addr.protocol === Protocol.RTC && addr.distance >= PeerAddressBook.MAX_DISTANCE) {\n                return false;\n            }\n\n            // Exclude known addresses from the response unless they are older than RELAY_THROTTLE.\n            const knownAddress = this._knownAddresses.get(addr);\n            return !knownAddress || knownAddress.timestamp < Date.now() - NetworkAgent.RELAY_THROTTLE;\n        });\n\n        // Send the addresses back to the peer.\n        // If we don't have any new addresses, don't send the message at all.\n        if (filteredAddresses.length) {\n            this._channel.addr(filteredAddresses);\n        }\n    }\n\n    /* Connectivity Check */\n\n    _checkConnectivity() {\n        // Generate random nonce.\n        const nonce = NumberUtils.randomUint32();\n\n        // Send ping message to peer.\n        // If sending the ping message fails, assume the connection has died.\n        if (!this._channel.ping(nonce)) {\n            this._channel.close(CloseType.SENDING_PING_MESSAGE_FAILED, 'sending ping message failed');\n            return;\n        }\n\n        // Save ping timestamp to detect the speed of the connection.\n        const startTime = Date.now();\n        this._pingTimes.set(nonce, startTime);\n\n        // Expect the peer to answer with a pong message if we haven't heard anything from it\n        // within the last CONNECTIVITY_CHECK_INTERVAL. Drop the peer otherwise.\n        if (this._channel.lastMessageReceivedAt < startTime - NetworkAgent.CONNECTIVITY_CHECK_INTERVAL) {\n            this._timers.setTimeout(`ping_${nonce}`, () => {\n                this._timers.clearTimeout(`ping_${nonce}`);\n                this._pingTimes.delete(nonce);\n                this._channel.close(CloseType.PING_TIMEOUT, 'ping timeout');\n            }, NetworkAgent.PING_TIMEOUT);\n        }\n    }\n\n    /**\n     * @param {PingMessage} msg\n     * @private\n     */\n    _onPing(msg) {\n        // Make sure this is a valid message in our current state.\n        if (!this._canAcceptMessage(msg)) {\n            return;\n        }\n\n        // Respond with a pong message\n        this._channel.pong(msg.nonce);\n    }\n\n    /**\n     * @param {PongMessage} msg\n     * @fires NetworkAgent#ping-pong\n     * @private\n     */\n    _onPong(msg) {\n        // Clear the ping timeout for this nonce.\n        this._timers.clearTimeout(`ping_${msg.nonce}`);\n\n        /** @type {number} */\n        const startTime = this._pingTimes.get(msg.nonce);\n        if (startTime) {\n            const delta = Date.now() - startTime;\n            if (delta > 0) {\n                this.fire('ping-pong', delta);\n            }\n            this._pingTimes.delete(msg.nonce);\n        }\n    }\n\n    /**\n     * @private\n     */\n    _onClose() {\n        // Clear all timers and intervals when the peer disconnects.\n        this._timers.clearAll();\n        this._addrQueue.stop();\n    }\n\n    /**\n     * @param {Message} msg\n     * @return {boolean}\n     * @private\n     */\n    _canAcceptMessage(msg) {\n        // The first message must be the version message.\n        if (!this._versionReceived && msg.type !== Message.Type.VERSION) {\n            Log.w(NetworkAgent, `Discarding '${PeerChannel.Event[msg.type] || msg.type}' message from ${this._channel}`\n                + ' - no version message received previously');\n            return false;\n        }\n        if (this._versionReceived && !this._verackReceived && msg.type !== Message.Type.VERACK) {\n            Log.w(NetworkAgent, `Discarding '${PeerChannel.Event[msg.type] || msg.type}' message from ${this._channel}`\n                + ' - no verack message received previously');\n            return false;\n        }\n        return true;\n    }\n\n    /** @type {PeerChannel} */\n    get channel() {\n        return this._channel;\n    }\n\n    /** @type {Peer} */\n    get peer() {\n        return this._peer;\n    }\n}\n\nNetworkAgent.HANDSHAKE_TIMEOUT = 1000 * 4; // 4 seconds\nNetworkAgent.PING_TIMEOUT = 1000 * 10; // 10 seconds\nNetworkAgent.CONNECTIVITY_CHECK_INTERVAL = 1000 * 60; // 1 minute\nNetworkAgent.ANNOUNCE_ADDR_INTERVAL = 1000 * 60 * 5; // 5 minutes\nNetworkAgent.RELAY_THROTTLE = 1000 * 60 * 2; // 2 minutes\nNetworkAgent.VERSION_ATTEMPTS_MAX = 10;\nNetworkAgent.VERSION_RETRY_DELAY = 500; // 500 ms\nNetworkAgent.ADDR_RATE_LIMIT = 2000;\nNetworkAgent.ADDR_QUEUE_INTERVAL = 5000;\nNetworkAgent.MAX_ADDR_PER_MESSAGE = 1000;\nNetworkAgent.MAX_ADDR_RELAY_PER_MESSAGE = 10;\nClass.register(NetworkAgent);\n","class PeerConnectionStatistics {\n    /**\n     * @constructor\n     */\n    constructor() {\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        this._latencies = [];\n\n        /**\n         * @type {HashMap<number, number>}\n         * @private\n         */\n        this._messages = new HashMap();\n    }\n\n    /**\n     * @returns {void}\n     */\n    reset() {\n        this._latencies = [];\n        this._messages = new HashMap();\n    }\n\n    /**\n     * @param {number} latency\n     * @returns {void}\n     */\n    addLatency(latency) {\n        this._latencies.push(latency);\n    }\n\n    /**\n     * @param {Message} msg\n     * @returns {void}\n     */\n    addMessage(msg) {\n        this._messages.put(msg.type, this._messages.contains(msg.type) ? this._messages.get(msg.type) + 1 : 1);\n    }\n\n    /**\n     * @param {number} msgType\n     * @returns {number}\n     */\n    getMessageCount(msgType) {\n        return this._messages.contains(msgType) ? this._messages.get(msgType) : 0;\n    }\n\n    /** @type {number} */\n    get latencyMedian() {\n        const length = this._latencies.length;\n\n        if (length === 0) {\n            return 0;\n        }\n\n        this._latencies.sort((a, b) => a - b);\n        let median;\n        if ((length % 2) === 0) {\n            median = Math.round((this._latencies[(length / 2) - 1] + this._latencies[length / 2]) / 2);\n        } else {\n            median = this._latencies[(length - 1) / 2];\n        }\n        return median;\n    }\n\n}\nClass.register(PeerConnectionStatistics);\n","class PeerConnection {\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {PeerConnection}\n     */\n    static getOutbound(peerAddress) {\n        const peerConnection = new PeerConnection();\n        peerConnection._peerAddress = peerAddress;\n        peerConnection._state = PeerConnectionState.CONNECTING;\n        return peerConnection;\n    }\n\n    /**\n     * @param {NetworkConnection} networkConnection\n     * @returns {PeerConnection}\n     */\n    static getInbound(networkConnection) {\n        const peerConnection = new PeerConnection();\n        peerConnection._networkConnection = networkConnection;\n        return peerConnection;\n    }\n\n    /**\n     * @constructor\n     */\n    constructor() {\n        // Unique id for this connection.\n        /** @type {number} */\n        this._id = PeerConnection._instanceCount++;\n\n        /**\n         * @type {PeerAddress}\n         * @private\n         */\n        this._peerAddress = null;\n\n        // Helper Objects are added during lifecycle\n        /**\n         * @type {NetworkConnection}\n         * @private\n         */\n        this._networkConnection = null;\n \n        /**\n         * @type {PeerChannel}\n         * @private\n         */\n        this._peerChannel = null;\n\n        /**\n         * @type {NetworkAgent}\n         * @private\n         */\n        this._networkAgent = null;\n\n        /**\n         * @type {Peer}\n         * @private\n         */\n        this._peer = null;\n\n        /**\n         * Lifecycle state of connection\n         * @type {number}\n         * @private\n         */\n        this._state = PeerConnectionState.NEW;\n\n        /**\n         * Latest score given, computed by PeerScorer\n         * @type {number}\n         * @private\n         */\n        this._score = null;\n\n        /**\n         * @type {number}\n         * @private\n         */\n        this._establishedSince = null;\n\n        /**\n         * @type {PeerConnectionStatistics}\n         * @private\n         */\n        this._statistics = new PeerConnectionStatistics();\n    }\n\n    /** @type {number} */\n    get id() {\n        return this._id;\n    }\n\n    /** @type {number} */\n    get state() {\n        return this._state;\n    }\n\n    /** @type {PeerAddress} */\n    get peerAddress() {\n        return this._peerAddress;\n    }\n\n    /** @param {PeerAddress} value */\n    set peerAddress(value) {\n        this._peerAddress = value;\n    }\n\n    /** @type {NetworkConnection} */\n    get networkConnection() {\n        return this._networkConnection;\n    }\n\n    /** @param {NetworkConnection} value */\n    set networkConnection(value) {\n        this._networkConnection = value;\n        this._state = PeerConnectionState.CONNECTED;\n    }\n\n    /** @type {PeerChannel} */\n    get peerChannel() {\n        return this._peerChannel;\n    }\n\n    /** @param {PeerChannel} value */\n    set peerChannel(value) {\n        this._peerChannel = value;\n    }\n\n    /** @type {NetworkAgent} */\n    get networkAgent() {\n        return this._networkAgent;\n    }\n\n    /** @param {NetworkAgent} value */\n    set networkAgent(value) {\n        this._networkAgent = value;\n    }\n\n    /**\n     * @returns {void}\n     */\n    negotiating() {\n        Assert.that(this._state === PeerConnectionState.CONNECTED);\n        this._state = PeerConnectionState.NEGOTIATING;\n    }\n\n    /** @type {Peer} */\n    get peer() {\n        return this._peer;\n    }\n\n    /** @param {Peer} value */\n    set peer(value) {\n        this._peer = value;\n        this._state = PeerConnectionState.ESTABLISHED;\n        this._establishedSince = Date.now();\n\n        // start statistics\n        this._networkAgent.on('ping-pong', (latency) => this._statistics.addLatency(latency));\n        this._peerChannel.on('message-log', (msg) => this._statistics.addMessage(msg));\n    }\n\n    /** @type {number} */\n    get score() {\n        return this._score;\n    }\n\n    /** @param {number} value */\n    set score(value) {\n        this._score = value;\n    }\n\n    /** @type {number} */\n    get establishedSince() {\n        return this._establishedSince;\n    }\n\n    /** @type {number} */\n    get ageEstablished() {\n        return Date.now() - this.establishedSince;\n    }\n\n    /** @type {PeerConnectionStatistics} */\n    get statistics() {\n        return this._statistics;\n    }\n\n    /**\n     * @returns {void}\n     */\n    close() {\n        this._state = PeerConnectionState.CLOSED;\n        this._networkConnection = null;\n        this._networkAgent = null;\n        this._peerChannel = null;\n        this._peer = null;\n    }\n}\n// Used to generate unique PeerConnection ids.\nPeerConnection._instanceCount = 0;\nClass.register(PeerConnection);\n\nclass PeerConnectionState {\n}\nPeerConnectionState.NEW = 1;\nPeerConnectionState.CONNECTING = 2;\nPeerConnectionState.CONNECTED = 3;\nPeerConnectionState.NEGOTIATING = 4;\nPeerConnectionState.ESTABLISHED = 5;\nPeerConnectionState.CLOSED = 6;\nClass.register(PeerConnectionState);\n","class SignalProcessor {\n    /**\n     * @constructor\n     * @param {PeerAddressBook} peerAddresses\n     * @param {NetworkConfig} networkConfig\n     * @param {WebRtcConnector} rtcConnector\n     */\n    constructor(peerAddresses, networkConfig, rtcConnector) {\n        /**\n         * @type {PeerAddressBook}\n         * @private\n         */\n        this._addresses = peerAddresses;\n\n        /**\n         * @type {NetworkConfig}\n         * @private\n         */\n        this._networkConfig = networkConfig;\n\n        /**\n         * @type {WebRtcConnector}\n         * @private\n         */\n        this._rtcConnector = rtcConnector;\n\n        /**\n         * @type {SignalStore}\n         * @private\n         */\n        this._forwards = new SignalStore();\n    }\n\n    /**\n     * @param {PeerChannel} channel\n     * @param {SignalMessage} msg\n     * @returns {void}\n     */\n    onSignal(channel, msg) {\n        // Discard signals with invalid TTL.\n        if (msg.ttl > Network.SIGNAL_TTL_INITIAL) {\n            channel.close(CloseType.INVALID_SIGNAL_TTL, 'invalid signal ttl');\n            return;\n        }\n\n        // Discard signals that have a payload, which is not properly signed.\n        if (msg.hasPayload() && !msg.verifySignature()) {\n            channel.close(CloseType.INVALID_SIGNATURE, 'invalid signature');\n            return;\n        }\n\n        // Can be undefined for non-rtc nodes.\n        const myPeerId = this._networkConfig.peerAddress.peerId;\n\n        // Discard signals from myself.\n        if (msg.senderId.equals(myPeerId)) {\n            Log.w(SignalProcessor, `Received signal from myself to ${msg.recipientId} from ${channel.peerAddress} (myId: ${myPeerId})`);\n            return;\n        }\n\n        // If the signal has the unroutable flag set and we previously forwarded a matching signal,\n        // mark the route as unusable.\n        if (msg.isUnroutable() && this._forwards.signalForwarded(/*senderId*/ msg.recipientId, /*recipientId*/ msg.senderId, /*nonce*/ msg.nonce)) {\n            const senderAddr = this._addresses.getByPeerId(msg.senderId);\n            this._addresses.unroutable(channel, senderAddr);\n        }\n\n        // If the signal is intended for us, pass it on to our WebRTC connector.\n        if (msg.recipientId.equals(myPeerId)) {\n            // If we sent out a signal that did not reach the recipient because of TTL\n            // or it was unroutable, delete this route.\n            if (this._rtcConnector.isValidSignal(msg) && (msg.isUnroutable() || msg.isTtlExceeded())) {\n                const senderAddr = this._addresses.getByPeerId(msg.senderId);\n                this._addresses.unroutable(channel, senderAddr);\n            }\n            this._rtcConnector.onSignal(channel, msg);\n            return;\n        }\n\n        // Discard signals that have reached their TTL.\n        if (msg.ttl <= 0) {\n            Log.d(SignalProcessor, `Discarding signal from ${msg.senderId} to ${msg.recipientId} - TTL reached`);\n            // Send signal containing TTL_EXCEEDED flag back in reverse direction.\n            if (msg.flags === 0) {\n                channel.signal(/*senderId*/ msg.recipientId, /*recipientId*/ msg.senderId, msg.nonce, Network.SIGNAL_TTL_INITIAL, SignalMessage.Flag.TTL_EXCEEDED);\n            }\n            return;\n        }\n\n        // Otherwise, try to forward the signal to the intended recipient.\n        const signalChannel = this._addresses.getChannelByPeerId(msg.recipientId);\n        if (!signalChannel) {\n            Log.d(SignalProcessor, `Failed to forward signal from ${msg.senderId} to ${msg.recipientId} - no route found`);\n            // If we don't know a route to the intended recipient, return signal to sender with unroutable flag set and payload removed.\n            // Only do this if the signal is not already a unroutable response.\n            if (msg.flags === 0) {\n                channel.signal(/*senderId*/ msg.recipientId, /*recipientId*/ msg.senderId, msg.nonce, Network.SIGNAL_TTL_INITIAL, SignalMessage.Flag.UNROUTABLE);\n            }\n            return;\n        }\n\n        // Discard signal if our shortest route to the target is via the sending peer.\n        // XXX Why does this happen?\n        if (signalChannel.peerAddress.equals(channel.peerAddress)) {\n            Log.w(SignalProcessor, `Discarding signal from ${msg.senderId} to ${msg.recipientId} - shortest route via sending peer`);\n            // If our best route is via the sending peer, return signal to sender with unroutable flag set and payload removed.\n            // Only do this if the signal is not already a unroutable response.\n            if (msg.flags === 0) {\n                channel.signal(/*senderId*/ msg.recipientId, /*recipientId*/ msg.senderId, msg.nonce, Network.SIGNAL_TTL_INITIAL, SignalMessage.Flag.UNROUTABLE);\n            }\n            return;\n        }\n\n        // Decrement ttl and forward signal.\n        signalChannel.signal(msg.senderId, msg.recipientId, msg.nonce, msg.ttl - 1, msg.flags, msg.payload, msg.senderPubKey, msg.signature);\n\n        // We store forwarded messages if there are no special flags set.\n        if (msg.flags === 0) {\n            this._forwards.add(msg.senderId, msg.recipientId, msg.nonce);\n        }\n\n        // XXX This is very spammy!!!\n        // Log.v(Network, `Forwarding signal (ttl=${msg.ttl}) from ${msg.senderId} `\n        //     + `(received from ${channel.peerAddress}) to ${msg.recipientId} `\n        //     + `(via ${signalChannel.peerAddress})`);\n    }\n}\nClass.register(SignalProcessor);\n\nclass SignalStore {\n    /**\n     * @param {number} maxSize maximum number of entries\n     */\n    constructor(maxSize = 1000) {\n        /** @type {number} */\n        this._maxSize = maxSize;\n        /** @type {Queue.<ForwardedSignal>} */\n        this._queue = new Queue();\n        /** @type {HashMap.<ForwardedSignal, number>} */\n        this._store = new HashMap();\n    }\n\n    /** @type {number} */\n    get length() {\n        return this._queue.length;\n    }\n\n    /**\n     * @param {PeerId} senderId\n     * @param {PeerId} recipientId\n     * @param {number} nonce\n     */\n    add(senderId, recipientId, nonce) {\n        // If we already forwarded such a message, just update timestamp.\n        if (this.contains(senderId, recipientId, nonce)) {\n            const signal = new ForwardedSignal(senderId, recipientId, nonce);\n            this._store.put(signal, Date.now());\n            this._queue.remove(signal);\n            this._queue.enqueue(signal);\n            return;\n        }\n\n        // Delete oldest if needed.\n        if (this.length >= this._maxSize) {\n            const oldest = this._queue.dequeue();\n            this._store.remove(oldest);\n        }\n        const signal = new ForwardedSignal(senderId, recipientId, nonce);\n        this._queue.enqueue(signal);\n        this._store.put(signal, Date.now());\n    }\n\n    /**\n     * @param {PeerId} senderId\n     * @param {PeerId} recipientId\n     * @param {number} nonce\n     * @return {boolean}\n     */\n    contains(senderId, recipientId, nonce) {\n        const signal = new ForwardedSignal(senderId, recipientId, nonce);\n        return this._store.contains(signal);\n    }\n\n    /**\n     * @param {PeerId} senderId\n     * @param {PeerId} recipientId\n     * @param {number} nonce\n     * @return {boolean}\n     */\n    signalForwarded(senderId, recipientId, nonce) {\n        const signal = new ForwardedSignal(senderId, recipientId, nonce);\n        const lastSeen = this._store.get(signal);\n        if (!lastSeen) {\n            return false;\n        }\n        const valid = lastSeen + ForwardedSignal.SIGNAL_MAX_AGE > Date.now();\n        if (!valid) {\n            // Because of the ordering, we know that everything after that is invalid too.\n            const toDelete = this._queue.dequeueUntil(signal);\n            for (const dSignal of toDelete) {\n                this._store.remove(dSignal);\n            }\n        }\n        return valid;\n    }\n}\nSignalStore.SIGNAL_MAX_AGE = 10 /* seconds */;\nClass.register(SignalStore);\n\nclass ForwardedSignal {\n    /**\n     * @param {PeerId} senderId\n     * @param {PeerId} recipientId\n     * @param {number} nonce\n     */\n    constructor(senderId, recipientId, nonce) {\n        /** @type {PeerId} */\n        this._senderId = senderId;\n        /** @type {PeerId} */\n        this._recipientId = recipientId;\n        /** @type {number} */\n        this._nonce = nonce;\n    }\n\n    /**\n     * @param {ForwardedSignal} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof ForwardedSignal\n            && this._senderId.equals(o._senderId)\n            && this._recipientId.equals(o._recipientId)\n            && this._nonce === o._nonce;\n    }\n\n    hashCode() {\n        return this.toString();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `ForwardedSignal{senderId=${this._senderId}, recipientId=${this._recipientId}, nonce=${this._nonce}}`;\n    }\n}\nClass.register(ForwardedSignal);\n","class ConnectionPool extends Observable {\n    /**\n     * @constructor\n     * @param {PeerAddressBook} peerAddresses\n     * @param {NetworkConfig} networkConfig\n     * @param {IBlockchain} blockchain\n     * @param {Time} time\n     * @listens WebSocketConnector#connection\n     * @listens WebSocketConnector#error\n     * @listens WebRtcConnector#connection\n     * @listens WebRtcConnector#error\n     */\n    constructor(peerAddresses, networkConfig, blockchain, time) {\n        super();\n\n        /**\n         * @type {PeerAddressBook}\n         * @private\n         */\n        this._addresses = peerAddresses;\n\n        /**\n         * @type {NetworkConfig}\n         * @private\n         */\n        this._networkConfig = networkConfig;\n\n        /**\n         * @type {IBlockchain}\n         * @private\n         */\n        this._blockchain = blockchain;\n\n        /**\n         * @type {Time}\n         * @private\n         */\n        this._time = time;\n\n        /**\n         * HashMap from peerAddresses to connections.\n         * @type {HashMap.<PeerAddress, PeerConnection>}\n         * @private\n         */\n        this._connectionsByPeerAddress = new HashMap();\n        \n        /**\n         * HashMap from netAddresses to connections.\n         * @type {HashMap.<NetAddress, Array.<PeerConnection>>}\n         * @private\n         */\n        this._connectionsByNetAddress = new HashMap();\n\n        /**\n         * HashMap from subnet addresses to connections.\n         * @type {HashMap.<NetAddress, Array.<PeerConnection>>}\n         * @private\n         */\n        this._connectionsBySubnet = new HashMap();\n\n        // Total bytes sent/received on past connections.\n        /** @type {number} */\n        this._bytesSent = 0;\n        /** @type {number} */\n        this._bytesReceived = 0;\n\n        /** @type {WebSocketConnector} */\n        this._wsConnector = new WebSocketConnector(this._networkConfig);\n        this._wsConnector.on('connection', conn => this._onConnection(conn));\n        this._wsConnector.on('error', (peerAddr, e) => this._onConnectError(peerAddr, e));\n\n        /** @type {WebRtcConnector} */\n        this._rtcConnector = new WebRtcConnector(this._networkConfig);\n        this._rtcConnector.on('connection', conn => this._onConnection(conn));\n        this._rtcConnector.on('error', (peerAddr, reason) => this._onConnectError(peerAddr, reason));\n\n        // Various counters for established connections.\n        /** @type {number} */\n        this._peerCountWs = 0;\n        /** @type {number} */\n        this._peerCountRtc = 0;\n        /** @type {number} */\n        this._peerCountDumb = 0;\n        /** @type {number} */\n        this._peerCountFull = 0;\n        /** @type {number} */\n        this._peerCountLight = 0;\n        /** @type {number} */\n        this._peerCountNano = 0;\n        /** @type {number} */\n        this._peerCountOutbound = 0;\n        /** @type {number} */\n        this._peerCountFullWsOutbound = 0;\n\n        /**\n         * Number of ongoing outbound connection attempts.\n         * @type {number}\n         * @private\n         */\n        this._connectingCount = 0;\n\n        /**\n         * Number of not established inbound connections.\n         * @type {number}\n         * @private\n         */\n        this._inboundCount = 0;\n\n        /** @type {SignalProcessor} */\n        this._signalProcessor = new SignalProcessor(peerAddresses, networkConfig, this._rtcConnector);\n\n        // When true, send a signal to network to close an established connection for a incoming one\n        /** @type {boolean} */\n        this._allowInboundExchange = false;\n\n        // Whether we allow inbound connections. Does not apply to WebRTC connections.\n        /** @type {boolean} */\n        this._allowInboundConnections = false;\n\n        /** @type {HashMap.<NetAddress, number>} */\n        this._bannedIPv4IPs = new HashMap();\n\n        /** @type {HashMap.<Uint8Array, number>} */\n        this._bannedIPv6IPs = new HashMap();\n\n        setInterval(() => this._checkUnbanIps(), ConnectionPool.UNBAN_IPS_INTERVAL);\n    }\n\n    /**\n     * @returns {Array.<PeerConnection>}\n     */\n    values() {\n        return Array.from(this._connectionsByPeerAddress.values());\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {PeerConnection|null}\n     */\n    getConnectionByPeerAddress(peerAddress) {\n        return this._connectionsByPeerAddress.get(peerAddress);\n    }\n\n    /**\n     * @param {NetAddress} netAddress\n     * @returns {Array.<PeerConnection>}\n     */\n    getConnectionsByNetAddress(netAddress) {\n        return this._connectionsByNetAddress.get(netAddress) || [];\n    }\n\n    /**\n     * @param {NetAddress} netAddress\n     * @returns {Array.<PeerConnection>}\n     */\n    getConnectionsBySubnet(netAddress) {\n        return this._connectionsBySubnet.get(this._getSubnetAddress(netAddress)) || [];\n    }\n\n    /**\n     * @param {NetAddress} netAddress\n     * @returns {Array.<PeerConnection>}\n     */\n    getOutboundConnectionsBySubnet(netAddress) {\n        return (this._connectionsBySubnet.get(this._getSubnetAddress(netAddress)) || [])\n            .filter(/** @type {PeerConnection} */ peerConnection => peerConnection.networkConnection.outbound);\n    }\n\n    /**\n     * @param {NetAddress} netAddress\n     * @returns {NetAddress}\n     */\n    _getSubnetAddress(netAddress) {\n        return netAddress.subnet(netAddress.isIPv4() ? Network.IPV4_SUBNET_MASK : Network.IPV6_SUBNET_MASK);\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @returns {void}\n     * @private\n     */\n    _add(peerConnection) {\n        if (peerConnection.peerAddress) {\n            this._connectionsByPeerAddress.put(peerConnection.peerAddress, peerConnection);\n        }\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @returns {void}\n     * @private\n     */\n    _remove(peerConnection) {\n        if (peerConnection.peerAddress) {\n            this._connectionsByPeerAddress.remove(peerConnection.peerAddress);\n        }\n\n        if (peerConnection.networkConnection && peerConnection.networkConnection.netAddress) {\n            this._removeNetAddress(peerConnection, peerConnection.networkConnection.netAddress);\n        }\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @param {NetAddress} netAddress\n     * @returns {void}\n     * @private\n     */\n    _addNetAddress(peerConnection, netAddress) {\n        // Only add reliable netAddresses.\n        if (netAddress.isPseudo() || !netAddress.reliable) {\n            return;\n        }\n\n        if (this._connectionsByNetAddress.contains(netAddress)) {\n            this._connectionsByNetAddress.get(netAddress).push(peerConnection);\n        } else {\n            this._connectionsByNetAddress.put(netAddress, [peerConnection]);\n        }\n\n        const subnetAddress = this._getSubnetAddress(netAddress);\n        if (this._connectionsBySubnet.contains(subnetAddress)) {\n            this._connectionsBySubnet.get(subnetAddress).push(peerConnection);\n        } else {\n            this._connectionsBySubnet.put(subnetAddress, [peerConnection]);\n        }\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @param {NetAddress} netAddress\n     * @returns {void}\n     * @private\n     */\n    _removeNetAddress(peerConnection, netAddress) {\n        if (netAddress.isPseudo() || !netAddress.reliable) {\n            return;\n        }\n\n        if (this._connectionsByNetAddress.contains(netAddress)) {\n            const peerConnections = this._connectionsByNetAddress.get(netAddress);\n\n            const index = peerConnections.indexOf(peerConnection);\n            if (index >= 0) {\n                peerConnections.splice(index, 1);\n            }\n\n            if (peerConnections.length === 0) {\n                this._connectionsByNetAddress.remove(netAddress);\n            }\n        }\n\n        const subnetAddress = this._getSubnetAddress(netAddress);\n        if (this._connectionsBySubnet.contains(subnetAddress)) {\n            const peerConnections = this._connectionsBySubnet.get(subnetAddress);\n\n            const index = peerConnections.indexOf(peerConnection);\n            if (index >= 0) {\n                peerConnections.splice(index, 1);\n            }\n\n            if (peerConnections.length === 0) {\n                this._connectionsBySubnet.remove(subnetAddress);\n            }\n        }\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {boolean}\n     */\n    _checkOutboundConnectionRequest(peerAddress) {\n        if (peerAddress === null) {\n            return false;\n        }\n\n        if (peerAddress.protocol !== Protocol.WS && peerAddress.protocol !== Protocol.RTC) {\n            Log.e(ConnectionPool, `Cannot connect to ${peerAddress} - unsupported protocol`);\n            return false;\n        }\n\n        if (this._addresses.isBanned(peerAddress)){\n            Log.e(ConnectionPool, `Connecting to banned address ${peerAddress}`);\n            return false;\n        }\n\n        const peerConnection = this.getConnectionByPeerAddress(peerAddress);\n        if (peerConnection) {\n            Log.e(ConnectionPool, `Duplicate connection to ${peerAddress}`);\n            return false;\n        }\n\n        // Forbid connection if we have too many connections to the peer's IP address.\n        if (peerAddress.netAddress && peerAddress.netAddress.reliable) {\n            if (this.getConnectionsByNetAddress(peerAddress.netAddress).length >= Network.PEER_COUNT_PER_IP_MAX) {\n                Log.e(ConnectionPool, `connection limit per ip (${Network.PEER_COUNT_PER_IP_MAX}) reached`);\n                return false;\n            }\n\n            if (this.getOutboundConnectionsBySubnet(peerAddress.netAddress).length >= Network.OUTBOUND_PEER_COUNT_PER_SUBNET_MAX) {\n                Log.e(ConnectionPool, `connection limit per ip (${Network.OUTBOUND_PEER_COUNT_PER_SUBNET_MAX}) reached`);\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {boolean}\n     */\n    connectOutbound(peerAddress) {\n        // all checks in one step\n        if (!this._checkOutboundConnectionRequest(peerAddress)) {\n            return false;\n        }\n\n        // Connection request accepted.\n\n        // create fresh PeerConnection instance\n        const peerConnection = PeerConnection.getOutbound(peerAddress);\n        this._add(peerConnection);\n\n        // choose connector type and call\n        let connecting = false;\n        if (peerAddress.protocol === Protocol.WS) {\n            connecting = this._wsConnector.connect(peerAddress);\n        } else {\n            const signalChannel = this._addresses.getChannelByPeerId(peerAddress.peerId);\n            connecting = this._rtcConnector.connect(peerAddress, signalChannel);\n        }\n\n        if (connecting) {\n            this._connectingCount++;\n        } else {\n            this._remove(peerConnection);\n            Log.d(Network, `Outbound attempt not connecting: ${peerAddress}`);\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @returns {boolean}\n     * @private\n     */\n    _checkConnection(peerConnection) {\n        /** @type {NetworkConnection} */\n        const conn = peerConnection.networkConnection;\n\n        // Close connection if we currently do not allow inbound connections. WebRTC connections are exempt.\n        if (conn.inbound && !this._allowInboundConnections && conn.protocol !== Protocol.RTC) {\n            conn.close(CloseType.INBOUND_CONNECTIONS_BLOCKED, 'inbound connections are blocked temporarily');\n            return false;\n        }\n\n        if (conn.netAddress && !conn.netAddress.isPseudo() && conn.netAddress.reliable) {\n            // Close connection if peer's IP is banned.\n            if (this._isIpBanned(conn.netAddress)) {\n                conn.close(CloseType.BANNED_IP, `connection with banned IP ${conn.netAddress}`);\n                return false;\n            }\n\n            // Close connection if we have too many connections to the peer's IP address.\n            if (this.getConnectionsByNetAddress(conn.netAddress).length >= Network.PEER_COUNT_PER_IP_MAX) {\n                conn.close(CloseType.CONNECTION_LIMIT_PER_IP, `connection limit per IP (${Network.PEER_COUNT_PER_IP_MAX}) reached`);\n                return false;\n            }\n\n            // Close connection if we have too many connections to the peer's subnet.\n            if (this.getConnectionsBySubnet(conn.netAddress).length >= Network.INBOUND_PEER_COUNT_PER_SUBNET_MAX) {\n                conn.close(CloseType.CONNECTION_LIMIT_PER_IP, `connection limit per subnet (${Network.INBOUND_PEER_COUNT_PER_SUBNET_MAX}) reached`);\n                return false;\n            }\n        }\n\n        // Reject peer if we have reached max peer count.\n        if (this.peerCount >= Network.PEER_COUNT_MAX\n            && !conn.outbound\n            && !(conn.inbound && this._allowInboundExchange)) {\n\n            conn.close(CloseType.MAX_PEER_COUNT_REACHED, `max peer count reached (${Network.PEER_COUNT_MAX})`);\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @listens PeerChannel#signal\n     * @listens NetworkAgent#handshake\n     * @listens NetworkAgent#close\n     * @fires ConnectionPool#connection\n     * @param {NetworkConnection} conn\n     * @returns {void}\n     * @private\n     */\n    _onConnection(conn) {\n        /** @type {PeerConnection} */\n        let peerConnection;\n        if (conn.outbound) {\n            this._connectingCount--;\n            Assert.that(this._connectingCount >= 0, 'connectingCount < 0');\n\n            peerConnection = this.getConnectionByPeerAddress(conn.peerAddress);\n\n            Assert.that(!!peerConnection, `PeerAddress not stored ${conn.peerAddress}`);\n            Assert.that(peerConnection.state === PeerConnectionState.CONNECTING,\n                `PeerConnection state not CONNECTING, but ${peerConnection.state} (${conn.peerAddress})`);\n        } else {\n            peerConnection = PeerConnection.getInbound(conn);\n            this._inboundCount++;\n        }\n\n        // Set peerConnection to CONNECTED state.\n        peerConnection.networkConnection = conn;\n\n        // Register close listener early to clean up correctly in case _checkConnection() closes the connection.\n        conn.on('close', (type, reason) => this._onClose(peerConnection, type, reason));\n\n        if (!this._checkConnection(peerConnection)) {\n            return;\n        }\n\n        // Connection accepted.\n\n        if (conn.netAddress && !conn.netAddress.isPseudo()) {\n            this._addNetAddress(peerConnection, conn.netAddress);\n        }\n\n        const connType = conn.inbound ? 'inbound' : 'outbound';\n        Log.d(ConnectionPool, `Connection established (${connType}) #${conn.id} ${conn.netAddress || conn.peerAddress || '<pending>'}`);\n\n        // Let listeners know about this connection.\n        this.fire('connection', conn);\n\n        // Create peer channel.\n        const channel = new PeerChannel(conn);\n        channel.on('signal', msg => this._signalProcessor.onSignal(channel, msg));\n \n        peerConnection.peerChannel = channel;\n\n        // Create network agent.\n        const agent = new NetworkAgent(this._blockchain, this._addresses, this._networkConfig, channel);\n        agent.on('version', peer => this._checkHandshake(peerConnection, peer));\n        agent.on('handshake', peer => this._onHandshake(peerConnection, peer));\n\n        peerConnection.networkAgent = agent;\n\n        // Initiate handshake with the peer.\n        agent.handshake();\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @param {Peer} peer\n     * @returns {boolean}\n     * @private\n     */\n    _checkHandshake(peerConnection, peer) {\n        // Close connection if peer's address is banned.\n        if (this._addresses.isBanned(peer.peerAddress)) {\n            peerConnection.peerChannel.close(CloseType.PEER_IS_BANNED,\n                `connection with banned address ${peer.peerAddress} (post version)`);\n            return false;\n        }\n\n        // Duplicate/simultaneous connection check (post version):\n        const storedConnection = this.getConnectionByPeerAddress(peer.peerAddress);\n        if (storedConnection && storedConnection.id !== peerConnection.id) {\n            // If we already have an established connection to this peer, close this connection.\n            if (storedConnection.state === PeerConnectionState.ESTABLISHED) {\n                peerConnection.peerChannel.close(CloseType.DUPLICATE_CONNECTION,\n                    'duplicate connection (post version)');\n                return false;\n            }\n        }\n\n        // Set peerConnection to NEGOTIATING state.\n        peerConnection.negotiating();\n\n        return true;\n    }\n\n    /**\n     * Handshake with this peer was successful.\n     * @fires ConnectionPool#peer-joined\n     * @fires ConnectionPool#peers-changed\n     * @fires ConnectionPool#recyling-request\n     * @param {PeerConnection} peerConnection\n     * @param {Peer} peer\n     * @returns {void}\n     * @private\n     */\n    _onHandshake(peerConnection, peer) {\n        if (peerConnection.networkConnection.inbound) {\n            // Re-check allowInboundExchange as it might have changed.\n            if (this.peerCount >= Network.PEER_COUNT_MAX && !this._allowInboundExchange) {\n                peerConnection.peerChannel.close(CloseType.MAX_PEER_COUNT_REACHED,\n                    `max peer count reached (${Network.PEER_COUNT_MAX})`);\n                return;\n            }\n\n            // Duplicate/simultaneous connection check (post handshake):\n            const storedConnection = this.getConnectionByPeerAddress(peer.peerAddress);\n            if (storedConnection && storedConnection.id !== peerConnection.id) {\n                switch (storedConnection.state) {\n                    case PeerConnectionState.CONNECTING:\n                        // Abort the stored connection attempt and accept this connection.\n                        Assert.that(peer.peerAddress.protocol === Protocol.WS, 'Duplicate connection to non-WS node');\n                        Log.d(ConnectionPool, `Aborting connection attempt to ${peer.peerAddress}, simultaneous inbound connection succeeded`);\n                        this._wsConnector.abort(peer.peerAddress);\n                        Assert.that(!this.getConnectionByPeerAddress(peer.peerAddress), 'PeerConnection not removed');\n                        break;\n\n                    case PeerConnectionState.ESTABLISHED:\n                        // If we have another established connection to this peer, close this connection.\n                        peerConnection.peerChannel.close(CloseType.DUPLICATE_CONNECTION,\n                            'duplicate connection (post handshake)');\n                        return;\n\n                    case PeerConnectionState.NEGOTIATING:\n                        // The peer with the lower peerId accepts this connection and closes his stored connection.\n                        if (this._networkConfig.peerAddress.peerId.compare(peer.peerAddress.peerId) < 0) {\n                            storedConnection.peerChannel.close(CloseType.SIMULTANEOUS_CONNECTION,\n                                'simultaneous connection (post handshake) - lower peerId');\n                            Assert.that(!this.getConnectionByPeerAddress(peer.peerAddress), 'PeerConnection not removed');\n                        }\n                        // The peer with the higher peerId closes this connection and keeps his stored connection.\n                        else {\n                            peerConnection.peerChannel.close(CloseType.SIMULTANEOUS_CONNECTION,\n                                'simultaneous connection (post handshake) - higher peerId');\n                            return;\n                        }\n                        break;\n\n                    default:\n                        // Accept this connection and close the stored connection.\n                        storedConnection.peerChannel.close(CloseType.SIMULTANEOUS_CONNECTION,\n                            `simultaneous connection (post handshake) - state ${storedConnection.state}`);\n                        Assert.that(!this.getConnectionByPeerAddress(peer.peerAddress), 'PeerConnection not removed');\n                }\n            }\n\n            Assert.that(!this.getConnectionByPeerAddress(peer.peerAddress), `PeerConnection ${peer.peerAddress} already exists`);\n            peerConnection.peerAddress = peer.peerAddress;\n            this._add(peerConnection);\n\n            this._inboundCount--;\n            Assert.that(this._inboundCount >= 0, 'inboundCount < 0');\n        }\n\n        // Handshake accepted.\n\n        // Check if we need to recycle a connection.\n        if (this.peerCount >= Network.PEER_COUNT_MAX) {\n            this.fire('recycling-request');\n        }\n\n        // Set peerConnection to ESTABLISHED state.\n        peerConnection.peer = peer;\n\n        if (peer.netAddress && !peer.netAddress.isPseudo() && this.getConnectionsByNetAddress(peer.netAddress).indexOf(peerConnection) < 0) {\n            this._addNetAddress(peerConnection, peer.netAddress);\n        }\n \n        this._updateConnectedPeerCount(peerConnection, 1);\n\n        this._addresses.established(peer.channel, peer.peerAddress);\n\n        // Let listeners know about this peer.\n        this.fire('peer-joined', peer);\n\n        // Let listeners know that the peers changed.\n        this.fire('peers-changed');\n\n        Log.d(ConnectionPool, () => `[PEER-JOINED] ${peer.peerAddress} ${peer.netAddress} (version=${peer.version}, services=${peer.peerAddress.services}, headHash=${peer.headHash.toBase64()})`);\n    }\n\n    /**\n     * This peer channel was closed.\n     * @param {PeerConnection} peerConnection\n     * @param {number} type\n     * @param {string} reason\n     * @fires ConnectionPool#peer-left\n     * @fires ConnectionPool#peers-changed\n     * @fires ConnectionPool#close\n     * @returns {void}\n     * @private\n     */\n    _onClose(peerConnection, type, reason) {\n        // Update total bytes sent/received.\n        this._bytesSent += peerConnection.networkConnection.bytesSent;\n        this._bytesReceived += peerConnection.networkConnection.bytesReceived;\n\n        // Only propagate the close type (i.e. track fails/bans) if the peerAddress is set.\n        // This is true for\n        // - all outbound connections\n        // - inbound connections post handshake (peerAddress is verified)\n        if (peerConnection.peerAddress) {\n            this._addresses.close(peerConnection.peerChannel, peerConnection.peerAddress, type);\n        }\n\n        this._remove(peerConnection);\n\n        // Check if the handshake with this peer has completed.\n        if (peerConnection.state === PeerConnectionState.ESTABLISHED) {\n            // If closing is due to a ban, also ban the IP\n            if (CloseType.isBanningType(type) && peerConnection.peer.netAddress){\n                this._banIp(peerConnection.peer.netAddress);\n            }\n\n            this._updateConnectedPeerCount(peerConnection, -1);\n\n            // Tell listeners that this peer has gone away.\n            this.fire('peer-left', peerConnection.peer);\n\n            // Let listeners know that the peers changed.\n            this.fire('peers-changed');\n\n            const kbTransferred = ((peerConnection.networkConnection.bytesSent\n                + peerConnection.networkConnection.bytesReceived) / 1000).toFixed(2);\n            Log.d(ConnectionPool, `[PEER-LEFT] ${peerConnection.peerAddress} ${peerConnection.peer.netAddress} `\n                + `(version=${peerConnection.peer.version}, transferred=${kbTransferred} kB, closeType=${type} ${reason})`);\n        } else {\n            if (peerConnection.networkConnection.inbound) {\n                this._inboundCount--;\n                Log.w(ConnectionPool, `Inbound connection #${peerConnection.networkConnection.id} closed pre-handshake: ${reason} (${type})`);\n            } else {\n                Log.w(ConnectionPool, `Connection #${peerConnection.networkConnection.id} to ${peerConnection.peerAddress} closed pre-handshake: ${reason} (${type})`);\n                this.fire('connect-error', peerConnection.peerAddress, `${reason} (${type})`);\n            }\n        }\n\n        // Let listeners know about this closing.\n        this.fire('close', peerConnection, type, reason);\n\n        // Set the peer connection to closed state.\n        peerConnection.close();\n    }\n\n    /**\n     * @param {NetAddress} netAddress\n     * @returns {void}\n     * @private\n     */\n    _banIp(netAddress) {\n        if (!netAddress.isPseudo() && netAddress.reliable) {\n            Log.w(ConnectionPool, `Banning IP ${netAddress}`);\n            if (netAddress.isIPv4()) {\n                this._bannedIPv4IPs.put(netAddress, Date.now() + ConnectionPool.DEFAULT_BAN_TIME);\n            } else if (netAddress.isIPv6()) {\n                // Ban IPv6 IPs prefix based\n                this._bannedIPv6IPs.put(netAddress.ip.subarray(0,8), Date.now() + ConnectionPool.DEFAULT_BAN_TIME);\n            }\n        }\n    }\n\n    /**\n     * @param {NetAddress} netAddress\n     * @returns {boolean}\n     * @private\n     */\n    _isIpBanned(netAddress) {\n        if (netAddress.isPseudo()) return false;\n        if (netAddress.isIPv4()) {\n            return this._bannedIPv4IPs.contains(netAddress);\n        } else if (netAddress.isIPv6()) {\n            const prefix = netAddress.ip.subarray(0, 8);\n            return this._bannedIPv6IPs.contains(prefix);\n        }\n        return false;\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _checkUnbanIps() {\n        const now = Date.now();\n        for (const netAddress of this._bannedIPv4IPs.keys()) {\n            if (this._bannedIPv4IPs.get(netAddress) < now) {\n                this._bannedIPv4IPs.remove(netAddress);\n            }\n        }\n        for (const prefix of this._bannedIPv6IPs.keys()) {\n            if (this._bannedIPv6IPs.get(prefix) < now) {\n                this._bannedIPv6IPs.remove(prefix);\n            }\n        }\n    }\n\n    /**\n     * Connection to this peer address failed.\n     * @param {PeerAddress} peerAddress\n     * @param {string|*} [reason]\n     * @fires ConnectionPool#connect-error\n     * @returns {void}\n     * @private\n     */\n    _onConnectError(peerAddress, reason) {\n        Log.w(ConnectionPool, `Connection to ${peerAddress} failed` + (typeof reason === 'string' ? ` - ${reason}` : ''));\n\n        const peerConnection = this.getConnectionByPeerAddress(peerAddress);\n        Assert.that(!!peerConnection, `PeerAddress not stored ${peerAddress}`);\n        Assert.that(peerConnection.state === PeerConnectionState.CONNECTING,\n            `PeerConnection state not CONNECTING, but ${peerConnection.state} (${peerAddress})`);\n        this._remove(peerConnection);\n\n        this._connectingCount--;\n        Assert.that(this._connectingCount >= 0, 'connectingCount < 0');\n\n        this._addresses.close(null, peerAddress, CloseType.CONNECTION_FAILED);\n\n        this.fire('connect-error', peerAddress, reason);\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @param {number} delta\n     * @returns {void}\n     * @private\n     */\n    _updateConnectedPeerCount(peerConnection, delta) {\n        const peerAddress = peerConnection.peerAddress;\n        switch (peerAddress.protocol) {\n            case Protocol.WS:\n                this._peerCountWs += delta;\n                Assert.that(this._peerCountWs >= 0, 'peerCountWs < 0');\n                break;\n            case Protocol.RTC:\n                this._peerCountRtc += delta;\n                Assert.that(this._peerCountRtc >= 0, 'peerCountRtc < 0');\n                break;\n            case Protocol.DUMB:\n                this._peerCountDumb += delta;\n                Assert.that(this._peerCountDumb >= 0, 'peerCountDumb < 0');\n                break;\n            default:\n                Log.w(PeerAddressBook, `Unknown protocol ${peerAddress.protocol}`);\n        }\n\n        if (Services.isFullNode(peerAddress.services)) {\n            this._peerCountFull += delta;\n            Assert.that(this._peerCountFull >= 0, 'peerCountFull < 0');\n        } else if (Services.isLightNode(peerAddress.services)) {\n            this._peerCountLight += delta;\n            Assert.that(this._peerCountLight >= 0, 'peerCountLight < 0');\n        } else {\n            this._peerCountNano += delta;\n            Assert.that(this._peerCountNano >= 0, 'peerCountNano < 0');\n        }\n\n        if (peerConnection.networkConnection.outbound) {\n            this._peerCountOutbound += delta;\n            if (Services.isFullNode(peerAddress.services) && peerAddress.protocol === Protocol.WS) {\n                this._peerCountFullWsOutbound += delta;\n            }\n        }\n    }\n\n\n    /**\n     * @param {string|*} reason\n     * @returns {void}\n     */\n    disconnect(reason) {\n        // Close all active connections.\n        for (const connection of this.values()) {\n            if (connection.peerChannel) {\n                connection.peerChannel.close(CloseType.MANUAL_NETWORK_DISCONNECT, reason || 'manual network disconnect');\n            }\n        }\n    }\n\n    // XXX For testing\n    disconnectWebSocket() {\n        // Close all websocket connections.\n        for (const connection of this.values()) {\n            if (connection.peerChannel && connection.peerAddress && connection.peerAddress.protocol === Protocol.WS) {\n                connection.channel.close(CloseType.MANUAL_WEBSOCKET_DISCONNECT, 'manual websocket disconnect');\n            }\n        }\n    }\n\n    /** @type {number} */\n    get peerCountWs() {\n        return this._peerCountWs;\n    }\n\n    /** @type {number} */\n    get peerCountRtc() {\n        return this._peerCountRtc;\n    }\n\n    /** @type {number} */\n    get peerCountDumb() {\n        return this._peerCountDumb;\n    }\n\n    /** @type {number} */\n    get peerCount() {\n        return this._peerCountWs + this._peerCountRtc + this._peerCountDumb;\n    }\n\n    /** @type {number} */\n    get peerCountFull() {\n        return this._peerCountFull;\n    }\n\n    /** @type {number} */\n    get peerCountLight() {\n        return this._peerCountLight;\n    }\n\n    /** @type {number} */\n    get peerCountNano() {\n        return this._peerCountNano;\n    }\n\n    /** @type {number} */\n    get peerCountOutbound() {\n        return this._peerCountOutbound;\n    }\n\n    /** @type {number} */\n    get peerCountFullWsOutbound() {\n        return this._peerCountFullWsOutbound;\n    }\n\n    /** @type {number} */\n    get connectingCount() {\n        return this._connectingCount;\n    }\n\n    /** @type {number} */\n    get count() {\n        return this._connectionsByPeerAddress.length + this._inboundCount;\n    }\n\n    /** @type {number} */\n    get bytesSent() {\n        return this._bytesSent\n            + this.values().reduce((n, peerConnection) => n + (peerConnection.networkConnection ? peerConnection.networkConnection.bytesSent : 0), 0);\n    }\n\n    /** @type {number} */\n    get bytesReceived() {\n        return this._bytesReceived\n            + this.values().reduce((n, peerConnection) => n + (peerConnection.networkConnection ? peerConnection.networkConnection.bytesReceived : 0), 0);\n    }\n\n    /** @param {boolean} value */\n    set allowInboundExchange(value) {\n        this._allowInboundExchange = value;\n    }\n\n    /** @type {boolean} */\n    get allowInboundConnections() {\n        return this._allowInboundConnections;\n    }\n\n    /** @param {boolean} value */\n    set allowInboundConnections(value) {\n        this._allowInboundConnections = value;\n    }\n\n}\nConnectionPool.DEFAULT_BAN_TIME = 1000 * 60 * 10; // 10 minutes\nConnectionPool.UNBAN_IPS_INTERVAL = 1000 * 60; // 1 minute\n\nClass.register(ConnectionPool);\n","class PeerScorer {\n    /**\n     * @constructor\n     * @param {NetworkConfig} networkConfig\n     * @param {PeerAddressBook} addresses\n     * @param {ConnectionPool} connections\n     */\n    constructor(networkConfig, addresses, connections) {\n        /**\n         * @type {NetworkConfig}\n         * @private\n         */\n        this._networkConfig = networkConfig;\n\n        /**\n         * @type {PeerAddressBook}\n         * @private\n         */\n        this._addresses = addresses;\n\n        /**\n         * @type {ConnectionPool}\n         * @private\n         */\n        this._connections = connections;\n\n        /**\n         * @type {Array.<PeerConnection>}\n         * @private\n         */\n        this._connectionScores = null;\n    }\n\n    /**\n     * @returns {?PeerAddress}\n     */\n    pickAddress() {\n        const findCandidates = (addressStates, numCandidates, allowBadPeers = false) => {\n            const numAddresses = addressStates.length;\n\n            // Pick a random start index.\n            const index = Math.floor(Math.random() * numAddresses);\n\n            // Compute address scores until we have found at 1000 candidates with score >= 0.\n            const minCandidates = Math.min(numAddresses, numCandidates);\n            const candidates = [];\n            for (let i = 0; i < numAddresses; i++) {\n                const idx = (index + i) % numAddresses;\n                const addressState = addressStates[idx];\n                const score = this._scoreAddress(addressState, allowBadPeers);\n                if (score >= 0) {\n                    candidates.push({score, addressState});\n                    if (candidates.length >= minCandidates) {\n                        break;\n                    }\n                }\n            }\n\n            return candidates;\n        };\n\n        const addressStates = this._addresses.values();\n        let candidates = findCandidates(addressStates, 1000);\n        if (candidates.length === 0 && this.needsGoodPeers()) {\n            candidates = findCandidates(addressStates, 1000, true);\n        }\n\n        if (candidates.length === 0) {\n            return null;\n        }\n\n        // Return a random candidate with a high score.\n        const scores = candidates.sort((a, b) => b.score - a.score);\n        const goodCandidates = scores.slice(0, PeerScorer.PICK_SELECTION_SIZE);\n        const winner = ArrayUtils.randomElement(goodCandidates);\n        return winner.addressState.peerAddress;\n    }\n\n    /**\n     * @param {PeerAddressState} peerAddressState\n     * @param {boolean} [allowBadPeers]\n     * @returns {number}\n     * @private\n     */\n    _scoreAddress(peerAddressState, allowBadPeers = false) {\n        const peerAddress = peerAddressState.peerAddress;\n\n        // Filter addresses that we cannot connect to.\n        if (!this._networkConfig.canConnect(peerAddress.protocol)) {\n            return -1;\n        }\n\n        // Filter addresses not matching our accepted services.\n        if ((peerAddress.services & this._networkConfig.services.accepted) === 0) {\n            return -1;\n        }\n\n        // Filter addresses that are too old.\n        if (peerAddress.exceedsAge()) {\n            return -1;\n        }\n\n        // A channel to that peer address is CONNECTING, CONNECTED, NEGOTIATING OR ESTABLISHED\n        if (this._connections.getConnectionByPeerAddress(peerAddress)) {\n            return -1;\n        }\n\n        // If we need more good peers, only allow good peers unless allowBadPeers is true.\n        if (this.needsGoodPeers() && !this.isGoodPeer(peerAddress) && !allowBadPeers) {\n            return -1;\n        }\n\n        // Give all peers the same base score. Penalize peers with failed connection attempts.\n        const score = 1;\n        switch (peerAddressState.state) {\n            case PeerAddressState.BANNED:\n                return -1;\n\n            case PeerAddressState.NEW:\n            case PeerAddressState.TRIED:\n                return score;\n\n            case PeerAddressState.FAILED:\n                // Don't pick failed addresses when they have failed the maximum number of times.\n                return (1 - ((peerAddressState.failedAttempts + 1) / peerAddressState.maxFailedAttempts)) * score;\n\n            default:\n                return -1;\n        }\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    isGoodPeerSet() {\n        return !this.needsGoodPeers() && !this.needsMorePeers();\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    needsGoodPeers() {\n        return this._connections.peerCountFullWsOutbound < PeerScorer.PEER_COUNT_MIN_FULL_WS_OUTBOUND;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    needsMorePeers() {\n        return this._connections.peerCountOutbound < PeerScorer.PEER_COUNT_MIN_OUTBOUND;\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {boolean}\n     */\n    isGoodPeer(peerAddress) {\n        return Services.isFullNode(peerAddress.services) && peerAddress.protocol === Protocol.WS;\n    }\n\n    /**\n     * @returns {void}\n     */\n    scoreConnections() {\n        const candidates = [];\n\n        for (const peerConnection of this._connections.values()) {\n            if (peerConnection.state === PeerConnectionState.ESTABLISHED) {\n                // Grant new connections a grace period from recycling.\n                if (peerConnection.ageEstablished > PeerScorer._getMinAge(peerConnection.peerAddress)) {\n                    peerConnection.score = this._scoreConnection(peerConnection);\n                    candidates.push(peerConnection);\n                }\n\n                peerConnection.statistics.reset();\n            }\n        }\n\n        // sort by score\n        this._connectionScores = candidates.sort((a, b) => b.score - a.score);\n    }\n\n    /**\n     * @param {number} count\n     * @param {number} type\n     * @param {string} reason\n     * @returns {void}\n     */\n    recycleConnections(count, type, reason) {\n        if (!this._connectionScores) {\n            return;\n        }\n\n        while (count > 0 && this._connectionScores.length > 0) {\n            const peerConnection = this._connectionScores.pop();\n            if (peerConnection.state === PeerConnectionState.ESTABLISHED) {\n                peerConnection.peerChannel.close(type, `${reason}`);\n                count--;\n            }\n        }\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @returns {number}\n     * @private\n     */\n    _scoreConnection(peerConnection) {\n        // Connection age\n        const scoreAge = this._scoreConnectionAge(peerConnection);\n\n        // Connection type (inbound/outbound)\n        const scoreOutbound = peerConnection.networkConnection.inbound ? 0 : 1;\n\n        // Node type (full/light/nano)\n        const peerAddress = peerConnection.peerAddress;\n        const scoreType = Services.isFullNode(peerAddress.services)\n            ? 1\n            : Services.isLightNode(peerAddress.services) ? 0.5 : 0;\n\n        // Protocol: Prefer WebSocket when low on WebSocket connections.\n        let scoreProtocol = 0;\n        if (peerAddress.protocol === Protocol.WS) {\n            const distribution = this._connections.peerCountWs / this._connections.peerCount;\n            if (distribution < PeerScorer.BEST_PROTOCOL_WS_DISTRIBUTION || this._connections.peerCountFullWsOutbound <= PeerScorer.PEER_COUNT_MIN_FULL_WS_OUTBOUND) {\n                scoreProtocol = 1;\n            }\n        }\n\n        // Connection speed, based on ping-pong latency median\n        const medianLatency = peerConnection.statistics.latencyMedian;\n        let scoreSpeed = 0;\n        if (medianLatency > 0 && medianLatency < NetworkAgent.PING_TIMEOUT) {\n            scoreSpeed = 1 - medianLatency / NetworkAgent.PING_TIMEOUT;\n        }\n\n        return 0.15 * scoreAge + 0.25 * scoreOutbound + 0.2 * scoreType + 0.2 * scoreProtocol + 0.2 * scoreSpeed;\n    }\n\n    /**\n     * @param {PeerConnection} peerConnection\n     * @returns {number}\n     * @private\n     */\n    _scoreConnectionAge(peerConnection) {\n        const score = (age, bestAge, maxAge) => Math.max(Math.min(1 - (age - bestAge) / maxAge, 1), 0);\n\n        const age = peerConnection.ageEstablished;\n        const services = peerConnection.peerAddress.services;\n        if (Services.isFullNode(services)) {\n            return age / (2 * PeerScorer.BEST_AGE_FULL) + 0.5;\n        } else if (Services.isLightNode(services)) {\n            return score(age, PeerScorer.BEST_AGE_LIGHT, PeerScorer.MAX_AGE_LIGHT);\n        } else {\n            return score(age, PeerScorer.BEST_AGE_NANO, PeerScorer.MAX_AGE_NANO);\n        }\n    }\n\n    /**\n     * @param {PeerAddress} peerAddress\n     * @returns {number}\n     * @private\n     */\n    static _getMinAge(peerAddress) {\n        if (Services.isFullNode(peerAddress.services)) {\n            return PeerScorer.MIN_AGE_FULL;\n        } else if (Services.isLightNode(peerAddress.services)) {\n            return PeerScorer.MIN_AGE_LIGHT;\n        } else {\n            return PeerScorer.MIN_AGE_NANO;\n        }\n    }\n\n    /** @type {Number} */\n    get lowestConnectionScore() {\n        if (!this._connectionScores) {\n            return null;\n        }\n\n        // Remove all closed connections from the end of connectionScores.\n        while (this._connectionScores.length > 0\n            && this._connectionScores[this._connectionScores.length - 1].state !== PeerConnectionState.ESTABLISHED) {\n\n            this._connectionScores.pop();\n        }\n\n        return this._connectionScores.length > 0\n            ? this._connectionScores[this._connectionScores.length - 1].score\n            : null;\n    }\n}\n/**\n * @type {number}\n * @constant\n */\nPeerScorer.PEER_COUNT_MIN_FULL_WS_OUTBOUND = PlatformUtils.isNodeJs() ? 12 : 3;\n/**\n * @type {number}\n * @constant\n */\nPeerScorer.PEER_COUNT_MIN_OUTBOUND = PlatformUtils.isNodeJs() ? 12 : 6;\n/**\n * @type {number}\n * @constant\n */\nPeerScorer.PICK_SELECTION_SIZE = 100;\n\nPeerScorer.MIN_AGE_FULL = 5 * 60 * 1000; // 5 minutes\nPeerScorer.BEST_AGE_FULL = 24 * 60 * 60 * 1000; // 24 hours\n\nPeerScorer.MIN_AGE_LIGHT = 2 * 60 * 1000; // 2 minutes\nPeerScorer.BEST_AGE_LIGHT = 15 * 60 * 1000; // 15 minutes\nPeerScorer.MAX_AGE_LIGHT = 6 * 60 * 60 * 1000; // 6 hours\n\nPeerScorer.MIN_AGE_NANO = 60 * 1000; // 1 minute\nPeerScorer.BEST_AGE_NANO = 5 * 60 * 1000; // 5 minutes\nPeerScorer.MAX_AGE_NANO = 30 * 60 * 1000; // 30 minutes\n\nPeerScorer.BEST_PROTOCOL_WS_DISTRIBUTION = 0.15; // 15%\n\nClass.register(PeerScorer);\n","class NetworkConfig {\n    /**\n     * @returns {NetworkConfig}\n     */\n    static getDefault() {\n        return PlatformUtils.supportsWebRTC()\n            ? new RtcNetworkConfig()\n            : new DumbNetworkConfig();\n    }\n\n    /**\n     * @constructor\n     * @param {number} protocolMask\n     */\n    constructor(protocolMask) {\n        /** @type {number} */\n        this._protocolMask = protocolMask;\n\n        /**\n         * @type {KeyPair}\n         * @protected\n         */\n        this._keyPair = null;\n\n        /**\n         * @type {PeerId}\n         * @protected\n         */\n        this._peerId = null;\n\n        /**\n         * @type {Services}\n         * @protected\n         */\n        this._services = null;\n    }\n\n    /**\n     * @returns {void}\n     */\n    async initPersistent() {\n        const db = await PeerKeyStore.getPersistent();\n        await this._init(db);\n    }\n\n    /**\n     * @returns {void}\n     */\n    async initVolatile() {\n        const db = PeerKeyStore.createVolatile();\n        await this._init(db);\n    }\n\n    /**\n     * @private\n     * @param {PeerKeyStore} db\n     * @returns {void}\n     */\n    async _init(db) {\n        if (this._keyPair) {\n            return;\n        }\n\n        /** @type {KeyPair} */\n        let keys = await db.get('keys');\n        if (!keys) {\n            keys = KeyPair.generate();\n            await db.put('keys', keys);\n        }\n\n        this._keyPair = keys;\n        this._peerId = keys.publicKey.toPeerId();\n    }\n\n    /**\n     * Used for filtering peer addresses by protocols.\n     * @type {number}\n     */\n    get protocolMask() {\n        return this._protocolMask;\n    }\n\n    /**\n     * @type {KeyPair}\n     */\n    get keyPair() {\n        return this._keyPair;\n    }\n\n    /**\n     * @type {PublicKey}\n     */\n    get publicKey() {\n        return this._keyPair.publicKey;\n    }\n\n    /**\n     * @type {PeerId}\n     */\n    get peerId() {\n        return this._peerId;\n    }\n\n    /**\n     * @type {Services}\n     */\n    get services() {\n        return this._services;\n    }\n\n    /**\n     * @param {Services} services\n     */\n    set services(services) {\n        this._services = services;\n    }\n\n    /**\n     * @type {PeerAddress}\n     */\n    get peerAddress() {\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * @param {number} protocol\n     * @returns {boolean}\n     */\n    canConnect(protocol) {\n        return (protocol & this._protocolMask) !== 0;\n    }\n}\n\nClass.register(NetworkConfig);\n\nclass WsNetworkConfig extends NetworkConfig {\n    /**\n     * @constructor\n     * @param {string} host\n     * @param {number} port\n     * @param {string} key\n     * @param {string} cert\n     */\n    constructor(host, port, key, cert) {\n        super(Protocol.WS);\n        this._host = host;\n        this._port = port;\n        this._key = key;\n        this._cert = cert;\n\n        /* @type {{key: string, cert: string}} */\n        this._sslConfig = {\n            key: this._key,\n            cert: this._cert\n        };\n    }\n\n    /**\n     * @type {{key: string, cert: string}}\n     */\n    get sslConfig() {\n        return this._sslConfig;\n    }\n\n    /**\n     * @type {WsPeerAddress}\n     * @override\n     */\n    get peerAddress() {\n        if (!this._services || !this._keyPair) {\n            throw 'PeerAddress is not configured.';\n        }\n\n        const peerAddress = new WsPeerAddress(\n            this._services.provided, Date.now(), NetAddress.UNSPECIFIED,\n            this.publicKey, /*distance*/ 0,\n            this._host, this._port);\n\n        if (!peerAddress.globallyReachable()) {\n            throw 'PeerAddress not globally reachable.';\n        }\n        peerAddress.signature = Signature.create(this._keyPair.privateKey, this.publicKey, peerAddress.serializeContent());\n        return peerAddress;\n    }\n}\n\nClass.register(WsNetworkConfig);\n\nclass RtcNetworkConfig extends NetworkConfig {\n    /**\n     * @constructor\n     */\n    constructor() {\n        super(Protocol.WS | Protocol.RTC);\n        this._rtcConfig = {\n            iceServers: [\n                {urls: 'stun:stun.l.google.com:19302'},\n                {urls: 'stun:stun.nimiq-network.com:19302'}\n            ]\n        };\n    }\n\n    /**\n     * @returns {?RTCConfiguration}\n     */\n    get rtcConfig() {\n        return this._rtcConfig;\n    }\n\n    /**\n     * @type {RtcPeerAddress}\n     * @override\n     */\n    get peerAddress() {\n        if (!this._services || !this._keyPair) {\n            throw 'PeerAddress is not configured.';\n        }\n\n        const peerAddress = new RtcPeerAddress(\n            this._services.provided, Date.now(), NetAddress.UNSPECIFIED,\n            this.publicKey, /*distance*/ 0);\n        peerAddress.signature = Signature.create(this._keyPair.privateKey, this.publicKey, peerAddress.serializeContent());\n        return peerAddress;\n    }\n}\n\nClass.register(RtcNetworkConfig);\n\nclass DumbNetworkConfig extends NetworkConfig {\n    /**\n     * @constructor\n     */\n    constructor() {\n        super(Protocol.WS);\n    }\n\n    /**\n     * @type {DumbPeerAddress}\n     * @override\n     */\n    get peerAddress() {\n        if (!this._services || !this._keyPair) {\n            throw 'PeerAddress is not configured.';\n        }\n\n        const peerAddress = new DumbPeerAddress(\n            this._services.provided, Date.now(), NetAddress.UNSPECIFIED,\n            this.publicKey, /*distance*/ 0);\n        peerAddress.signature = Signature.create(this._keyPair.privateKey, this.publicKey, peerAddress.serializeContent());\n        return peerAddress;\n    }\n}\n\nClass.register(DumbNetworkConfig);\n","class Network extends Observable {\n    /**\n     * @constructor\n     * @param {IBlockchain} blockchain\n     * @param {NetworkConfig} networkConfig\n     * @param {Time} time\n     * @listens PeerAddressBook#added\n     * @listens ConnectionPool#peer-joined\n     * @listens ConnectionPool#peer-left\n     * @listens ConnectionPool#peers-changed\n     * @listens ConnectionPool#recycling-request\n     * @listens ConnectionPool#connect-error\n     */\n    constructor(blockchain, networkConfig, time) {\n        super();\n\n        /**\n         * @type {IBlockchain}\n         * @private\n         */\n        this._blockchain = blockchain;\n\n        /**\n         * @type {NetworkConfig}\n         * @private\n         */\n        this._networkConfig = networkConfig;\n\n        /**\n         * @type {Time}\n         * @private\n         */\n        this._time = time;\n\n        /**\n         * Flag indicating whether we should actively connect to other peers\n         * if our peer count is below PEER_COUNT_DESIRED.\n         * @type {boolean}\n         * @private\n         */\n        this._autoConnect = false;\n\n        /**\n         * Backoff for peer count check in seconds.\n         * @type {number}\n         * @private\n         */\n        this._backoff = Network.CONNECT_BACKOFF_INITIAL;\n\n        /**\n         * Flag indicating whether we already triggered a backoff.\n         * @type {boolean}\n         * @private\n         */\n        this._backedOff = false;\n\n        /**\n         * The network's addressbook\n         * @type {PeerAddressBook}\n         * @private\n         */\n        this._addresses = new PeerAddressBook(this._networkConfig);\n\n        // Relay new addresses to peers.\n        this._addresses.on('added', addresses => {\n            this._relayAddresses(addresses);\n            this._checkPeerCount();\n        });\n       \n        /**\n         * Peer connections database & operator\n         * @type {ConnectionPool}\n         * @private\n         */\n        this._connections = new ConnectionPool(this._addresses, networkConfig, blockchain, time);\n\n        this._connections.on('peer-joined', peer => this._onPeerJoined(peer));\n        this._connections.on('peer-left', peer => this._onPeerLeft(peer));\n        this._connections.on('peers-changed', () => this._onPeersChanged());\n        this._connections.on('recycling-request', () => this._onRecyclingRequest());\n        this._connections.on('connect-error', () => setTimeout(this._checkPeerCount.bind(this), Network.CONNECT_THROTTLE));\n\n        /**\n         * Helper object to pick addresses from PeerAddressBook.\n         * @type {PeerScorer}\n         * @private\n         */\n        this._scorer = new PeerScorer(this._networkConfig, this._addresses, this._connections);\n\n        /**\n         * @type {number|null}\n         * @private\n         */\n        this._houseKeepingIntervalId = null;\n\n        /**\n         * @type {Timers}\n         */\n        this._timers = new Timers();\n    }\n\n    /**\n     * @returns {void}\n     */\n    connect() {\n        this._autoConnect = true;\n\n        // Setup housekeeping interval.\n        this._houseKeepingIntervalId = setInterval(() => this._housekeeping(), Network.HOUSEKEEPING_INTERVAL);\n\n        // Start connecting to peers.\n        this._checkPeerCount();\n    }\n\n    /**\n     * @param {string|*} reason\n     * @returns {void}\n     */\n    disconnect(reason) {\n        this._autoConnect = false;\n\n        // Clear housekeeping interval.\n        clearInterval(this._houseKeepingIntervalId);\n\n        this._connections.disconnect(reason);\n        this._connections.allowInboundConnections = false;\n    }\n\n    // XXX For testing\n    disconnectWebSocket() {\n        this._autoConnect = false;\n\n        this._connections.disconnectWebSocket();\n    }\n\n    /**\n     * @param {Peer} peer\n     * @returns {void}\n     * @fires Network#peer-joined\n     * @private\n     */\n    _onPeerJoined(peer) {\n        // Recalculate the network adjusted offset\n        this._updateTimeOffset();\n\n        // Tell others about the address that we just connected to.\n        this._relayAddresses([peer.peerAddress]);\n\n        this.fire('peer-joined', peer);\n    }\n\n    /**\n     * @param {Peer} peer\n     * @returns {void}\n     * @fires Network#peer-left\n     * @private\n     */\n    _onPeerLeft(peer) {\n        // Recalculate the network adjusted offset\n        this._updateTimeOffset();\n\n        this.fire('peer-left', peer);\n    }\n\n    /**\n     * @returns {void}\n     * @fires Network#peers-changed\n     * @private\n     */\n    _onPeersChanged() {\n        setTimeout(this._checkPeerCount.bind(this), Network.CONNECT_THROTTLE);\n\n        this.fire('peers-changed');\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _onRecyclingRequest() {\n        this._scorer.recycleConnections(1, CloseType.PEER_CONNECTION_RECYCLED_INBOUND_EXCHANGE, 'Peer connection recycled inbound exchange');\n\n        // set ability to exchange for new inbound connections\n        this._connections.allowInboundExchange = this._scorer.lowestConnectionScore !== null\n            ? this._scorer.lowestConnectionScore < Network.SCORE_INBOUND_EXCHANGE\n            : false;\n    }\n\n    /**\n     * @param {Array.<PeerAddress>} addresses\n     * @returns {void}\n     * @private\n     */\n    _relayAddresses(addresses) {\n        // Pick PEER_COUNT_RELAY random peers and relay addresses to them if:\n        // - number of addresses <= 10\n        // TODO more restrictions, see Bitcoin\n        if (addresses.length > 10) {\n            return;\n        }\n\n        // XXX We don't protect against picking the same peer more than once.\n        // The NetworkAgent will take care of not sending the addresses twice.\n        // In that case, the address will simply be relayed to less peers. Also,\n        // the peer that we pick might already know the address.\n        const peerConnections = this._connections.values();\n        for (let i = 0; i < Network.PEER_COUNT_RELAY; ++i) {\n            const peerConnection = ArrayUtils.randomElement(peerConnections);\n            if (peerConnection && peerConnection.state === PeerConnectionState.ESTABLISHED && peerConnection.networkAgent) {\n                peerConnection.networkAgent.relayAddresses(addresses);\n            }\n        }\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _checkPeerCount() {\n        if (this._autoConnect\n            && !this._scorer.isGoodPeerSet()\n            && this._connections.connectingCount < Network.CONNECTING_COUNT_MAX) {\n\n            // Pick a peer address that we are not connected to yet.\n            const peerAddress = this._scorer.pickAddress();\n\n            // We can't connect if we don't know any more addresses or only want connections to good peers.\n            const onlyGoodPeers = this._scorer.needsGoodPeers() && !this._scorer.needsMorePeers();\n            if (!peerAddress || onlyGoodPeers && !this._scorer.isGoodPeer(peerAddress)) {\n                // If no backoff has been triggered, trigger one.\n                // This helps us to check back whether we need more connections.\n                if (!this._backedOff) {\n                    this._backedOff = true;\n                    const oldBackoff = this._backoff;\n                    this._backoff = Math.min(Network.CONNECT_BACKOFF_MAX, oldBackoff * 2);\n                    setTimeout(() => {\n                        this._backedOff = false;\n                        this._checkPeerCount();\n                    }, oldBackoff);\n\n                    if (this._connections.count === 0) {\n                        // We are not connected to any peers (anymore) and don't know any more addresses to connect to.\n\n                        // Tell listeners that we are disconnected. This is primarily useful for tests.\n                        this.fire('disconnected');\n\n                        // Allow inbound connections. This is important for the first seed node on the network which\n                        // will never establish a consensus and needs to accept incoming connections eventually.\n                        this._connections.allowInboundConnections = true;\n                    }\n                }\n\n                return;\n            }\n\n            // Connect to this address.\n            if (!this._connections.connectOutbound(peerAddress)) {\n                this._addresses.close(null, peerAddress, CloseType.CONNECTION_FAILED);\n                setTimeout(() => this._checkPeerCount(), Network.CONNECT_THROTTLE);\n            }\n        }\n        this._backoff = Network.CONNECT_BACKOFF_INITIAL;\n    }\n\n    /**\n     * Updates the network time offset by calculating the median offset\n     * from all our peers.\n     * @returns {void}\n     * @private\n     */\n    _updateTimeOffset() {\n        const peerConnections = this._connections.values();\n\n        const offsets = [0]; // Add our own offset.\n        peerConnections.forEach(peerConnection => {\n            if (peerConnection.state === PeerConnectionState.ESTABLISHED) {\n                offsets.push(peerConnection.networkAgent.peer.timeOffset);\n            }\n        });\n\n        const offsetsLength = offsets.length;\n        offsets.sort((a, b) => a - b);\n\n        let timeOffset;\n        if ((offsetsLength % 2) === 0) {\n            timeOffset = Math.round((offsets[(offsetsLength / 2) - 1] + offsets[offsetsLength / 2]) / 2);\n        } else {\n            timeOffset = offsets[(offsetsLength - 1) / 2];\n        }\n\n        this._time.offset = Math.max(Math.min(timeOffset, Network.TIME_OFFSET_MAX), -Network.TIME_OFFSET_MAX);\n    }\n\n    /**\n     * @returns {void}\n     * @private\n     */\n    _housekeeping() {\n        this._scorer.scoreConnections();\n\n        // recycle\n        if (this.peerCount > Network.PEER_COUNT_RECYCLING_ACTIVE) {\n            // recycle 1% at PEER_COUNT_RECYCLING_ACTIVE, 20% at PEER_COUNT_MAX\n            const percentageToRecycle = (this.peerCount - Network.PEER_COUNT_RECYCLING_ACTIVE) * 0.19 / (Network.PEER_COUNT_MAX - Network.PEER_COUNT_RECYCLING_ACTIVE) + 0.01;\n            const connectionsToRecycle = Math.ceil(this.peerCount * percentageToRecycle);\n            this._scorer.recycleConnections(connectionsToRecycle, CloseType.PEER_CONNECTION_RECYCLED, 'Peer connection recycled');\n        }\n\n        // set ability to exchange for new inbound connections\n        this._connections.allowInboundExchange = this._scorer.lowestConnectionScore !== null\n            ? this._scorer.lowestConnectionScore < Network.SCORE_INBOUND_EXCHANGE\n            : false;\n    }\n\n    /** @type {Time} */\n    get time() {\n        return this._time;\n    }\n\n    /** @type {number} */\n    get peerCount() {\n        return this._connections.peerCount;\n    }\n\n    /** @type {number} */\n    get peerCountWebSocket() {\n        return this._connections.peerCountWs;\n    }\n\n    /** @type {number} */\n    get peerCountWebRtc() {\n        return this._connections.peerCountRtc;\n    }\n\n    /** @type {number} */\n    get peerCountDumb() {\n        return this._connections.peerCountDumb;\n    }\n\n    /** @type {number} */\n    get peerCountConnecting() {\n        return this._connections.connectingCount;\n    }\n\n    /** @type {number} */\n    get knownAddressesCount() {\n        return this._addresses.knownAddressesCount;\n    }\n\n    /** @type {number} */\n    get bytesSent() {\n        return this._connections.bytesSent;\n    }\n\n    /** @type {number} */\n    get bytesReceived() {\n        return this._connections.bytesReceived;\n    }\n\n    /** @type {boolean} */\n    get allowInboundConnections() {\n        return this._connections.allowInboundConnections;\n    }\n\n    /** @param {boolean} allowInboundConnections */\n    set allowInboundConnections(allowInboundConnections) {\n        this._connections.allowInboundConnections = allowInboundConnections;\n    }\n\n    /** @type {PeerAddressBook} */\n    get addresses() {\n        return this._addresses;\n    }\n\n    /** @type {ConnectionPool} */\n    get connections() {\n        return this._connections;\n    }\n}\n/**\n * @type {number}\n * @constant\n */\nNetwork.PEER_COUNT_MAX = PlatformUtils.isBrowser() ? 15 : 50000;\n/**\n * @type {number}\n * @constant\n */\nNetwork.INBOUND_PEER_COUNT_PER_SUBNET_MAX = PlatformUtils.isBrowser() ? 2 : 100;\n/**\n * @type {number}\n * @constant\n */\nNetwork.OUTBOUND_PEER_COUNT_PER_SUBNET_MAX = 2;\n/**\n * @type {number}\n * @constant\n */\nNetwork.PEER_COUNT_PER_IP_MAX = PlatformUtils.isBrowser() ? 1 : 20;\n/**\n * @type {number}\n * @constant\n */\nNetwork.IPV4_SUBNET_MASK = 24;\n/**\n * @type {number}\n * @constant\n */\nNetwork.IPV6_SUBNET_MASK = 96;\n/**\n * @type {number}\n * @constant\n */\nNetwork.PEER_COUNT_RECYCLING_ACTIVE = PlatformUtils.isBrowser() ? 5 : 1000;\n/**\n * @type {number}\n * @constant\n */\nNetwork.PEER_COUNT_RELAY = 4;\n/**\n * @type {number}\n * @constant\n */\nNetwork.CONNECTING_COUNT_MAX = 2;\n/**\n * @type {number}\n * @constant\n */\nNetwork.SIGNAL_TTL_INITIAL = 3;\n/**\n * @type {number}\n * @constant\n */\nNetwork.CONNECT_BACKOFF_INITIAL = 1000; // 1 second\n/**\n * @type {number}\n * @constant\n */\nNetwork.CONNECT_BACKOFF_MAX = 5 * 60 * 1000; // 5 minutes\n/**\n * @type {number}\n * @constant\n */\nNetwork.TIME_OFFSET_MAX = 15 * 60 * 1000; // 15 minutes\n/**\n * @type {number}\n * @constant\n */\nNetwork.HOUSEKEEPING_INTERVAL = 5 * 60 * 1000; // 5 minutes\n/**\n * @type {number}\n * @constant\n */\nNetwork.SCORE_INBOUND_EXCHANGE = 0.5;\n/**\n * @type {number}\n * @constant\n */\nNetwork.CONNECT_THROTTLE = 300; // 300 ms\n\nClass.register(Network);\n","class NetUtils {\n    /**\n     * @param {string|Uint8Array} ip\n     * @return {boolean}\n     */\n    static isPrivateIP(ip) {\n        if (!(ip instanceof Uint8Array)) {\n            ip = NetUtils.ipToBytes(ip);\n        }\n\n        if (NetUtils.isLocalIP(ip)) {\n            return true;\n        }\n\n        if (NetUtils.isIPv4Address(ip)) {\n            for (const subnet of NetUtils.IPv4_PRIVATE_NETWORK) {\n                if (NetUtils.isIPv4inSubnet(ip, subnet)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        if (NetUtils.isIPv6Address(ip)) {\n            // Private subnet is fc00::/7.\n            // So, we only check the first 7 bits of the address to be equal fc00.\n            if ((ip[0] & 0xfe) === 0xfc) {\n                return true;\n            }\n\n            // Link-local addresses are fe80::/10.\n            if (ip[0] === 0xfe && (ip[1] & 0xc0) === 0x80) {\n                return true;\n            }\n\n            // Does not seem to be a private IP.\n            return false;\n        }\n\n        throw new Error(`Malformed IP address ${ip}`);\n    }\n\n    /**\n     * @param {string|Uint8Array} ip\n     * @returns {boolean}\n     */\n    static isLocalIP(ip) {\n        if (!(ip instanceof Uint8Array)) {\n            ip = NetUtils.ipToBytes(ip);\n        }\n\n        if (ip.length === NetUtils.IPv4_LENGTH) {\n            return ip[0] === 127 && ip[1] === 0 && ip[2] === 0 && ip[3] === 1;\n        }\n        if (ip.length === NetUtils.IPv6_LENGTH) {\n            for (let i = 0; i < NetUtils.IPv6_LENGTH - 1; i++) {\n                if (ip[i] !== 0) return false;\n            }\n            return ip[NetUtils.IPv6_LENGTH - 1] === 1;\n        }\n\n        return false;\n    }\n\n    /**\n     * @param {string|Uint8Array} ip\n     * @param {string} subnet\n     * @return {boolean}\n     */\n    static isIPv4inSubnet(ip, subnet) {\n        if (!(ip instanceof Uint8Array)) {\n            ip = NetUtils.ipToBytes(ip);\n        }\n\n        let [subIp, mask] = subnet.split('/');\n        mask = -1<<(32-parseInt(mask));\n        return (NetUtils._IPv4toLong(ip) & mask) === NetUtils._IPv4toLong(subIp);\n    }\n\n    /**\n     * @param {string|Uint8Array} ip\n     * @return {boolean}\n     */\n    static isIPv4Address(ip) {\n        if (ip instanceof Uint8Array) return ip.length === NetUtils.IPv4_LENGTH;\n        const match = ip.match(/^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/);\n        return !!match && parseInt(match[1]) <= 255 && parseInt(match[2]) <= 255\n            && parseInt(match[3]) <= 255 && parseInt(match[4]) <= 255;\n    }\n\n    /**\n     * @param {string|Uint8Array} ip\n     * @return {boolean}\n     */\n    static isIPv6Address(ip) {\n        if (ip instanceof Uint8Array) return ip.length === NetUtils.IPv6_LENGTH;\n\n        const parts = ip.toLowerCase().split(':');\n        // An IPv6 address consists of at most 8 parts and at least 3.\n        if (parts.length > 8 || parts.length < 3) {\n            return false;\n        }\n\n        const isEmbeddedIPv4 = NetUtils.isIPv4Address(parts[parts.length - 1]);\n\n        let innerEmpty = false;\n        for (let i = 0; i < parts.length; ++i) {\n            // Check whether each part is valid.\n            // Note: the last part may be a IPv4 address!\n            // They can be embedded in the last part. Remember that they take 32bit.\n            if (!(/^[a-f0-9]{0,4}$/.test(parts[i])\n                    || (i === parts.length - 1\n                        && isEmbeddedIPv4\n                        && parts.length < 8))) {\n                return false;\n            }\n            // Inside the parts, there has to be at most one empty part.\n            if (parts[i].length === 0 && i > 0 && i < parts.length - 1) {\n                if (innerEmpty) {\n                    return false; // at least two empty parts\n                }\n                innerEmpty = true;\n            }\n        }\n\n        // In the special case of embedded IPv4 addresses, everything but the last 48 bit must be 0.\n        if (isEmbeddedIPv4) {\n            // Exclude the last two parts.\n            for (let i=0; i<parts.length-2; ++i) {\n                if (!/^0{0,4}$/.test(parts[i])) {\n                    return false;\n                }\n            }\n        }\n\n        // If the first part is empty, the second has to be empty as well (e.g., ::1).\n        if (parts[0].length === 0) {\n            return parts[1].length === 0;\n        }\n\n        // If the last part is empty, the second last has to be empty as well (e.g., 1::).\n        if (parts[parts.length - 1].length === 0) {\n            return parts[parts.length - 2].length === 0;\n        }\n\n        // If the length is less than 7 and an IPv4 address is embedded, there has to be an empty part.\n        if (isEmbeddedIPv4 && parts.length < 7) {\n            return innerEmpty;\n        }\n\n        // Otherwise if the length is less than 8, there has to be an empty part.\n        if (parts.length < 8) {\n            return innerEmpty;\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {string} host\n     * @returns {boolean}\n     */\n    static hostGloballyReachable(host) {\n        // IP addresses can't have a proper certificate\n        if (NetUtils.isIPv4Address(host) || NetUtils.isIPv6Address(host)) {\n            return false;\n        }\n        // \"the use of dotless domains is prohibited [in new gTLDs]\" [ https://www.icann.org/resources/board-material/resolutions-new-gtld-2013-08-13-en#1 ]. Old gTLDs rarely use them.\n        if (!host.match(/.+\\..+$/)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @param {string|Uint8Array} ip\n     * @return {number}\n     */\n    static _IPv4toLong(ip) {\n        if (!(ip instanceof Uint8Array)) {\n            ip = NetUtils.ipToBytes(ip);\n        }\n        return (ip[0]<<24) + (ip[1]<<16) + (ip[2]<<8) + ip[3];\n    }\n\n    /**\n     * @param {string} ip\n     * @returns {string}\n     * @private\n     */\n    static _IPv4toIPv6(ip) {\n        let parts = ip.split('.');\n        parts = parts.map(x => parseInt(x));\n        const mask = [];\n        for(let i = 0; i < 4; i++) {\n            mask.push(('00' + parts[i].toString(16)).slice(-2));\n        }\n        return `${mask[0]}${mask[1]}:${mask[2]}${mask[3]}`;\n    }\n\n    /**\n     * @param {string} ip\n     * @returns {Uint8Array}\n     */\n    static ipToBytes(ip) {\n        if (NetUtils.isIPv4Address(ip)) {\n            const parts = ip.split('.');\n            return new Uint8Array(parts.map(x => parseInt(x)));\n        }\n\n        if (NetUtils.isIPv6Address(ip)) {\n            let parts = ip.toLowerCase().split(':');\n\n            // Handle embedded IPv4 addresses.\n            if (NetUtils.isIPv4Address(parts[parts.length - 1])) {\n                return NetUtils.ipToBytes(parts[parts.length - 1]);\n            }\n\n            // IPv6\n            parts = NetUtils._extendIPv6(parts);\n            parts = parts.map(x => parseInt(x, 16));\n            const bytes = [];\n            for(let i = 0; i < 8; i++) {\n                bytes.push(parts[i] >> 8);\n                bytes.push(parts[i] & 0xff);\n            }\n            return new Uint8Array(bytes);\n        }\n\n        throw new Error(`Malformed IP address ${ip}`);\n    }\n\n    /**\n     * @param {Uint8Array} ip\n     * @returns {string}\n     */\n    static bytesToIp(ip) {\n        if (NetUtils.isIPv4Address(ip)) {\n            return ip.join('.');\n        }\n\n        if (NetUtils.isIPv6Address(ip)) {\n            const hexIp = Array.from(ip, x => ('00' + x.toString(16)).slice(-2));\n            const ipv6 = [];\n            for (let i = 0; i < 8; i++) {\n                ipv6.push(hexIp[i*2] + hexIp[i*2+1]);\n            }\n            return ipv6.join(':');\n        }\n\n        throw new Error(`Malformed IP address ${ip}`);\n    }\n\n    /**\n     * @param {Array.<string>} parts\n     * @returns {Array.<string>}\n     * @private\n     */\n    static _extendIPv6(parts) {\n        // Handle embedded IPv4 addresses.\n        if (NetUtils.isIPv4Address(parts[parts.length - 1])) {\n            const ipv4 = parts[parts.length - 1];\n            const ipv6 = NetUtils._IPv4toIPv6(ipv4);\n            ip = ip.replace(ipv4, ipv6);\n            parts = ip.toLowerCase().split(':');\n        }\n\n        let emptyPart = parts.indexOf('');\n        // If there is an empty part, fill it up.\n        if (emptyPart >= 0) {\n            parts[emptyPart] = '0';\n            for (let i = parts.length; i < 8; i++) {\n                parts.splice(emptyPart, 0, '0');\n            }\n        }\n        // Fill remaining empty fields with 0 as well.\n        emptyPart = parts.indexOf('');\n        while (emptyPart >= 0) {\n            parts[emptyPart] = '0';\n            emptyPart = parts.indexOf('');\n        }\n\n        return parts;\n    }\n\n    /**\n     * @param {string|Uint8Array} ip\n     * @param {number} bitCount\n     * @return {string|Uint8Array}\n     */\n    static ipToSubnet(ip, bitCount) {\n        let stringResult = false;\n        if (!(ip instanceof Uint8Array)) {\n            ip = NetUtils.ipToBytes(ip);\n            stringResult = true;\n        }\n\n        const mask = [];\n        for(let i = 0; i < ip.byteLength; i++) {\n            const n = Math.min(bitCount, 8);\n            mask.push(ip[i] & (256 - Math.pow(2, 8 - n)));\n            bitCount -= n;\n        }\n        const result = new Uint8Array(mask);\n        return stringResult ? NetUtils.bytesToIp(result) : result;\n    }\n}\nNetUtils.IPv4_LENGTH = 4;\nNetUtils.IPv6_LENGTH = 16;\nNetUtils.IPv4_PRIVATE_NETWORK = [\n    '10.0.0.0/8',\n    '172.16.0.0/12',\n    '192.168.0.0/16',\n    '100.64.0.0/10', // link-local\n\n    // Actually, the following one is only an approximation,\n    // the first and the last /24 subnets in the range should be excluded.\n    '169.254.0.0/16'\n];\nClass.register(NetUtils);\n","class PeerKeyStore {\n    /**\n     * @returns {Promise.<PeerKeyStore>}\n     */\n    static async getPersistent() {\n        if (!PeerKeyStore._instance) {\n            const jdb = new JDB.JungleDB('peer-key', PeerKeyStore.VERSION, { maxDbSize: PeerKeyStore.INITIAL_DB_SIZE });\n\n            // Initialize object stores.\n            jdb.createObjectStore(PeerKeyStore.KEY_DATABASE, { codec: new PeerKeyStoreCodec() });\n\n            // Establish connection to database.\n            await jdb.connect();\n\n            PeerKeyStore._instance = new PeerKeyStore(jdb.getObjectStore(PeerKeyStore.KEY_DATABASE));\n        }\n        return PeerKeyStore._instance;\n    }\n\n    /**\n     * @returns {PeerKeyStore}\n     */\n    static createVolatile() {\n        const store = JDB.JungleDB.createVolatileObjectStore();\n        return new PeerKeyStore(store);\n    }\n\n    /**\n     * @param {IObjectStore} store\n     */\n    constructor(store) {\n        this._store = store;\n    }\n\n    /**\n     * @param {string} key\n     * @returns {Promise.<KeyPair>}\n     */\n    get(key) {\n        return this._store.get(key);\n    }\n\n    /**\n     * @param {string} key\n     * @param {KeyPair} keyPair\n     * @returns {Promise}\n     */\n    put(key, keyPair) {\n        return this._store.put(key, keyPair);\n    }\n}\nPeerKeyStore._instance = null;\nPeerKeyStore.VERSION = 2;\nPeerKeyStore.KEY_DATABASE = 'keys';\nPeerKeyStore.INITIAL_DB_SIZE = 1024*1024*10; // 10 MB\nClass.register(PeerKeyStore);\n\n/**\n * @implements {ICodec}\n */\nclass PeerKeyStoreCodec {\n    /**\n     * @param {*} obj The object to encode before storing it.\n     * @returns {*} Encoded object.\n     */\n    encode(obj) {\n        return obj.serialize();\n    }\n\n    /**\n     * @param {*} buf The object to decode.\n     * @param {string} key The object's primary key.\n     * @returns {*} Decoded object.\n     */\n    decode(buf, key) {\n        return KeyPair.unserialize(new SerialBuffer(buf));\n    }\n\n    /**\n     * @type {string}\n     */\n    get leveldbValueEncoding() {\n        return 'binary';\n    }\n\n    /**\n     * @type {object}\n     */\n    get lmdbValueEncoding() {\n        return JDB.JungleDB.BINARY_ENCODING;\n    }\n}\n","class Peer {\n    /**\n     * @param {PeerChannel} channel\n     * @param {number} version\n     * @param {Hash} headHash\n     * @param {number} timeOffset\n     */\n    constructor(channel, version, headHash, timeOffset) {\n        /** @type {PeerChannel} */\n        this._channel = channel;\n        /** @type {number} */\n        this._version = version;\n        /** @type {Hash} */\n        this._headHash = headHash;\n        /** @type {BlockHeader} */\n        this._head = null;\n        /**\n         * Offset between the peer's time and our local time.\n         * @type {number}\n         */\n        this._timeOffset = timeOffset;\n\n        this._setNetAddress();\n    }\n\n    /**\n     * @private\n     * @returns {void}\n     */\n    _setNetAddress() {\n        // If the connector was able the determine the peer's netAddress, update the peer's advertised netAddress.\n        if (this.channel.netAddress) {\n            /*\n             * TODO What to do if it doesn't match the currently advertised one?\n             * This might happen if multiple IPs are assigned to a host.\n             */\n            if (this.peerAddress.netAddress && !this.peerAddress.netAddress.equals(this.channel.netAddress)) {\n                Log.w(Peer, `Got different netAddress ${this.channel.netAddress} for ${this.peerAddress} `\n                    + `- advertised was ${this.peerAddress.netAddress}`);\n            }\n\n            // Only set the advertised netAddress if we have the public IP of the peer.\n            // WebRTC connectors might return local IP addresses for peers on the same LAN.\n            if (!this.channel.netAddress.isPrivate()) {\n                this.peerAddress.netAddress = this.channel.netAddress;\n            }\n        }\n        // Otherwise, use the netAddress advertised for this peer if available.\n        else if (this.channel.peerAddress.netAddress) {\n            this.channel.netAddress = this.channel.peerAddress.netAddress;\n        }\n        // Otherwise, we don't know the netAddress of this peer. Use a pseudo netAddress.\n        else {\n            this.channel.netAddress = NetAddress.UNKNOWN;\n        }\n    }\n\n    /** @type {PeerChannel} */\n    get channel() {\n        return this._channel;\n    }\n\n    /** @type {number} */\n    get version() {\n        return this._version;\n    }\n\n    /** @type {Hash} */\n    get headHash() {\n        return this._headHash;\n    }\n\n    /** @type {BlockHeader} */\n    get head() {\n        return this._head;\n    }\n\n    /** @param {BlockHeader} head */\n    set head(head) {\n        this._head = head;\n        this._headHash = head.hash();\n    }\n\n    /** @type {number} */\n    get timeOffset() {\n        return this._timeOffset;\n    }\n\n    /** @type {number} */\n    get id() {\n        return this._channel.id;\n    }\n\n    /** @type {PeerAddress} */\n    get peerAddress() {\n        return this._channel.peerAddress;\n    }\n\n    /** @type {NetAddress} */\n    get netAddress() {\n        return this._channel.netAddress;\n    }\n\n    /**\n     * @param {Peer} o\n     * @returns {boolean}\n     */\n    equals(o) {\n        return o instanceof Peer\n            && this._channel.equals(o.channel);\n    }\n\n    hashCode() {\n        return this._channel.hashCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    toString() {\n        return `Peer{version=${this._version}, headHash=${this._headHash}, `\n            + `peerAddress=${this.peerAddress}, netAddress=${this.netAddress}}`;\n    }\n}\nClass.register(Peer);\n","class Miner extends Observable {\n    /**\n     * @param {IBlockchain} blockchain\n     * @param {Accounts} accounts\n     * @param {Mempool} mempool\n     * @param {Time} time\n     * @param {Address} minerAddress\n     * @param {Uint8Array} [extraData=new Uint8Array(0)]\n     *\n     * @listens Mempool#transaction-added\n     * @listens Mempool#transaction-ready\n     */\n    constructor(blockchain, accounts, mempool, time, minerAddress, extraData = new Uint8Array(0)) {\n        super();\n        /** @type {IBlockchain} */\n        this._blockchain = blockchain;\n        /** @type {Accounts} */\n        this._accounts = accounts;\n        /** @type {Mempool} */\n        this._mempool = mempool;\n        /** @type {Time} */\n        this._time = time;\n        /** @type {Address} */\n        this._address = minerAddress;\n        /** @type {Uint8Array} */\n        this._extraData = extraData;\n\n        /**\n         * Number of hashes computed since the last hashrate update.\n         * @type {number}\n         * @private\n         */\n        this._hashCount = 0;\n\n        /**\n         * Timestamp of the last hashrate update.\n         * @type {number}\n         * @private\n         */\n        this._lastHashrate = 0;\n\n        /**\n         * Hashrate computation interval handle.\n         * @private\n         */\n        this._hashrateWorker = null;\n\n        /**\n         * The current hashrate of this miner.\n         * @type {number}\n         * @private\n         */\n        this._hashrate = 0;\n\n        /**\n         * The last hash counts used in the moving average.\n         * @type {Array.<number>}\n         * @private\n         */\n        this._lastHashCounts = [];\n\n        /**\n         * The total hashCount used in the current moving average.\n         * @type {number}\n         * @private\n         */\n        this._totalHashCount = 0;\n\n        /**\n         * The time elapsed for the last measurements used in the moving average.\n         * @type {Array.<number>}\n         * @private\n         */\n        this._lastElapsed = [];\n\n        /**\n         * The total time elapsed used in the current moving average.\n         * @type {number}\n         * @private\n         */\n        this._totalElapsed = 0;\n\n        /** @type {MinerWorkerPool} */\n        this._workerPool = new MinerWorkerPool();\n\n        if (typeof navigator === 'object' && navigator.hardwareConcurrency) {\n            this.threads = Math.ceil(navigator.hardwareConcurrency / 2);\n        } else if (PlatformUtils.isNodeJs()) {\n            const cores = require('os').cpus().length;\n            this.threads = Math.ceil(cores / 2);\n            if (cores === 1) this.throttleAfter = 2;\n        } else {\n            this.threads = 1;\n        }\n        this._workerPool.on('share', (obj) => this._onWorkerShare(obj));\n        this._workerPool.on('no-share', (obj) => this._onWorkerShare(obj));\n\n        /**\n         * Flag indicating that the mempool has changed since we started mining the current block.\n         * @type {boolean}\n         * @private\n         */\n        this._mempoolChanged = false;\n\n        /** @type {boolean} */\n        this._restarting = false;\n\n        /** @type {number} */\n        this._lastRestart = 0;\n\n        /** @type {boolean} */\n        this._submittingBlock = false;\n\n        // Listen to changes in the mempool which evicts invalid transactions\n        // after every blockchain head change and then fires 'transactions-ready'\n        // when the eviction process finishes. Restart work on the next block\n        // with fresh transactions when this fires.\n        this._mempool.on('transactions-ready', () => this._startWork());\n\n        // Immediately start processing transactions when they come in.\n        this._mempool.on('transaction-added', () => this._mempoolChanged = true);\n    }\n\n    startWork() {\n        if (this.working) {\n            return;\n        }\n\n        // Initialize hashrate computation.\n        this._hashCount = 0;\n        this._lastElapsed = [];\n        this._lastHashCounts = [];\n        this._totalHashCount = 0;\n        this._totalElapsed = 0;\n        this._lastHashrate = Date.now();\n        this._hashrateWorker = setInterval(() => this._updateHashrate(), 1000);\n        this._retry = 0;\n\n        // Tell listeners that we've started working.\n        this.fire('start', this);\n\n        // Kick off the mining process.\n        this._startWork().catch(Log.w.tag(Miner));\n    }\n\n    async _startWork() {\n        // XXX Needed as long as we cannot unregister from transactions-ready events.\n        if (!this.working || this._restarting) {\n            return;\n        }\n        try {\n            this._lastRestart = Date.now();\n            this._restarting = true;\n            this._mempoolChanged = false;\n\n            // Construct next block.\n            this._retry = 0;\n            const block = await this.getNextBlock();\n\n            Log.i(Miner, `Starting work on ${block.header}, transactionCount=${block.transactionCount}, hashrate=${this._hashrate} H/s`);\n\n            this._workerPool.startMiningOnBlock(block).catch(Log.w.tag(Miner));\n        } catch (e) {\n            Log.w(Miner, 'Failed to start work, retrying in 100ms');\n            this.stopWork();\n            setTimeout(() => this.startWork(), 100);\n        } finally {\n            this._restarting = false;\n        }\n    }\n\n    /**\n     * @param {{hash: Hash, nonce: number, block: Block}} obj\n     * @private\n     */\n    async _onWorkerShare(obj) {\n        this._hashCount += this._workerPool.noncesPerRun;\n        if (obj.block && obj.block.prevHash.equals(this._blockchain.headHash)) {\n            Log.d(Miner, () => `Received share: ${obj.nonce} / ${obj.hash.toHex()}`);\n            if (BlockUtils.isProofOfWork(obj.hash, obj.block.target) && !this._submittingBlock) {\n                obj.block.header.nonce = obj.nonce;\n                this._submittingBlock = true;\n                if (await obj.block.header.verifyProofOfWork()) {\n                    // Tell listeners that we've mined a block.\n                    this.fire('block-mined', obj.block, this);\n\n                    // Push block into blockchain.\n                    if ((await this._blockchain.pushBlock(obj.block)) < 0) {\n                        this._submittingBlock = false;\n                        this._startWork().catch(Log.w.tag(Miner));\n                        return;\n                    } else {\n                        this._submittingBlock = false;\n                    }\n                } else {\n                    Log.d(Miner, `Ignoring invalid share: ${await obj.block.header.pow()}`);\n                }\n            }\n        }\n        if (this._mempoolChanged && this._lastRestart + Miner.MIN_TIME_ON_BLOCK < Date.now()) {\n            this._startWork().catch(Log.w.tag(Miner));\n        }\n    }\n\n    /**\n     * @return {Promise.<Block>}\n     * @private\n     */\n    async getNextBlock() {\n        this._retry++;\n        try {\n            const nextTarget = await this._blockchain.getNextTarget();\n            const interlink = await this._getNextInterlink(nextTarget);\n            const body = await this._getNextBody(interlink.serializedSize);\n            const header = await this._getNextHeader(nextTarget, interlink, body);\n            if ((await this._blockchain.getNextTarget()) !== nextTarget) return this.getNextBlock();\n            return new Block(header, interlink, body);\n        } catch (e) {\n            // Retry up to three times.\n            if (this._retry <= 3) return this.getNextBlock();\n            throw e;\n        }\n    }\n\n    /**\n     * @param {number} nextTarget\n     * @param {BlockInterlink} interlink\n     * @param {BlockBody} body\n     * @return {Promise.<BlockHeader>}\n     * @private\n     */\n    async _getNextHeader(nextTarget, interlink, body) {\n        const prevHash = this._blockchain.headHash;\n        const interlinkHash = interlink.hash();\n        const height = this._blockchain.height + 1;\n\n        // Compute next accountsHash.\n        const accounts = await this._accounts.transaction();\n        let accountsHash;\n        try {\n            await accounts.commitBlockBody(body, height, this._blockchain.transactionCache);\n            accountsHash = await accounts.hash();\n            await accounts.abort();\n        } catch (e) {\n            await accounts.abort();\n            throw new Error(`Invalid block body: ${e.message}`);\n        }\n\n        const bodyHash = body.hash();\n        const timestamp = this._getNextTimestamp();\n        const nBits = BlockUtils.targetToCompact(nextTarget);\n        const nonce = 0;\n        return new BlockHeader(prevHash, interlinkHash, bodyHash, accountsHash, nBits, height, timestamp, nonce);\n    }\n\n    /**\n     * @param {number} nextTarget\n     * @returns {Promise.<BlockInterlink>}\n     * @private\n     */\n    _getNextInterlink(nextTarget) {\n        return this._blockchain.head.getNextInterlink(nextTarget);\n    }\n\n    /**\n     * @param {number} interlinkSize\n     * @return {BlockBody}\n     * @private\n     */\n    async _getNextBody(interlinkSize) {\n        const maxSize = Policy.BLOCK_SIZE_MAX\n            - BlockHeader.SERIALIZED_SIZE\n            - interlinkSize\n            - BlockBody.getMetadataSize(this._extraData);\n        const transactions = await this._mempool.getTransactionsForBlock(maxSize);\n        const prunedAccounts = await this._accounts.gatherToBePrunedAccounts(transactions, this._blockchain.height + 1, this._blockchain.transactionCache);\n        return new BlockBody(this._address, transactions, this._extraData, prunedAccounts);\n    }\n\n    /**\n     * @return {number}\n     * @private\n     */\n    _getNextTimestamp() {\n        const now = Math.floor(this._time.now() / 1000);\n        return Math.max(now, this._blockchain.head.timestamp + 1);\n    }\n\n    /**\n     * @fires Miner#stop\n     */\n    stopWork() {\n        // TODO unregister from blockchain head-changed events.\n        if (!this.working) {\n            return;\n        }\n\n        clearInterval(this._hashrateWorker);\n        this._hashrateWorker = null;\n        this._hashrate = 0;\n        this._lastElapsed = [];\n        this._lastHashCounts = [];\n        this._totalHashCount = 0;\n        this._totalElapsed = 0;\n\n        // Tell listeners that we've stopped working.\n        this._workerPool.stop();\n        this.fire('stop', this);\n\n        Log.i(Miner, 'Stopped work');\n    }\n\n    /**\n     * @fires Miner#hashrate-changed\n     * @private\n     */\n    _updateHashrate() {\n        const elapsed = (Date.now() - this._lastHashrate) / 1000;\n        const hashCount = this._hashCount;\n        // Enable next measurement.\n        this._hashCount = 0;\n        this._lastHashrate = Date.now();\n\n        // Update stored information on moving average.\n        this._lastElapsed.push(elapsed);\n        this._lastHashCounts.push(hashCount);\n        this._totalElapsed += elapsed;\n        this._totalHashCount += hashCount;\n\n        if (this._lastElapsed.length > Miner.MOVING_AVERAGE_MAX_SIZE) {\n            const oldestElapsed = this._lastElapsed.shift();\n            const oldestHashCount = this._lastHashCounts.shift();\n            this._totalElapsed -= oldestElapsed;\n            this._totalHashCount -= oldestHashCount;\n        }\n\n        this._hashrate = Math.round(this._totalHashCount / this._totalElapsed);\n\n        // Tell listeners about our new hashrate.\n        this.fire('hashrate-changed', this._hashrate, this);\n    }\n\n    /** @type {Address} */\n    get address() {\n        return this._address;\n    }\n\n    /** @type {boolean} */\n    get working() {\n        return !!this._hashrateWorker;\n    }\n\n    /** @type {number} */\n    get hashrate() {\n        return this._hashrate;\n    }\n\n    /** @type {number} */\n    get threads() {\n        return this._workerPool.poolSize;\n    }\n\n    /**\n     * @param {number} threads\n     */\n    set threads(threads) {\n        this._workerPool.poolSize = threads;\n    }\n\n    /** @type {number} */\n    get throttleWait() {\n        return this._workerPool.cycleWait;\n    }\n\n    /**\n     * @param {number} throttleWait\n     */\n    set throttleWait(throttleWait) {\n        this._workerPool.cycleWait = throttleWait;\n    }\n\n    /** @type {number} */\n    get throttleAfter() {\n        return this._workerPool.runsPerCycle;\n    }\n\n    /**\n     * @param {number} throttleAfter\n     */\n    set throttleAfter(throttleAfter) {\n        this._workerPool.runsPerCycle = throttleAfter;\n    }\n}\n\nMiner.MIN_TIME_ON_BLOCK = 10000;\nMiner.MOVING_AVERAGE_MAX_SIZE = 10;\nClass.register(Miner);\n","class Wallet {\n    /**\n     * Create a new Wallet.\n     * @returns {Promise.<Wallet>} Newly created Wallet.\n     */\n    static async generate() {\n        return new Wallet(KeyPair.generate());\n    }\n\n    /**\n     * @param {Uint8Array|string} buf\n     * @return {Wallet}\n     */\n    static loadPlain(buf) {\n        if (typeof buf === 'string') buf = BufferUtils.fromHex(buf);\n        if (!buf || buf.byteLength === 0) {\n            throw new Error('Invalid wallet seed');\n        }\n        return new Wallet(KeyPair.unserialize(new SerialBuffer(buf)));\n    }\n\n    /**\n     * @param {Uint8Array|string} buf\n     * @param {Uint8Array|string} key\n     * @return {Promise.<Wallet>}\n     */\n    static async loadEncrypted(buf, key) {\n        if (typeof buf === 'string') buf = BufferUtils.fromHex(buf);\n        if (typeof key === 'string') key = BufferUtils.fromAscii(key);\n        return new Wallet(await KeyPair.fromEncrypted(new SerialBuffer(buf), key));\n    }\n\n    /**\n     * Create a new Wallet object.\n     * @param {KeyPair} keyPair KeyPair owning this Wallet.\n     * @returns {Wallet} A newly generated Wallet.\n     */\n    constructor(keyPair) {\n        /** @type {KeyPair} */\n        this._keyPair = keyPair;\n        /** @type {Address} */\n        this._address = this._keyPair.publicKey.toAddress();\n    }\n\n    /**\n     * Create a Transaction that is signed by the owner of this Wallet.\n     * @param {Address} recipient Address of the transaction receiver\n     * @param {number} value Number of Satoshis to send.\n     * @param {number} fee Number of Satoshis to donate to the Miner.\n     * @param {number} validityStartHeight The validityStartHeight for the transaction.\n     * @returns {Transaction} A prepared and signed Transaction object. This still has to be sent to the network.\n     */\n    createTransaction(recipient, value, fee, validityStartHeight) {\n        const transaction = new BasicTransaction(this._keyPair.publicKey, recipient, value, fee, validityStartHeight);\n        transaction.signature = Signature.create(this._keyPair.privateKey, this._keyPair.publicKey, transaction.serializeContent());\n        return transaction;\n    }\n\n    /**\n     * Sign a transaction by the owner of this Wallet.\n     * @param {Transaction} transaction The transaction to sign.\n     * @returns {SignatureProof} A signature proof for this transaction.\n     */\n    signTransaction(transaction) {\n        const signature = Signature.create(this._keyPair.privateKey, this._keyPair.publicKey, transaction.serializeContent());\n        return SignatureProof.singleSig(this._keyPair.publicKey, signature);\n    }\n\n    /**\n     * @returns {Uint8Array}\n     */\n    exportPlain() {\n        return this._keyPair.serialize();\n    }\n\n    /**\n     * @param {Uint8Array|string} key\n     * @param {Uint8Array|string} [unlockKey]\n     * @return {Promise.<Uint8Array>}\n     */\n    exportEncrypted(key, unlockKey) {\n        if (typeof key === 'string') key = BufferUtils.fromAscii(key);\n        if (typeof unlockKey === 'string') unlockKey = BufferUtils.fromAscii(unlockKey);\n        return this._keyPair.exportEncrypted(key, unlockKey);\n    }\n\n    /** @type {boolean} */\n    get isLocked() {\n        return this.keyPair.isLocked;\n    }\n\n    /**\n     * @param {Uint8Array|string} key\n     * @returns {Promise.<void>}\n     */\n    lock(key) {\n        if (typeof key === 'string') key = BufferUtils.fromAscii(key);\n        return this.keyPair.lock(key);\n    }\n\n    relock() {\n        this.keyPair.relock();\n    }\n\n    /**\n     * @param {Uint8Array|string} key\n     * @returns {Promise.<void>}\n     */\n    unlock(key) {\n        if (typeof key === 'string') key = BufferUtils.fromAscii(key);\n        return this.keyPair.unlock(key);\n    }\n\n    /**\n     * @param {Wallet} o\n     * @return {boolean}\n     */\n    equals(o) {\n        return o instanceof Wallet && this.keyPair.equals(o.keyPair) && this.address.equals(o.address);\n    }\n\n    /**\n     * The address of the Wallet owner.\n     * @type {Address}\n     */\n    get address() {\n        return this._address;\n    }\n\n    /**\n     * The public key of the Wallet owner\n     * @type {PublicKey}\n     */\n    get publicKey() {\n        return this._keyPair.publicKey;\n    }\n\n    /** @type {KeyPair} */\n    get keyPair() {\n        return this._keyPair;\n    }\n}\n\nClass.register(Wallet);\n","class MultiSigWallet extends Wallet {\n    /**\n     * Create a new MultiSigWallet object.\n     * @param {KeyPair} keyPair KeyPair owning this Wallet.\n     * @param {number} minSignatures Number of signatures required.\n     * @param {Array.<PublicKey>} publicKeys A list of all owners' public keys.\n     * @returns {MultiSigWallet} A newly generated MultiSigWallet.\n     */\n    static fromPublicKeys(keyPair, minSignatures, publicKeys) {\n        if (publicKeys.length === 0) throw new Error('publicKeys may not be empty');\n        if (minSignatures <= 0) throw new Error('minSignatures must be greater than 0');\n        if (!publicKeys.some(key => key.equals(keyPair.publicKey))) throw new Error('Own publicKey must be part of publicKeys');\n\n        // Sort public keys so that the order when signing and construction does not matter.\n        publicKeys = publicKeys.slice();\n        publicKeys.sort((a, b) => a.compare(b));\n        const combinations = [...ArrayUtils.k_combinations(publicKeys, minSignatures)];\n        const multiSigKeys = combinations.map(arr => PublicKey.sum(arr));\n        return new MultiSigWallet(keyPair, minSignatures, multiSigKeys);\n    }\n\n    /**\n     * @param {KeyPair} keyPair\n     * @param {SerialBuffer} buf\n     * @returns {MultiSigWallet}\n     * @private\n     */\n    static _loadMultiSig(keyPair, buf) {\n        const minSignatures = buf.readUint8();\n        const numPublicKeys = buf.readUint8();\n        const publicKeys = [];\n        for (let i = 0; i < numPublicKeys; ++i) {\n            publicKeys.push(PublicKey.unserialize(buf));\n        }\n        return new MultiSigWallet(keyPair, minSignatures, publicKeys);\n    }\n\n    /**\n     * @param {Uint8Array|string} buf\n     * @return {MultiSigWallet}\n     */\n    static loadPlain(buf) {\n        if (typeof buf === 'string') buf = BufferUtils.fromHex(buf);\n        if (!buf || buf.byteLength === 0) {\n            throw new Error('Invalid wallet seed');\n        }\n\n        const serialBuf = new SerialBuffer(buf);\n        const keyPair = KeyPair.unserialize(serialBuf);\n        return MultiSigWallet._loadMultiSig(keyPair, serialBuf);\n    }\n\n    /**\n     * @param {Uint8Array|string} buf\n     * @param {Uint8Array|string} key\n     * @return {Promise.<MultiSigWallet>}\n     */\n    static async loadEncrypted(buf, key) {\n        if (typeof buf === 'string') buf = BufferUtils.fromHex(buf);\n        if (typeof key === 'string') key = BufferUtils.fromAscii(key);\n\n        const serialBuf = new SerialBuffer(buf);\n        const keyPair = await KeyPair.fromEncrypted(serialBuf, key);\n        return MultiSigWallet._loadMultiSig(keyPair, serialBuf);\n    }\n\n    /**\n     * Create a new MultiSigWallet object.\n     * @param {KeyPair} keyPair KeyPair owning this Wallet.\n     * @param {number} minSignatures Number of signatures required.\n     * @param {Array.<PublicKey>} publicKeys A list of all aggregated public keys.\n     * @returns {MultiSigWallet} A newly generated MultiSigWallet.\n     */\n    constructor(keyPair, minSignatures, publicKeys) {\n        super(keyPair);\n        /** @type {number} minSignatures */\n        this._minSignatures = minSignatures;\n        /** @type {Array.<PublicKey>} publicKeys */\n        this._publicKeys = publicKeys;\n        this._publicKeys.sort((a, b) => a.compare(b));\n\n        const merkleRoot = MerkleTree.computeRoot(this._publicKeys);\n        /** @type {Address} */\n        this._address = Address.fromHash(merkleRoot);\n    }\n\n    /**\n     * @override\n     * @returns {Uint8Array}\n     */\n    exportPlain() {\n        const buf = new SerialBuffer(this.exportedSize);\n        this._keyPair.serialize(buf);\n        buf.writeUint8(this._minSignatures);\n        buf.writeUint8(this._publicKeys.length);\n        for (const pubKey of this._publicKeys) {\n            pubKey.serialize(buf);\n        }\n        return buf;\n    }\n\n    /**\n     * @override\n     * @param {Uint8Array|string} key\n     * @param {Uint8Array|string} [unlockKey]\n     * @return {Promise.<Uint8Array>}\n     */\n    async exportEncrypted(key, unlockKey) {\n        if (typeof key === 'string') key = BufferUtils.fromAscii(key);\n        if (typeof unlockKey === 'string') unlockKey = BufferUtils.fromAscii(unlockKey);\n        const buf = new SerialBuffer(this.encryptedExportedSize);\n        buf.write(await this._keyPair.exportEncrypted(key, unlockKey));\n        buf.writeUint8(this._minSignatures);\n        buf.writeUint8(this._publicKeys.length);\n        for (const pubKey of this._publicKeys) {\n            pubKey.serialize(buf);\n        }\n        return buf;\n    }\n\n    /** @type {number} */\n    get encryptedExportedSize() {\n        return this._keyPair.encryptedSize\n            + /*minSignatures*/ 1\n            + /*count*/ 1\n            + this._publicKeys.reduce((sum, pubKey) => sum + pubKey.serializedSize, 0);\n    }\n\n    /** @type {number} */\n    get exportedSize() {\n        return this._keyPair.serializedSize\n            + /*minSignatures*/ 1\n            + /*count*/ 1\n            + this._publicKeys.reduce((sum, pubKey) => sum + pubKey.serializedSize, 0);\n    }\n\n    /**\n     * Create a Transaction that still needs to be signed.\n     * @param {Address} recipientAddr Address of the transaction receiver\n     * @param {number} value Number of Satoshis to send.\n     * @param {number} fee Number of Satoshis to donate to the Miner.\n     * @param {number} validityStartHeight The validityStartHeight for the transaction.\n     * @returns {Transaction} A prepared Transaction object.\n     * @override\n     */\n    createTransaction(recipientAddr, value, fee, validityStartHeight) {\n        return new ExtendedTransaction(this._address, Account.Type.BASIC,\n            recipientAddr, Account.Type.BASIC, value, fee, validityStartHeight,\n            Transaction.Flag.NONE, new Uint8Array(0));\n    }\n\n    /**\n     * Creates a commitment pair for signing a transaction.\n     * @returns {CommitmentPair} The commitment pair.\n     */\n    createCommitment() {\n        return CommitmentPair.generate();\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {Array.<PublicKey>} publicKeys\n     * @param {Commitment} aggregatedCommitment\n     * @param {RandomSecret} secret\n     * @returns {PartialSignature}\n     */\n    partiallySignTransaction(transaction, publicKeys, aggregatedCommitment, secret) {\n        // Sort public keys to get the right combined public key.\n        publicKeys = publicKeys.slice();\n        publicKeys.sort((a, b) => a.compare(b));\n\n        return PartialSignature.create(this._keyPair.privateKey, this._keyPair.publicKey, publicKeys,\n            secret, aggregatedCommitment, transaction.serializeContent());\n    }\n\n    /**\n     * Sign a transaction by the owner of this Wallet.\n     * @param {Transaction} transaction The transaction to sign.\n     * @param {PublicKey} aggregatedPublicKey\n     * @param {Commitment} aggregatedCommitment\n     * @param {Array.<PartialSignature>} signatures\n     * @returns {SignatureProof} A signature proof for this transaction.\n     */\n    signTransaction(transaction, aggregatedPublicKey, aggregatedCommitment, signatures) {\n        if (signatures.length !== this._minSignatures) {\n            throw 'Not enough signatures to complete this transaction';\n        }\n\n        const signature = Signature.fromPartialSignatures(aggregatedCommitment, signatures);\n        return SignatureProof.multiSig(aggregatedPublicKey, this._publicKeys, signature);\n    }\n\n    /**\n     * @param {Transaction} transaction\n     * @param {PublicKey} aggregatedPublicKey\n     * @param {Commitment} aggregatedCommitment\n     * @param {Array.<PartialSignature>} signatures\n     * @returns {Transaction}\n     */\n    completeTransaction(transaction, aggregatedPublicKey, aggregatedCommitment, signatures) {\n        const proof = this.signTransaction(transaction, aggregatedPublicKey, aggregatedCommitment, signatures);\n        transaction.proof = proof.serialize();\n        return transaction;\n    }\n\n    /** @type {number} */\n    get minSignatures() {\n        return this._minSignatures;\n    }\n\n    /** @type {Array.<PublicKey>} */\n    get publicKeys() {\n        return this._publicKeys;\n    }\n}\nClass.register(MultiSigWallet);\n","// TODO: Move outside of Nimiq Core library?\nclass WalletStore {\n    /**\n     * @returns {Promise.<WalletStore>}\n     */\n    constructor(dbName = 'wallet') {\n        this._jdb = new JDB.JungleDB(dbName, WalletStore.VERSION, {\n            maxDbSize: WalletStore.INITIAL_DB_SIZE,\n            autoResize: true,\n            minResize: WalletStore.MIN_RESIZE\n        });\n        /** @type {ObjectStore} */\n        this._walletStore = null;\n        /** @type {ObjectStore} */\n        this._multiSigStore = null;\n\n        return this._init();\n    }\n\n    /**\n     * @returns {Promise.<WalletStore>}\n     */\n    async _init() {\n        // Initialize object stores.\n        this._walletStore = this._jdb.createObjectStore(WalletStore.WALLET_DATABASE, { codec: new WalletStoreCodec() });\n        this._multiSigStore = this._jdb.createObjectStore(WalletStore.MULTISIG_WALLET_DATABASE, { codec: new WalletStoreCodec() });\n\n        // Establish connection to database.\n        await this._jdb.connect();\n\n        return this;\n    }\n\n    /**\n     * @returns {Promise.<boolean>}\n     */\n    async hasDefault(key) {\n        const defaultAddress = await this._walletStore.get('default');\n        return !!defaultAddress;\n    }\n\n    /**\n     * @param {Uint8Array|string} [key]\n     * @returns {Promise.<?Wallet>}\n     */\n    async getDefault(key) {\n        const defaultAddress = await this._walletStore.get('default');\n        if (!defaultAddress) {\n            const defaultWallet = await Wallet.generate();\n            await this.put(defaultWallet);\n            await this.setDefault(defaultWallet.address);\n            return defaultWallet;\n        }\n        const base64Address = new Address(defaultAddress);\n        return this.get(base64Address, key);\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise}\n     */\n    setDefault(address) {\n        const defaultAddress = address.serialize();\n        return this._walletStore.put('default', defaultAddress);\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Uint8Array|string} [key]\n     * @returns {Promise.<?Wallet>}\n     */\n    async get(address, key) {\n        const base64Address = address.toBase64();\n        const buf = await this._walletStore.get(base64Address);\n        if (!buf) return null;\n        if (key) {\n            return Wallet.loadEncrypted(buf, key);\n        }\n        return Wallet.loadPlain(buf);\n    }\n\n    /**\n     * @param {Wallet} wallet\n     * @param {Uint8Array|string} [key]\n     * @param {Uint8Array|string} [unlockKey]\n     * @returns {Promise}\n     */\n    async put(wallet, key, unlockKey) {\n        const base64Address = wallet.address.toBase64();\n        /** @type {Uint8Array} */\n        let buf = null;\n        if (key) {\n            buf = await wallet.exportEncrypted(key, unlockKey);\n        } else {\n            buf = wallet.exportPlain();\n        }\n        return this._walletStore.put(base64Address, buf);\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise}\n     */\n    async remove(address) {\n        const base64Address = address.toBase64();\n        const tx = this._walletStore.transaction();\n        tx.removeSync(base64Address);\n        // Remove default address as well if they coincide.\n        let defaultAddress = await this._walletStore.get('default');\n        if (defaultAddress) {\n            defaultAddress = new Address(defaultAddress);\n            if (address.equals(defaultAddress)) {\n                tx.removeSync('default');\n            }\n        }\n        return tx.commit();\n    }\n\n    /**\n     * @returns {Promise<Array.<Address>>}\n     */\n    async list() {\n        const keys = await this._walletStore.keys();\n        return Array.from(keys).filter(key => key !== 'default').map(key => Address.fromBase64(key));\n    }\n\n    /**\n     * @param {Address} address\n     * @param {Uint8Array|string} [key]\n     * @returns {Promise.<?MultiSigWallet>}\n     */\n    async getMultiSig(address, key) {\n        const base64Address = address.toBase64();\n        const buf = await this._multiSigStore.get(base64Address);\n        if (!buf) return null;\n        if (key) {\n            return MultiSigWallet.loadEncrypted(buf, key);\n        }\n        return MultiSigWallet.loadPlain(buf);\n    }\n\n    /**\n     * @param {MultiSigWallet} wallet\n     * @param {Uint8Array|string} [key]\n     * @param {Uint8Array|string} [unlockKey]\n     * @returns {Promise}\n     */\n    async putMultiSig(wallet, key, unlockKey) {\n        const base64Address = wallet.address.toBase64();\n        /** @type {Uint8Array} */\n        let buf = null;\n        if (key) {\n            buf = await wallet.exportEncrypted(key, unlockKey);\n        } else {\n            buf = wallet.exportPlain();\n        }\n        return this._multiSigStore.put(base64Address, buf);\n    }\n\n    /**\n     * @param {Address} address\n     * @returns {Promise}\n     */\n    removeMultiSig(address) {\n        const base64Address = address.toBase64();\n        return this._multiSigStore.remove(base64Address);\n    }\n\n    /**\n     * @returns {Promise<Array.<Address>>}\n     */\n    async listMultiSig() {\n        const keys = await this._multiSigStore.keys();\n        return Array.from(keys).map(key => Address.fromBase64(key));\n    }\n\n    close() {\n        return this._jdb.close();\n    }\n}\nClass.register(WalletStore);\nWalletStore._instance = null;\nWalletStore.VERSION = 1;\nWalletStore.INITIAL_DB_SIZE = 1024*1024*10; // 10 MB initially\nWalletStore.MIN_RESIZE = 1024*1024*10; // 10 MB\nWalletStore.WALLET_DATABASE = 'wallets';\nWalletStore.MULTISIG_WALLET_DATABASE = 'multisig-wallets';\n\n/**\n * @implements {ICodec}\n */\nclass WalletStoreCodec {\n    /**\n     * @param {*} obj The object to encode before storing it.\n     * @returns {*} Encoded object.\n     */\n    encode(obj) {\n        return obj;\n    }\n\n    /**\n     * @param {*} buf The object to decode.\n     * @param {string} key The object's primary key.\n     * @returns {*} Decoded object.\n     */\n    decode(buf, key) {\n        return new Uint8Array(buf);\n    }\n\n    /**\n     * @type {string}\n     */\n    get leveldbValueEncoding() {\n        return 'binary';\n    }\n\n    /**\n     * @type {object}\n     */\n    get lmdbValueEncoding() {\n        return JDB.JungleDB.BINARY_ENCODING;\n    }\n}\n","/**\n * @interface\n */\nclass MinerWorker {\n    /**\n     * @param blockHeader\n     * @param compact\n     * @param minNonce\n     * @param maxNonce\n     * @returns {Promise.<{hash: Uint8Array, nonce: number}|boolean>}\n     */\n    async multiMine(blockHeader, compact, minNonce, maxNonce) {}\n}\nClass.register(MinerWorker);\n","class MinerWorkerImpl extends IWorker.Stub(MinerWorker) {\n    constructor() {\n        super();\n        // FIXME: This is needed for Babel to work correctly. Can be removed as soon as we updated to Babel v7.\n        this._superInit = super.init;\n    }\n\n    async init(name) {\n        await this._superInit.call(this, name);\n        await WasmHelper.doImportBrowser();\n    }\n\n    async multiMine(input, compact, minNonce, maxNonce) {\n        const hash = new Uint8Array(32);\n        let wasmOut, wasmIn;\n        try {\n            wasmOut = Module._malloc(hash.length);\n            wasmIn = Module._malloc(input.length);\n            Module.HEAPU8.set(input, wasmIn);\n            const nonce = Module._nimiq_argon2_target(wasmOut, wasmIn, input.length, compact, minNonce, maxNonce, 512);\n            if (nonce === maxNonce) return false;\n            hash.set(new Uint8Array(Module.HEAPU8.buffer, wasmOut, hash.length));\n            return {hash, nonce};\n        } catch (e) {\n            Log.w(MinerWorkerImpl, e);\n            throw e;\n        } finally {\n            if (wasmOut !== undefined) Module._free(wasmOut);\n            if (wasmIn !== undefined) Module._free(wasmIn);\n        }\n    }\n}\n\nIWorker.prepareForWorkerUse(MinerWorker, new MinerWorkerImpl());\n","/**\n *\n */\nclass MinerWorkerPool extends IWorker.Pool(MinerWorker) {\n    constructor(size = 1) {\n        super((name) => IWorker.startWorkerForProxy(MinerWorker, name), 'miner', size);\n        /** @type {boolean} */\n        this._miningEnabled = false;\n        /** @type {Array.<{minNonce: number, maxNonce: number}>} */\n        this._activeNonces = [];\n        /** @type {Block} */\n        this._block = null;\n        /** @type {number} */\n        this._noncesPerRun = 256;\n        /** @type {Observable} */\n        this._observable = new Observable();\n        /** @type {number} */\n        this._shareCompact = Policy.BLOCK_TARGET_MAX;\n        /** @type {number} */\n        this._runsPerCycle = Infinity;\n        /** @type {number} */\n        this._cycleWait = 100;\n\n        // FIXME: This is needed for Babel to work correctly. Can be removed as soon as we updated to Babel v7.\n        this._superUpdateToSize = super._updateToSize;\n\n        if (PlatformUtils.isNodeJs()) {\n            /**\n             * @param {SerialBuffer} blockHeader\n             * @param {number} compact\n             * @param {number} minNonce\n             * @param {number} maxNonce\n             * @returns {Promise.<{hash: Uint8Array, nonce: number}|boolean>}\n             */\n            this.multiMine = function (blockHeader, compact, minNonce, maxNonce) {\n                return new Promise((resolve, fail) => {\n                    NodeNative.node_argon2_target_async(async (nonce) => {\n                        try {\n                            if (nonce === maxNonce) {\n                                resolve(false);\n                            } else {\n                                blockHeader.writePos -= 4;\n                                blockHeader.writeUint32(nonce);\n                                const hash = await (await CryptoWorker.getInstanceAsync()).computeArgon2d(blockHeader);\n                                resolve({hash, nonce});\n                            }\n                        } catch (e) {\n                            fail(e);\n                        }\n                    }, blockHeader, compact, minNonce, maxNonce, 512);\n                });\n            };\n        }\n    }\n\n    /**\n     * @type {number}\n     */\n    get noncesPerRun() {\n        return this._noncesPerRun;\n    }\n\n    /**\n     * @param {number} nonces\n     */\n    set noncesPerRun(nonces) {\n        this._noncesPerRun = nonces;\n    }\n\n    /**\n     * @type {number}\n     */\n    get runsPerCycle() {\n        return this._runsPerCycle;\n    }\n\n    /**\n     * @param {number} runsPerCycle\n     */\n    set runsPerCycle(runsPerCycle) {\n        this._runsPerCycle = runsPerCycle;\n    }\n\n    /**\n     * @type {number}\n     */\n    get cycleWait() {\n        return this._cycleWait;\n    }\n\n    /**\n     * @param {number} cycleWait\n     */\n    set cycleWait(cycleWait) {\n        this._cycleWait = cycleWait;\n    }\n\n    /**\n     * @param {string} type\n     * @param {Function} callback\n     * @return {number}\n     */\n    on(type, callback) { this._observable.on(type, callback); }\n\n    /**\n     * @param {string} type\n     * @param {number} id\n     */\n    off(type, id) { this._observable.off(type, id); }\n\n    /**\n     * @param {Block} block\n     * @param {number} [shareCompact] target of a share, in compact format.\n     */\n    async startMiningOnBlock(block, shareCompact = block.nBits) {\n        this._block = block;\n        this._shareCompact = shareCompact;\n        if (!this._miningEnabled) {\n            await this._updateToSize();\n            this._activeNonces = [];\n            this._miningEnabled = true;\n            for (let i = 0; i < this.poolSize; ++i) {\n                this._startMiner();\n            }\n        } else {\n            this._activeNonces = [{minNonce:0, maxNonce:0}];\n        }\n    }\n\n    stop() {\n        this._miningEnabled = false;\n    }\n\n    async _updateToSize() {\n        if (!PlatformUtils.isNodeJs()) {\n            await this._superUpdateToSize.call(this);\n        }\n\n        while (this._miningEnabled && this._activeNonces.length < this.poolSize) {\n            this._startMiner();\n        }\n    }\n\n    _startMiner() {\n        const minNonce = this._activeNonces.length === 0 ? 0 : Math.max.apply(null, this._activeNonces.map((a) => a.maxNonce));\n        const maxNonce = minNonce + this._noncesPerRun;\n        const nonceRange = {minNonce, maxNonce};\n        this._activeNonces.push(nonceRange);\n        this._singleMiner(nonceRange).catch((e) => Log.e(MinerWorkerPool, e));\n    }\n\n    /**\n     * @param {{minNonce: number, maxNonce: number}} nonceRange\n     * @return {Promise.<void>}\n     * @private\n     */\n    async _singleMiner(nonceRange) {\n        let i = 0;\n        while (this._miningEnabled && (IWorker.areWorkersAsync || PlatformUtils.isNodeJs() || i === 0) && i < this._runsPerCycle) {\n            i++;\n            const block = this._block;\n            const result = await this.multiMine(block.header.serialize(), this._shareCompact, nonceRange.minNonce, nonceRange.maxNonce);\n            if (result) {\n                const hash = new Hash(result.hash);\n                this._observable.fire('share', {\n                    block,\n                    nonce: result.nonce,\n                    hash\n                });\n            } else {\n                this._observable.fire('no-share', {\n                    nonce: nonceRange.maxNonce\n                });\n            }\n            if (this._activeNonces.length > this.poolSize) {\n                this._activeNonces.splice(this._activeNonces.indexOf(nonceRange), 1);\n                return;\n            } else {\n                const newMin = Math.max.apply(null, this._activeNonces.map((a) => a.maxNonce));\n                const newRange = {minNonce: newMin, maxNonce: newMin + this._noncesPerRun};\n                this._activeNonces.splice(this._activeNonces.indexOf(nonceRange), 1, newRange);\n                nonceRange = newRange;\n            }\n        }\n        if (this._miningEnabled) {\n            setTimeout(() => this._singleMiner(nonceRange), this._cycleWait);\n        }\n    }\n}\n\nClass.register(MinerWorkerPool);\n","    exports._loaded = true;\n    if (typeof exports._onload === 'function') exports._onload();\n    return exports;\n})(Nimiq);\n"]}